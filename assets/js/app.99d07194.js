(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,r=e[0],l=e[1],h=e[2],d=0,u=[];d<r.length;d++)o=r[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&u.push(i[o][0]),i[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(c&&c(e);u.length;)u.shift()();return s.push.apply(s,h||[]),t()}function t(){for(var n,e=0;e<s.length;e++){for(var t=s[e],a=!0,r=1;r<t.length;r++){var l=t[r];0!==i[l]&&(a=!1)}a&&(s.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},i={1:0},s=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var s,r=document.createElement("script");r.charset="utf-8",r.timeout=120,o.nc&&r.setAttribute("nonce",o.nc),r.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"ab4658c0",3:"ab8a97d8",4:"06497870",5:"b8548e7f",6:"349bf431",7:"5451cfed",8:"522ce892",9:"4d4f4bdb",10:"ac38cab7",11:"38d5ee16",12:"c434ce94",13:"4e922264",14:"db841cfa",15:"b9c227cc",16:"41dadc32",17:"48b5f1eb",18:"ec254833",19:"288ca382",20:"cfeb5fdb",21:"ce8ddc5a",22:"1b8c89f0",23:"cb062ace",24:"ff271672",25:"5541f3af",26:"a1bbc4cb",27:"522d7884",28:"9335c003",29:"3fc0b07a",30:"57708681",31:"8571b949",32:"f91be5de",33:"8089c59b",34:"874d0299",35:"aff8adfd",36:"ac78b86e",37:"3fae0334",38:"3db4a8d6",39:"e585cc70",40:"afcb8fbe",41:"01f314da",42:"8e4fe21d",43:"571fb232",44:"14aebad2",45:"32f18970",46:"ce0d522f",47:"0bd83351",48:"648f667a",49:"83709ae0",50:"060e0424",51:"a1291856",52:"45f73497",53:"525782ca",54:"45a04a86",55:"65a94ba0",56:"2d038113",57:"579db650",58:"832d4c89",59:"13befb53",60:"41227bb1",61:"1d1b92f4",62:"2cdbc236",63:"83de9482",64:"4ecd0d25",65:"25118b81",66:"cdab1b54",67:"655e6e84",68:"84effb44",69:"8f07f81a",70:"d9a299e6",71:"16ef2000",72:"8252acc5",73:"f53e39bc",74:"5ef910c4",75:"72174d00",76:"bebf75c9",77:"b85547c7",78:"a0a1f574",79:"a731d645",80:"6e5b64b0",81:"6e19e312",82:"9244e788",83:"f08c5aed",84:"085ef3f8",85:"c41e6e0e",86:"e3798708",87:"fdac1c1c",88:"665ac8c8",89:"78dc55eb",90:"4757b202",91:"a0746cf2"}[n]+".js"}(n);var l=new Error;s=function(e){r.onerror=r.onload=null,clearTimeout(h);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),s=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+s+")",l.name="ChunkLoadError",l.type=a,l.request=s,t[1](l)}i[n]=void 0}};var h=setTimeout((function(){s({type:"timeout",target:r})}),12e4);r.onerror=r.onload=s,document.head.appendChild(r)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/dafnycommunity/",o.oe=function(n){throw console.error(n),n};var r=window.webpackJsonp=window.webpackJsonp||[],l=r.push.bind(r);r.push=e,r=r.slice();for(var h=0;h<r.length;h++)e(r[h]);var c=l;s.push([234,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(59),i=Function.prototype,s=i.bind,o=i.call,r=a&&s.bind(o,o);n.exports=a?function(n){return n&&r(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e,t){var a=t(0),i=t(39).f,s=t(26),o=t(14),r=t(107),l=t(112),h=t(101);n.exports=function(n,e){var t,c,d,u,f,m=n.target,p=n.global,y=n.stat;if(t=p?a:y?a[m]||r(m,{}):(a[m]||{}).prototype)for(c in e){if(u=e[c],d=n.noTargetGet?(f=i(t,c))&&f.value:t[c],!h(p?c:m+(y?".":"#")+c,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&s(u,"sham",!0),o(t,c,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var a=t(115),i=t(14),s=t(250);a||i(Object.prototype,"toString",s,{unsafe:!0})},function(n,e,t){var a=t(0),i=t(77),s=t(10),o=t(78),r=t(108),l=t(150),h=i("wks"),c=a.Symbol,d=c&&c.for,u=l?c:c&&c.withoutSetter||o;n.exports=function(n){if(!s(h,n)||!r&&"string"!=typeof h[n]){var e="Symbol."+n;r&&s(c,n)?h[n]=c[n]:h[n]=l&&d?d(e):u(e)}return h[n]}},function(n,e,t){var a=t(0),i=t(8),s=a.String,o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not an object")}},function(n,e,t){var a=t(4);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(1),i=t(15),s=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return s(i(n),e)}},function(n,e,t){var a=t(59),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var a=t(0),i=t(73),s=a.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return s(n)}},function(n,e,t){var a=t(0),i=t(9),s=t(152),o=t(151),r=t(7),l=t(80),h=a.TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(r(n),e=l(e),r(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(r(n),e=l(e),r(t),s)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw h("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(0),i=t(4),s=t(10),o=t(26),r=t(107),l=t(85),h=t(38),c=t(72).CONFIGURABLE,d=h.get,u=h.enforce,f=String(String).split("String");(n.exports=function(n,e,t,l){var h,d=!!l&&!!l.unsafe,m=!!l&&!!l.enumerable,p=!!l&&!!l.noTargetGet,y=l&&void 0!==l.name?l.name:e;i(t)&&("Symbol("===String(y).slice(0,7)&&(y="["+String(y).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!s(t,"name")||c&&t.name!==y)&&o(t,"name",y),(h=u(t)).source||(h.source=f.join("string"==typeof y?y:""))),n!==a?(d?!p&&n[e]&&(m=!0):delete n[e],m?n[e]=t:o(n,e,t)):m?n[e]=t:r(e,t)})(Function.prototype,"toString",(function(){return i(this)&&d(this).source||l(this)}))},function(n,e,t){var a=t(0),i=t(17),s=a.Object;n.exports=function(n){return s(i(n))}},function(n,e,t){var a=t(0),i=t(4),s=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?s(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0).TypeError;n.exports=function(n){if(null==n)throw a("Can't call method on "+n);return n}},function(n,e,t){"use strict";function a(n,e,t,a,i,s,o,r){var l,h="function"==typeof n?n.options:n;if(e&&(h.render=e,h.staticRenderFns=t,h._compiled=!0),a&&(h.functional=!0),s&&(h._scopeId="data-v-"+s),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},h._ssrRegister=l):i&&(l=r?function(){i.call(this,(h.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(h.functional){h._injectStyles=l;var c=h.render;h.render=function(n,e){return l.call(e),c(n,e)}}else{var d=h.beforeCreate;h.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:h}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(58),i=t(17);n.exports=function(n){return a(i(n))}},function(n,e,t){"use strict";var a=t(2),i=t(91);a({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e,t){var a=t(50);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(169).charAt,i=t(12),s=t(38),o=t(156),r=s.set,l=s.getterFor("String Iterator");o(String,"String",(function(n){r(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,e=l(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=a(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var a=t(14),i=t(266),s=Error.prototype;s.toString!==i&&a(s,"toString",i)},function(n,e,t){var a=t(1),i=a({}.toString),s=a("".slice);n.exports=function(n){return s(i(n),8,-1)}},function(n,e){n.exports=!1},function(n,e,t){var a=t(9),i=t(13),s=t(46);n.exports=a?function(n,e,t){return i.f(n,e,s(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(16);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(183),i="object"==typeof self&&self&&self.Object===Object&&self,s=a||i||Function("return this")();n.exports=s},function(n,e,t){"use strict";var a=t(2),i=t(47).filter;a({target:"Array",proto:!0,forced:!t(89)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),i=t(170),s=t(171),o=t(137),r=t(26),l=t(6),h=l("iterator"),c=l("toStringTag"),d=o.values,u=function(n,e){if(n){if(n[h]!==d)try{r(n,h,d)}catch(e){n[h]=d}if(n[c]||r(n,c,e),i[e])for(var t in o)if(n[t]!==o[t])try{r(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var f in i)u(a[f]&&a[f].prototype,f);u(s,"DOMTokenList")},function(n,e,t){var a,i=t(7),s=t(138),o=t(110),r=t(60),l=t(155),h=t(79),c=t(84),d=c("IE_PROTO"),u=function(){},f=function(n){return"<script>"+n+"<\/script>"},m=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},p=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;p="undefined"!=typeof document?document.domain&&a?m(a):((e=h("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):m(a);for(var t=o.length;t--;)delete p.prototype[o[t]];return p()};r[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=i(n),t=new u,u.prototype=null,t[d]=n):t=p(),void 0===e?t:s.f(t,e)}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59),i=Function.prototype,s=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(s):function(){return o.apply(s,arguments)})},function(n,e,t){var a=t(0),i=t(4),s=t(82),o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(2),i=t(175);a({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var a=t(0),i=t(170),s=t(171),o=t(175),r=t(26),l=function(n){if(n&&n.forEach!==o)try{r(n,"forEach",o)}catch(e){n.forEach=o}};for(var h in i)i[h]&&l(a[h]&&a[h].prototype);l(s)},function(n,e,t){var a,i,s,o=t(236),r=t(0),l=t(1),h=t(8),c=t(26),d=t(10),u=t(106),f=t(84),m=t(60),p=r.TypeError,y=r.WeakMap;if(o||u.state){var g=u.state||(u.state=new y),b=l(g.get),v=l(g.has),x=l(g.set);a=function(n,e){if(v(g,n))throw new p("Object already initialized");return e.facade=n,x(g,n,e),e},i=function(n){return b(g,n)||{}},s=function(n){return v(g,n)}}else{var w=f("state");m[w]=!0,a=function(n,e){if(d(n,w))throw new p("Object already initialized");return e.facade=n,c(n,w,e),e},i=function(n){return d(n,w)?n[w]:{}},s=function(n){return d(n,w)}}n.exports={set:a,get:i,has:s,enforce:function(n){return s(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!h(e)||(t=i(e)).type!==n)throw p("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(9),i=t(11),s=t(111),o=t(46),r=t(19),l=t(80),h=t(10),c=t(152),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=r(n),e=l(e),c)try{return d(n,e)}catch(n){}if(h(n,e))return o(!i(s.f,n,e),n[e])}},function(n,e,t){var a=t(2),i=t(0),s=t(34),o=t(262),r=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,h=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,forced:l},t)},c=function(n,e){if(r&&r[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,forced:l},t)}};h("Error",(function(n){return function(e){return s(n,this,arguments)}})),h("EvalError",(function(n){return function(e){return s(n,this,arguments)}})),h("RangeError",(function(n){return function(e){return s(n,this,arguments)}})),h("ReferenceError",(function(n){return function(e){return s(n,this,arguments)}})),h("SyntaxError",(function(n){return function(e){return s(n,this,arguments)}})),h("TypeError",(function(n){return function(e){return s(n,this,arguments)}})),h("URIError",(function(n){return function(e){return s(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return s(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return s(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return s(n,this,arguments)}}))},function(n,e,t){var a=t(287),i=t(290);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return s})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return h})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return y})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(20),t(51),t(218),t(71),t(217),t(146),t(43),t(36),t(5),t(37),t(30),t(75),t(131),t(133),t(70),t(149),t(23),t(134);var a=/#.*$/,i=/\.(md|html)$/,s=/\/$/,o=/^[a-z]+:/i;function r(n){return decodeURI(n).replace(a,"").replace(i,"")}function l(n){return o.test(n)}function h(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(a),t=e?e[0]:"",i=r(n);return s.test(i)?n:i+".html"+t}function u(n,e){var t=n.hash,i=function(n){var e=n.match(a);if(e)return e[0]}(e);return(!i||t===i)&&r(n.path)===r(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var s=n.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var r=s[o];".."===r?i.pop():"."!==r&&i.push(r)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var a=r(e),i=0;i<n.length;i++)if(r(n[i].regularPath)===a)return Object.assign({},n[i],{type:"page",path:d(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function m(n,e,t,a){var i=t.pages,s=t.themeConfig,o=a&&s.locales&&s.locales[a]||s;if("auto"===(n.frontmatter.sidebar||o.sidebar||s.sidebar))return p(n);var r=o.sidebar||s.sidebar;if(r){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(a=n,/(\.html|\/)$/.test(a)?a:a+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var a;return{}}(e,r),h=l.base,c=l.config;return"auto"===c?p(n):c?c.map((function(n){return function n(e,t,a){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return f(t,e,a);if(Array.isArray(e))return Object.assign(f(t,e[0],a),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var s=e.children||[];return 0===s.length&&e.path?Object.assign(f(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:s.map((function(e){return n(e,t,a,i+1)})),collapsable:!1!==e.collapsable}}(n,i,h)})):[]}return[]}function p(n){var e=y(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function y(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var a=t(2),i=t(47).map;a({target:"Array",proto:!0,forced:!t(89)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(35);n.exports=function(n,e){var t=n[e];return null==t?void 0:a(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(53),i=t(1),s=t(58),o=t(15),r=t(21),l=t(141),h=i([].push),c=function(n){var e=1==n,t=2==n,i=3==n,c=4==n,d=6==n,u=7==n,f=5==n||d;return function(m,p,y,g){for(var b,v,x=o(m),w=s(x),k=a(p,y),T=r(w),q=0,S=g||l,A=e?S(m,T):t||u?S(m,0):void 0;T>q;q++)if((f||q in w)&&(v=k(b=w[q],q,x),n))if(e)A[q]=v;else if(v)switch(n){case 3:return!0;case 5:return b;case 6:return q;case 2:h(A,b)}else switch(n){case 4:return!1;case 7:h(A,b)}return d?-1:i||c?c:A}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterReject:c(7)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a,i,s=t(0),o=t(28),r=s.process,l=s.Deno,h=r&&r.versions||l&&l.version,c=h&&h.v8;c&&(i=(a=c.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){var a=t(52),i=Math.min;n.exports=function(n){return n>0?i(a(n),9007199254740991):0}},function(n,e,t){"use strict";var a=t(34),i=t(11),s=t(1),o=t(104),r=t(3),l=t(7),h=t(4),c=t(52),d=t(50),u=t(12),f=t(17),m=t(119),p=t(45),y=t(267),g=t(105),b=t(6)("replace"),v=Math.max,x=Math.min,w=s([].concat),k=s([].push),T=s("".indexOf),q=s("".slice),S="$0"==="a".replace(/./,"$0"),A=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var s=A?"$":"$0";return[function(n,t){var a=f(this),s=null==n?void 0:p(n,b);return s?i(s,n,a,t):i(e,u(a),n,t)},function(n,i){var o=l(this),r=u(n);if("string"==typeof i&&-1===T(i,s)&&-1===T(i,"$<")){var f=t(e,o,r,i);if(f.done)return f.value}var p=h(i);p||(i=u(i));var b=o.global;if(b){var S=o.unicode;o.lastIndex=0}for(var A=[];;){var D=g(o,r);if(null===D)break;if(k(A,D),!b)break;""===u(D[0])&&(o.lastIndex=m(r,d(o.lastIndex),S))}for(var I,E="",j=0,C=0;C<A.length;C++){for(var z=u((D=A[C])[0]),L=v(x(c(D.index),r.length),0),F=[],_=1;_<D.length;_++)k(F,void 0===(I=D[_])?I:String(I));var P=D.groups;if(p){var M=w([z],F,L,r);void 0!==P&&k(M,P);var R=u(a(i,void 0,M))}else R=y(z,r,L,F,P,i);L>=j&&(E+=q(r,j,L)+R,j=L+z.length)}return E+q(r,j)}]}),!!r((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!S||A)},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?a:t)(e)}},function(n,e,t){var a=t(1),i=t(35),s=t(59),o=a(a.bind);n.exports=function(n,e){return i(n),void 0===e?n:s?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var a=t(154),i=t(110).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){var a=t(13).f,i=t(10),s=t(6)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,s)&&a(n,s,{configurable:!0,value:e})}},function(n,e,t){var a=t(24);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e,t){var a=t(65),i=t(272),s=t(273),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):s(n)}},function(n,e,t){var a=t(0),i=t(1),s=t(3),o=t(24),r=a.Object,l=i("".split);n.exports=s((function(){return!r("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?l(n,""):r(n)}:r},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var a=t(1),i=t(7),s=t(237);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),s(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e,t){var a=t(1);n.exports=a([].slice)},function(n,e,t){"use strict";var a=t(80),i=t(13),s=t(46);n.exports=function(n,e,t){var o=a(e);o in n?i.f(n,o,s(0,t)):n[o]=t}},function(n,e,t){var a=t(29).Symbol;n.exports=a},function(n,e,t){"use strict";t.d(e,"a",(function(){return s}));t(75);var a=t(67);t(74),t(90),t(5),t(118),t(22),t(31),t(143);var i=t(97);t(40),t(23);function s(n){return function(n){if(Array.isArray(n))return Object(a.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,a=new Array(e);t<e;t++)a[t]=n[t];return a}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(56),o=t(86),r=t(8),l=t(100),h=t(21),c=t(19),d=t(64),u=t(6),f=t(89),m=t(63),p=f("slice"),y=u("species"),g=i.Array,b=Math.max;a({target:"Array",proto:!0,forced:!p},{slice:function(n,e){var t,a,i,u=c(this),f=h(u),p=l(n,f),v=l(void 0===e?f:e,f);if(s(u)&&(t=u.constructor,(o(t)&&(t===g||s(t.prototype))||r(t)&&null===(t=t[y]))&&(t=void 0),t===g||void 0===t))return m(u,p,v);for(a=new(void 0===t?g:t)(b(v-p,0)),i=0;p<v;p++,i++)p in u&&d(a,i,u[p]);return a.length=i,a}})},function(n,e,t){var a=t(2),i=t(0),s=t(34),o=t(4),r=t(28),l=t(63),h=t(140),c=/MSIE .\./.test(r),d=i.Function,u=function(n){return function(e,t){var a=h(arguments.length,1)>2,i=o(e)?e:d(e),r=a?l(arguments,2):void 0;return n(a?function(){s(i,this,r)}:i,t)}};a({global:!0,bind:!0,forced:c},{setTimeout:u(i.setTimeout),setInterval:u(i.setInterval)})},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(3),o=t(56),r=t(8),l=t(15),h=t(21),c=t(64),d=t(141),u=t(89),f=t(6),m=t(49),p=f("isConcatSpreadable"),y=i.TypeError,g=m>=51||!s((function(){var n=[];return n[p]=!1,n.concat()[0]!==n})),b=u("concat"),v=function(n){if(!r(n))return!1;var e=n[p];return void 0!==e?!!e:o(n)};a({target:"Array",proto:!0,forced:!g||!b},{concat:function(n){var e,t,a,i,s,o=l(this),r=d(o,0),u=0;for(e=-1,a=arguments.length;e<a;e++)if(v(s=-1===e?o:arguments[e])){if(u+(i=h(s))>9007199254740991)throw y("Maximum allowed index exceeded");for(t=0;t<i;t++,u++)t in s&&c(r,u,s[t])}else{if(u>=9007199254740991)throw y("Maximum allowed index exceeded");c(r,u++,s)}return r.length=u,r}})},function(n,e,t){"use strict";t(20);var a,i,s=t(2),o=t(0),r=t(11),l=t(1),h=t(4),c=t(8),d=(a=!1,(i=/[ac]/).exec=function(){return a=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&a),u=o.Error,f=l(/./.test);s({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!h(e))return f(this,n);var t=r(e,this,n);if(null!==t&&!c(t))throw new u("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var a=t(9),i=t(10),s=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,r=i(s,"name"),l=r&&"something"===function(){}.name,h=r&&(!a||a&&o(s,"name").configurable);n.exports={EXISTS:r,PROPER:l,CONFIGURABLE:h}},function(n,e,t){var a=t(0),i=t(115),s=t(4),o=t(24),r=t(6)("toStringTag"),l=a.Object,h="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),r))?t:h?o(e):"Object"==(a=o(e))&&s(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(16),o=t(34),r=t(11),l=t(1),h=t(25),c=t(9),d=t(108),u=t(3),f=t(10),m=t(56),p=t(4),y=t(8),g=t(33),b=t(81),v=t(7),x=t(15),w=t(19),k=t(80),T=t(12),q=t(46),S=t(32),A=t(83),D=t(54),I=t(177),E=t(113),j=t(39),C=t(13),z=t(138),L=t(111),F=t(63),_=t(14),P=t(77),M=t(84),R=t(60),B=t(78),O=t(6),N=t(178),W=t(179),U=t(55),G=t(38),$=t(47).forEach,H=M("hidden"),X=O("toPrimitive"),Y=G.set,Z=G.getterFor("Symbol"),V=Object.prototype,K=i.Symbol,J=K&&K.prototype,Q=i.TypeError,nn=i.QObject,en=s("JSON","stringify"),tn=j.f,an=C.f,sn=I.f,on=L.f,rn=l([].push),ln=P("symbols"),hn=P("op-symbols"),cn=P("string-to-symbol-registry"),dn=P("symbol-to-string-registry"),un=P("wks"),fn=!nn||!nn.prototype||!nn.prototype.findChild,mn=c&&u((function(){return 7!=S(an({},"a",{get:function(){return an(this,"a",{value:7}).a}})).a}))?function(n,e,t){var a=tn(V,e);a&&delete V[e],an(n,e,t),a&&n!==V&&an(V,e,a)}:an,pn=function(n,e){var t=ln[n]=S(J);return Y(t,{type:"Symbol",tag:n,description:e}),c||(t.description=e),t},yn=function(n,e,t){n===V&&yn(hn,e,t),v(n);var a=k(e);return v(t),f(ln,a)?(t.enumerable?(f(n,H)&&n[H][a]&&(n[H][a]=!1),t=S(t,{enumerable:q(0,!1)})):(f(n,H)||an(n,H,q(1,{})),n[H][a]=!0),mn(n,a,t)):an(n,a,t)},gn=function(n,e){v(n);var t=w(e),a=A(t).concat(wn(t));return $(a,(function(e){c&&!r(bn,t,e)||yn(n,e,t[e])})),n},bn=function(n){var e=k(n),t=r(on,this,e);return!(this===V&&f(ln,e)&&!f(hn,e))&&(!(t||!f(this,e)||!f(ln,e)||f(this,H)&&this[H][e])||t)},vn=function(n,e){var t=w(n),a=k(e);if(t!==V||!f(ln,a)||f(hn,a)){var i=tn(t,a);return!i||!f(ln,a)||f(t,H)&&t[H][a]||(i.enumerable=!0),i}},xn=function(n){var e=sn(w(n)),t=[];return $(e,(function(n){f(ln,n)||f(R,n)||rn(t,n)})),t},wn=function(n){var e=n===V,t=sn(e?hn:w(n)),a=[];return $(t,(function(n){!f(ln,n)||e&&!f(V,n)||rn(a,ln[n])})),a};(d||(_(J=(K=function(){if(g(J,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?T(arguments[0]):void 0,e=B(n),t=function(n){this===V&&r(t,hn,n),f(this,H)&&f(this[H],e)&&(this[H][e]=!1),mn(this,e,q(1,n))};return c&&fn&&mn(V,e,{configurable:!0,set:t}),pn(e,n)}).prototype,"toString",(function(){return Z(this).tag})),_(K,"withoutSetter",(function(n){return pn(B(n),n)})),L.f=bn,C.f=yn,z.f=gn,j.f=vn,D.f=I.f=xn,E.f=wn,N.f=function(n){return pn(O(n),n)},c&&(an(J,"description",{configurable:!0,get:function(){return Z(this).description}}),h||_(V,"propertyIsEnumerable",bn,{unsafe:!0}))),a({global:!0,wrap:!0,forced:!d,sham:!d},{Symbol:K}),$(A(un),(function(n){W(n)})),a({target:"Symbol",stat:!0,forced:!d},{for:function(n){var e=T(n);if(f(cn,e))return cn[e];var t=K(e);return cn[e]=t,dn[t]=e,t},keyFor:function(n){if(!b(n))throw Q(n+" is not a symbol");if(f(dn,n))return dn[n]},useSetter:function(){fn=!0},useSimple:function(){fn=!1}}),a({target:"Object",stat:!0,forced:!d,sham:!c},{create:function(n,e){return void 0===e?S(n):gn(S(n),e)},defineProperty:yn,defineProperties:gn,getOwnPropertyDescriptor:vn}),a({target:"Object",stat:!0,forced:!d},{getOwnPropertyNames:xn,getOwnPropertySymbols:wn}),a({target:"Object",stat:!0,forced:u((function(){E.f(1)}))},{getOwnPropertySymbols:function(n){return E.f(x(n))}}),en)&&a({target:"JSON",stat:!0,forced:!d||u((function(){var n=K();return"[null]"!=en([n])||"{}"!=en({a:n})||"{}"!=en(Object(n))}))},{stringify:function(n,e,t){var a=F(arguments),i=e;if((y(e)||void 0!==n)&&!b(n))return m(e)||(e=function(n,e){if(p(i)&&(e=r(i,this,n,e)),!b(e))return e}),a[1]=e,o(en,null,a)}});if(!J[X]){var kn=J.valueOf;_(J,X,(function(n){return r(kn,this)}))}U(K,"Symbol"),R[H]=!0},function(n,e,t){t(2)({target:"Array",stat:!0},{isArray:t(56)})},function(n,e,t){var a=t(9),i=t(72).EXISTS,s=t(1),o=t(13).f,r=Function.prototype,l=s(r.toString),h=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,c=s(h.exec);a&&!i&&o(r,"name",{configurable:!0,get:function(){try{return c(h,l(this))[1]}catch(n){return""}}})},function(n,e,t){var a=t(25),i=t(106);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var a=t(1),i=0,s=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+s,36)}},function(n,e,t){var a=t(0),i=t(8),s=a.document,o=i(s)&&i(s.createElement);n.exports=function(n){return o?s.createElement(n):{}}},function(n,e,t){var a=t(153),i=t(81);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e,t){var a=t(0),i=t(16),s=t(4),o=t(33),r=t(150),l=a.Object;n.exports=r?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return s(e)&&o(e.prototype,l(n))}},function(n,e,t){var a=t(0).String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(154),i=t(110);n.exports=Object.keys||function(n){return a(n,i)}},function(n,e,t){var a=t(77),i=t(78),s=a("keys");n.exports=function(n){return s[n]||(s[n]=i(n))}},function(n,e,t){var a=t(1),i=t(4),s=t(106),o=a(Function.toString);i(s.inspectSource)||(s.inspectSource=function(n){return o(n)}),n.exports=s.inspectSource},function(n,e,t){var a=t(1),i=t(3),s=t(4),o=t(73),r=t(16),l=t(85),h=function(){},c=[],d=r("Reflect","construct"),u=/^\s*(?:class|function)\b/,f=a(u.exec),m=!u.exec(h),p=function(n){if(!s(n))return!1;try{return d(h,c,n),!0}catch(n){return!1}},y=function(n){if(!s(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return m||!!f(u,l(n))}catch(n){return!0}};y.sham=!0,n.exports=!d||i((function(){var n;return p(p.call)||!p(Object)||!p((function(){n=!0}))||n}))?y:p},function(n,e,t){var a=t(24),i=t(0);n.exports="process"==a(i.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(5);function a(n,e,t,a,i,s,o){try{var r=n[s](o),l=r.value}catch(n){return void t(n)}r.done?e(l):Promise.resolve(l).then(a,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,s){var o=n.apply(e,t);function r(n){a(o,i,s,r,l,"next",n)}function l(n){a(o,i,s,r,l,"throw",n)}r(void 0)}))}}},function(n,e,t){var a=t(3),i=t(6),s=t(49),o=i("species");n.exports=function(n){return s>=51||!a((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var a=t(2),i=t(9),s=t(0),o=t(1),r=t(10),l=t(4),h=t(33),c=t(12),d=t(13).f,u=t(112),f=s.Symbol,m=f&&f.prototype;if(i&&l(f)&&(!("description"in m)||void 0!==f().description)){var p={},y=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:c(arguments[0]),e=h(m,this)?new f(n):void 0===n?f():f(n);return""===n&&(p[e]=!0),e};u(y,f),y.prototype=m,m.constructor=y;var g="Symbol(test)"==String(f("test")),b=o(m.toString),v=o(m.valueOf),x=/^Symbol\((.*)\)[^)]+$/,w=o("".replace),k=o("".slice);d(m,"description",{configurable:!0,get:function(){var n=v(this),e=b(n);if(r(p,n))return"";var t=g?k(e,7,-1):w(e,x,"$1");return""===t?void 0:t}}),a({global:!0,forced:!0},{Symbol:y})}},function(n,e,t){"use strict";var a,i,s=t(11),o=t(1),r=t(12),l=t(144),h=t(103),c=t(77),d=t(32),u=t(38).get,f=t(219),m=t(226),p=c("native-string-replace",String.prototype.replace),y=RegExp.prototype.exec,g=y,b=o("".charAt),v=o("".indexOf),x=o("".replace),w=o("".slice),k=(i=/b*/g,s(y,a=/a/,"a"),s(y,i,"a"),0!==a.lastIndex||0!==i.lastIndex),T=h.BROKEN_CARET,q=void 0!==/()??/.exec("")[1];(k||q||T||f||m)&&(g=function(n){var e,t,a,i,o,h,c,f=this,m=u(f),S=r(n),A=m.raw;if(A)return A.lastIndex=f.lastIndex,e=s(g,A,S),f.lastIndex=A.lastIndex,e;var D=m.groups,I=T&&f.sticky,E=s(l,f),j=f.source,C=0,z=S;if(I&&(E=x(E,"y",""),-1===v(E,"g")&&(E+="g"),z=w(S,f.lastIndex),f.lastIndex>0&&(!f.multiline||f.multiline&&"\n"!==b(S,f.lastIndex-1))&&(j="(?: "+j+")",z=" "+z,C++),t=new RegExp("^(?:"+j+")",E)),q&&(t=new RegExp("^"+j+"$(?!\\s)",E)),k&&(a=f.lastIndex),i=s(y,I?t:f,z),I?i?(i.input=w(i.input,C),i[0]=w(i[0],C),i.index=f.lastIndex,f.lastIndex+=i[0].length):f.lastIndex=0:k&&i&&(f.lastIndex=f.global?i.index+i[0].length:a),q&&i&&i.length>1&&s(p,i[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&D)for(i.groups=h=d(null),o=0;o<D.length;o++)h[(c=D[o])[0]]=i[c[1]];return i}),n.exports=g},function(n,e,t){var a=t(277),i=t(278),s=t(279),o=t(280),r=t(281);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e,t){var a=t(185);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(41)(Object,"create");n.exports=a},function(n,e,t){var a=t(299);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(127);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(68),t(5),t(76),t(143),t(22),t(20),t(71);var a=t(67);function i(n,e){if(n){if("string"==typeof n)return Object(a.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(a.a)(n,e):void 0}}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function s(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),h=l.querySelector(a.barSelector),c=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),r(h,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+s(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+s(n)+"%,0)"}:{"margin-left":s(n)+"%"}).transition="all "+e+"ms "+t,i}(n,c,d)),1===n?(r(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){r(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");h(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,o=e.querySelector(a.barSelector),l=n?"-100":s(t.status||0),c=document.querySelector(a.parent);return r(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&u(i),c!=document.body&&h(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),r=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,s=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+s)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,s=arguments;if(2==s.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,s[1],s[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function h(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function c(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n,e,t){var a=t(6),i=t(32),s=t(13),o=a("unscopables"),r=Array.prototype;null==r[o]&&s.f(r,o,{configurable:!0,value:i(null)}),n.exports=function(n){r[o][n]=!0}},function(n,e,t){var a=t(52),i=Math.max,s=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):s(t,e)}},function(n,e,t){var a=t(3),i=t(4),s=/#|\.prototype\./,o=function(n,e){var t=l[r(n)];return t==c||t!=h&&(i(e)?a(e):!!e)},r=o.normalize=function(n){return String(n).replace(s,".").toLowerCase()},l=o.data={},h=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(73),i=t(45),s=t(61),o=t(6)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||s[a(n)]}},function(n,e,t){var a=t(3),i=t(0).RegExp,s=a((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=s||a((function(){return!i("a","y").sticky})),r=s||a((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:r,MISSED_STICKY:o,UNSUPPORTED_Y:s}},function(n,e,t){"use strict";t(20);var a=t(1),i=t(14),s=t(91),o=t(3),r=t(6),l=t(26),h=r("species"),c=RegExp.prototype;n.exports=function(n,e,t,d){var u=r(n),f=!o((function(){var e={};return e[u]=function(){return 7},7!=""[n](e)})),m=f&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[h]=function(){return t},t.flags="",t[u]=/./[u]),t.exec=function(){return e=!0,null},t[u](""),!e}));if(!f||!m||t){var p=a(/./[u]),y=e(u,""[n],(function(n,e,t,i,o){var r=a(n),l=e.exec;return l===s||l===c.exec?f&&!o?{done:!0,value:p(e,t,i)}:{done:!0,value:r(t,e,i)}:{done:!1}}));i(String.prototype,n,y[0]),i(c,u,y[1])}d&&l(c[u],"sham",!0)}},function(n,e,t){var a=t(0),i=t(11),s=t(7),o=t(4),r=t(24),l=t(91),h=a.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var a=i(t,n,e);return null!==a&&s(a),a}if("RegExp"===r(n))return i(l,n,e);throw h("RegExp#exec called on incompatible receiver")}},function(n,e,t){var a=t(0),i=t(107),s=a["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=s},function(n,e,t){var a=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(49),i=t(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a=t(19),i=t(100),s=t(21),o=function(n){return function(e,t,o){var r,l=a(e),h=s(l),c=i(o,h);if(n&&t!=t){for(;h>c;)if((r=l[c++])!=r)return!0}else for(;h>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,s=i&&!a.call({1:2},1);e.f=s?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(10),i=t(157),s=t(39),o=t(13);n.exports=function(n,e,t){for(var r=i(e),l=o.f,h=s.f,c=0;c<r.length;c++){var d=r[c];a(n,d)||t&&a(t,d)||l(n,d,h(e,d))}}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(0),i=t(10),s=t(4),o=t(15),r=t(84),l=t(159),h=r("IE_PROTO"),c=a.Object,d=c.prototype;n.exports=l?c.getPrototypeOf:function(n){var e=o(n);if(i(e,h))return e[h];var t=e.constructor;return s(t)&&e instanceof t?t.prototype:e instanceof c?d:null}},function(n,e,t){var a={};a[t(6)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(7),i=t(164),s=t(6)("species");n.exports=function(n,e){var t,o=a(n).constructor;return void 0===o||null==(t=a(o)[s])?e:i(t)}},function(n,e,t){var a=t(0),i=t(100),s=t(21),o=t(64),r=a.Array,l=Math.max;n.exports=function(n,e,t){for(var a=s(n),h=i(e,a),c=i(void 0===t?a:t,a),d=r(l(c-h,0)),u=0;h<c;h++,u++)o(d,u,n[h]);return d.length=u,d}},function(n,e,t){t(179)("iterator")},function(n,e,t){"use strict";var a=t(169).charAt;n.exports=function(n,e,t){return e+(t?a(n,e).length:1)}},function(n,e,t){var a=t(271),i=t(48),s=Object.prototype,o=s.hasOwnProperty,r=s.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return i(n)&&o.call(n,"callee")&&!r.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(41)(t(29),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(291),i=t(298),s=t(300),o=t(301),r=t(302);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(27),i=t(127),s=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!s.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(57),i=t(48);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(75);t(74),t(90),t(5),t(118),t(22),t(31);var a=t(97);t(40),t(23);function i(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var a,i,s=[],o=!0,r=!1;try{for(t=t.call(n);!(o=(a=t.next()).done)&&(s.push(a.value),!e||s.length!==e);o=!0);}catch(n){r=!0,i=n}finally{try{o||null==t.return||t.return()}finally{if(r)throw i}}return s}}(n,e)||Object(a.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){var a=t(2),i=t(15),s=t(83);a({target:"Object",stat:!0,forced:t(3)((function(){s(1)}))},{keys:function(n){return s(i(n))}})},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(109).indexOf,o=t(44),r=i([].indexOf),l=!!r&&1/r([1],1,-0)<0,h=o("indexOf");a({target:"Array",proto:!0,forced:l||!h},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?r(this,n,e)||0:s(this,n,e)}})},function(n,e,t){"use strict";var a=t(2),i=t(47).some;a({target:"Array",proto:!0,forced:!t(44)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(1),i=t(14),s=Date.prototype,o=a(s.toString),r=a(s.getTime);"Invalid Date"!=String(new Date(NaN))&&i(s,"toString",(function(){var n=r(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){"use strict";var a=t(1),i=t(72).PROPER,s=t(14),o=t(7),r=t(33),l=t(12),h=t(3),c=t(144),d=RegExp.prototype,u=d.toString,f=a(c),m=h((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),p=i&&"toString"!=u.name;(m||p)&&s(RegExp.prototype,"toString",(function(){var n=o(this),e=l(n.source),t=n.flags;return"/"+e+"/"+l(void 0===t&&r(d,n)&&!("flags"in d)?f(n):t)}),{unsafe:!0})},function(n,e,t){var a=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",o=a.toStringTag||"@@toStringTag";function r(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{r({},"")}catch(n){r=function(n,e,t){return n[e]=t}}function l(n,e,t,a){var i=e&&e.prototype instanceof d?e:d,s=Object.create(i.prototype),o=new T(a||[]);return s._invoke=function(n,e,t){var a="suspendedStart";return function(i,s){if("executing"===a)throw new Error("Generator is already running");if("completed"===a){if("throw"===i)throw s;return S()}for(t.method=i,t.arg=s;;){var o=t.delegate;if(o){var r=x(o,t);if(r){if(r===c)continue;return r}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===a)throw a="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);a="executing";var l=h(n,e,t);if("normal"===l.type){if(a=t.done?"completed":"suspendedYield",l.arg===c)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(a="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),s}function h(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var c={};function d(){}function u(){}function f(){}var m={};r(m,i,(function(){return this}));var p=Object.getPrototypeOf,y=p&&p(p(q([])));y&&y!==e&&t.call(y,i)&&(m=y);var g=f.prototype=d.prototype=Object.create(m);function b(n){["next","throw","return"].forEach((function(e){r(n,e,(function(n){return this._invoke(e,n)}))}))}function v(n,e){var a;this._invoke=function(i,s){function o(){return new e((function(a,o){!function a(i,s,o,r){var l=h(n[i],n,s);if("throw"!==l.type){var c=l.arg,d=c.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){a("next",n,o,r)}),(function(n){a("throw",n,o,r)})):e.resolve(d).then((function(n){c.value=n,o(c)}),(function(n){return a("throw",n,o,r)}))}r(l.arg)}(i,s,a,o)}))}return a=a?a.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return c;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return c}var a=h(t,n.iterator,e.arg);if("throw"===a.type)return e.method="throw",e.arg=a.arg,e.delegate=null,c;var i=a.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,c):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,c)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function T(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function q(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var a=-1,s=function e(){for(;++a<n.length;)if(t.call(n,a))return e.value=n[a],e.done=!1,e;return e.value=void 0,e.done=!0,e};return s.next=s}}return{next:S}}function S(){return{value:void 0,done:!0}}return u.prototype=f,r(g,"constructor",f),r(f,"constructor",u),u.displayName=r(f,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,f):(n.__proto__=f,r(n,o,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},b(v.prototype),r(v.prototype,s,(function(){return this})),n.AsyncIterator=v,n.async=function(e,t,a,i,s){void 0===s&&(s=Promise);var o=new v(l(e,t,a,i),s);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(g),r(g,o,"Generator"),r(g,i,(function(){return this})),r(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var a=e.pop();if(a in n)return t.value=a,t.done=!1,t}return t.done=!0,t}},n.values=q,T.prototype={constructor:T,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function a(t,a){return o.type="throw",o.arg=n,e.next=t,a&&(e.method="next",e.arg=void 0),!!a}for(var i=this.tryEntries.length-1;i>=0;--i){var s=this.tryEntries[i],o=s.completion;if("root"===s.tryLoc)return a("end");if(s.tryLoc<=this.prev){var r=t.call(s,"catchLoc"),l=t.call(s,"finallyLoc");if(r&&l){if(this.prev<s.catchLoc)return a(s.catchLoc,!0);if(this.prev<s.finallyLoc)return a(s.finallyLoc)}else if(r){if(this.prev<s.catchLoc)return a(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return a(s.finallyLoc)}}}},abrupt:function(n,e){for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var s=i;break}}s&&("break"===n||"continue"===n)&&s.tryLoc<=e&&e<=s.finallyLoc&&(s=null);var o=s?s.completion:{};return o.type=n,o.arg=e,s?(this.method="next",this.next=s.finallyLoc,c):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),c},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),c}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var a=t.completion;if("throw"===a.type){var i=a.arg;k(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:q(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),c}},n}(n.exports);try{regeneratorRuntime=a}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=a:Function("r","regeneratorRuntime = r")(a)}},function(n,e,t){var a=t(2),i=t(9),s=t(13).f;a({target:"Object",stat:!0,forced:Object.defineProperty!==s,sham:!i},{defineProperty:s})},function(n,e,t){"use strict";var a=t(19),i=t(99),s=t(61),o=t(38),r=t(13).f,l=t(156),h=t(25),c=t(9),d=o.set,u=o.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:a(n),index:0,kind:e})}),(function(){var n=u(this),e=n.target,t=n.kind,a=n.index++;return!e||a>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:a,done:!1}:"values"==t?{value:e[a],done:!1}:{value:[a,e[a]],done:!1}}),"values");var f=s.Arguments=s.Array;if(i("keys"),i("values"),i("entries"),!h&&c&&"values"!==f.name)try{r(f,"name",{value:"values"})}catch(n){}},function(n,e,t){var a=t(9),i=t(151),s=t(13),o=t(7),r=t(19),l=t(83);e.f=a&&!i?Object.defineProperties:function(n,e){o(n);for(var t,a=r(e),i=l(e),h=i.length,c=0;h>c;)s.f(n,t=i[c++],a[t]);return n}},function(n,e,t){var a=t(0),i=t(11),s=t(35),o=t(7),r=t(82),l=t(102),h=a.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(s(t))return o(i(t,n));throw h(r(n)+" is not iterable")}},function(n,e,t){var a=t(0).TypeError;n.exports=function(n,e){if(n<e)throw a("Not enough arguments");return n}},function(n,e,t){var a=t(251);n.exports=function(n,e){return new(a(n))(0===e?0:e)}},function(n,e,t){var a=t(8),i=t(24),s=t(6)("match");n.exports=function(n){var e;return a(n)&&(void 0!==(e=n[s])?!!e:"RegExp"==i(n))}},function(n,e,t){var a=t(2),i=t(260);a({target:"Array",stat:!0,forced:!t(163)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){"use strict";var a=t(7);n.exports=function(){var n=a(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var a=t(4),i=t(8),s=t(62);n.exports=function(n,e,t){var o,r;return s&&a(o=e.constructor)&&o!==t&&i(r=o.prototype)&&r!==t.prototype&&s(n,r),n}},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(58),o=t(19),r=t(44),l=i([].join),h=s!=Object,c=r("join",",");a({target:"Array",proto:!0,forced:h||!c},{join:function(n){return l(o(this),void 0===n?",":n)}})},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,s=/^0o[0-7]+$/i,o=parseInt,r="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,h=r||l||Function("return this")(),c=Object.prototype.toString,d=Math.max,u=Math.min,f=function(){return h.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function p(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var r=i.test(n);return r||s.test(n)?o(n.slice(2),r?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,s,o,r,l,h=0,c=!1,y=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,s=i;return a=i=void 0,h=e,o=n.apply(s,t)}function v(n){return h=n,r=setTimeout(w,e),c?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||y&&n-h>=s}function w(){var n=f();if(x(n))return k(n);r=setTimeout(w,function(n){var t=e-(n-l);return y?u(t,s-(n-h)):t}(n))}function k(n){return r=void 0,g&&a?b(n):(a=i=void 0,o)}function T(){var n=f(),t=x(n);if(a=arguments,i=this,l=n,t){if(void 0===r)return v(l);if(y)return r=setTimeout(w,e),b(l)}return void 0===r&&(r=setTimeout(w,e)),o}return e=p(e)||0,m(t)&&(c=!!t.leading,s=(y="maxWait"in t)?d(p(t.maxWait)||0,e):s,g="trailing"in t?!!t.trailing:g),T.cancel=function(){void 0!==r&&clearTimeout(r),h=0,a=l=i=r=void 0},T.flush=function(){return void 0===r?o:k(f())},T}},function(n,e,t){"use strict";var a=t(2),i=t(367).start;a({target:"String",proto:!0,forced:t(369)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(108);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(9),i=t(3);n.exports=a&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(9),i=t(3),s=t(79);n.exports=!a&&!i((function(){return 7!=Object.defineProperty(s("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(0),i=t(11),s=t(8),o=t(81),r=t(45),l=t(235),h=t(6),c=a.TypeError,d=h("toPrimitive");n.exports=function(n,e){if(!s(n)||o(n))return n;var t,a=r(n,d);if(a){if(void 0===e&&(e="default"),t=i(a,n,e),!s(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var a=t(1),i=t(10),s=t(19),o=t(109).indexOf,r=t(60),l=a([].push);n.exports=function(n,e){var t,a=s(n),h=0,c=[];for(t in a)!i(r,t)&&i(a,t)&&l(c,t);for(;e.length>h;)i(a,t=e[h++])&&(~o(c,t)||l(c,t));return c}},function(n,e,t){var a=t(16);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(2),i=t(11),s=t(25),o=t(72),r=t(4),l=t(221),h=t(114),c=t(62),d=t(55),u=t(26),f=t(14),m=t(6),p=t(61),y=t(158),g=o.PROPER,b=o.CONFIGURABLE,v=y.IteratorPrototype,x=y.BUGGY_SAFARI_ITERATORS,w=m("iterator"),k=function(){return this};n.exports=function(n,e,t,o,m,y,T){l(t,e,o);var q,S,A,D=function(n){if(n===m&&z)return z;if(!x&&n in j)return j[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},I=e+" Iterator",E=!1,j=n.prototype,C=j[w]||j["@@iterator"]||m&&j[m],z=!x&&C||D(m),L="Array"==e&&j.entries||C;if(L&&(q=h(L.call(new n)))!==Object.prototype&&q.next&&(s||h(q)===v||(c?c(q,v):r(q[w])||f(q,w,k)),d(q,I,!0,!0),s&&(p[I]=k)),g&&"values"==m&&C&&"values"!==C.name&&(!s&&b?u(j,"name","values"):(E=!0,z=function(){return i(C,this)})),m)if(S={values:D("values"),keys:y?z:D("keys"),entries:D("entries")},T)for(A in S)(x||E||!(A in j))&&f(j,A,S[A]);else a({target:e,proto:!0,forced:x||E},S);return s&&!T||j[w]===z||f(j,w,z,{name:m}),p[e]=z,S}},function(n,e,t){var a=t(16),i=t(1),s=t(54),o=t(113),r=t(7),l=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=s.f(r(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var a,i,s,o=t(3),r=t(4),l=t(32),h=t(114),c=t(14),d=t(6),u=t(25),f=d("iterator"),m=!1;[].keys&&("next"in(s=[].keys())?(i=h(h(s)))!==Object.prototype&&(a=i):m=!0),null==a||o((function(){var n={};return a[f].call(n)!==n}))?a={}:u&&(a=l(a)),r(a[f])||c(a,f,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){var a=t(3);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var a=t(0);n.exports=a.Promise},function(n,e,t){var a=t(6),i=t(61),s=a("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[s]===n)}},function(n,e,t){var a=t(11),i=t(7),s=t(45);n.exports=function(n,e,t){var o,r;i(n);try{if(!(o=s(n,"return"))){if("throw"===e)throw t;return t}o=a(o,n)}catch(n){r=!0,o=n}if("throw"===e)throw t;if(r)throw o;return i(o),t}},function(n,e,t){var a=t(6)("iterator"),i=!1;try{var s=0,o={next:function(){return{done:!!s++}},return:function(){i=!0}};o[a]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var s={};s[a]=function(){return{next:function(){return{done:t=!0}}}},n(s)}catch(n){}return t}},function(n,e,t){var a=t(0),i=t(86),s=t(82),o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not a constructor")}},function(n,e,t){var a,i,s,o,r=t(0),l=t(34),h=t(53),c=t(4),d=t(10),u=t(3),f=t(155),m=t(63),p=t(79),y=t(140),g=t(166),b=t(87),v=r.setImmediate,x=r.clearImmediate,w=r.process,k=r.Dispatch,T=r.Function,q=r.MessageChannel,S=r.String,A=0,D={};try{a=r.location}catch(n){}var I=function(n){if(d(D,n)){var e=D[n];delete D[n],e()}},E=function(n){return function(){I(n)}},j=function(n){I(n.data)},C=function(n){r.postMessage(S(n),a.protocol+"//"+a.host)};v&&x||(v=function(n){y(arguments.length,1);var e=c(n)?n:T(n),t=m(arguments,1);return D[++A]=function(){l(e,void 0,t)},i(A),A},x=function(n){delete D[n]},b?i=function(n){w.nextTick(E(n))}:k&&k.now?i=function(n){k.now(E(n))}:q&&!g?(o=(s=new q).port2,s.port1.onmessage=j,i=h(o.postMessage,o)):r.addEventListener&&c(r.postMessage)&&!r.importScripts&&a&&"file:"!==a.protocol&&!u(C)?(i=C,r.addEventListener("message",j,!1)):i="onreadystatechange"in p("script")?function(n){f.appendChild(p("script")).onreadystatechange=function(){f.removeChild(this),I(n)}}:function(n){setTimeout(E(n),0)}),n.exports={set:v,clear:x}},function(n,e,t){var a=t(28);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(a)},function(n,e,t){var a=t(7),i=t(8),s=t(168);n.exports=function(n,e){if(a(n),i(e)&&e.constructor===n)return e;var t=s.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var a=t(35),i=function(n){var e,t;this.promise=new n((function(n,a){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=a})),this.resolve=a(e),this.reject=a(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){var a=t(1),i=t(52),s=t(12),o=t(17),r=a("".charAt),l=a("".charCodeAt),h=a("".slice),c=function(n){return function(e,t){var a,c,d=s(o(e)),u=i(t),f=d.length;return u<0||u>=f?n?"":void 0:(a=l(d,u))<55296||a>56319||u+1===f||(c=l(d,u+1))<56320||c>57343?n?r(d,u):a:n?h(d,u,u+2):c-56320+(a-55296<<10)+65536}};n.exports={codeAt:c(!1),charAt:c(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var a=t(79)("span").classList,i=a&&a.constructor&&a.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,e,t){var a=t(2),i=t(3),s=t(15),o=t(114),r=t(159);a({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!r},{getPrototypeOf:function(n){return o(s(n))}})},function(n,e,t){var a=t(0),i=t(142),s=a.TypeError;n.exports=function(n){if(i(n))throw s("The method doesn't accept regular expressions");return n}},function(n,e,t){var a=t(6)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[a]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var a=t(47).forEach,i=t(44)("forEach");n.exports=i?[].forEach:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var a=t(24),i=t(19),s=t(54).f,o=t(117),r="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return r&&"Window"==a(n)?function(n){try{return s(n)}catch(n){return o(r)}}(n):s(i(n))}},function(n,e,t){var a=t(6);e.f=a},function(n,e,t){var a=t(259),i=t(10),s=t(178),o=t(13).f;n.exports=function(n){var e=a.Symbol||(a.Symbol={});i(e,n)||o(e,n,{value:s.f(n)})}},function(n,e,t){var a=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){t(2)({target:"Object",stat:!0,sham:!t(9)},{create:t(32)})},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(92),i=t(282),s=t(283),o=t(284),r=t(285),l=t(286);function h(n){var e=this.__data__=new a(n);this.size=e.size}h.prototype.clear=i,h.prototype.delete=s,h.prototype.get=o,h.prototype.has=r,h.prototype.set=l,n.exports=h},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(57),i=t(122);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(303),i=t(48);n.exports=function n(e,t,s,o,r){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,s,o,n,r))}},function(n,e,t){var a=t(190),i=t(306),s=t(191);n.exports=function(n,e,t,o,r,l){var h=1&t,c=n.length,d=e.length;if(c!=d&&!(h&&d>c))return!1;var u=l.get(n),f=l.get(e);if(u&&f)return u==e&&f==n;var m=-1,p=!0,y=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++m<c;){var g=n[m],b=e[m];if(o)var v=h?o(b,g,m,e,n,l):o(g,b,m,n,e,l);if(void 0!==v){if(v)continue;p=!1;break}if(y){if(!i(e,(function(n,e){if(!s(y,e)&&(g===n||r(g,n,t,o,l)))return y.push(e)}))){p=!1;break}}else if(g!==b&&!r(g,b,t,o,l)){p=!1;break}}return l.delete(n),l.delete(e),p}},function(n,e,t){var a=t(123),i=t(304),s=t(305);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=s,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(316),i=t(322),s=t(196);n.exports=function(n){return s(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(29),i=t(318),s=e&&!e.nodeType&&e,o=s&&"object"==typeof n&&n&&!n.nodeType&&n,r=o&&o.exports===s?a.Buffer:void 0,l=(r?r.isBuffer:void 0)||i;n.exports=l}).call(this,t(147)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(319),i=t(320),s=t(321),o=s&&s.isTypedArray,r=o?i(o):a;n.exports=r},function(n,e,t){var a=t(186),i=t(125);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(41)(t(29),"Set");n.exports=a},function(n,e,t){var a=t(122);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(201),i=t(96);n.exports=function(n,e){for(var t=0,s=(e=a(e,n)).length;null!=n&&t<s;)n=n[i(e[t++])];return t&&t==s?n:void 0}},function(n,e,t){var a=t(27),i=t(126),s=t(333),o=t(336);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:s(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){t(2)({target:"Object",stat:!0},{setPrototypeOf:t(62)})},function(n,e,t){var a=t(2),i=t(16),s=t(34),o=t(378),r=t(164),l=t(7),h=t(8),c=t(32),d=t(3),u=i("Reflect","construct"),f=Object.prototype,m=[].push,p=d((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),y=!d((function(){u((function(){}))})),g=p||y;a({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,e){r(n),l(e);var t=arguments.length<3?n:r(arguments[2]);if(y&&!p)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var a=[null];return s(m,a,e),new(s(o,n,a))}var i=t.prototype,d=c(h(i)?i:f),g=s(n,d,e);return h(g)?g:d}})},function(n,e,t){var a=t(2),i=t(0),s=t(55);a({global:!0},{Reflect:{}}),s(i.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(269),i=t(274),s=t(345),o=t(353),r=t(362),l=t(229),h=s((function(n){var e=l(n);return r(e)&&(e=void 0),o(a(n,1,r,!0),i(e,2))}));n.exports=h},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var s="",o=0,r=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}r!==o&&(s+=t.substring(r,o)),r=o+1,s+=e}return r!==o?s+t.substring(r,o):s}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(370),t(18)),s=Object(i.a)(a,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);t(36),t(5),t(37),t(43),t(30);var a={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(t(371),t(18)),s=Object(i.a)(a,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,a){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=s.exports},function(n,e,t){"use strict";var a=t(9),i=t(0),s=t(1),o=t(101),r=t(14),l=t(10),h=t(145),c=t(33),d=t(81),u=t(153),f=t(3),m=t(54).f,p=t(39).f,y=t(13).f,g=t(365),b=t(215).trim,v=i.Number,x=v.prototype,w=i.TypeError,k=s("".slice),T=s("".charCodeAt),q=function(n){var e=u(n,"number");return"bigint"==typeof e?e:S(e)},S=function(n){var e,t,a,i,s,o,r,l,h=u(n,"number");if(d(h))throw w("Cannot convert a Symbol value to a number");if("string"==typeof h&&h.length>2)if(h=b(h),43===(e=T(h,0))||45===e){if(88===(t=T(h,2))||120===t)return NaN}else if(48===e){switch(T(h,1)){case 66:case 98:a=2,i=49;break;case 79:case 111:a=8,i=55;break;default:return+h}for(o=(s=k(h,2)).length,r=0;r<o;r++)if((l=T(s,r))<48||l>i)return NaN;return parseInt(s,a)}return+h};if(o("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var A,D=function(n){var e=arguments.length<1?0:v(q(n)),t=this;return c(x,t)&&f((function(){g(t)}))?h(Object(e),t,D):e},I=a?m(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),E=0;I.length>E;E++)l(v,A=I[E])&&!l(D,A)&&y(D,A,p(v,A));D.prototype=x,x.constructor=D,r(i,"Number",D)}},function(n,e,t){var a=t(1),i=t(17),s=t(12),o=t(216),r=a("".replace),l="["+o+"]",h=RegExp("^"+l+l+"*"),c=RegExp(l+l+"*$"),d=function(n){return function(e){var t=s(i(e));return 1&n&&(t=r(t,h,"")),2&n&&(t=r(t,c,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){"use strict";var a=t(34),i=t(11),s=t(1),o=t(104),r=t(142),l=t(7),h=t(17),c=t(116),d=t(119),u=t(50),f=t(12),m=t(45),p=t(117),y=t(105),g=t(91),b=t(103),v=t(3),x=b.UNSUPPORTED_Y,w=Math.min,k=[].push,T=s(/./.exec),q=s(k),S=s("".slice);o("split",(function(n,e,t){var s;return s="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var s=f(h(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[s];if(!r(n))return i(e,s,n,o);for(var l,c,d,u=[],m=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),y=0,b=new RegExp(n.source,m+"g");(l=i(g,b,s))&&!((c=b.lastIndex)>y&&(q(u,S(s,y,l.index)),l.length>1&&l.index<s.length&&a(k,u,p(l,1)),d=l[0].length,y=c,u.length>=o));)b.lastIndex===l.index&&b.lastIndex++;return y===s.length?!d&&T(b,"")||q(u,""):q(u,S(s,y)),u.length>o?p(u,0,o):u}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:i(e,this,n,t)}:e,[function(e,t){var a=h(this),o=null==e?void 0:m(e,n);return o?i(o,e,a,t):i(s,f(a),e,t)},function(n,a){var i=l(this),o=f(n),r=t(s,i,o,a,s!==e);if(r.done)return r.value;var h=c(i,RegExp),m=i.unicode,p=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),g=new h(x?"^(?:"+i.source+")":i,p),b=void 0===a?4294967295:a>>>0;if(0===b)return[];if(0===o.length)return null===y(g,o)?[o]:[];for(var v=0,k=0,T=[];k<o.length;){g.lastIndex=x?0:k;var A,D=y(g,x?S(o,k):o);if(null===D||(A=w(u(g.lastIndex+(x?k:0)),o.length))===v)k=d(o,k,m);else{if(q(T,S(o,v,k)),T.length===b)return T;for(var I=1;I<=D.length-1;I++)if(q(T,D[I]),T.length===b)return T;k=v=A}}return q(T,S(o,v)),T}]}),!!v((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var a=t(11),i=t(104),s=t(7),o=t(50),r=t(12),l=t(17),h=t(45),c=t(119),d=t(105);i("match",(function(n,e,t){return[function(e){var t=l(this),i=null==e?void 0:h(e,n);return i?a(i,e,t):new RegExp(e)[n](r(t))},function(n){var a=s(this),i=r(n),l=t(e,a,i);if(l.done)return l.value;if(!a.global)return d(a,i);var h=a.unicode;a.lastIndex=0;for(var u,f=[],m=0;null!==(u=d(a,i));){var p=r(u[0]);f[m]=p,""===p&&(a.lastIndex=c(i,o(a.lastIndex),h)),m++}return 0===m?null:f}]}))},function(n,e,t){var a=t(3),i=t(0).RegExp;n.exports=a((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var a=t(2),i=t(47).find,s=t(99),o=!0;"find"in[]&&Array(1).find((function(){o=!1})),a({target:"Array",proto:!0,forced:o},{find:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),s("find")},function(n,e,t){"use strict";var a=t(158).IteratorPrototype,i=t(32),s=t(46),o=t(55),r=t(61),l=function(){return this};n.exports=function(n,e,t,h){var c=e+" Iterator";return n.prototype=i(a,{next:s(+!h,t)}),o(n,c,!1,!0),r[c]=l,n}},function(n,e,t){var a=t(14);n.exports=function(n,e,t){for(var i in e)a(n,i,e[i],t);return n}},function(n,e,t){"use strict";var a=t(16),i=t(13),s=t(6),o=t(9),r=s("species");n.exports=function(n){var e=a(n),t=i.f;o&&e&&!e[r]&&t(e,r,{configurable:!0,get:function(){return this}})}},function(n,e,t){var a=t(0),i=t(33),s=a.TypeError;n.exports=function(n,e){if(i(e,n))return n;throw s("Incorrect invocation")}},function(n,e,t){var a=t(2),i=t(9),s=t(157),o=t(19),r=t(39),l=t(64);a({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,a=o(n),i=r.f,h=s(a),c={},d=0;h.length>d;)void 0!==(t=i(a,e=h[d++]))&&l(c,e,t);return c}})},function(n,e,t){var a=t(3),i=t(0).RegExp;n.exports=a((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var a=t(2),i=t(109).includes,s=t(99);a({target:"Array",proto:!0},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),s("includes")},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(173),o=t(17),r=t(12),l=t(174),h=i("".indexOf);a({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~h(r(o(this)),r(s(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(366)},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(35),o=t(15),r=t(21),l=t(12),h=t(3),c=t(232),d=t(44),u=t(372),f=t(373),m=t(49),p=t(374),y=[],g=i(y.sort),b=i(y.push),v=h((function(){y.sort(void 0)})),x=h((function(){y.sort(null)})),w=d("sort"),k=!h((function(){if(m)return m<70;if(!(u&&u>3)){if(f)return!0;if(p)return p<603;var n,e,t,a,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(a=0;a<47;a++)y.push({k:e+a,v:t})}for(y.sort((function(n,e){return e.v-n.v})),a=0;a<y.length;a++)e=y[a].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));a({target:"Array",proto:!0,forced:v||!x||!w||!k},{sort:function(n){void 0!==n&&s(n);var e=o(this);if(k)return void 0===n?g(e):g(e,n);var t,a,i=[],h=r(e);for(a=0;a<h;a++)a in e&&b(i,e[a]);for(c(i,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=i.length,a=0;a<t;)e[a]=i[a++];for(;a<h;)delete e[a++];return e}})},function(n,e,t){var a=t(117),i=Math.floor,s=function(n,e){var t=n.length,l=i(t/2);return t<8?o(n,e):r(n,s(a(n,0,l),e),s(a(n,l),e),e)},o=function(n,e){for(var t,a,i=n.length,s=1;s<i;){for(a=s,t=n[s];a&&e(n[a-1],t)>0;)n[a]=n[--a];a!==s++&&(n[a]=t)}return n},r=function(n,e,t,a){for(var i=e.length,s=t.length,o=0,r=0;o<i||r<s;)n[o+r]=o<i&&r<s?a(e[o],t[r])<=0?e[o++]:t[r++]:o<i?e[o++]:t[r++];return n};n.exports=s},function(n,e,t){var a=t(0),i=t(9),s=t(103).MISSED_STICKY,o=t(24),r=t(13).f,l=t(38).get,h=RegExp.prototype,c=a.TypeError;i&&s&&r(h,"sticky",{configurable:!0,get:function(){if(this!==h){if("RegExp"===o(this))return!!l(this).sticky;throw c("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(381)},function(n,e,t){var a=t(0),i=t(11),s=t(4),o=t(8),r=a.TypeError;n.exports=function(n,e){var t,a;if("string"===e&&s(t=n.toString)&&!o(a=i(t,n)))return a;if(s(t=n.valueOf)&&!o(a=i(t,n)))return a;if("string"!==e&&s(t=n.toString)&&!o(a=i(t,n)))return a;throw r("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),i=t(4),s=t(85),o=a.WeakMap;n.exports=i(o)&&/native code/.test(s(o))},function(n,e,t){var a=t(0),i=t(4),s=a.String,o=a.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+s(n)+" as a prototype")}},function(n,e,t){"use strict";var a,i,s,o,r=t(2),l=t(25),h=t(0),c=t(16),d=t(11),u=t(160),f=t(14),m=t(222),p=t(62),y=t(55),g=t(223),b=t(35),v=t(4),x=t(8),w=t(224),k=t(85),T=t(239),q=t(163),S=t(116),A=t(165).set,D=t(240),I=t(167),E=t(243),j=t(168),C=t(244),z=t(245),L=t(38),F=t(101),_=t(6),P=t(246),M=t(87),R=t(49),B=_("species"),O="Promise",N=L.getterFor(O),W=L.set,U=L.getterFor(O),G=u&&u.prototype,$=u,H=G,X=h.TypeError,Y=h.document,Z=h.process,V=j.f,K=V,J=!!(Y&&Y.createEvent&&h.dispatchEvent),Q=v(h.PromiseRejectionEvent),nn=!1,en=F(O,(function(){var n=k($),e=n!==String($);if(!e&&66===R)return!0;if(l&&!H.finally)return!0;if(R>=51&&/native code/.test(n))return!1;var t=new $((function(n){n(1)})),a=function(n){n((function(){}),(function(){}))};return(t.constructor={})[B]=a,!(nn=t.then((function(){}))instanceof a)||!e&&P&&!Q})),tn=en||!q((function(n){$.all(n).catch((function(){}))})),an=function(n){var e;return!(!x(n)||!v(e=n.then))&&e},sn=function(n,e){var t,a,i,s=e.value,o=1==e.state,r=o?n.ok:n.fail,l=n.resolve,h=n.reject,c=n.domain;try{r?(o||(2===e.rejection&&cn(e),e.rejection=1),!0===r?t=s:(c&&c.enter(),t=r(s),c&&(c.exit(),i=!0)),t===n.promise?h(X("Promise-chain cycle")):(a=an(t))?d(a,t,l,h):l(t)):h(s)}catch(n){c&&!i&&c.exit(),h(n)}},on=function(n,e){n.notified||(n.notified=!0,D((function(){for(var t,a=n.reactions;t=a.get();)sn(t,n);n.notified=!1,e&&!n.rejection&&ln(n)})))},rn=function(n,e,t){var a,i;J?((a=Y.createEvent("Event")).promise=e,a.reason=t,a.initEvent(n,!1,!0),h.dispatchEvent(a)):a={promise:e,reason:t},!Q&&(i=h["on"+n])?i(a):"unhandledrejection"===n&&E("Unhandled promise rejection",t)},ln=function(n){d(A,h,(function(){var e,t=n.facade,a=n.value;if(hn(n)&&(e=C((function(){M?Z.emit("unhandledRejection",a,t):rn("unhandledrejection",t,a)})),n.rejection=M||hn(n)?2:1,e.error))throw e.value}))},hn=function(n){return 1!==n.rejection&&!n.parent},cn=function(n){d(A,h,(function(){var e=n.facade;M?Z.emit("rejectionHandled",e):rn("rejectionhandled",e,n.value)}))},dn=function(n,e,t){return function(a){n(e,a,t)}},un=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,on(n,!0))},fn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw X("Promise can't be resolved itself");var a=an(e);a?D((function(){var t={done:!1};try{d(a,e,dn(fn,t,n),dn(un,t,n))}catch(e){un(t,e,n)}})):(n.value=e,n.state=1,on(n,!1))}catch(e){un({done:!1},e,n)}}};if(en&&(H=($=function(n){w(this,H),b(n),d(a,this);var e=N(this);try{n(dn(fn,e),dn(un,e))}catch(n){un(e,n)}}).prototype,(a=function(n){W(this,{type:O,done:!1,notified:!1,parent:!1,reactions:new z,rejection:!1,state:0,value:void 0})}).prototype=m(H,{then:function(n,e){var t=U(this),a=V(S(this,$));return t.parent=!0,a.ok=!v(n)||n,a.fail=v(e)&&e,a.domain=M?Z.domain:void 0,0==t.state?t.reactions.add(a):D((function(){sn(a,t)})),a.promise},catch:function(n){return this.then(void 0,n)}}),i=function(){var n=new a,e=N(n);this.promise=n,this.resolve=dn(fn,e),this.reject=dn(un,e)},j.f=V=function(n){return n===$||n===s?new i(n):K(n)},!l&&v(u)&&G!==Object.prototype)){o=G.then,nn||(f(G,"then",(function(n,e){var t=this;return new $((function(n,e){d(o,t,n,e)})).then(n,e)}),{unsafe:!0}),f(G,"catch",H.catch,{unsafe:!0}));try{delete G.constructor}catch(n){}p&&p(G,H)}r({global:!0,wrap:!0,forced:en},{Promise:$}),y($,O,!1,!0),g(O),s=c(O),r({target:O,stat:!0,forced:en},{reject:function(n){var e=V(this);return d(e.reject,void 0,n),e.promise}}),r({target:O,stat:!0,forced:l||en},{resolve:function(n){return I(l&&this===s?$:this,n)}}),r({target:O,stat:!0,forced:tn},{all:function(n){var e=this,t=V(e),a=t.resolve,i=t.reject,s=C((function(){var t=b(e.resolve),s=[],o=0,r=1;T(n,(function(n){var l=o++,h=!1;r++,d(t,e,n).then((function(n){h||(h=!0,s[l]=n,--r||a(s))}),i)})),--r||a(s)}));return s.error&&i(s.value),t.promise},race:function(n){var e=this,t=V(e),a=t.reject,i=C((function(){var i=b(e.resolve);T(n,(function(n){d(i,e,n).then(t.resolve,a)}))}));return i.error&&a(i.value),t.promise}})},function(n,e,t){var a=t(0),i=t(53),s=t(11),o=t(7),r=t(82),l=t(161),h=t(21),c=t(33),d=t(139),u=t(102),f=t(162),m=a.TypeError,p=function(n,e){this.stopped=n,this.result=e},y=p.prototype;n.exports=function(n,e,t){var a,g,b,v,x,w,k,T=t&&t.that,q=!(!t||!t.AS_ENTRIES),S=!(!t||!t.IS_ITERATOR),A=!(!t||!t.INTERRUPTED),D=i(e,T),I=function(n){return a&&f(a,"normal",n),new p(!0,n)},E=function(n){return q?(o(n),A?D(n[0],n[1],I):D(n[0],n[1])):A?D(n,I):D(n)};if(S)a=n;else{if(!(g=u(n)))throw m(r(n)+" is not iterable");if(l(g)){for(b=0,v=h(n);v>b;b++)if((x=E(n[b]))&&c(y,x))return x;return new p(!1)}a=d(n,g)}for(w=a.next;!(k=s(w,a)).done;){try{x=E(k.value)}catch(n){f(a,"throw",n)}if("object"==typeof x&&x&&c(y,x))return x}return new p(!1)}},function(n,e,t){var a,i,s,o,r,l,h,c,d=t(0),u=t(53),f=t(39).f,m=t(165).set,p=t(166),y=t(241),g=t(242),b=t(87),v=d.MutationObserver||d.WebKitMutationObserver,x=d.document,w=d.process,k=d.Promise,T=f(d,"queueMicrotask"),q=T&&T.value;q||(a=function(){var n,e;for(b&&(n=w.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?o():s=void 0,n}}s=void 0,n&&n.enter()},p||b||g||!v||!x?!y&&k&&k.resolve?((h=k.resolve(void 0)).constructor=k,c=u(h.then,h),o=function(){c(a)}):b?o=function(){w.nextTick(a)}:(m=u(m,d),o=function(){m(a)}):(r=!0,l=x.createTextNode(""),new v(a).observe(l,{characterData:!0}),o=function(){l.data=r=!r})),n.exports=q||function(n){var e={fn:n,next:void 0};s&&(s.next=e),i||(i=e,o()),s=e}},function(n,e,t){var a=t(28),i=t(0);n.exports=/ipad|iphone|ipod/i.test(a)&&void 0!==i.Pebble},function(n,e,t){var a=t(28);n.exports=/web0s(?!.*chrome)/i.test(a)},function(n,e,t){var a=t(0);n.exports=function(n,e){var t=a.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window},function(n,e,t){var a=t(2),i=t(248);a({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var a=t(9),i=t(1),s=t(11),o=t(3),r=t(83),l=t(113),h=t(111),c=t(15),d=t(58),u=Object.assign,f=Object.defineProperty,m=i([].concat);n.exports=!u||o((function(){if(a&&1!==u({b:1},u(f({},"a",{enumerable:!0,get:function(){f(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=u({},n)[t]||"abcdefghijklmnopqrst"!=r(u({},e)).join("")}))?function(n,e){for(var t=c(n),i=arguments.length,o=1,u=l.f,f=h.f;i>o;)for(var p,y=d(arguments[o++]),g=u?m(r(y),u(y)):r(y),b=g.length,v=0;b>v;)p=g[v++],a&&!s(f,y,p)||(t[p]=y[p]);return t}:u},function(n,e,t){"use strict";var a=t(2),i=t(25),s=t(160),o=t(3),r=t(16),l=t(4),h=t(116),c=t(167),d=t(14);if(a({target:"Promise",proto:!0,real:!0,forced:!!s&&o((function(){s.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=h(this,r("Promise")),t=l(n);return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),!i&&l(s)){var u=r("Promise").prototype.finally;s.prototype.finally!==u&&d(s.prototype,"finally",u,{unsafe:!0})}},function(n,e,t){"use strict";var a=t(115),i=t(73);n.exports=a?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){var a=t(0),i=t(56),s=t(86),o=t(8),r=t(6)("species"),l=a.Array;n.exports=function(n){var e;return i(n)&&(e=n.constructor,(s(e)&&(e===l||i(e.prototype))||o(e)&&null===(e=e[r]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var a=t(2),i=t(253).left,s=t(44),o=t(49),r=t(87);a({target:"Array",proto:!0,forced:!s("reduce")||!r&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),i=t(35),s=t(15),o=t(58),r=t(21),l=a.TypeError,h=function(n){return function(e,t,a,h){i(t);var c=s(e),d=o(c),u=r(c),f=n?u-1:0,m=n?-1:1;if(a<2)for(;;){if(f in d){h=d[f],f+=m;break}if(f+=m,n?f<0:u<=f)throw l("Reduce of empty array with no initial value")}for(;n?f>=0:u>f;f+=m)f in d&&(h=t(h,d[f],f,c));return h}};n.exports={left:h(!1),right:h(!0)}},function(n,e,t){"use strict";var a,i=t(2),s=t(1),o=t(39).f,r=t(50),l=t(12),h=t(173),c=t(17),d=t(174),u=t(25),f=s("".startsWith),m=s("".slice),p=Math.min,y=d("startsWith");i({target:"String",proto:!0,forced:!!(u||y||(a=o(String.prototype,"startsWith"),!a||a.writable))&&!y},{startsWith:function(n){var e=l(c(this));h(n);var t=r(p(arguments.length>1?arguments[1]:void 0,e.length)),a=l(n);return f?f(e,a,t):m(e,t,t+a.length)===a}})},function(n,e,t){var a=t(2),i=t(176),s=t(3),o=t(8),r=t(256).onFreeze,l=Object.freeze;a({target:"Object",stat:!0,forced:s((function(){l(1)})),sham:!i},{freeze:function(n){return l&&o(n)?l(r(n)):n}})},function(n,e,t){var a=t(2),i=t(1),s=t(60),o=t(8),r=t(10),l=t(13).f,h=t(54),c=t(177),d=t(257),u=t(78),f=t(176),m=!1,p=u("meta"),y=0,g=function(n){l(n,p,{value:{objectID:"O"+y++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},m=!0;var n=h.f,e=i([].splice),t={};t[p]=1,n(t).length&&(h.f=function(t){for(var a=n(t),i=0,s=a.length;i<s;i++)if(a[i]===p){e(a,i,1);break}return a},a({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:c.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!r(n,p)){if(!d(n))return"F";if(!e)return"E";g(n)}return n[p].objectID},getWeakData:function(n,e){if(!r(n,p)){if(!d(n))return!0;if(!e)return!1;g(n)}return n[p].weakData},onFreeze:function(n){return f&&m&&d(n)&&!r(n,p)&&g(n),n}};s[p]=!0},function(n,e,t){var a=t(3),i=t(8),s=t(24),o=t(258),r=Object.isExtensible,l=a((function(){r(1)}));n.exports=l||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=s(n))&&(!r||r(n)))}:r},function(n,e,t){var a=t(3);n.exports=a((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){var a=t(0);n.exports=a},function(n,e,t){"use strict";var a=t(0),i=t(53),s=t(11),o=t(15),r=t(261),l=t(161),h=t(86),c=t(21),d=t(64),u=t(139),f=t(102),m=a.Array;n.exports=function(n){var e=o(n),t=h(this),a=arguments.length,p=a>1?arguments[1]:void 0,y=void 0!==p;y&&(p=i(p,a>2?arguments[2]:void 0));var g,b,v,x,w,k,T=f(e),q=0;if(!T||this==m&&l(T))for(g=c(e),b=t?new this(g):m(g);g>q;q++)k=y?p(e[q],q):e[q],d(b,q,k);else for(w=(x=u(e,T)).next,b=t?new this:[];!(v=s(w,x)).done;q++)k=y?r(x,p,[v.value,q],!0):v.value,d(b,q,k);return b.length=q,b}},function(n,e,t){var a=t(7),i=t(162);n.exports=function(n,e,t,s){try{return s?e(a(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";var a=t(16),i=t(10),s=t(26),o=t(33),r=t(62),l=t(112),h=t(145),c=t(180),d=t(263),u=t(264),f=t(265),m=t(25);n.exports=function(n,e,t,p){var y=p?2:1,g=n.split("."),b=g[g.length-1],v=a.apply(null,g);if(v){var x=v.prototype;if(!m&&i(x,"cause")&&delete x.cause,!t)return v;var w=a("Error"),k=e((function(n,e){var t=c(p?e:n,void 0),a=p?new v(n):new v;return void 0!==t&&s(a,"message",t),f&&s(a,"stack",u(a.stack,2)),this&&o(x,this)&&h(a,this,k),arguments.length>y&&d(a,arguments[y]),a}));if(k.prototype=x,"Error"!==b&&(r?r(k,w):l(k,w,{name:!0})),l(k,v),!m)try{x.name!==b&&s(x,"name",b),x.constructor=k}catch(n){}return k}}},function(n,e,t){var a=t(8),i=t(26);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var a=t(1)("".replace),i=String(Error("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,o=s.test(i);n.exports=function(n,e){if(o&&"string"==typeof n)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var a=t(3),i=t(46);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(9),i=t(3),s=t(7),o=t(32),r=t(180),l=Error.prototype.toString,h=i((function(){if(a){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=h?function(){var n=s(this),e=r(n.name,"Error"),t=r(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var a=t(1),i=t(15),s=Math.floor,o=a("".charAt),r=a("".replace),l=a("".slice),h=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,c=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,a,d,u){var f=t+n.length,m=a.length,p=c;return void 0!==d&&(d=i(d),p=h),r(u,p,(function(i,r){var h;switch(o(r,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,f);case"<":h=d[l(r,1,-1)];break;default:var c=+r;if(0===c)return i;if(c>m){var u=s(c/10);return 0===u?i:u<=m?void 0===a[u-1]?o(r,1):a[u-1]+o(r,1):i}h=a[c-1]}return void 0===h?"":h}))}},function(n,e,t){var a=t(2),i=t(0),s=t(16),o=t(34),r=t(1),l=t(3),h=i.Array,c=s("JSON","stringify"),d=r(/./.exec),u=r("".charAt),f=r("".charCodeAt),m=r("".replace),p=r(1..toString),y=/[\uD800-\uDFFF]/g,g=/^[\uD800-\uDBFF]$/,b=/^[\uDC00-\uDFFF]$/,v=function(n,e,t){var a=u(t,e-1),i=u(t,e+1);return d(g,n)&&!d(b,i)||d(b,n)&&!d(g,a)?"\\u"+p(f(n,0),16):n},x=l((function(){return'"\\udf06\\ud834"'!==c("\udf06\ud834")||'"\\udead"'!==c("\udead")}));c&&a({target:"JSON",stat:!0,forced:x},{stringify:function(n,e,t){for(var a=0,i=arguments.length,s=h(i);a<i;a++)s[a]=arguments[a];var r=o(c,null,s);return"string"==typeof r?m(r,y,v):r}})},function(n,e,t){var a=t(182),i=t(270);n.exports=function n(e,t,s,o,r){var l=-1,h=e.length;for(s||(s=i),r||(r=[]);++l<h;){var c=e[l];t>0&&s(c)?t>1?n(c,t-1,s,o,r):a(r,c):o||(r[r.length]=c)}return r}},function(n,e,t){var a=t(65),i=t(120),s=t(27),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return s(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(57),i=t(48);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(65),i=Object.prototype,s=i.hasOwnProperty,o=i.toString,r=a?a.toStringTag:void 0;n.exports=function(n){var e=s.call(n,r),t=n[r];try{n[r]=void 0;var a=!0}catch(n){}var i=o.call(n);return a&&(e?n[r]=t:delete n[r]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(275),i=t(331),s=t(128),o=t(27),r=t(342);n.exports=function(n){return"function"==typeof n?n:null==n?s:"object"==typeof n?o(n)?i(n[0],n[1]):a(n):r(n)}},function(n,e,t){var a=t(276),i=t(330),s=t(199);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?s(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(184),i=t(188);n.exports=function(n,e,t,s){var o=t.length,r=o,l=!s;if(null==n)return!r;for(n=Object(n);o--;){var h=t[o];if(l&&h[2]?h[1]!==n[h[0]]:!(h[0]in n))return!1}for(;++o<r;){var c=(h=t[o])[0],d=n[c],u=h[1];if(l&&h[2]){if(void 0===d&&!(c in n))return!1}else{var f=new a;if(s)var m=s(d,u,c,n,e,f);if(!(void 0===m?i(u,d,3,s,f):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(93),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(93);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(93);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(93);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(92);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(92),i=t(121),s=t(123);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new s(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(186),i=t(288),s=t(122),o=t(187),r=/^\[object .+?Constructor\]$/,l=Function.prototype,h=Object.prototype,c=l.toString,d=h.hasOwnProperty,u=RegExp("^"+c.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!s(n)||i(n))&&(a(n)?u:r).test(o(n))}},function(n,e,t){var a,i=t(289),s=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!s&&s in n}},function(n,e,t){var a=t(29)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(292),i=t(92),s=t(121);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(s||i),string:new a}}},function(n,e,t){var a=t(293),i=t(294),s=t(295),o=t(296),r=t(297);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e,t){var a=t(94);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(94),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(94),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(94);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(95);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(95);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(95);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(95);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(184),i=t(189),s=t(307),o=t(310),r=t(326),l=t(27),h=t(193),c=t(195),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,m,p){var y=l(n),g=l(e),b=y?"[object Array]":r(n),v=g?"[object Array]":r(e),x=(b="[object Arguments]"==b?d:b)==d,w=(v="[object Arguments]"==v?d:v)==d,k=b==v;if(k&&h(n)){if(!h(e))return!1;y=!0,x=!1}if(k&&!x)return p||(p=new a),y||c(n)?i(n,e,t,f,m,p):s(n,e,b,t,f,m,p);if(!(1&t)){var T=x&&u.call(n,"__wrapped__"),q=w&&u.call(e,"__wrapped__");if(T||q){var S=T?n.value():n,A=q?e.value():e;return p||(p=new a),m(S,A,t,f,p)}}return!!k&&(p||(p=new a),o(n,e,t,f,m,p))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(65),i=t(308),s=t(185),o=t(189),r=t(309),l=t(124),h=a?a.prototype:void 0,c=h?h.valueOf:void 0;n.exports=function(n,e,t,a,h,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return s(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=r;case"[object Set]":var m=1&a;if(f||(f=l),n.size!=e.size&&!m)return!1;var p=u.get(n);if(p)return p==e;a|=2,u.set(n,e);var y=o(f(n),f(e),a,h,d,u);return u.delete(n),y;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var a=t(29).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(311),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,s,o,r){var l=1&t,h=a(n),c=h.length;if(c!=a(e).length&&!l)return!1;for(var d=c;d--;){var u=h[d];if(!(l?u in e:i.call(e,u)))return!1}var f=r.get(n),m=r.get(e);if(f&&m)return f==e&&m==n;var p=!0;r.set(n,e),r.set(e,n);for(var y=l;++d<c;){var g=n[u=h[d]],b=e[u];if(s)var v=l?s(b,g,u,e,n,r):s(g,b,u,n,e,r);if(!(void 0===v?g===b||o(g,b,t,s,r):v)){p=!1;break}y||(y="constructor"==u)}if(p&&!y){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(p=!1)}return r.delete(n),r.delete(e),p}},function(n,e,t){var a=t(312),i=t(313),s=t(192);n.exports=function(n){return a(n,s,i)}},function(n,e,t){var a=t(182),i=t(27);n.exports=function(n,e,t){var s=e(n);return i(n)?s:a(s,t(n))}},function(n,e,t){var a=t(314),i=t(315),s=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,r=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return s.call(n,e)})))}:i;n.exports=r},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,s=[];++t<a;){var o=n[t];e(o,t,n)&&(s[i++]=o)}return s}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(317),i=t(120),s=t(27),o=t(193),r=t(194),l=t(195),h=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=s(n),c=!t&&i(n),d=!t&&!c&&o(n),u=!t&&!c&&!d&&l(n),f=t||c||d||u,m=f?a(n.length,String):[],p=m.length;for(var y in n)!e&&!h.call(n,y)||f&&("length"==y||d&&("offset"==y||"parent"==y)||u&&("buffer"==y||"byteLength"==y||"byteOffset"==y)||r(y,p))||m.push(y);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(57),i=t(125),s=t(48),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return s(n)&&i(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(183),i=e&&!e.nodeType&&e,s=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===i&&a.process,r=function(){try{var n=s&&s.require&&s.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=r}).call(this,t(147)(n))},function(n,e,t){var a=t(323),i=t(324),s=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))s.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(325)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(327),i=t(121),s=t(328),o=t(197),r=t(329),l=t(57),h=t(187),c=h(a),d=h(i),u=h(s),f=h(o),m=h(r),p=l;(a&&"[object DataView]"!=p(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=p(new i)||s&&"[object Promise]"!=p(s.resolve())||o&&"[object Set]"!=p(new o)||r&&"[object WeakMap]"!=p(new r))&&(p=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?h(t):"";if(a)switch(a){case c:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case f:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=p},function(n,e,t){var a=t(41)(t(29),"DataView");n.exports=a},function(n,e,t){var a=t(41)(t(29),"Promise");n.exports=a},function(n,e,t){var a=t(41)(t(29),"WeakMap");n.exports=a},function(n,e,t){var a=t(198),i=t(192);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var s=e[t],o=n[s];e[t]=[s,o,a(o)]}return e}},function(n,e,t){var a=t(188),i=t(332),s=t(339),o=t(126),r=t(198),l=t(199),h=t(96);n.exports=function(n,e){return o(n)&&r(e)?l(h(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?s(t,n):a(e,o,3)}}},function(n,e,t){var a=t(200);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(334),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,s=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(s,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(335);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(123);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],s=t.cache;if(s.has(i))return s.get(i);var o=n.apply(this,a);return t.cache=s.set(i,o)||s,o};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(337);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(65),i=t(338),s=t(27),o=t(127),r=a?a.prototype:void 0,l=r?r.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(s(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(340),i=t(341);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(201),i=t(120),s=t(27),o=t(194),r=t(125),l=t(96);n.exports=function(n,e,t){for(var h=-1,c=(e=a(e,n)).length,d=!1;++h<c;){var u=l(e[h]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++h!=c?d:!!(c=null==n?0:n.length)&&r(c)&&o(u,c)&&(s(n)||i(n))}},function(n,e,t){var a=t(343),i=t(344),s=t(126),o=t(96);n.exports=function(n){return s(n)?a(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(200);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(128),i=t(346),s=t(348);n.exports=function(n,e){return s(i(n,e,a),n+"")}},function(n,e,t){var a=t(347),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var s=arguments,o=-1,r=i(s.length-e,0),l=Array(r);++o<r;)l[o]=s[e+o];o=-1;for(var h=Array(e+1);++o<e;)h[o]=s[o];return h[e]=t(l),a(n,this,h)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(349),i=t(352)(a);n.exports=i},function(n,e,t){var a=t(350),i=t(351),s=t(128),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:s;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(41),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),s=16-(i-a);if(a=i,s>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(190),i=t(354),s=t(359),o=t(191),r=t(360),l=t(124);n.exports=function(n,e,t){var h=-1,c=i,d=n.length,u=!0,f=[],m=f;if(t)u=!1,c=s;else if(d>=200){var p=e?null:r(n);if(p)return l(p);u=!1,c=o,m=new a}else m=e?[]:f;n:for(;++h<d;){var y=n[h],g=e?e(y):y;if(y=t||0!==y?y:0,u&&g==g){for(var b=m.length;b--;)if(m[b]===g)continue n;e&&m.push(g),f.push(y)}else c(m,g,t)||(m!==f&&m.push(g),f.push(y))}return f}},function(n,e,t){var a=t(355);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(356),i=t(357),s=t(358);n.exports=function(n,e,t){return e==e?s(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,s=t+(a?1:-1);a?s--:++s<i;)if(e(n[s],s,n))return s;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(197),i=t(361),s=t(124),o=a&&1/s(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(196),i=t(48);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(1);n.exports=a(1..valueOf)},function(n,e){var t,a,i,s,o,r,l,h=!1,c=[];"undefined"!=typeof document&&(s=function(n){return h||"interactive"===document.readyState||"complete"===document.readyState?n.call(document):c.push((function(){return n.call(this)})),this},r=function(){for(var n=0,e=c.length;n<e;n++)c[n].apply(document);c=[]},l=function(){h||(h=!0,r.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",l),window==window.top&&(clearInterval(o),o=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",(function(){/loaded|complete/.test(document.readyState)&&l()})),window==window.top&&(o=setInterval((function(){try{h||document.documentElement.doScroll("left")}catch(n){return}l()}),5)))),t={fetch:function(n,e){var t="BusuanziCallback_"+Math.floor(1099511627776*Math.random());n=n.replace("=BusuanziCallback","="+t),(i=document.createElement("SCRIPT")).type="text/javascript",i.defer=!0,i.src=n,document.getElementsByTagName("HEAD")[0].appendChild(i),window[t]=this.evalCall(e)},evalCall:function(n){return function(e){s((function(){try{n(e),i&&i.parentElement&&i.parentElement.removeChild&&i.parentElement.removeChild(i)}catch(n){console.log(n),a.hides()}}))}}};const d=()=>{a&&a.hides(),t.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",(function(n){a.texts(n),a.shows()}))};a={bszs:["site_pv","page_pv","site_uv"],texts:function(n){this.bszs.map((function(e){var t=document.getElementById("busuanzi_value_"+e);t&&(t.innerHTML=n[e])}))},hides:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="none")}))},shows:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="inline")}))}},"undefined"!=typeof document&&d(),n.exports={fetch:d}},function(n,e,t){var a=t(1),i=t(50),s=t(12),o=t(368),r=t(17),l=a(o),h=a("".slice),c=Math.ceil,d=function(n){return function(e,t,a){var o,d,u=s(r(e)),f=i(t),m=u.length,p=void 0===a?" ":s(a);return f<=m||""==p?u:((d=l(p,c((o=f-m)/p.length))).length>o&&(d=h(d,0,o)),n?u+d:d+u)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var a=t(0),i=t(52),s=t(12),o=t(17),r=a.RangeError;n.exports=function(n){var e=s(o(this)),t="",a=i(n);if(a<0||a==1/0)throw r("Wrong number of repetitions");for(;a>0;(a>>>=1)&&(e+=e))1&a&&(t+=e);return t}},function(n,e,t){var a=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(a)},function(n,e,t){"use strict";t(202)},function(n,e,t){"use strict";t(203)},function(n,e,t){var a=t(28).match(/firefox\/(\d+)/i);n.exports=!!a&&+a[1]},function(n,e,t){var a=t(28);n.exports=/MSIE|Trident/.test(a)},function(n,e,t){var a=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!a&&+a[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(204)},function(n,e,t){"use strict";var a=t(0),i=t(1),s=t(35),o=t(8),r=t(10),l=t(63),h=t(59),c=a.Function,d=i([].concat),u=i([].join),f={},m=function(n,e,t){if(!r(f,e)){for(var a=[],i=0;i<e;i++)a[i]="a["+i+"]";f[e]=c("C,a","return new C("+u(a,",")+")")}return f[e](n,t)};n.exports=h?c.bind:function(n){var e=s(this),t=e.prototype,a=l(arguments,1),i=function(){var t=d(a,l(arguments));return this instanceof i?m(e,t.length,t):e.apply(n,t)};return o(t)&&(i.prototype=t),i}},function(n,e,t){"use strict";t(208)},function(n,e,t){"use strict";t(209)},function(n,e,t){"use strict";t.r(e);t(137),t(238),t(247),t(249);var a=t(88),i=(t(135),t(68),t(5),t(22),t(31),t(43),t(30),Object.freeze({}));function s(n){return null==n}function o(n){return null!=n}function r(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function h(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function d(n){return"[object Object]"===c.call(n)}function u(n){return"[object RegExp]"===c.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function p(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var b=g("key,ref,slot,slot-scope,is");function v(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,q=k((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),S=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,D=k((function(n){return n.replace(A,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function E(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function j(n,e){for(var t in e)n[t]=e[t];return n}function C(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function z(n,e,t){}var L=function(n,e,t){return!1},F=function(n){return n};function _(n,e){if(n===e)return!0;var t=h(n),a=h(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),s=Array.isArray(e);if(i&&s)return n.length===e.length&&n.every((function(n,t){return _(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||s)return!1;var o=Object.keys(n),r=Object.keys(e);return o.length===r.length&&o.every((function(t){return _(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(_(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],B=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],O={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:z,parsePlatformTagName:F,mustUseProp:L,async:!0,_lifecycleHooks:B},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var U=new RegExp("[^"+N.source+".$_\\d]");var G,$="__proto__"in{},H="undefined"!=typeof window,X="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Y=X&&WXEnvironment.platform.toLowerCase(),Z=H&&window.navigator.userAgent.toLowerCase(),V=Z&&/msie|trident/.test(Z),K=Z&&Z.indexOf("msie 9.0")>0,J=Z&&Z.indexOf("edge/")>0,Q=(Z&&Z.indexOf("android"),Z&&/iphone|ipad|ipod|ios/.test(Z)||"ios"===Y),nn=(Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z),Z&&Z.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(H)try{var an={};Object.defineProperty(an,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===G&&(G=!H&&!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),G},on=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function rn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,hn="undefined"!=typeof Symbol&&rn(Symbol)&&"undefined"!=typeof Reflect&&rn(Reflect.ownKeys);ln="undefined"!=typeof Set&&rn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=z,dn=0,un=function(){this.id=dn++,this.subs=[]};un.prototype.addSub=function(n){this.subs.push(n)},un.prototype.removeSub=function(n){v(this.subs,n)},un.prototype.depend=function(){un.target&&un.target.addDep(this)},un.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},un.target=null;var fn=[];function mn(n){fn.push(n),un.target=n}function pn(){fn.pop(),un.target=fn[fn.length-1]}var yn=function(n,e,t,a,i,s,o,r){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=r,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(yn.prototype,gn);var bn=function(n){void 0===n&&(n="");var e=new yn;return e.text=n,e.isComment=!0,e};function vn(n){return new yn(void 0,void 0,void 0,String(n))}function xn(n){var e=new yn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];W(kn,n,(function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];var i,s=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),s}))}));var Tn=Object.getOwnPropertyNames(kn),qn=!0;function Sn(n){qn=n}var An=function(n){this.value=n,this.dep=new un,this.vmCount=0,W(n,"__ob__",this),Array.isArray(n)?($?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var a=0,i=t.length;a<i;a++){var s=t[a];W(n,s,e[s])}}(n,kn,Tn),this.observeArray(n)):this.walk(n)};function Dn(n,e){var t;if(h(n)&&!(n instanceof yn))return w(n,"__ob__")&&n.__ob__ instanceof An?t=n.__ob__:qn&&!sn()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new An(n)),e&&t&&t.vmCount++,t}function In(n,e,t,a,i){var s=new un,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var r=o&&o.get,l=o&&o.set;r&&!l||2!==arguments.length||(t=n[e]);var h=!i&&Dn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=r?r.call(n):t;return un.target&&(s.depend(),h&&(h.dep.depend(),Array.isArray(e)&&Cn(e))),e},set:function(e){var a=r?r.call(n):t;e===a||e!=e&&a!=a||r&&!l||(l?l.call(n,e):t=e,h=!i&&Dn(e),s.notify())}})}}function En(n,e,t){if(Array.isArray(n)&&f(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var a=n.__ob__;return n._isVue||a&&a.vmCount?t:a?(In(a.value,e,t),a.dep.notify(),t):(n[e]=t,t)}function jn(n,e){if(Array.isArray(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Cn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Cn(e)}An.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)In(n,e[t])},An.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Dn(n[e])};var zn=O.optionMergeStrategies;function Ln(n,e){if(!e)return n;for(var t,a,i,s=hn?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(t=s[o])&&(a=n[t],i=e[t],w(n,t)?a!==i&&d(a)&&d(i)&&Ln(a,i):En(n,t,i));return n}function Fn(n,e,t){return t?function(){var a="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return a?Ln(a,i):i}:e?n?function(){return Ln("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function _n(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pn(n,e,t,a){var i=Object.create(n||null);return e?j(i,e):i}zn.data=function(n,e,t){return t?Fn(n,e,t):e&&"function"!=typeof e?n:Fn(n,e)},B.forEach((function(n){zn[n]=_n})),R.forEach((function(n){zn[n+"s"]=Pn})),zn.watch=function(n,e,t,a){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var s in j(i,n),e){var o=i[s],r=e[s];o&&!Array.isArray(o)&&(o=[o]),i[s]=o?o.concat(r):Array.isArray(r)?r:[r]}return i},zn.props=zn.methods=zn.inject=zn.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return j(i,n),e&&j(i,e),i},zn.provide=Fn;var Mn=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,s={};if(Array.isArray(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(s[q(i)]={type:null});else if(d(t))for(var o in t)i=t[o],s[q(o)]=d(i)?i:{type:i};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(d(t))for(var s in t){var o=t[s];a[s]=d(o)?j({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];"function"==typeof a&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Rn(n,e.mixins[a],t);var s,o={};for(s in n)r(s);for(s in e)w(n,s)||r(s);function r(a){var i=zn[a]||Mn;o[a]=i(n[a],e[a],t,a)}return o}function Bn(n,e,t,a){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var s=q(t);if(w(i,s))return i[s];var o=S(s);return w(i,o)?i[o]:i[t]||i[s]||i[o]}}function On(n,e,t,a){var i=e[n],s=!w(t,n),o=t[n],r=Gn(Boolean,i.type);if(r>-1)if(s&&!w(i,"default"))o=!1;else if(""===o||o===D(n)){var l=Gn(String,i.type);(l<0||r<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof a&&"Function"!==Wn(e.type)?a.call(n):a}(a,i,n);var h=qn;Sn(!0),Dn(o),Sn(h)}return o}var Nn=/^\s*function (\w+)/;function Wn(n){var e=n&&n.toString().match(Nn);return e?e[1]:""}function Un(n,e){return Wn(n)===Wn(e)}function Gn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Un(e[t],n))return t;return-1}function $n(n,e,t){mn();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,n,e,t))return}catch(n){Xn(n,a,"errorCaptured hook")}}Xn(n,e,t)}finally{pn()}}function Hn(n,e,t,a,i){var s;try{(s=t?n.apply(e,t):n.call(e))&&!s._isVue&&m(s)&&!s._handled&&(s.catch((function(n){return $n(n,a,i+" (Promise/async)")})),s._handled=!0)}catch(n){$n(n,a,i)}return s}function Xn(n,e,t){if(O.errorHandler)try{return O.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Yn(e,null,"config.errorHandler")}Yn(n,e,t)}function Yn(n,e,t){if(!H&&!X||"undefined"==typeof console)throw n;console.error(n)}var Zn,Vn=!1,Kn=[],Jn=!1;function Qn(){Jn=!1;var n=Kn.slice(0);Kn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&rn(Promise)){var ne=Promise.resolve();Zn=function(){ne.then(Qn),Q&&setTimeout(z)},Vn=!0}else if(V||"undefined"==typeof MutationObserver||!rn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Zn="undefined"!=typeof setImmediate&&rn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),ae=document.createTextNode(String(ee));te.observe(ae,{characterData:!0}),Zn=function(){ee=(ee+1)%2,ae.data=String(ee)},Vn=!0}function ie(n,e){var t;if(Kn.push((function(){if(n)try{n.call(e)}catch(n){$n(n,e,"nextTick")}else t&&t(e)})),Jn||(Jn=!0,Zn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var se=new ln;function oe(n){!function n(e,t){var a,i,s=Array.isArray(e);if(!s&&!h(e)||Object.isFrozen(e)||e instanceof yn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(a=e.length;a--;)n(e[a],t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,se),se.clear()}var re=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function le(n,e){function t(){var n=arguments,a=t.fns;if(!Array.isArray(a))return Hn(a,null,arguments,e,"v-on handler");for(var i=a.slice(),s=0;s<i.length;s++)Hn(i[s],null,n,e,"v-on handler")}return t.fns=n,t}function he(n,e,t,a,i,o){var l,h,c,d;for(l in n)h=n[l],c=e[l],d=re(l),s(h)||(s(c)?(s(h.fns)&&(h=n[l]=le(h,o)),r(d.once)&&(h=n[l]=i(d.name,h,d.capture)),t(d.name,h,d.capture,d.passive,d.params)):h!==c&&(c.fns=h,n[l]=c));for(l in e)s(n[l])&&a((d=re(l)).name,e[l],d.capture)}function ce(n,e,t){var a;n instanceof yn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),v(a.fns,l)}s(i)?a=le([l]):o(i.fns)&&r(i.merged)?(a=i).fns.push(l):a=le([i,l]),a.merged=!0,n[e]=a}function de(n,e,t,a,i){if(o(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function ue(n){return l(n)?[vn(n)]:Array.isArray(n)?function n(e,t){var a,i,h,c,d=[];for(a=0;a<e.length;a++)s(i=e[a])||"boolean"==typeof i||(h=d.length-1,c=d[h],Array.isArray(i)?i.length>0&&(fe((i=n(i,(t||"")+"_"+a))[0])&&fe(c)&&(d[h]=vn(c.text+i[0].text),i.shift()),d.push.apply(d,i)):l(i)?fe(c)?d[h]=vn(c.text+i):""!==i&&d.push(vn(i)):fe(i)&&fe(c)?d[h]=vn(c.text+i.text):(r(e._isVList)&&o(i.tag)&&s(i.key)&&o(t)&&(i.key="__vlist"+t+"_"+a+"__"),d.push(i)));return d}(n):void 0}function fe(n){return o(n)&&o(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),a=hn?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){for(var o=n[s].from,r=e;r;){if(r._provided&&w(r._provided,o)){t[s]=r._provided[o];break}r=r.$parent}if(!r)if("default"in n[s]){var l=n[s].default;t[s]="function"==typeof l?l.call(e):l}else 0}}return t}}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var s=n[a],o=s.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,s.context!==e&&s.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(s);else{var r=o.slot,l=t[r]||(t[r]=[]);"template"===s.tag?l.push.apply(l,s.children||[]):l.push(s)}}for(var h in t)t[h].every(ye)&&delete t[h];return t}function ye(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var a,s=Object.keys(e).length>0,o=n?!!n.$stable:!s,r=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&r===t.$key&&!s&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=ve(e,l,n[l]))}else a={};for(var h in e)h in a||(a[h]=xe(e,h));return n&&Object.isExtensible(n)&&(n._normalized=a),W(a,"$stable",o),W(a,"$key",r),W(a,"$hasNormal",s),a}function ve(n,e,t){var a=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ge(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:a,enumerable:!0,configurable:!0}),a}function xe(n,e){return function(){return n[e]}}function we(n,e){var t,a,i,s,r;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),a=0,i=n.length;a<i;a++)t[a]=e(n[a],a);else if("number"==typeof n)for(t=new Array(n),a=0;a<n;a++)t[a]=e(a+1,a);else if(h(n))if(hn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),c=l.next();!c.done;)t.push(e(c.value,t.length)),c=l.next()}else for(s=Object.keys(n),t=new Array(s.length),a=0,i=s.length;a<i;a++)r=s[a],t[a]=e(n[r],r,a);return o(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,a){var i,s=this.$scopedSlots[n];s?(t=t||{},a&&(t=j(j({},a),t)),i=s(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Te(n){return Bn(this.$options,"filters",n)||F}function qe(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,a,i){var s=O.keyCodes[e]||t;return i&&a&&!O.keyCodes[e]?qe(i,a):s?qe(s,n):a?D(a)!==e:void 0===n}function Ae(n,e,t,a,i){if(t)if(h(t)){var s;Array.isArray(t)&&(t=C(t));var o=function(o){if("class"===o||"style"===o||b(o))s=n;else{var r=n.attrs&&n.attrs.type;s=a||O.mustUseProp(e,r,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=q(o),h=D(o);l in s||h in s||(s[o]=t[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var r in t)o(r)}else;return n}function De(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||Ee(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),a}function Ie(n,e,t){return Ee(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ee(n,e,t){if(Array.isArray(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&je(n[a],e+"_"+a,t);else je(n,e,t)}function je(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(d(e)){var t=n.on=n.on?j({},n.on):{};for(var a in e){var i=t[a],s=e[a];t[a]=i?[].concat(i,s):s}}else;return n}function ze(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var s=n[i];Array.isArray(s)?ze(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function Le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function Fe(n,e){return"string"==typeof n?e+n:n}function _e(n){n._o=Ie,n._n=y,n._s=p,n._l=we,n._t=ke,n._q=_,n._i=P,n._m=De,n._f=Te,n._k=Se,n._b=Ae,n._v=vn,n._e=bn,n._u=ze,n._g=Ce,n._d=Le,n._p=Fe}function Pe(n,e,t,a,s){var o,l=this,h=s.options;w(a,"_uid")?(o=Object.create(a))._original=a:(o=a,a=a._original);var c=r(h._compiled),d=!c;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||i,this.injections=me(h.inject,a),this.slots=function(){return l.$slots||be(n.scopedSlots,l.$slots=pe(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),c&&(this.$options=h,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),h._scopeId?this._c=function(n,e,t,i){var s=Ue(o,n,e,t,i,d);return s&&!Array.isArray(s)&&(s.fnScopeId=h._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,a){return Ue(o,n,e,t,a,d)}}function Me(n,e,t,a,i){var s=xn(n);return s.fnContext=t,s.fnOptions=a,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function Re(n,e){for(var t in e)n[q(t)]=e[t]}_e(Pe.prototype);var Be={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Be.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Je)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,s){0;var o=a.data.scopedSlots,r=n.$scopedSlots,l=!!(o&&!o.$stable||r!==i&&!r.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),h=!!(s||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=s,n.$attrs=a.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){Sn(!1);for(var c=n._props,d=n.$options._propKeys||[],u=0;u<d.length;u++){var f=d[u],m=n.$options.props;c[f]=On(f,m,e,n)}Sn(!0),n.$options.propsData=e}t=t||i;var p=n.$options._parentListeners;n.$options._parentListeners=t,Ke(n,t,p),h&&(n.$slots=pe(s,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,tt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,it.push(e)):et(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Oe=Object.keys(Be);function Ne(n,e,t,a,l){if(!s(n)){var c=t.$options._base;if(h(n)&&(n=c.extend(n)),"function"==typeof n){var d;if(s(n.cid)&&void 0===(n=function(n,e){if(r(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=$e;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(r(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return v(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=M((function(t){n.resolved=He(t,e),i?a.length=0:d(!0)})),f=M((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),p=n(u,f);return h(p)&&(m(p)?s(n.resolved)&&p.then(u,f):m(p.component)&&(p.component.then(u,f),o(p.error)&&(n.errorComp=He(p.error,e)),o(p.loading)&&(n.loadingComp=He(p.loading,e),0===p.delay?n.loading=!0:l=setTimeout((function(){l=null,s(n.resolved)&&s(n.error)&&(n.loading=!0,d(!1))}),p.delay||200)),o(p.timeout)&&(c=setTimeout((function(){c=null,s(n.resolved)&&f(null)}),p.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,c)))return function(n,e,t,a,i){var s=bn();return s.asyncFactory=n,s.asyncMeta={data:e,context:t,children:a,tag:i},s}(d,e,t,a,l);e=e||{},qt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],r=e.model.callback;o(s)?(Array.isArray(s)?-1===s.indexOf(r):s!==r)&&(i[a]=[r].concat(s)):i[a]=r}(n.options,e);var u=function(n,e,t){var a=e.options.props;if(!s(a)){var i={},r=n.attrs,l=n.props;if(o(r)||o(l))for(var h in a){var c=D(h);de(i,l,h,c,!0)||de(i,r,h,c,!1)}return i}}(e,n);if(r(n.options.functional))return function(n,e,t,a,s){var r=n.options,l={},h=r.props;if(o(h))for(var c in h)l[c]=On(c,h,e||i);else o(t.attrs)&&Re(l,t.attrs),o(t.props)&&Re(l,t.props);var d=new Pe(t,l,s,a,n),u=r.render.call(null,d._c,d);if(u instanceof yn)return Me(u,t,d.parent,r,d);if(Array.isArray(u)){for(var f=ue(u)||[],m=new Array(f.length),p=0;p<f.length;p++)m[p]=Me(f[p],t,d.parent,r,d);return m}}(n,u,e,t,a);var f=e.on;if(e.on=e.nativeOn,r(n.options.abstract)){var p=e.slot;e={},p&&(e.slot=p)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Oe.length;t++){var a=Oe[t],i=e[a],s=Be[a];i===s||i&&i._merged||(e[a]=i?We(s,i):s)}}(e);var y=n.options.name||l;return new yn("vue-component-"+n.cid+(y?"-"+y:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:f,tag:l,children:a},d)}}}function We(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}function Ue(n,e,t,a,i,c){return(Array.isArray(t)||l(t))&&(i=a,a=t,t=void 0),r(c)&&(i=2),function(n,e,t,a,i){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(a)&&"function"==typeof a[0]&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===i?a=ue(a):1===i&&(a=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var l,c;if("string"==typeof e){var d;c=n.$vnode&&n.$vnode.ns||O.getTagNamespace(e),l=O.isReservedTag(e)?new yn(O.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(d=Bn(n.$options,"components",e))?new yn(e,t,a,void 0,void 0,n):Ne(d,t,n,a,e)}else l=Ne(e,t,n,a);return Array.isArray(l)?l:o(l)?(o(c)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var h=e.children[i];o(h.tag)&&(s(h.ns)||r(a)&&"svg"!==h.tag)&&n(h,t,a)}}(l,c),o(t)&&function(n){h(n.style)&&oe(n.style);h(n.class)&&oe(n.class)}(t),l):bn()}(n,e,t,a,i)}var Ge,$e=null;function He(n,e){return(n.__esModule||hn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),h(n)?e.extend(n):n}function Xe(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ge(t)))return t}}function Ye(n,e){Ge.$on(n,e)}function Ze(n,e){Ge.$off(n,e)}function Ve(n,e){var t=Ge;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Ke(n,e,t){Ge=n,he(e,t||{},Ye,Ze,Ve,n),Ge=void 0}var Je=null;function Qe(n){var e=Je;return Je=n,function(){Je=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){mn();var t=n.$options[e],a=e+" hook";if(t)for(var i=0,s=t.length;i<s;i++)Hn(t[i],n,null,n,a);n._hasHookEvent&&n.$emit("hook:"+e),pn()}var at=[],it=[],st={},ot=!1,rt=!1,lt=0;var ht=0,ct=Date.now;if(H&&!V){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}function ut(){var n,e;for(ht=ct(),rt=!0,at.sort((function(n,e){return n.id-e.id})),lt=0;lt<at.length;lt++)(n=at[lt]).before&&n.before(),e=n.id,st[e]=null,n.run();var t=it.slice(),a=at.slice();lt=at.length=it.length=0,st={},ot=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a._watcher===t&&a._isMounted&&!a._isDestroyed&&tt(a,"updated")}}(a),on&&O.devtools&&on.emit("flush")}var ft=0,mt=function(n,e,t,a,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ft,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$n(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),pn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==st[e]){if(st[e]=!0,rt){for(var t=at.length-1;t>lt&&at[t].id>n.id;)t--;at.splice(t+1,0,n)}else at.push(n);ot||(ot=!0,ie(ut))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||h(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Hn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var pt={enumerable:!0,configurable:!0,get:z,set:z};function yt(n,e,t){pt.get=function(){return this[e][t]},pt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,pt)}function gt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props={},i=n.$options._propKeys=[];n.$parent&&Sn(!1);var s=function(s){i.push(s);var o=On(s,e,t,n);In(a,s,o),s in n||yt(n,"_props",s)};for(var o in e)s(o);Sn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:I(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return $n(n,e,"data()"),{}}finally{pn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var s=t[i];0,a&&w(a,s)||(o=void 0,36!==(o=(s+"").charCodeAt(0))&&95!==o&&yt(n,"_data",s))}var o;Dn(e,!0)}(n):Dn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var i in e){var s=e[i],o="function"==typeof s?s:s.get;0,a||(t[i]=new mt(n,o||z,z,bt)),i in n||vt(n,i,s)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var a=e[t];if(Array.isArray(a))for(var i=0;i<a.length;i++)kt(n,t,a[i]);else kt(n,t,a)}}(n,e.watch)}var bt={lazy:!0};function vt(n,e,t){var a=!sn();"function"==typeof t?(pt.get=a?xt(e):wt(t),pt.set=z):(pt.get=t.get?a&&!1!==t.cache?xt(e):wt(t.get):z,pt.set=t.set||z),Object.defineProperty(n,e,pt)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),un.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Tt=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&j(n.extendOptions,a),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function St(n){this._init(n)}function At(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var s=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)yt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)vt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),s&&(o.options.components[s]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=j({},o.options),i[a]=o,o}}function Dt(n){return n&&(n.Ctor.options.name||n.tag)}function It(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Et(n,e){var t=n.cache,a=n.keys,i=n._vnode;for(var s in t){var o=t[s];if(o){var r=o.name;r&&!e(r)&&jt(t,s,a,i)}}}function jt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,v(t,e)}St.prototype._init=function(n){var e=this;e._uid=Tt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=pe(e._renderChildren,a),n.$scopedSlots=i,n._c=function(e,t,a,i){return Ue(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return Ue(n,e,t,a,i,!0)};var s=t&&t.data;In(n,"$attrs",s&&s.attrs||i,null,!0),In(n,"$listeners",e._parentListeners||i,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){In(n,t,e[t])})),Sn(!0))}(e),gt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=En,n.prototype.$delete=jn,n.prototype.$watch=function(n,e,t){if(d(e))return kt(this,n,e,t);(t=t||{}).user=!0;var a=new mt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+a.expression+'"';mn(),Hn(e,this,[a.value],this,i),pn()}return function(){a.teardown()}}}(St),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var r=o.length;r--;)if((s=o[r])===e||s.fn===e){o.splice(r,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?E(t):t;for(var a=E(arguments,1),i='event handler for "'+n+'"',s=0,o=t.length;s<o;s++)Hn(t[s],e,a,e,i)}return e}}(St),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,s=Qe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),s(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||v(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(St),function(n){_e(n.prototype),n.prototype.$nextTick=function(n){return ie(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&(e.$scopedSlots=be(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{$e=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){$n(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof yn||(n=bn()),n.parent=i,n}}(St);var Ct=[String,RegExp,Array],zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,s=t.componentInstance,o=t.componentOptions;n[a]={name:Dt(o),tag:i,componentInstance:s},e.push(a),this.max&&e.length>parseInt(this.max)&&jt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)jt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Et(n,(function(n){return It(e,n)}))})),this.$watch("exclude",(function(e){Et(n,(function(n){return!It(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Xe(n),t=e&&e.componentOptions;if(t){var a=Dt(t),i=this.include,s=this.exclude;if(i&&(!a||!It(i,a))||s&&a&&It(s,a))return e;var o=this.cache,r=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,v(r,l),r.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return O}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:j,mergeOptions:Rn,defineReactive:In},n.set=En,n.delete=jn,n.nextTick=ie,n.observable=function(n){return Dn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=E(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),At(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(St),Object.defineProperty(St.prototype,"$isServer",{get:sn}),Object.defineProperty(St.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(St,"FunctionalRenderContext",{value:Pe}),St.version="2.6.14";var Lt=g("style,class"),Ft=g("input,textarea,option,select,progress"),_t=g("contenteditable,draggable,spellcheck"),Pt=g("events,caret,typing,plaintext-only"),Mt=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Bt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ot=function(n){return Bt(n)?n.slice(6,n.length):""},Nt=function(n){return null==n||!1===n};function Wt(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=Ut(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(o(n)||o(e))return Gt(n,$t(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:Gt(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Gt(n,e){return n?e?n+" "+e:n:e||""}function $t(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)o(e=$t(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):h(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Xt=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Yt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Zt=function(n){return Xt(n)||Yt(n)};var Vt=Object.create(null);var Kt=g("text,number,password,search,email,tel,url");var Jt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){na(e)},update:function(n,e){n.data.ref!==e.data.ref&&(na(n,!0),na(e))},destroy:function(n){na(n,!0)}};function na(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=a.$refs;e?Array.isArray(s[t])?v(s[t],i):s[t]===i&&(s[t]=void 0):n.data.refInFor?Array.isArray(s[t])?s[t].indexOf(i)<0&&s[t].push(i):s[t]=[i]:s[t]=i}}var ea=new yn("",{},[]),ta=["create","activate","update","remove","destroy"];function aa(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===i||Kt(a)&&Kt(i)}(n,e)||r(n.isAsyncPlaceholder)&&s(e.asyncFactory.error))}function ia(n,e,t){var a,i,s={};for(a=e;a<=t;++a)o(i=n[a].key)&&(s[i]=a);return s}var sa={create:oa,update:oa,destroy:function(n){oa(n,ea)}};function oa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,s=n===ea,o=e===ea,r=la(n.data.directives,n.context),l=la(e.data.directives,e.context),h=[],c=[];for(t in l)a=r[t],i=l[t],a?(i.oldValue=a.value,i.oldArg=a.arg,ca(i,"update",e,n),i.def&&i.def.componentUpdated&&c.push(i)):(ca(i,"bind",e,n),i.def&&i.def.inserted&&h.push(i));if(h.length){var d=function(){for(var t=0;t<h.length;t++)ca(h[t],"inserted",e,n)};s?ce(e,"insert",d):d()}c.length&&ce(e,"postpatch",(function(){for(var t=0;t<c.length;t++)ca(c[t],"componentUpdated",e,n)}));if(!s)for(t in r)l[t]||ca(r[t],"unbind",n,n,o)}(n,e)}var ra=Object.create(null);function la(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(a=n[t]).modifiers||(a.modifiers=ra),i[ha(a)]=a,a.def=Bn(e.$options,"directives",a.name);return i}function ha(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ca(n,e,t,a,i){var s=n.def&&n.def[e];if(s)try{s(t.elm,n,t,a,i)}catch(a){$n(a,t.context,"directive "+n.name+" "+e+" hook")}}var da=[Qt,sa];function ua(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||s(n.data.attrs)&&s(e.data.attrs))){var a,i,r=e.elm,l=n.data.attrs||{},h=e.data.attrs||{};for(a in o(h.__ob__)&&(h=e.data.attrs=j({},h)),h)i=h[a],l[a]!==i&&fa(r,a,i,e.data.pre);for(a in(V||J)&&h.value!==l.value&&fa(r,"value",h.value),l)s(h[a])&&(Bt(a)?r.removeAttributeNS(Rt,Ot(a)):_t(a)||r.removeAttribute(a))}}function fa(n,e,t,a){a||n.tagName.indexOf("-")>-1?ma(n,e,t):Mt(e)?Nt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):_t(e)?n.setAttribute(e,function(n,e){return Nt(e)||"false"===e?"false":"contenteditable"===n&&Pt(e)?e:"true"}(e,t)):Bt(e)?Nt(t)?n.removeAttributeNS(Rt,Ot(e)):n.setAttributeNS(Rt,e,t):ma(n,e,t)}function ma(n,e,t){if(Nt(t))n.removeAttribute(e);else{if(V&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var pa={create:ua,update:ua};function ya(n,e){var t=e.elm,a=e.data,i=n.data;if(!(s(a.staticClass)&&s(a.class)&&(s(i)||s(i.staticClass)&&s(i.class)))){var r=Wt(e),l=t._transitionClasses;o(l)&&(r=Gt(r,$t(l))),r!==t._prevClass&&(t.setAttribute("class",r),t._prevClass=r)}}var ga,ba={create:ya,update:ya};function va(n,e,t){var a=ga;return function i(){var s=e.apply(null,arguments);null!==s&&ka(n,i,t,a)}}var xa=Vn&&!(nn&&Number(nn[1])<=53);function wa(n,e,t,a){if(xa){var i=ht,s=e;e=s._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return s.apply(this,arguments)}}ga.addEventListener(n,e,tn?{capture:t,passive:a}:t)}function ka(n,e,t,a){(a||ga).removeEventListener(n,e._wrapper||e,t)}function Ta(n,e){if(!s(n.data.on)||!s(e.data.on)){var t=e.data.on||{},a=n.data.on||{};ga=e.elm,function(n){if(o(n.__r)){var e=V?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),he(t,a,wa,ka,va,e.context),ga=void 0}}var qa,Sa={create:Ta,update:Ta};function Aa(n,e){if(!s(n.data.domProps)||!s(e.data.domProps)){var t,a,i=e.elm,r=n.data.domProps||{},l=e.data.domProps||{};for(t in o(l.__ob__)&&(l=e.data.domProps=j({},l)),r)t in l||(i[t]="");for(t in l){if(a=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===r[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var h=s(a)?"":String(a);Da(i,h)&&(i.value=h)}else if("innerHTML"===t&&Yt(i.tagName)&&s(i.innerHTML)){(qa=qa||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var c=qa.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;c.firstChild;)i.appendChild(c.firstChild)}else if(a!==r[t])try{i[t]=a}catch(n){}}}}function Da(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return y(t)!==y(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ia={create:Aa,update:Aa},Ea=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function ja(n){var e=Ca(n.style);return n.staticStyle?j(n.staticStyle,e):e}function Ca(n){return Array.isArray(n)?C(n):"string"==typeof n?Ea(n):n}var za,La=/^--/,Fa=/\s*!important$/,_a=function(n,e,t){if(La.test(e))n.style.setProperty(e,t);else if(Fa.test(t))n.style.setProperty(D(e),t.replace(Fa,""),"important");else{var a=Ma(e);if(Array.isArray(t))for(var i=0,s=t.length;i<s;i++)n.style[a]=t[i];else n.style[a]=t}},Pa=["Webkit","Moz","ms"],Ma=k((function(n){if(za=za||document.createElement("div").style,"filter"!==(n=q(n))&&n in za)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Pa.length;t++){var a=Pa[t]+e;if(a in za)return a}}));function Ra(n,e){var t=e.data,a=n.data;if(!(s(t.staticStyle)&&s(t.style)&&s(a.staticStyle)&&s(a.style))){var i,r,l=e.elm,h=a.staticStyle,c=a.normalizedStyle||a.style||{},d=h||c,u=Ca(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?j({},u):u;var f=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=ja(i.data))&&j(a,t);(t=ja(n.data))&&j(a,t);for(var s=n;s=s.parent;)s.data&&(t=ja(s.data))&&j(a,t);return a}(e,!0);for(r in d)s(f[r])&&_a(l,r,"");for(r in f)(i=f[r])!==d[r]&&_a(l,r,null==i?"":i)}}var Ba={create:Ra,update:Ra},Oa=/\s+/;function Na(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Wa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,Ga(n.name||"v")),j(e,n),e}return"string"==typeof n?Ga(n):void 0}}var Ga=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),$a=H&&!K,Ha="transition",Xa="transitionend",Ya="animation",Za="animationend";$a&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ha="WebkitTransition",Xa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ya="WebkitAnimation",Za="webkitAnimationEnd"));var Va=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ka(n){Va((function(){Va(n)}))}function Ja(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Na(n,e))}function Qa(n,e){n._transitionClasses&&v(n._transitionClasses,e),Wa(n,e)}function ni(n,e,t){var a=ti(n,e),i=a.type,s=a.timeout,o=a.propCount;if(!i)return t();var r="transition"===i?Xa:Za,l=0,h=function(){n.removeEventListener(r,c),t()},c=function(e){e.target===n&&++l>=o&&h()};setTimeout((function(){l<o&&h()}),s+1),n.addEventListener(r,c)}var ei=/\b(transform|all)(,|$)/;function ti(n,e){var t,a=window.getComputedStyle(n),i=(a[Ha+"Delay"]||"").split(", "),s=(a[Ha+"Duration"]||"").split(", "),o=ai(i,s),r=(a[Ya+"Delay"]||"").split(", "),l=(a[Ya+"Duration"]||"").split(", "),h=ai(r,l),c=0,d=0;return"transition"===e?o>0&&(t="transition",c=o,d=s.length):"animation"===e?h>0&&(t="animation",c=h,d=l.length):d=(t=(c=Math.max(o,h))>0?o>h?"transition":"animation":null)?"transition"===t?s.length:l.length:0,{type:t,timeout:c,propCount:d,hasTransform:"transition"===t&&ei.test(a[Ha+"Property"])}}function ai(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ii(e)+ii(n[t])})))}function ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function si(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=Ua(n.data.transition);if(!s(a)&&!o(t._enterCb)&&1===t.nodeType){for(var i=a.css,r=a.type,l=a.enterClass,c=a.enterToClass,d=a.enterActiveClass,u=a.appearClass,f=a.appearToClass,m=a.appearActiveClass,p=a.beforeEnter,g=a.enter,b=a.afterEnter,v=a.enterCancelled,x=a.beforeAppear,w=a.appear,k=a.afterAppear,T=a.appearCancelled,q=a.duration,S=Je,A=Je.$vnode;A&&A.parent;)S=A.context,A=A.parent;var D=!S._isMounted||!n.isRootInsert;if(!D||w||""===w){var I=D&&u?u:l,E=D&&m?m:d,j=D&&f?f:c,C=D&&x||p,z=D&&"function"==typeof w?w:g,L=D&&k||b,F=D&&T||v,_=y(h(q)?q.enter:q);0;var P=!1!==i&&!K,R=li(z),B=t._enterCb=M((function(){P&&(Qa(t,j),Qa(t,E)),B.cancelled?(P&&Qa(t,I),F&&F(t)):L&&L(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,B)})),C&&C(t),P&&(Ja(t,I),Ja(t,E),Ka((function(){Qa(t,I),B.cancelled||(Ja(t,j),R||(ri(_)?setTimeout(B,_):ni(t,r,B)))}))),n.data.show&&(e&&e(),z&&z(t,B)),P||R||B()}}}function oi(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=Ua(n.data.transition);if(s(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=a.css,r=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,f=a.leave,m=a.afterLeave,p=a.leaveCancelled,g=a.delayLeave,b=a.duration,v=!1!==i&&!K,x=li(f),w=y(h(b)?b.leave:b);0;var k=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(Qa(t,c),Qa(t,d)),k.cancelled?(v&&Qa(t,l),p&&p(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(T):T()}function T(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),v&&(Ja(t,l),Ja(t,d),Ka((function(){Qa(t,l),k.cancelled||(Ja(t,c),x||(ri(w)?setTimeout(k,w):ni(t,r,k)))}))),f&&f(t,k),v||x||k())}}function ri(n){return"number"==typeof n&&!isNaN(n)}function li(n){if(s(n))return!1;var e=n.fns;return o(e)?li(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function hi(n,e){!0!==e.data.show&&si(e)}var ci=function(n){var e,t,a={},i=n.modules,h=n.nodeOps;for(e=0;e<ta.length;++e)for(a[ta[e]]=[],t=0;t<i.length;++t)o(i[t][ta[e]])&&a[ta[e]].push(i[t][ta[e]]);function c(n){var e=h.parentNode(n);o(e)&&h.removeChild(e,n)}function d(n,e,t,i,s,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=xn(n)),n.isRootInsert=!s,!function(n,e,t,i){var s=n.data;if(o(s)){var l=o(n.componentInstance)&&s.keepAlive;if(o(s=s.hook)&&o(s=s.init)&&s(n,!1),o(n.componentInstance))return u(n,e),f(t,n.elm,i),r(l)&&function(n,e,t,i){var s,r=n;for(;r.componentInstance;)if(r=r.componentInstance._vnode,o(s=r.data)&&o(s=s.transition)){for(s=0;s<a.activate.length;++s)a.activate[s](ea,r);e.push(r);break}f(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?h.createElementNS(n.ns,g):h.createElement(g,n),b(n),m(n,p,e),o(d)&&y(n,e),f(t,n.elm,i)):r(n.isComment)?(n.elm=h.createComment(n.text),f(t,n.elm,i)):(n.elm=h.createTextNode(n.text),f(t,n.elm,i))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,p(n)?(y(n,e),b(n)):(na(n),e.push(n))}function f(n,e,t){o(n)&&(o(t)?h.parentNode(t)===n&&h.insertBefore(n,e,t):h.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var a=0;a<e.length;++a)d(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&h.appendChild(n.elm,h.createTextNode(String(n.text)))}function p(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function y(n,t){for(var i=0;i<a.create.length;++i)a.create[i](ea,n);o(e=n.data.hook)&&(o(e.create)&&e.create(ea,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))h.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e),t=t.parent;o(e=Je)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e)}function v(n,e,t,a,i,s){for(;a<=i;++a)d(t[a],s,n,e,!1,t,a)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(k(a),x(a)):c(a.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=a.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&c(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else c(n.elm)}function T(n,e,t,a){for(var i=t;i<a;i++){var s=e[i];if(o(s)&&aa(n,s))return i}}function q(n,e,t,i,l,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=xn(e));var u=e.elm=n.elm;if(r(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?D(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(r(e.isStatic)&&r(n.isStatic)&&e.key===n.key&&(r(e.isCloned)||r(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,m=e.data;o(m)&&o(f=m.hook)&&o(f=f.prepatch)&&f(n,e);var y=n.children,g=e.children;if(o(m)&&p(e)){for(f=0;f<a.update.length;++f)a.update[f](n,e);o(f=m.hook)&&o(f=f.update)&&f(n,e)}s(e.text)?o(y)&&o(g)?y!==g&&function(n,e,t,a,i){var r,l,c,u=0,f=0,m=e.length-1,p=e[0],y=e[m],g=t.length-1,b=t[0],x=t[g],k=!i;for(0;u<=m&&f<=g;)s(p)?p=e[++u]:s(y)?y=e[--m]:aa(p,b)?(q(p,b,a,t,f),p=e[++u],b=t[++f]):aa(y,x)?(q(y,x,a,t,g),y=e[--m],x=t[--g]):aa(p,x)?(q(p,x,a,t,g),k&&h.insertBefore(n,p.elm,h.nextSibling(y.elm)),p=e[++u],x=t[--g]):aa(y,b)?(q(y,b,a,t,f),k&&h.insertBefore(n,y.elm,p.elm),y=e[--m],b=t[++f]):(s(r)&&(r=ia(e,u,m)),s(l=o(b.key)?r[b.key]:T(b,e,u,m))?d(b,a,n,p.elm,!1,t,f):aa(c=e[l],b)?(q(c,b,a,t,f),e[l]=void 0,k&&h.insertBefore(n,c.elm,p.elm)):d(b,a,n,p.elm,!1,t,f),b=t[++f]);u>m?v(n,s(t[g+1])?null:t[g+1].elm,t,f,g,a):f>g&&w(e,u,m)}(u,y,g,t,c):o(g)?(o(n.text)&&h.setTextContent(u,""),v(u,null,g,0,g.length-1,t)):o(y)?w(y,0,y.length-1):o(n.text)&&h.setTextContent(u,""):n.text!==e.text&&h.setTextContent(u,e.text),o(m)&&o(f=m.hook)&&o(f=f.postpatch)&&f(n,e)}}}function S(n,e,t){if(r(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var A=g("attrs,class,staticClass,staticStyle,key");function D(n,e,t,a){var i,s=e.tag,l=e.data,h=e.children;if(a=a||l&&l.pre,e.elm=n,r(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return u(e,t),!0;if(o(s)){if(o(h))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var c=!0,d=n.firstChild,f=0;f<h.length;f++){if(!d||!D(d,h[f],t,a)){c=!1;break}d=d.nextSibling}if(!c||d)return!1}else m(e,h,t);if(o(l)){var p=!1;for(var g in l)if(!A(g)){p=!0,y(e,t);break}!p&&l.class&&oe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!s(e)){var l,c=!1,u=[];if(s(n))c=!0,d(e,u);else{var f=o(n.nodeType);if(!f&&aa(n,e))q(n,e,u,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),r(t)&&D(n,e,u))return S(e,u,!0),n;l=n,n=new yn(h.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,y=h.parentNode(m);if(d(e,u,m._leaveCb?null:y,h.nextSibling(m)),o(e.parent))for(var g=e.parent,b=p(e);g;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](g);if(g.elm=e.elm,b){for(var k=0;k<a.create.length;++k)a.create[k](ea,g);var T=g.data.hook.insert;if(T.merged)for(var A=1;A<T.fns.length;A++)T.fns[A]()}else na(g);g=g.parent}o(y)?w([n],0,0):o(n.tag)&&x(n)}}return S(e,u,c),e.elm}o(n)&&x(n)}}({nodeOps:Jt,modules:[pa,ba,Sa,Ia,Ba,H?{create:hi,activate:hi,remove:function(n,e){!0!==n.data.show?oi(n,e):e()}}:{}].concat(da)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var di={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?ce(t,"postpatch",(function(){di.componentUpdated(n,e,t)})):ui(n,e,t.context),n._vOptions=[].map.call(n.options,pi)):("textarea"===t.tag||Kt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",yi),n.addEventListener("compositionend",gi),n.addEventListener("change",gi),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ui(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,pi);if(i.some((function(n,e){return!_(n,a[e])})))(n.multiple?e.value.some((function(n){return mi(n,i)})):e.value!==e.oldValue&&mi(e.value,i))&&bi(n,"change")}}};function ui(n,e,t){fi(n,e,t),(V||J)&&setTimeout((function(){fi(n,e,t)}),0)}function fi(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var s,o,r=0,l=n.options.length;r<l;r++)if(o=n.options[r],i)s=P(a,pi(o))>-1,o.selected!==s&&(o.selected=s);else if(_(pi(o),a))return void(n.selectedIndex!==r&&(n.selectedIndex=r));i||(n.selectedIndex=-1)}}function mi(n,e){return e.every((function(e){return!_(e,n)}))}function pi(n){return"_value"in n?n._value:n.value}function yi(n){n.target.composing=!0}function gi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function vi(n){return!n.componentInstance||n.data&&n.data.transition?n:vi(n.componentInstance._vnode)}var xi={model:di,show:{bind:function(n,e,t){var a=e.value,i=(t=vi(t)).data&&t.data.transition,s=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,si(t,(function(){n.style.display=s}))):n.style.display=a?s:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=vi(t)).data&&t.data.transition?(t.data.show=!0,a?si(t,(function(){n.style.display=n.__vOriginalDisplay})):oi(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},wi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ki(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ki(Xe(e.children)):n}function Ti(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var s in i)e[q(s)]=i[s];return e}function qi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Si=function(n){return n.tag||ge(n)},Ai=function(n){return"show"===n.name},Di={name:"transition",props:wi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Si)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var s=ki(i);if(!s)return i;if(this._leaving)return qi(n,i);var o="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?o+"comment":o+s.tag:l(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var r=(s.data||(s.data={})).transition=Ti(this),h=this._vnode,c=ki(h);if(s.data.directives&&s.data.directives.some(Ai)&&(s.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(s,c)&&!ge(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var d=c.data.transition=j({},r);if("out-in"===a)return this._leaving=!0,ce(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),qi(n,i);if("in-out"===a){if(ge(s))return h;var u,f=function(){u()};ce(r,"afterEnter",f),ce(r,"enterCancelled",f),ce(d,"delayLeave",(function(n){u=n}))}}return i}}},Ii=j({tag:String,moveClass:String},wi);function Ei(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ci(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var s=n.elm.style;s.transform=s.WebkitTransform="translate("+a+"px,"+i+"px)",s.transitionDuration="0s"}}delete Ii.mode;var zi={Transition:Di,TransitionGroup:{props:Ii,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],o=Ti(this),r=0;r<i.length;r++){var l=i[r];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))s.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(a){for(var h=[],c=[],d=0;d<a.length;d++){var u=a[d];u.data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?h.push(u):c.push(u)}this.kept=n(e,null,h),this.removed=c}return n(e,null,s)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ei),n.forEach(ji),n.forEach(Ci),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Ja(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(Xa,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(Xa,n),t._moveCb=null,Qa(t,e))})}})))},methods:{hasMove:function(n,e){if(!$a)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Wa(t,n)})),Na(t,e),t.style.display="none",this.$el.appendChild(t);var a=ti(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};St.config.mustUseProp=function(n,e,t){return"value"===t&&Ft(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},St.config.isReservedTag=Zt,St.config.isReservedAttr=Lt,St.config.getTagNamespace=function(n){return Yt(n)?"svg":"math"===n?"math":void 0},St.config.isUnknownElement=function(n){if(!H)return!0;if(Zt(n))return!1;if(n=n.toLowerCase(),null!=Vt[n])return Vt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Vt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Vt[n]=/HTMLUnknownElement/.test(e.toString())},j(St.options.directives,xi),j(St.options.components,zi),St.prototype.__patch__=H?ci:z,St.prototype.$mount=function(n,e){return function(n,e,t){var a;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new mt(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){O.devtools&&on&&on.emit("init",St)}),0);var Li=St;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Fi(n,e){for(var t in e)n[t]=e[t];return n}var _i=/[!'()*]/g,Pi=function(n){return"%"+n.charCodeAt(0).toString(16)},Mi=/%2C/g,Ri=function(n){return encodeURIComponent(n).replace(_i,Pi).replace(Mi,",")};function Bi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Oi=function(n){return null==n||"object"==typeof n?n:String(n)};function Ni(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=Bi(t.shift()),i=t.length>0?Bi(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function Wi(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Ri(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(Ri(e)):a.push(Ri(e)+"="+Ri(n)))})),a.join("&")}return Ri(e)+"="+Ri(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ui=/\/?$/;function Gi(n,e,t,a){var i=a&&a.options.stringifyQuery,s=e.query||{};try{s=$i(s)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:s,params:e.params||{},fullPath:Yi(e,i),matched:n?Xi(n):[]};return t&&(o.redirectedFrom=Yi(t,i)),Object.freeze(o)}function $i(n){if(Array.isArray(n))return n.map($i);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=$i(n[t]);return e}return n}var Hi=Gi(null,{path:"/"});function Xi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Yi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Wi)(a)+i}function Zi(n,e,t){return e===Hi?n===e:!!e&&(n.path&&e.path?n.path.replace(Ui,"")===e.path.replace(Ui,"")&&(t||n.hash===e.hash&&Vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Vi(n.query,e.query)&&Vi(n.params,e.params))))}function Vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var s=n[t];if(a[i]!==t)return!1;var o=e[t];return null==s||null==o?s===o:"object"==typeof s&&"object"==typeof o?Vi(s,o):String(s)===String(o)}))}function Ki(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],s=t.enteredCbs[a];if(i&&s){delete t.enteredCbs[a];for(var o=0;o<s.length;o++)i._isBeingDestroyed||s[o](i)}}}}var Ji={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,s=e.data;s.routerView=!0;for(var o=i.$createElement,r=t.name,l=i.$route,h=i._routerViewCache||(i._routerViewCache={}),c=0,d=!1;i&&i._routerRoot!==i;){var u=i.$vnode?i.$vnode.data:{};u.routerView&&c++,u.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(s.routerViewDepth=c,d){var f=h[r],m=f&&f.component;return m?(f.configProps&&Qi(m,s,f.route,f.configProps),o(m,s,a)):o()}var p=l.matched[c],y=p&&p.components[r];if(!p||!y)return h[r]=null,o();h[r]={component:y},s.registerRouteInstance=function(n,e){var t=p.instances[r];(e&&t!==n||!e&&t===n)&&(p.instances[r]=e)},(s.hook||(s.hook={})).prepatch=function(n,e){p.instances[r]=e.componentInstance},s.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==p.instances[r]&&(p.instances[r]=n.componentInstance),Ki(l)};var g=p.props&&p.props[r];return g&&(Fi(h[r],{route:l,configProps:g}),Qi(y,s,l,g)),o(y,s,a)}};function Qi(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=Fi({},i);var s=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(s[o]=i[o],delete i[o])}}function ns(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var s=n.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var r=s[o];".."===r?i.pop():"."!==r&&i.push(r)}return""!==i[0]&&i.unshift(""),i.join("/")}function es(n){return n.replace(/\/+/g,"/")}var ts=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},as=gs,is=hs,ss=function(n,e){return ds(hs(n,e),e)},os=ds,rs=ys,ls=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function hs(n,e){for(var t,a=[],i=0,s=0,o="",r=e&&e.delimiter||"/";null!=(t=ls.exec(n));){var l=t[0],h=t[1],c=t.index;if(o+=n.slice(s,c),s=c+l.length,h)o+=h[1];else{var d=n[s],u=t[2],f=t[3],m=t[4],p=t[5],y=t[6],g=t[7];o&&(a.push(o),o="");var b=null!=u&&null!=d&&d!==u,v="+"===y||"*"===y,x="?"===y||"*"===y,w=t[2]||r,k=m||p;a.push({name:f||i++,prefix:u||"",delimiter:w,optional:x,repeat:v,partial:b,asterisk:!!g,pattern:k?fs(k):g?".*":"[^"+us(w)+"]+?"})}}return s<n.length&&(o+=n.substr(s)),o&&a.push(o),a}function cs(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ds(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",ps(e)));return function(e,a){for(var i="",s=e||{},o=(a||{}).pretty?cs:encodeURIComponent,r=0;r<n.length;r++){var l=n[r];if("string"!=typeof l){var h,c=s[l.name];if(null==c){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ts(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<c.length;d++){if(h=o(c[d]),!t[r].test(h))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(h)+"`");i+=(0===d?l.prefix:l.delimiter)+h}}else{if(h=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[r].test(h))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+h+'"');i+=l.prefix+h}}else i+=l}return i}}function us(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function fs(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ms(n,e){return n.keys=e,n}function ps(n){return n&&n.sensitive?"":"i"}function ys(n,e,t){ts(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,s="",o=0;o<n.length;o++){var r=n[o];if("string"==typeof r)s+=us(r);else{var l=us(r.prefix),h="(?:"+r.pattern+")";e.push(r),r.repeat&&(h+="(?:"+l+h+")*"),s+=h=r.optional?r.partial?l+"("+h+")?":"(?:"+l+"("+h+"))?":l+"("+h+")"}}var c=us(t.delimiter||"/"),d=s.slice(-c.length)===c;return a||(s=(d?s.slice(0,-c.length):s)+"(?:"+c+"(?=$))?"),s+=i?"$":a&&d?"":"(?="+c+"|$)",ms(new RegExp("^"+s,ps(t)),e)}function gs(n,e,t){return ts(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ms(n,e)}(n,e):ts(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(gs(n[i],e,t).source);return ms(new RegExp("(?:"+a.join("|")+")",ps(t)),e)}(n,e,t):function(n,e,t){return ys(hs(n,t),e,t)}(n,e,t)}as.parse=is,as.compile=ss,as.tokensToFunction=os,as.tokensToRegExp=rs;var bs=Object.create(null);function vs(n,e,t){e=e||{};try{var a=bs[n]||(bs[n]=as.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xs(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var s=(i=Fi({},n)).params;return s&&"object"==typeof s&&(i.params=Fi({},s)),i}if(!i.path&&i.params&&e){(i=Fi({},i))._normalized=!0;var o=Fi(Fi({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var r=e.matched[e.matched.length-1].path;i.path=vs(r,o,e.path)}else 0;return i}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),h=e&&e.path||"/",c=l.path?ns(l.path,h,t||i.append):h,d=function(n,e,t){void 0===e&&(e={});var a,i=t||Ni;try{a=i(n||"")}catch(n){a={}}for(var s in e){var o=e[s];a[s]=Array.isArray(o)?o.map(Oi):Oi(o)}return a}(l.query,i.query,a&&a.options.parseQuery),u=i.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:c,query:d,hash:u}}var ws,ks=function(){},Ts={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),s=i.location,o=i.route,r=i.href,l={},h=t.options.linkActiveClass,c=t.options.linkExactActiveClass,d=null==h?"router-link-active":h,u=null==c?"router-link-exact-active":c,f=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?u:this.exactActiveClass,p=o.redirectedFrom?Gi(null,xs(o.redirectedFrom),null,t):o;l[m]=Zi(a,p,this.exactPath),l[f]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(Ui,"/").indexOf(e.path.replace(Ui,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,p);var y=l[m]?this.ariaCurrentValue:null,g=function(n){qs(n)&&(e.replace?t.replace(s,ks):t.push(s,ks))},b={click:qs};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var v={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:r,route:o,navigate:g,isActive:l[f],isExactActive:l[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)v.on=b,v.attrs={href:r,"aria-current":y};else{var w=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=Fi({},w.data);for(var T in k.on=k.on||{},k.on){var q=k.on[T];T in b&&(k.on[T]=Array.isArray(q)?q:[q])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=g;var A=w.data.attrs=Fi({},w.data.attrs);A.href=r,A["aria-current"]=y}else v.on=b}return n(this.tag,v,this.$slots.default)}};function qs(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ss="undefined"!=typeof window;function As(n,e,t,a,i){var s=e||[],o=t||Object.create(null),r=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,s,o){var r=i.path,l=i.name;0;var h=i.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return es(e.path+"/"+n)}(r,s,h.strict);"boolean"==typeof i.caseSensitive&&(h.sensitive=i.caseSensitive);var d={path:c,regex:Ds(c,h),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:s,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var s=o?es(o+"/"+i.path):void 0;n(e,t,a,i,d,s)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var u=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<u.length;++f){0;var m={path:u[f],children:i.children};n(e,t,a,m,s,d.path||"/")}l&&(a[l]||(a[l]=d))}(s,o,r,n,i)}));for(var l=0,h=s.length;l<h;l++)"*"===s[l]&&(s.push(s.splice(l,1)[0]),h--,l--);return{pathList:s,pathMap:o,nameMap:r}}function Ds(n,e){return as(n,[],e)}function Is(n,e){var t=As(n),a=t.pathList,i=t.pathMap,s=t.nameMap;function o(n,t,o){var r=xs(n,t,!1,e),h=r.name;if(h){var c=s[h];if(!c)return l(null,r);var d=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof r.params&&(r.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in r.params)&&d.indexOf(u)>-1&&(r.params[u]=t.params[u]);return r.path=vs(c.path,r.params),l(c,r,o)}if(r.path){r.params={};for(var f=0;f<a.length;f++){var m=a[f],p=i[m];if(Es(p.regex,r.path,r.params))return l(p,r,o)}}return l(null,r)}function r(n,t){var a=n.redirect,i="function"==typeof a?a(Gi(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var r=i,h=r.name,c=r.path,d=t.query,u=t.hash,f=t.params;if(d=r.hasOwnProperty("query")?r.query:d,u=r.hasOwnProperty("hash")?r.hash:u,f=r.hasOwnProperty("params")?r.params:f,h){s[h];return o({_normalized:!0,name:h,query:d,hash:u,params:f},void 0,t)}if(c){var m=function(n,e){return ns(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:vs(m,f),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?r(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:vs(t,e.params)});if(a){var i=a.matched,s=i[i.length-1];return e.params=a.params,l(s,e)}return l(null,e)}(0,t,n.matchAs):Gi(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?s[n]:void 0;As([e||n],a,i,s,t),t&&t.alias.length&&As(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,s,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){As(n,a,i,s)}}}function Es(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,s=a.length;i<s;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[i]?Bi(a[i]):a[i])}return!0}var js=Ss&&window.performance&&window.performance.now?window.performance:Date;function Cs(){return js.now().toFixed(3)}var zs=Cs();function Ls(){return zs}function Fs(n){return zs=n}var _s=Object.create(null);function Ps(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Fi({},window.history.state);return t.key=Ls(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Bs),function(){window.removeEventListener("popstate",Bs)}}function Ms(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var s=function(){var n=Ls();if(n)return _s[n]}(),o=i.call(n,e,t,a?s:null);o&&("function"==typeof o.then?o.then((function(n){Gs(n,s)})).catch((function(n){0})):Gs(o,s))}))}}function Rs(){var n=Ls();n&&(_s[n]={x:window.pageXOffset,y:window.pageYOffset})}function Bs(n){Rs(),n.state&&n.state.key&&Fs(n.state.key)}function Os(n){return Ws(n.x)||Ws(n.y)}function Ns(n){return{x:Ws(n.x)?n.x:window.pageXOffset,y:Ws(n.y)?n.y:window.pageYOffset}}function Ws(n){return"number"==typeof n}var Us=/^#\d/;function Gs(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=Us.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var s=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,s={x:Ws((t=s).x)?t.x:0,y:Ws(t.y)?t.y:0})}else Os(n)&&(e=Ns(n))}else a&&Os(n)&&(e=Ns(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var $s,Hs=Ss&&((-1===($s=window.navigator.userAgent).indexOf("Android 2.")&&-1===$s.indexOf("Android 4.0")||-1===$s.indexOf("Mobile Safari")||-1!==$s.indexOf("Chrome")||-1!==$s.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Xs(n,e){Rs();var t=window.history;try{if(e){var a=Fi({},t.state);a.key=Ls(),t.replaceState(a,"",n)}else t.pushState({key:Fs(Cs())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ys(n){Xs(n,!0)}function Zs(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}var Vs={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ks(n,e){return Qs(n,e,Vs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Js(n,e){return Qs(n,e,Vs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Qs(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ao(n){return function(e,t,a){var i=!1,s=0,o=null;io(n,(function(n,e,t,r){if("function"==typeof n&&void 0===n.cid){i=!0,s++;var l,h=ro((function(e){var i;((i=e).__esModule||oo&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ws.extend(e),t.components[r]=e,--s<=0&&a()})),c=ro((function(n){var e="Failed to resolve async component "+r+": "+n;o||(o=eo(n)?n:new Error(e),a(o))}));try{l=n(h,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(h,c);else{var d=l.component;d&&"function"==typeof d.then&&d.then(h,c)}}})),i||a()}}function io(n,e){return so(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function so(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ro(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var lo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ss){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Hi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ho(n,e,t,a){var i=io(n,(function(n,a,i,s){var o=function(n,e){"function"!=typeof n&&(n=ws.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,i,s)})):t(o,a,i,s)}));return so(a?i.reverse():i)}function co(n,e){if(e)return function(){return n.apply(e,arguments)}}lo.prototype.listen=function(n){this.cb=n},lo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},lo.prototype.onError=function(n){this.errorCbs.push(n)},lo.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(to(n,Vs.redirected)&&s===Hi||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},lo.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var s,o,r=function(n){!to(n)&&eo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,h=i.matched.length-1;if(Zi(n,i)&&l===h&&n.matched[l]===i.matched[h])return this.ensureURL(),n.hash&&Ms(this.router,i,n,!1),r(((o=Qs(s=i,n,Vs.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=c.updated,u=c.deactivated,f=c.activated,m=[].concat(function(n){return ho(n,"beforeRouteLeave",co,!0)}(u),this.router.beforeHooks,function(n){return ho(n,"beforeRouteUpdate",co)}(d),f.map((function(n){return n.beforeEnter})),ao(f)),p=function(e,t){if(a.pending!==n)return r(Js(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),r(function(n,e){return Qs(n,e,Vs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):eo(e)?(a.ensureURL(!0),r(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(r(Ks(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){r(n)}};Zs(m,p,(function(){Zs(function(n){return ho(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,s){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),s(n)}))}}(n,t,a)}))}(f).concat(a.router.resolveHooks),p,(function(){if(a.pending!==n)return r(Js(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){Ki(n)}))}))}))},lo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},lo.prototype.setupListeners=function(){},lo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Hi,this.pending=null};var uo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=fo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=Hs&&t;a&&this.listeners.push(Ps());var i=function(){var t=n.current,i=fo(n.base);n.current===Hi&&i===n._startLocation||n.transitionTo(i,(function(n){a&&Ms(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Xs(es(a.base+n.fullPath)),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Ys(es(a.base+n.fullPath)),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(fo(this.base)!==this.current.fullPath){var e=es(this.base+this.current.fullPath);n?Xs(e):Ys(e)}},e.prototype.getCurrentLocation=function(){return fo(this.base)},e}(lo);function fo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(es(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var mo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=fo(n);if(!/^\/#/.test(e))return window.location.replace(es(n+"/#"+e)),!0}(this.base)||po()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Hs&&e;t&&this.listeners.push(Ps());var a=function(){var e=n.current;po()&&n.transitionTo(yo(),(function(a){t&&Ms(n.router,a,e,!0),Hs||vo(a.fullPath)}))},i=Hs?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){vo(n.fullPath),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;yo()!==e&&(n?bo(e):vo(e))},e.prototype.getCurrentLocation=function(){return yo()},e}(lo);function po(){var n=yo();return"/"===n.charAt(0)||(vo("/"+n),!1)}function yo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function go(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Hs?Xs(go(n)):window.location.hash=n}function vo(n){Hs?Ys(go(n)):window.location.replace(go(n))}var xo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){to(n,Vs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(lo),wo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Is(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Hs&&!1!==n.fallback,this.fallback&&(e="hash"),Ss||(e="abstract"),this.mode=e,e){case"history":this.history=new uo(this,n.base);break;case"hash":this.history=new mo(this,n.base,this.fallback);break;case"abstract":this.history=new xo(this,n.base);break;default:0}},ko={currentRoute:{configurable:!0}};function To(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ko.currentRoute.get=function(){return this.history&&this.history.current},wo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof uo||t instanceof mo){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;Hs&&i&&"fullPath"in n&&Ms(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wo.prototype.beforeEach=function(n){return To(this.beforeHooks,n)},wo.prototype.beforeResolve=function(n){return To(this.resolveHooks,n)},wo.prototype.afterEach=function(n){return To(this.afterHooks,n)},wo.prototype.onReady=function(n,e){this.history.onReady(n,e)},wo.prototype.onError=function(n){this.history.onError(n)},wo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},wo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},wo.prototype.go=function(n){this.history.go(n)},wo.prototype.back=function(){this.go(-1)},wo.prototype.forward=function(){this.go(1)},wo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wo.prototype.resolve=function(n,e,t){var a=xs(n,e=e||this.history.current,t,this),i=this.match(a,e),s=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?es(n+"/"+a):a}(this.history.base,s,this.mode),normalizedTo:a,resolved:i}},wo.prototype.getRoutes=function(){return this.matcher.getRoutes()},wo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Hi&&this.history.transitionTo(this.history.getCurrentLocation())},wo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Hi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wo.prototype,ko),wo.install=function n(e){if(!n.installed||ws!==e){n.installed=!0,ws=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ji),e.component("RouterLink",Ts);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},wo.version="3.5.3",wo.isNavigationFailure=to,wo.NavigationFailureType=Vs,wo.START_LOCATION=Hi,Ss&&window.Vue&&window.Vue.use(wo);var qo=wo;t(225),t(172),t(252),t(130),t(254),t(36),t(37),t(255);function So(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(74),t(90),t(118);function Ao(n){return(Ao="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Do=t(66),Io=(t(181),t(20),t(51),t(227),t(228),t(40),t(23),{NotFound:function(){return Promise.all([t.e(0),t.e(9)]).then(t.bind(null,489))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,487))}}),Eo={"v-77a2df87":function(){return t.e(11).then(t.bind(null,496))},"v-c81280ce":function(){return t.e(12).then(t.bind(null,497))},"v-44fa5406":function(){return t.e(13).then(t.bind(null,498))},"v-eaf3e45e":function(){return t.e(14).then(t.bind(null,499))},"v-8274608c":function(){return t.e(15).then(t.bind(null,500))},"v-9356a500":function(){return t.e(16).then(t.bind(null,501))},"v-69ba53dc":function(){return t.e(17).then(t.bind(null,502))},"v-53783a7a":function(){return t.e(18).then(t.bind(null,503))},"v-4bb54d5a":function(){return t.e(19).then(t.bind(null,504))},"v-665d2ff5":function(){return Promise.all([t.e(0),t.e(10)]).then(t.bind(null,505))},"v-714308ff":function(){return t.e(20).then(t.bind(null,506))},"v-4ac269ee":function(){return t.e(21).then(t.bind(null,507))},"v-135bff0e":function(){return t.e(22).then(t.bind(null,508))},"v-240065b4":function(){return t.e(23).then(t.bind(null,509))},"v-4fafc755":function(){return t.e(24).then(t.bind(null,510))},"v-350b180b":function(){return t.e(25).then(t.bind(null,511))},"v-e0d76c86":function(){return t.e(26).then(t.bind(null,512))},"v-a626afce":function(){return t.e(27).then(t.bind(null,513))},"v-57bdc255":function(){return t.e(28).then(t.bind(null,514))},"v-96b41596":function(){return t.e(29).then(t.bind(null,515))},"v-6de99164":function(){return t.e(30).then(t.bind(null,516))},"v-fb6a0bc6":function(){return t.e(31).then(t.bind(null,517))},"v-022af798":function(){return t.e(32).then(t.bind(null,518))},"v-9ec8b0e0":function(){return t.e(33).then(t.bind(null,519))},"v-78a1ec51":function(){return t.e(34).then(t.bind(null,520))},"v-0c0b0a3c":function(){return t.e(35).then(t.bind(null,521))},"v-af1f7912":function(){return t.e(36).then(t.bind(null,522))},"v-3dbdb6b8":function(){return t.e(37).then(t.bind(null,523))},"v-5e14a608":function(){return t.e(38).then(t.bind(null,524))},"v-4f011ddc":function(){return t.e(39).then(t.bind(null,525))},"v-8af21fba":function(){return t.e(40).then(t.bind(null,526))},"v-305b9b44":function(){return t.e(41).then(t.bind(null,527))},"v-2b81695b":function(){return t.e(42).then(t.bind(null,528))},"v-d588bd04":function(){return t.e(43).then(t.bind(null,529))},"v-2cd59290":function(){return t.e(44).then(t.bind(null,530))},"v-380fb48e":function(){return t.e(45).then(t.bind(null,531))},"v-a6041e50":function(){return t.e(46).then(t.bind(null,532))},"v-56398717":function(){return t.e(47).then(t.bind(null,533))},"v-29984e8a":function(){return t.e(48).then(t.bind(null,534))},"v-3a5a84d4":function(){return t.e(49).then(t.bind(null,535))},"v-5546a966":function(){return t.e(50).then(t.bind(null,536))},"v-2472a78b":function(){return t.e(51).then(t.bind(null,537))},"v-51317608":function(){return t.e(52).then(t.bind(null,538))},"v-3957ebbe":function(){return t.e(53).then(t.bind(null,539))},"v-d1f85536":function(){return t.e(54).then(t.bind(null,540))},"v-5b4bcfa3":function(){return t.e(55).then(t.bind(null,541))},"v-7a49265a":function(){return t.e(56).then(t.bind(null,542))},"v-1b6b0b30":function(){return t.e(57).then(t.bind(null,543))},"v-ad783cd0":function(){return t.e(58).then(t.bind(null,544))},"v-fbc707cc":function(){return t.e(59).then(t.bind(null,545))},"v-93595222":function(){return t.e(60).then(t.bind(null,546))},"v-523d0d4e":function(){return t.e(61).then(t.bind(null,547))},"v-5ca082b2":function(){return t.e(62).then(t.bind(null,548))},"v-3c7b36da":function(){return t.e(63).then(t.bind(null,549))},"v-03378743":function(){return t.e(64).then(t.bind(null,550))},"v-7bba5a2e":function(){return t.e(65).then(t.bind(null,551))},"v-99fc7970":function(){return t.e(66).then(t.bind(null,490))},"v-18848ef1":function(){return t.e(67).then(t.bind(null,491))},"v-77d4d05b":function(){return t.e(68).then(t.bind(null,552))},"v-618eaefe":function(){return t.e(69).then(t.bind(null,553))},"v-e10e4096":function(){return t.e(70).then(t.bind(null,554))},"v-6f2fc85c":function(){return t.e(71).then(t.bind(null,555))},"v-508d0816":function(){return t.e(72).then(t.bind(null,556))},"v-0789c349":function(){return t.e(73).then(t.bind(null,557))},"v-4069c5f8":function(){return t.e(74).then(t.bind(null,558))},"v-4d8171d5":function(){return t.e(75).then(t.bind(null,559))},"v-0c0b63a6":function(){return t.e(76).then(t.bind(null,560))},"v-4470a5a9":function(){return t.e(77).then(t.bind(null,561))},"v-111c7b94":function(){return t.e(78).then(t.bind(null,562))},"v-57bcc112":function(){return t.e(79).then(t.bind(null,563))},"v-6754fb32":function(){return t.e(80).then(t.bind(null,564))},"v-6cd0ba1b":function(){return t.e(81).then(t.bind(null,565))},"v-62c9c110":function(){return t.e(82).then(t.bind(null,566))},"v-75eb6ec4":function(){return t.e(83).then(t.bind(null,567))},"v-76a9f96e":function(){return t.e(84).then(t.bind(null,568))},"v-b98a2e5c":function(){return t.e(85).then(t.bind(null,569))},"v-1cf80342":function(){return t.e(86).then(t.bind(null,570))},"v-75b9d625":function(){return t.e(87).then(t.bind(null,571))},"v-27678185":function(){return t.e(88).then(t.bind(null,572))},"v-6ae3dba5":function(){return t.e(89).then(t.bind(null,573))},"v-3e5a3109":function(){return t.e(90).then(t.bind(null,574))},"v-87a57784":function(){return t.e(91).then(t.bind(null,575))}};function jo(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Co=/-(\w)/g,zo=jo((function(n){return n.replace(Co,(function(n,e){return e?e.toUpperCase():""}))})),Lo=/\B([A-Z])/g,Fo=jo((function(n){return n.replace(Lo,"-$1").toLowerCase()})),_o=jo((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Po(n,e){if(e)return n(e)?n(e):e.includes("-")?n(_o(zo(e))):n(_o(e))||n(Fo(e))}var Mo=Object.assign({},Io,Eo),Ro=function(n){return Mo[n]},Bo=function(n){return Eo[n]},Oo=function(n){return Io[n]},No=function(n){return Li.component(n)};function Wo(n){return Po(Bo,n)}function Uo(n){return Po(Oo,n)}function Go(n){return Po(Ro,n)}function $o(n){return Po(No,n)}function Ho(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(a.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if($o(e)||!Go(e)){n.next=5;break}return n.next=3,Go(e)();case 3:t=n.sent,Li.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Xo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Yo=t(129),Zo=(t(268),t(146),t(70),t(210)),Vo=t.n(Zo),Ko=t(211),Jo=t.n(Ko),Qo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Yo.a)(n,1)[0]})).map((function(n){var e=Object(Yo.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Jo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=er(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Do.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tr(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Vo()([{name:"description",content:this.$description}],n,this.siteMeta,ar)},updateCanonicalLink:function(){nr(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",er(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tr(null,this.currentMetaTags),nr()}};function nr(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function er(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tr(n,e){if(e&&Object(Do.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ar(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var a=t[e];if(n.hasOwnProperty(a))return n[a]+a}return JSON.stringify(n)}t(132);var ir=t(148),sr={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ir)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),a=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),s=window.innerHeight+a,o=0;o<t.length;o++){var r=t[o],l=t[o+1],h=0===o&&0===a||a>=r.parentElement.offsetTop+10&&(!l||a<l.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(h&&c!==decodeURIComponent(r.hash)){var d=r;if(s===i)for(var u=o+1;u<t.length;u++)if(c===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},or=(t(76),t(98)),rr=t.n(or),lr={mounted:function(){var n=this;rr.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Li.component(n.name)||rr.a.start(),t()})),this.$router.afterEach((function(){rr.a.done(),n.isSidebarOpen=!1}))}};t(71),t(69),t(75),t(363);function hr(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(136);function cr(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function dr(n,e,t){return e&&cr(n.prototype,e),t&&cr(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(364);var ur=function(){function n(){hr(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return dr(n,[{key:"show",value:function(n){var e=this,t=n.text,a=void 0===t?"":t,i=n.duration,s=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(a,"</div>\n    "),this.containerEl.appendChild(o),s>0&&setTimeout((function(){e.close(o)}),s)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),fr={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ur).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},mr=(t(214),"auto"),pr="zoom-in",yr="zoom-out",gr="grab",br="move";function vr(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function xr(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function wr(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function kr(n,e,t){!function(n){var e=Tr,t=qr;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var s in e)t&&(i[s]=a[s]||""),a[s]=e[s];return i}var Tr="transition",qr="transform",Sr="transform",Ar="transitionend";var Dr=function(){},Ir={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Dr,onClose:Dr,onGrab:Dr,onMove:Dr,onRelease:Dr,onBeforeOpen:Dr,onBeforeClose:Dr,onBeforeGrab:Dr,onBeforeRelease:Dr,onImageLoading:Dr,onImageLoaded:Dr},Er={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Cr(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,s=this.options.scrollThreshold;(Math.abs(i)>=s||Math.abs(a)>=s)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(jr(n)&&!Cr(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){jr(n)&&!Cr(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function jr(n){return 0===n.button}function Cr(n){return n.metaKey||n.ctrlKey}var zr={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,kr(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),vr(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){kr(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Fr=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),_r=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},Pr={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=wr(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?gr:yr,transition:Sr+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=kr(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,kr(this.el,{transform:"none"})},grab:function(n,e,t){var a=Mr(),i=a.x-n,s=a.y-e;kr(this.el,{cursor:br,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=Mr(),i=a.x-n,s=a.y-e;kr(this.el,{transition:Sr,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){kr(this.el,this.styleClose)},restoreOpenStyle:function(){kr(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Mr(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,s=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Lr(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,r=this.rect.height/2,l=Mr(),h={x:l.x-o,y:l.y-r},c=h.x/o,d=h.y/r,u=s+Math.min(c,d);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,m=e||this.el.naturalHeight,p=parseFloat(i)*f/(100*this.rect.width),y=parseFloat(i)*m/(100*this.rect.height);if(u>p||u>y)return{x:p,y:y}}return{x:u,y:u}}};function Mr(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Rr(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){vr(n,a,e[a],t)}))}var Br=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Pr),this.overlay=Object.create(zr),this.handler=Object.create(Er),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=_r({},Ir,e),this.overlay.init(this),this.handler.init(this)}return Fr(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=pr,vr(n,"click",this.handler.click),this.options.preloadImage&&xr(wr(n)));return this}},{key:"config",value:function(n){return n?(_r(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),xr(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),vr(document,"scroll",this.handler.scroll),vr(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&vr(window,"resize",this.handler.resizeWindow);var s=function n(){vr(a,Ar,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Rr(document,e.handler,!0),t(a)};return vr(a,Ar,s),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=mr,this.overlay.fadeOut(),this.target.zoomOut(),vr(document,"scroll",this.handler.scroll,!1),vr(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&vr(window,"resize",this.handler.resizeWindow,!1);var a=function a(){vr(t,Ar,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Rr(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return vr(t,Ar,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var s=function n(){vr(i,Ar,n,!1),a(i)};return vr(i,Ar,s),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=br,this.target.move(n,e,t);var i=this.target.el,s=function n(){vr(i,Ar,n,!1),a(i)};return vr(i,Ar,s),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=mr,this.target.restoreOpenStyle();var a=function a(){vr(t,Ar,a,!1),n.lock=!1,n.released=!0,e(t)};return vr(t,Ar,a),this}}}]),n}(),Or=".theme-vdoing-content img:not(.no-zoom)",Nr=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Wr=Number("500"),Ur=function(){function n(){hr(this,n),this.instance=new Br(Nr)}return dr(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Wr;setTimeout((function(){return n.update(e)}),t)}}]),n}(),Gr=[Qo,sr,lr,fr,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new Ur,this.$vuepress.zooming.updateDelay()}}],$r={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Xo("layout",n),Li.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Hr=t(18),Xr=Object(Hr.a)($r,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var a;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(a=n[e]).push.apply(a,Object(Do.a)(t));break;default:throw new Error("Unknown option name.")}}(Xr,"mixins",Gr);var Yr,Zr=[{name:"v-77a2df87",path:"/peizhi/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-77a2df87").then(t)}},{path:"/peizhi/index.html",redirect:"/peizhi/"},{path:"/00.目录页/01.前端.html",redirect:"/peizhi/"},{name:"v-c81280ce",path:"/zhinan/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-c81280ce").then(t)}},{path:"/zhinan/index.html",redirect:"/zhinan/"},{path:"/00.目录页/02.指南.html",redirect:"/zhinan/"},{name:"v-44fa5406",path:"/jiaocheng/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-44fa5406").then(t)}},{path:"/jiaocheng/index.html",redirect:"/jiaocheng/"},{path:"/00.目录页/03.教程.html",redirect:"/jiaocheng/"},{name:"v-eaf3e45e",path:"/ziyuan/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-eaf3e45e").then(t)}},{path:"/ziyuan/index.html",redirect:"/ziyuan/"},{path:"/00.目录页/04.资源.html",redirect:"/ziyuan/"},{name:"v-8274608c",path:"/shoucang/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-8274608c").then(t)}},{path:"/shoucang/index.html",redirect:"/shoucang/"},{path:"/00.目录页/05.收藏.html",redirect:"/shoucang/"},{name:"v-9356a500",path:"/tips/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-9356a500").then(t)}},{path:"/tips/index.html",redirect:"/tips/"},{path:"/00.目录页/07.tips.html",redirect:"/tips/"},{name:"v-69ba53dc",path:"/en-US/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-69ba53dc").then(t)}},{path:"/en-US/index.html",redirect:"/en-US/"},{path:"/00.目录页/08.语言.html",redirect:"/en-US/"},{name:"v-53783a7a",path:"/more/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-53783a7a").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/09.更多.html",redirect:"/more/"},{name:"v-4bb54d5a",path:"/pages/56e571/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4bb54d5a").then(t)}},{path:"/pages/56e571/index.html",redirect:"/pages/56e571/"},{path:"/10.配置/00.入门介绍/00.什么是Dafny.html",redirect:"/pages/56e571/"},{name:"v-665d2ff5",path:"/pages/4fa796/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-665d2ff5").then(t)}},{path:"/pages/4fa796/index.html",redirect:"/pages/4fa796/"},{path:"/10.配置/10.用起来吧/00.安装.html",redirect:"/pages/4fa796/"},{name:"v-714308ff",path:"/pages/085606/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-714308ff").then(t)}},{path:"/pages/085606/index.html",redirect:"/pages/085606/"},{path:"/10.配置/10.用起来吧/05.快速入门.html",redirect:"/pages/085606/"},{name:"v-4ac269ee",path:"/pages/39fb20/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4ac269ee").then(t)}},{path:"/pages/39fb20/index.html",redirect:"/pages/39fb20/"},{path:"/10.配置/10.用起来吧/10.简单上手.html",redirect:"/pages/39fb20/"},{name:"v-135bff0e",path:"/pages/caf1f9/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-135bff0e").then(t)}},{path:"/pages/caf1f9/index.html",redirect:"/pages/caf1f9/"},{path:"/100.社区留言板/留言板.html",redirect:"/pages/caf1f9/"},{name:"v-240065b4",path:"/pages/6e15a6/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-240065b4").then(t)}},{path:"/pages/6e15a6/index.html",redirect:"/pages/6e15a6/"},{path:"/20.指南/00.Dafny快速入门/00.基础 Basic.html",redirect:"/pages/6e15a6/"},{name:"v-4fafc755",path:"/pages/eba166/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4fafc755").then(t)}},{path:"/pages/eba166/index.html",redirect:"/pages/eba166/"},{path:"/20.指南/00.Dafny快速入门/05.方法 Method.html",redirect:"/pages/eba166/"},{name:"v-350b180b",path:"/pages/83cdf9/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-350b180b").then(t)}},{path:"/pages/83cdf9/index.html",redirect:"/pages/83cdf9/"},{path:"/20.指南/00.Dafny快速入门/10.关键字 Keyword.html",redirect:"/pages/83cdf9/"},{name:"v-e0d76c86",path:"/pages/01d76e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-e0d76c86").then(t)}},{path:"/pages/01d76e/index.html",redirect:"/pages/01d76e/"},{path:"/20.指南/00.Dafny快速入门/15.函数 Function.html",redirect:"/pages/01d76e/"},{name:"v-a626afce",path:"/pages/0fadc1/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-a626afce").then(t)}},{path:"/pages/0fadc1/index.html",redirect:"/pages/0fadc1/"},{path:"/20.指南/00.Dafny快速入门/20.类 Class.html",redirect:"/pages/0fadc1/"},{name:"v-57bdc255",path:"/pages/a010ab/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-57bdc255").then(t)}},{path:"/pages/a010ab/index.html",redirect:"/pages/a010ab/"},{path:"/20.指南/00.Dafny快速入门/30.泛型 Generics.html",redirect:"/pages/a010ab/"},{name:"v-96b41596",path:"/pages/c4fda3/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-96b41596").then(t)}},{path:"/pages/c4fda3/index.html",redirect:"/pages/c4fda3/"},{path:"/20.指南/00.Dafny快速入门/35.声明 Statement.html",redirect:"/pages/c4fda3/"},{name:"v-6de99164",path:"/pages/e8438e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6de99164").then(t)}},{path:"/pages/e8438e/index.html",redirect:"/pages/e8438e/"},{path:"/20.指南/00.Dafny快速入门/40.表达式 Expression.html",redirect:"/pages/e8438e/"},{name:"v-fb6a0bc6",path:"/pages/0978ce/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-fb6a0bc6").then(t)}},{path:"/pages/0978ce/index.html",redirect:"/pages/0978ce/"},{path:"/20.指南/10.简单例子/00.寻找最大和最小数.html",redirect:"/pages/0978ce/"},{name:"v-022af798",path:"/pages/e3e481/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-022af798").then(t)}},{path:"/pages/e3e481/index.html",redirect:"/pages/e3e481/"},{path:"/20.指南/10.简单例子/05.斐波那契数列.html",redirect:"/pages/e3e481/"},{name:"v-9ec8b0e0",path:"/pages/02fdef/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-9ec8b0e0").then(t)}},{path:"/pages/02fdef/index.html",redirect:"/pages/02fdef/"},{path:"/20.指南/10.简单例子/10.线性查询.html",redirect:"/pages/02fdef/"},{name:"v-78a1ec51",path:"/pages/9b332b/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-78a1ec51").then(t)}},{path:"/pages/9b332b/index.html",redirect:"/pages/9b332b/"},{path:"/20.指南/10.简单例子/15. 引理-计算序列中非负元素的个数.html",redirect:"/pages/9b332b/"},{name:"v-0c0b0a3c",path:"/pages/3d1110/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0c0b0a3c").then(t)}},{path:"/pages/3d1110/index.html",redirect:"/pages/3d1110/"},{path:"/20.指南/10.简单例子/20.集合.html",redirect:"/pages/3d1110/"},{name:"v-af1f7912",path:"/pages/2146d4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-af1f7912").then(t)}},{path:"/pages/2146d4/index.html",redirect:"/pages/2146d4/"},{path:"/20.指南/10.简单例子/25.终止.html",redirect:"/pages/2146d4/"},{name:"v-3dbdb6b8",path:"/pages/877eb3/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3dbdb6b8").then(t)}},{path:"/pages/877eb3/index.html",redirect:"/pages/877eb3/"},{path:"/30.教程/00.Dafny教程/00.介绍.html",redirect:"/pages/877eb3/"},{name:"v-5e14a608",path:"/pages/bf40c0/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5e14a608").then(t)}},{path:"/pages/bf40c0/index.html",redirect:"/pages/bf40c0/"},{path:"/30.教程/00.Dafny教程/05.方法.html",redirect:"/pages/bf40c0/"},{name:"v-4f011ddc",path:"/pages/2e0c73/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4f011ddc").then(t)}},{path:"/pages/2e0c73/index.html",redirect:"/pages/2e0c73/"},{path:"/30.教程/00.Dafny教程/10.前置和后置条件.html",redirect:"/pages/2e0c73/"},{name:"v-8af21fba",path:"/pages/36c1b4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-8af21fba").then(t)}},{path:"/pages/36c1b4/index.html",redirect:"/pages/36c1b4/"},{path:"/30.教程/00.Dafny教程/15.断言.html",redirect:"/pages/36c1b4/"},{name:"v-305b9b44",path:"/pages/a1d5a4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-305b9b44").then(t)}},{path:"/pages/a1d5a4/index.html",redirect:"/pages/a1d5a4/"},{path:"/30.教程/00.Dafny教程/20.函数.html",redirect:"/pages/a1d5a4/"},{name:"v-2b81695b",path:"/pages/d89435/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2b81695b").then(t)}},{path:"/pages/d89435/index.html",redirect:"/pages/d89435/"},{path:"/30.教程/00.Dafny教程/25.循环不变式.html",redirect:"/pages/d89435/"},{name:"v-d588bd04",path:"/pages/af29e4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-d588bd04").then(t)}},{path:"/pages/af29e4/index.html",redirect:"/pages/af29e4/"},{path:"/30.教程/00.Dafny教程/30.终止.html",redirect:"/pages/af29e4/"},{name:"v-2cd59290",path:"/pages/828a83/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2cd59290").then(t)}},{path:"/pages/828a83/index.html",redirect:"/pages/828a83/"},{path:"/30.教程/00.Dafny教程/35.数组.html",redirect:"/pages/828a83/"},{name:"v-380fb48e",path:"/pages/17e8d1/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-380fb48e").then(t)}},{path:"/pages/17e8d1/index.html",redirect:"/pages/17e8d1/"},{path:"/30.教程/00.Dafny教程/40.量词.html",redirect:"/pages/17e8d1/"},{name:"v-a6041e50",path:"/pages/cc01af/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-a6041e50").then(t)}},{path:"/pages/cc01af/index.html",redirect:"/pages/cc01af/"},{path:"/30.教程/00.Dafny教程/45.谓词.html",redirect:"/pages/cc01af/"},{name:"v-56398717",path:"/pages/13bbcd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-56398717").then(t)}},{path:"/pages/13bbcd/index.html",redirect:"/pages/13bbcd/"},{path:"/30.教程/00.Dafny教程/50.框架.html",redirect:"/pages/13bbcd/"},{name:"v-29984e8a",path:"/pages/1319be/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-29984e8a").then(t)}},{path:"/pages/1319be/index.html",redirect:"/pages/1319be/"},{path:"/30.教程/00.Dafny教程/55.二分查找.html",redirect:"/pages/1319be/"},{name:"v-3a5a84d4",path:"/pages/30a8c2/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3a5a84d4").then(t)}},{path:"/pages/30a8c2/index.html",redirect:"/pages/30a8c2/"},{path:"/30.教程/00.Dafny教程/60.结论.html",redirect:"/pages/30a8c2/"},{name:"v-5546a966",path:"/pages/273cac/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5546a966").then(t)}},{path:"/pages/273cac/index.html",redirect:"/pages/273cac/"},{path:"/30.教程/10.Dafny进阶语法/00.引理和归纳.html",redirect:"/pages/273cac/"},{name:"v-2472a78b",path:"/pages/9d19b8/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2472a78b").then(t)}},{path:"/pages/9d19b8/index.html",redirect:"/pages/9d19b8/"},{path:"/30.教程/10.Dafny进阶语法/05.模块.html",redirect:"/pages/9d19b8/"},{name:"v-51317608",path:"/pages/b9300a/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-51317608").then(t)}},{path:"/pages/b9300a/index.html",redirect:"/pages/b9300a/"},{path:"/30.教程/10.Dafny进阶语法/10.集合.html",redirect:"/pages/b9300a/"},{name:"v-3957ebbe",path:"/pages/cb3d21/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3957ebbe").then(t)}},{path:"/pages/cb3d21/index.html",redirect:"/pages/cb3d21/"},{path:"/30.教程/10.Dafny进阶语法/15.序列.html",redirect:"/pages/cb3d21/"},{name:"v-d1f85536",path:"/pages/fc6196/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-d1f85536").then(t)}},{path:"/pages/fc6196/index.html",redirect:"/pages/fc6196/"},{path:"/30.教程/10.Dafny进阶语法/20.终止.html",redirect:"/pages/fc6196/"},{name:"v-5b4bcfa3",path:"/pages/a2a107/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5b4bcfa3").then(t)}},{path:"/pages/a2a107/index.html",redirect:"/pages/a2a107/"},{path:"/30.教程/10.Dafny进阶语法/25.值类型.html",redirect:"/pages/a2a107/"},{name:"v-7a49265a",path:"/pages/718207/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-7a49265a").then(t)}},{path:"/pages/718207/index.html",redirect:"/pages/718207/"},{path:"/40.资源/00.实践探索/1.自动归纳.html",redirect:"/pages/718207/"},{name:"v-1b6b0b30",path:"/pages/1f579f/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-1b6b0b30").then(t)}},{path:"/pages/1f579f/index.html",redirect:"/pages/1f579f/"},{path:"/40.资源/00.实践探索/2.自动调用引理.html",redirect:"/pages/1f579f/"},{name:"v-ad783cd0",path:"/pages/f6638c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-ad783cd0").then(t)}},{path:"/pages/f6638c/index.html",redirect:"/pages/f6638c/"},{path:"/40.资源/00.实践探索/3.定义、证明、算法正确性的案例研究GCD.html",redirect:"/pages/f6638c/"},{name:"v-fbc707cc",path:"/pages/1d2420/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-fbc707cc").then(t)}},{path:"/pages/1d2420/index.html",redirect:"/pages/1d2420/"},{path:"/40.资源/00.实践探索/4.各种推导式.html",redirect:"/pages/1d2420/"},{name:"v-93595222",path:"/pages/20c275/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-93595222").then(t)}},{path:"/pages/20c275/index.html",redirect:"/pages/20c275/"},{path:"/40.资源/00.实践探索/5.不同类型的证明.html",redirect:"/pages/20c275/"},{name:"v-523d0d4e",path:"/pages/67167e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-523d0d4e").then(t)}},{path:"/pages/67167e/index.html",redirect:"/pages/67167e/"},{path:"/40.资源/00.实践探索/6.集合元素上的函数.html",redirect:"/pages/67167e/"},{name:"v-5ca082b2",path:"/pages/be298d/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5ca082b2").then(t)}},{path:"/pages/be298d/index.html",redirect:"/pages/be298d/"},{path:"/40.资源/00.实践探索/7.在集合上迭代.html",redirect:"/pages/be298d/"},{name:"v-3c7b36da",path:"/pages/8065fd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3c7b36da").then(t)}},{path:"/pages/8065fd/index.html",redirect:"/pages/8065fd/"},{path:"/40.资源/10.常用工具/00.Dafny type system.html",redirect:"/pages/8065fd/"},{name:"v-03378743",path:"/pages/0f17ab/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-03378743").then(t)}},{path:"/pages/0f17ab/index.html",redirect:"/pages/0f17ab/"},{path:"/40.资源/10.常用工具/05.Style Guide for Dafny programs.html",redirect:"/pages/0f17ab/"},{name:"v-7bba5a2e",path:"/pages/a65c3f/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-7bba5a2e").then(t)}},{path:"/pages/a65c3f/index.html",redirect:"/pages/a65c3f/"},{path:"/40.资源/10.常用工具/10.Cheet Sheet.html",redirect:"/pages/a65c3f/"},{name:"v-99fc7970",path:"/pages/1b94a4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-99fc7970").then(t)}},{path:"/pages/1b94a4/index.html",redirect:"/pages/1b94a4/"},{path:"/50.收藏/01.收藏站.html",redirect:"/pages/1b94a4/"},{name:"v-18848ef1",path:"/pages/30bf81/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-18848ef1").then(t)}},{path:"/pages/30bf81/index.html",redirect:"/pages/30bf81/"},{path:"/60.支持/01.导航站.html",redirect:"/pages/30bf81/"},{name:"v-77d4d05b",path:"/pages/8fb957/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-77d4d05b").then(t)}},{path:"/pages/8fb957/index.html",redirect:"/pages/8fb957/"},{path:"/80.语言/00.dafny-quick-start/00.Dafny Quick Reference.html",redirect:"/pages/8fb957/"},{name:"v-618eaefe",path:"/pages/8766fd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-618eaefe").then(t)}},{path:"/pages/8766fd/index.html",redirect:"/pages/8766fd/"},{path:"/80.语言/00.dafny-quick-start/10.Getting Started with Dafny A Guide.html",redirect:"/pages/8766fd/"},{name:"v-e10e4096",path:"/pages/fe5721/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-e10e4096").then(t)}},{path:"/pages/fe5721/index.html",redirect:"/pages/fe5721/"},{path:"/80.语言/00.dafny-quick-start/20.cheet.html",redirect:"/pages/fe5721/"},{name:"v-6f2fc85c",path:"/pages/c80a4c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6f2fc85c").then(t)}},{path:"/pages/c80a4c/index.html",redirect:"/pages/c80a4c/"},{path:"/80.语言/10.dafny-tutorials/00.Getting Started with Dafny A Guide.html",redirect:"/pages/c80a4c/"},{name:"v-508d0816",path:"/pages/a9c4a5/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-508d0816").then(t)}},{path:"/pages/a9c4a5/index.html",redirect:"/pages/a9c4a5/"},{path:"/80.语言/20.detailed-document/00.Dafny type system.html",redirect:"/pages/a9c4a5/"},{name:"v-0789c349",path:"/pages/c0c2c7/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0789c349").then(t)}},{path:"/pages/c0c2c7/index.html",redirect:"/pages/c0c2c7/"},{path:"/80.语言/20.detailed-document/10.Style Guide for Dafny programers.html",redirect:"/pages/c0c2c7/"},{name:"v-4069c5f8",path:"/pages/a9363c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4069c5f8").then(t)}},{path:"/pages/a9363c/index.html",redirect:"/pages/a9363c/"},{path:"/80.语言/30.publication-lecture/00.Automatic Induction.html",redirect:"/pages/a9363c/"},{name:"v-4d8171d5",path:"/pages/30441e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4d8171d5").then(t)}},{path:"/pages/30441e/index.html",redirect:"/pages/30441e/"},{path:"/80.语言/30.publication-lecture/05.Calling Lemmas Automatically.html",redirect:"/pages/30441e/"},{name:"v-0c0b63a6",path:"/pages/746026/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0c0b63a6").then(t)}},{path:"/pages/746026/index.html",redirect:"/pages/746026/"},{path:"/80.语言/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.html",redirect:"/pages/746026/"},{name:"v-4470a5a9",path:"/pages/da6921/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4470a5a9").then(t)}},{path:"/pages/da6921/index.html",redirect:"/pages/da6921/"},{path:"/80.语言/30.publication-lecture/15.Comprehensions.html",redirect:"/pages/da6921/"},{name:"v-111c7b94",path:"/pages/8d8607/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-111c7b94").then(t)}},{path:"/pages/8d8607/index.html",redirect:"/pages/8d8607/"},{path:"/80.语言/30.publication-lecture/20.Different Styles of Proofs.html",redirect:"/pages/8d8607/"},{name:"v-57bcc112",path:"/pages/097ba0/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-57bcc112").then(t)}},{path:"/pages/097ba0/index.html",redirect:"/pages/097ba0/"},{path:"/80.语言/30.publication-lecture/30.Functions over Set Elements.html",redirect:"/pages/097ba0/"},{name:"v-6754fb32",path:"/pages/c4484e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6754fb32").then(t)}},{path:"/pages/c4484e/index.html",redirect:"/pages/c4484e/"},{path:"/80.语言/30.publication-lecture/35.Iterating over a Collection.html",redirect:"/pages/c4484e/"},{name:"v-6cd0ba1b",path:"/pages/7fe522/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6cd0ba1b").then(t)}},{path:"/pages/7fe522/index.html",redirect:"/pages/7fe522/"},{path:"/80.语言/30.publication-lecture/40.old and unchanged.html",redirect:"/pages/7fe522/"},{name:"v-62c9c110",path:"/pages/369e25/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-62c9c110").then(t)}},{path:"/pages/369e25/index.html",redirect:"/pages/369e25/"},{path:"/80.语言/30.publication-lecture/45.Short-Circuit Operators.html",redirect:"/pages/369e25/"},{name:"v-75eb6ec4",path:"/pages/f8c1c5/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-75eb6ec4").then(t)}},{path:"/pages/f8c1c5/index.html",redirect:"/pages/f8c1c5/"},{path:"/80.语言/30.publication-lecture/50.Statement versus Expression Syntax.html",redirect:"/pages/f8c1c5/"},{name:"v-76a9f96e",path:"/pages/5a4346/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-76a9f96e").then(t)}},{path:"/pages/5a4346/index.html",redirect:"/pages/5a4346/"},{path:"/80.语言/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.html",redirect:"/pages/5a4346/"},{name:"v-b98a2e5c",path:"/pages/c45b5a/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-b98a2e5c").then(t)}},{path:"/pages/c45b5a/index.html",redirect:"/pages/c45b5a/"},{path:"/80.语言/30.publication-lecture/60.Type-Parameter Completion.html",redirect:"/pages/c45b5a/"},{name:"v-1cf80342",path:"/pages/3c9a0b/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-1cf80342").then(t)}},{path:"/pages/3c9a0b/index.html",redirect:"/pages/3c9a0b/"},{path:"/80.语言/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.html",redirect:"/pages/3c9a0b/"},{name:"v-75b9d625",path:"/archives/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-75b9d625").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-27678185",path:"/categories/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-27678185").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-6ae3dba5",path:"/tags/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6ae3dba5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-3e5a3109",path:"/pages/12f287/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3e5a3109").then(t)}},{path:"/pages/12f287/index.html",redirect:"/pages/12f287/"},{path:"/_posts/tips/tips.html",redirect:"/pages/12f287/"},{name:"v-87a57784",path:"/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-87a57784").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:Xr}],Vr={title:"",description:"",base:"/dafnycommunity/",headTags:[["link",{rel:"icon",href:"/dafnycommunity/img/bgico2.ico"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["link",{rel:"stylesheet",href:"https://at.alicdn.com/t/font_3282046_1qux519eoim.css"}],["script",{src:"https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"}]],pages:[{title:"Dafny入门",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"10.配置",imgUrl:"/img/rumen.png",description:"语言入门资料"}},title:"Dafny入门",date:"2020-03-11T21:50:53.000Z",permalink:"/peizhi",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-77a2df87",path:"/peizhi/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny进阶",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.指南",imgUrl:"/img/jinjie.png",description:"Dafny进阶教程"}},title:"Dafny进阶",date:"2020-03-11T21:50:54.000Z",permalink:"/zhinan",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E6%8C%87%E5%8D%97.html",relativePath:"00.目录页/02.指南.md",key:"v-c81280ce",path:"/zhinan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny教程",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.教程",imgUrl:"/img/jinjie.png",description:"Dafny教程集锦"}},title:"Dafny教程",date:"2020-03-11T21:50:55.000Z",permalink:"/jiaocheng",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%95%99%E7%A8%8B.html",relativePath:"00.目录页/03.教程.md",key:"v-44fa5406",path:"/jiaocheng/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"40.资源",imgUrl:"/img/ziyuan.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/ziyuan",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E8%B5%84%E6%BA%90.html",relativePath:"00.目录页/04.资源.md",key:"v-eaf3e45e",path:"/ziyuan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"收藏",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.收藏",imgUrl:"/img/ziyuan.png",description:"更多验证语言在这里"}},title:"收藏",date:"2020-03-11T21:50:53.000Z",permalink:"/shoucang",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E6%94%B6%E8%97%8F.html",relativePath:"00.目录页/05.收藏.md",key:"v-8274608c",path:"/shoucang/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny tips",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"70.tips",imgUrl:"/img/ziyuan.png",description:"tips"}},title:"Dafny tips",date:"2020-03-11T21:50:53.000Z",permalink:"/tips",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/07.tips.html",relativePath:"00.目录页/07.tips.md",key:"v-9356a500",path:"/tips/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"languages",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"80.语言",imgUrl:"/img/ziyuan.png",description:"language"}},title:"languages",date:"2020-03-11T21:50:53.000Z",permalink:"/en-US",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/08.%E8%AF%AD%E8%A8%80.html",relativePath:"00.目录页/08.语言.md",key:"v-69ba53dc",path:"/en-US/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny more",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"80.更多",imgUrl:"/img/ziyuan.png",description:"更多"}},title:"Dafny more",date:"2020-03-11T21:50:53.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/09.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/09.更多.md",key:"v-53783a7a",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"语言介绍",frontmatter:{title:"语言介绍",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/56e571/",categories:["配置"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/00.%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/00.%E4%BB%80%E4%B9%88%E6%98%AFDafny.html",relativePath:"10.配置/00.入门介绍/00.什么是Dafny.md",key:"v-4bb54d5a",path:"/pages/56e571/",headersStr:null,content:"# 介绍\n\nDafny 是一种旨在使编写正确代码变得容易的语言。怎么更容意的验证正确性呢？Dafny依靠高级注释来实现。通过高级注释（high-level annotations）的推理和验证，一段代码的逻辑可以用高级注释更自然抽象的表达出来，当然这样更加容易编写和验证，且不易写错。\n\n编译dafny程序后，dafny会生成与高级注释匹配的逻辑证明，来告诉程序员这个程序逻辑正不正确，错了也会有报错。Dafny这样实际上是把编写无错误代码减轻为编写无错误注释，这样写起来当然更容易，因为注释更短更直接。下面举个例子：\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\n这个例子是说：对于所有数组下标索引k，其索引对应的数组值a[k]>0。通过编写这段注释，可以验证这个是正确的。\n\n除了证明程序员写的高级注释是否正确外，Dafny还能实时验证逻辑。它能边写程序边验证，比如数组越界、空引用、除以零等，还可以证明循环中代码是否终止，总之功能非常强大。\n\n那么在何处编写Dafny呢？可以上github下载Dafny语言包，用命令行打开Dafny.exe文件输入程序就可以验证，也可以在浏览器web上打开rise4fun网站，这网站上能实时编写并且有教程。如果想有更好的体验比如高亮注释实时报错这种功能的话，可以用VScode下载相应 适用广泛的基础单选\n\nmarkdown content",normalizedContent:"# 介绍\n\ndafny 是一种旨在使编写正确代码变得容易的语言。怎么更容意的验证正确性呢？dafny依靠高级注释来实现。通过高级注释（high-level annotations）的推理和验证，一段代码的逻辑可以用高级注释更自然抽象的表达出来，当然这样更加容易编写和验证，且不易写错。\n\n编译dafny程序后，dafny会生成与高级注释匹配的逻辑证明，来告诉程序员这个程序逻辑正不正确，错了也会有报错。dafny这样实际上是把编写无错误代码减轻为编写无错误注释，这样写起来当然更容易，因为注释更短更直接。下面举个例子：\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\n这个例子是说：对于所有数组下标索引k，其索引对应的数组值a[k]>0。通过编写这段注释，可以验证这个是正确的。\n\n除了证明程序员写的高级注释是否正确外，dafny还能实时验证逻辑。它能边写程序边验证，比如数组越界、空引用、除以零等，还可以证明循环中代码是否终止，总之功能非常强大。\n\n那么在何处编写dafny呢？可以上github下载dafny语言包，用命令行打开dafny.exe文件输入程序就可以验证，也可以在浏览器web上打开rise4fun网站，这网站上能实时编写并且有教程。如果想有更好的体验比如高亮注释实时报错这种功能的话，可以用vscode下载相应 适用广泛的基础单选\n\nmarkdown content",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"安装Dafny",frontmatter:{title:"安装Dafny",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/4fa796/",comment:!0,categories:["配置"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/00.%E5%AE%89%E8%A3%85.html",relativePath:"10.配置/10.用起来吧/00.安装.md",key:"v-665d2ff5",path:"/pages/4fa796/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:11},{level:2,title:"Vscode",slug:"vscode",normalizedTitle:"vscode",charIndex:45},{level:3,title:"下载Dafny扩展包",slug:"下载dafny扩展包",normalizedTitle:"下载dafny扩展包",charIndex:264},{level:3,title:"下载NetCore5.0",slug:"下载netcore5-0",normalizedTitle:"下载netcore5.0",charIndex:281},{level:3,title:"自动下载language server",slug:"自动下载language-server",normalizedTitle:"自动下载language server",charIndex:416},{level:3,title:"手动配置language server",slug:"手动配置language-server",normalizedTitle:"手动配置language server",charIndex:666},{level:4,title:"GitHub下载dafny",slug:"github下载dafny",normalizedTitle:"github下载dafny",charIndex:689},{level:4,title:"相关配置文件",slug:"相关配置文件",normalizedTitle:"相关配置文件",charIndex:747},{level:4,title:"更改相关路径",slug:"更改相关路径",normalizedTitle:"更改相关路径",charIndex:805}],headersStr:"安装 Vscode 下载Dafny扩展包 下载NetCore5.0 自动下载language server 手动配置language server GitHub下载dafny 相关配置文件 更改相关路径",content:"# 快速上手\n\n\n# 安装\n\n可以访问Dafny-lang查看最新Dafny版本\n\n\n# Vscode\n\n具体下载方法可查看Dafny wiki，这是语言团队推出并维护的wiki博客。\n\n如果你想快速上手使用，可以观看Install Dafny on Windows，了解如何在vscode上创建并编译Dafny文件。\n\n步骤如下：\n\n * 下载vscode,安装Dafny(v1.6.0)扩展包\n * 下载Netcore5.0\n * 创建.dfy文件，等待language server自动下载完成。\n * 编译运行\n\n\n# 下载Dafny扩展包\n\n\n\n\n# 下载NetCore5.0\n\n进入vscode新建或打开一个dafny（.dfy）文件，此时vscode会提示需要下载[NETCore5.0](Download .NET (Linux, macOS, and Windows) (microsoft.com))。\n\n\n# 自动下载language server\n\n注意扩展包中有如下提示：\n\n> This VSCode plugin requires the Dafny language server (shipped with the Dafny release since v3.1.0).\n> \n> The plugin will install it automatically upon first use.\n\nDafny扩展插件会自动下载language server,但实际速度和成功率不尽人意。\n\n\n# 手动配置language server\n\n# GitHub下载dafny\n\n以dafny(v3.2.0)为例，进入Dafny-lang下载对应版本语言包。\n\n# 相关配置文件\n\n找到Dafny.dll与DafnyLanguageServer.dll文件，记住其文件路径。\n\n# 更改相关路径\n\n在vscode工作区--扩展--Dafny extension中修改Compiler Runtime Path、Language Server Runtime Path为以上两个文件的对应路径。\n\n----------------------------------------\n\n\n# 第一个Dafny程序\n\n配置完成，让我们来创建个简单的dafny文件来体验一下吧！\n\n * 实时验证\n\n * hello,Dafny\n\n> 相关链接：\n> \n> github wiki\n> \n> vscode dafny-extension\n> \n> youtube Install Dafny on Windows",normalizedContent:"# 快速上手\n\n\n# 安装\n\n可以访问dafny-lang查看最新dafny版本\n\n\n# vscode\n\n具体下载方法可查看dafny wiki，这是语言团队推出并维护的wiki博客。\n\n如果你想快速上手使用，可以观看install dafny on windows，了解如何在vscode上创建并编译dafny文件。\n\n步骤如下：\n\n * 下载vscode,安装dafny(v1.6.0)扩展包\n * 下载netcore5.0\n * 创建.dfy文件，等待language server自动下载完成。\n * 编译运行\n\n\n# 下载dafny扩展包\n\n\n\n\n# 下载netcore5.0\n\n进入vscode新建或打开一个dafny（.dfy）文件，此时vscode会提示需要下载[netcore5.0](download .net (linux, macos, and windows) (microsoft.com))。\n\n\n# 自动下载language server\n\n注意扩展包中有如下提示：\n\n> this vscode plugin requires the dafny language server (shipped with the dafny release since v3.1.0).\n> \n> the plugin will install it automatically upon first use.\n\ndafny扩展插件会自动下载language server,但实际速度和成功率不尽人意。\n\n\n# 手动配置language server\n\n# github下载dafny\n\n以dafny(v3.2.0)为例，进入dafny-lang下载对应版本语言包。\n\n# 相关配置文件\n\n找到dafny.dll与dafnylanguageserver.dll文件，记住其文件路径。\n\n# 更改相关路径\n\n在vscode工作区--扩展--dafny extension中修改compiler runtime path、language server runtime path为以上两个文件的对应路径。\n\n----------------------------------------\n\n\n# 第一个dafny程序\n\n配置完成，让我们来创建个简单的dafny文件来体验一下吧！\n\n * 实时验证\n\n * hello,dafny\n\n> 相关链接：\n> \n> github wiki\n> \n> vscode dafny-extension\n> \n> youtube install dafny on windows",charsets:{cjk:!0},lastUpdated:"2022/03/26, 22:28:20",lastUpdatedTimestamp:16483049e5},{title:"快速入门",frontmatter:{title:"快速入门",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/085606/",categories:["配置"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/05.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"10.配置/10.用起来吧/05.快速入门.md",key:"v-714308ff",path:"/pages/085606/",headers:[{level:2,title:"基本定义",slug:"基本定义",normalizedTitle:"基本定义",charIndex:448},{level:2,title:"方法 methods",slug:"方法-methods",normalizedTitle:"方法 methods",charIndex:787},{level:3,title:"框架Frame",slug:"框架frame",normalizedTitle:"框架frame",charIndex:1306},{level:3,title:"变体函数 variant function",slug:"变体函数-variant-function",normalizedTitle:"变体函数 variant function",charIndex:1545},{level:3,title:"ghost 关键字",slug:"ghost-关键字",normalizedTitle:"ghost 关键字",charIndex:1691},{level:3,title:"this 关键字",slug:"this-关键字",normalizedTitle:"this 关键字",charIndex:1754},{level:3,title:"构造函数/构造体 constructor",slug:"构造函数-构造体-constructor",normalizedTitle:"构造函数/构造体 constructor",charIndex:1858},{level:3,title:"lemma 关键字",slug:"lemma-关键字",normalizedTitle:"lemma 关键字",charIndex:2181},{level:2,title:"函数 function",slug:"函数-function",normalizedTitle:"函数 function",charIndex:2581},{level:3,title:"类 class",slug:"类-class",normalizedTitle:"类 class",charIndex:3516},{level:3,title:"数据类型 datatypes",slug:"数据类型-datatypes",normalizedTitle:"数据类型 datatypes",charIndex:3624},{level:3,title:"泛型 Generics",slug:"泛型-generics",normalizedTitle:"泛型 generics",charIndex:4278},{level:3,title:"声明 Statement",slug:"声明-statement",normalizedTitle:"声明 statement",charIndex:4606},{level:4,title:"函数/方法的返回值赋值给变量",slug:"函数-方法的返回值赋值给变量",normalizedTitle:"函数/方法的返回值赋值给变量",charIndex:5043},{level:4,title:"assert 声明",slug:"assert-声明",normalizedTitle:"assert 声明",charIndex:5476},{level:4,title:"print 打印语句",slug:"print-打印语句",normalizedTitle:"print 打印语句",charIndex:5523},{level:4,title:"if 选择语句",slug:"if-选择语句",normalizedTitle:"if 选择语句",charIndex:5606},{level:4,title:"while 循环语句",slug:"while-循环语句",normalizedTitle:"while 循环语句",charIndex:5676},{level:4,title:"match语句(阿巴阿巴)",slug:"match语句-阿巴阿巴",normalizedTitle:"match语句(阿巴阿巴)",charIndex:5969},{level:4,title:"break语句",slug:"break语句",normalizedTitle:"break语句",charIndex:6109},{level:2,title:"表达式 Expressions",slug:"表达式-expressions",normalizedTitle:"表达式 expressions",charIndex:6158},{level:3,title:"基本运算符",slug:"基本运算符",normalizedTitle:"基本运算符",charIndex:6224},{level:4,title:"整数运算",slug:"整数运算",normalizedTitle:"整数运算",charIndex:6679},{level:4,title:"离 散 数 学",slug:"离-散-数-学",normalizedTitle:"离 散 数 学",charIndex:6846},{level:4,title:"集合运算",slug:"集合运算",normalizedTitle:"集合运算",charIndex:6966},{level:4,title:"序列运算",slug:"序列运算",normalizedTitle:"序列运算",charIndex:7187},{level:4,title:"if-then-else判断语句",slug:"if-then-else判断语句",normalizedTitle:"if-then-else判断语句",charIndex:7733},{level:4,title:"match匹配表达式",slug:"match匹配表达式",normalizedTitle:"match匹配表达式",charIndex:7896}],headersStr:"基本定义 方法 methods 框架Frame 变体函数 variant function ghost 关键字 this 关键字 构造函数/构造体 constructor lemma 关键字 函数 function 类 class 数据类型 datatypes 泛型 Generics 声明 Statement 函数/方法的返回值赋值给变量 assert 声明 print 打印语句 if 选择语句 while 循环语句 match语句(阿巴阿巴) break语句 表达式 Expressions 基本运算符 整数运算 离 散 数 学 集合运算 序列运算 if-then-else判断语句 match匹配表达式",content:"# 基础学习\n\n页面说明\n\n此页面说明了 Dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 Dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\nDafny程序长这样：xxxxx.dfy，Dafny文件是以dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main`不是必须的。\n\n> 注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)T：\n\nvar x: T\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\nDafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<T>：不可变的无序集合\n * seq<T>：不可变的有序集合\n * array<T>、array2<T>、array3<T>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。\n\n\n# 方法 methods\n\n方法的声明如下：\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //输入输出参数\nrequires Pre\t//前置条件\nmodifies Frame  //框架\nensures Post\t//后置条件\ndecreases TerminationMetric //变体函数\n{\nBody //函数体`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * Pre: 表示方法 前提条件 的 布尔表达式\n * Frame: 表示类对象的集合，可以被方法更新(Frame denotes a set of objects whose fields may be updated by the method)\n * Post: 是方法 后置条件 的 布尔表达式\n * TerminationMetric: 是方法的变体函数(TerminationMetric is the method’s variant function)\n * Body: 是实现方法的语句。\n\n\n# 框架Frame\n\n框架Frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架Frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类C的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的“top”元素。\n\n如果省略没写的话，Dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\nDafny IDE 将在工具提示中显示猜测。\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 C 中的静态方法 M 可以由 C.M(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器` \nmodifies this //框架内对象的构造体 this就是this.frame？`\n\n{\n  Body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# lemma 关键字\n\n有时，方法(method)关键字会被引理(lemmas)取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件`\n{\nx, y, z := a, b, c;\nif z < y {\ny, z := z, y;\n}\nif y < x {\n    x, y := y, x;\n  }\nif z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 函数 function\n\n函数具有以下形式：\n\nfunction F(a: A, b: B, c: C): T\nrequires Pre  //前置条件pre\nreads Frame\t//框架frame\nensures Post //后置条件post\ndecreases TerminationMetric //变体函数\n{\n  Body\t//函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : 输入的形参，\n * T : 返回结果的类型，\n * Pre: 表示函数前提条件的布尔表达式，\n * Frame: 函数体body需要的对象列表\n * Post: 函数的后置条件布尔表达式\n * TerminationMetric: 变体函数\n * Body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 Dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如Factorial这个函数所有数字都≥1）\n\nfunction Factorial(n: int): int\nrequires 0 <= n //前置条件pre\nensures 1 <= Factorial(n) //后置条件post\n{\n if n == 0 then 1 else Factorial(n-1) * n //函数体body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字static来删除此参数。\n\n类 C 中的静态函数 F 可以被 C.F(...) 调用。\n\n\n# 类 class\n\n一个类定义如下：\n\nclass C {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。\n\n\n# 数据类型 datatypes\n\n归纳数据类型（inductive datatype）是一种类型，其值是用一组固定的构造函数创建的。\n\n数据类型 为Tree带有构造函数 Leaf 和 Node 的函数声明如下：\n\ndatatype Tree = Leaf | Node(Tree, int, Tree)//Leaf为无参构造函数 Node为有参\n\n构造函数由竖线分隔。 无参数构造函数不需要使用括号，如 Leaf 所示。\n\n对于每个构造函数 Ct，数据类型隐式声明了一个布尔成员 Ct?，对于已经使用 Ct 构造函数赋的值的成员，它返回 true。 例如，在代码片段之后：\n\nvar t0 := Leaf; var t1 := Node(t0, 5, t0);\n\n表达式 t1.Node结果为 true, t0.Node结果为false。\n\n如果两个数据类型值是使用相同的构造函数和该构造函数的相同参数创建的，则它们是相等的。因此，对于像 Leaf、t.Leaf 这样的无参数构造函数，Dafny会给出与 t == Leaf 相同的结果。(没看懂，不管了)\n\n构造函数可以选择为其任何参数声明析构函数，这是通过为参数引入名称来完成的。 例如，如果 Tree 被声明为：\n\ndatatype Tree = Leaf | Node(left: Tree, data: int, right: Tree)\n\n那么t1.data == 5和t1.left == t0在上面的代码片段之后保持不变。(还是没懂)\n\n\n# 泛型 Generics\n\nDafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型T\n\nclass MyMultiset<T> {\n /*...*/\n}\t\t//类泛型\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //自定义数据泛型\nmethod Find<T>(key: T, collection: Tree<T>) { //方法泛型`\n /*...*/\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T {\t//函数泛型\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明 Statement\n\n以下是 Dafny 中最常见语句:\n\nvar LocalVariables := ExprList;\nLvalues := ExprList;\nassert BoolExpr;\nprint ExprList;\n\nif BoolExpr0 {\n  Stmts0\n} else if BoolExpr1 {\n  Stmts1\n} else {\n  Stmts2\n}\n\n  while BoolExpr\n  invariant Inv\n  modifies Frame\n  decreases Rank\n{\n  Stmts\n}\n match Expr {\n  case Empty => Stmts0\n  case Node(l, d, r) => Stmts1\n}\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个局部变量而已） var LocalVariables := ExprList; var 语句引入了局部变量。 Lvalues := ExprList;\n\n赋值语句将 ExprList变量赋给Lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 L 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\n第一种形式分配一个类型为 T 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了T是一维和二维数组对象的匿名构造方法\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies语句限制了循环的框架\n * reduction语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。(真没看懂）\n\nwhile BoolExpr //布尔表达式-循环条件`\n  invariant Inv\n  modifies Frame\n  decreases Rank\n\n{\n  Statements\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# match语句(阿巴阿巴)\n\nmatch 语句计算源 Expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。\n\n\n# 表达式 Expressions\n\nDafny 中的表达式与类 Java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），Dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==>低的绑定力，而后者又比 && 和 ||具有更低的绑定力。\n\nDafny 比较表达式可以是链式的，这意味着相同方向的比较可以串在一起。例如，0 <= i < j <= a.Length == N\n\n含义相同： 0 <= i && i < j && j <= a.Length && a.Length == N\n\n请注意，布尔相等可以使用 == 和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和 %（整数模）遵循欧几里德定义，这意味着 % 总是导致非负数。 （因此，当 / 或 % 的第一个参数为负数时，结果与您在 C、Java 或 C# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/Modulo_operation。）\n\n# 离 散 数 学\n\nDafny 表达式包括全称量词和存在量词，其形式为：forall x :: Expr 和exists x :: Expr，其中x是绑定变量（可以使用显式类型声明，如x: T 中所示），而Expr 是一个布尔表达式。\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 S 中的表达式 x 表示 x 是集合 S 的成员，而 x !in S 是一个方便的写法 !(x in S)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in S 和 x !in S。序列 S 的长度表示为 |S|，并且此类序列的元素具有从 0 到小于 |S| 的索引。表达式 S[j] 表示序列 S 的索引 j 处的元素。表达式 S[m..n]，其中 0 <= m <= n <= |S|，返回一个序列，其元素是S 从索引 m 开始（即，从 S[m]、S[m+1]、……直到但不包括 S[n]）。表达式 S[m..]; （通常称为“drop m”)与 S[m..|S|] 相同；也就是说，它返回除 S 的前 m 个元素之外的所有元素的序列。表达式 S[..n] ; （通常称为“take n”）与 S[0..n] 相同，即它返回由 S 的前 n 个元素组成的序列。\n\n如果 j 是序列 S 的有效索引，则表达式 S[j := x];是类似于 S 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得 [x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if BoolExpr then Expr0 else Expr1\n\n其中 Expr0 和 Expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",normalizedContent:"# 基础学习\n\n页面说明\n\n此页面说明了 dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\ndafny程序长这样：xxxxx.dfy，dafny文件是以dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main`不是必须的。\n\n> 注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)t：\n\nvar x: t\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\ndafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<t>：不可变的无序集合\n * seq<t>：不可变的有序集合\n * array<t>、array2<t>、array3<t>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。\n\n\n# 方法 methods\n\n方法的声明如下：\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //输入输出参数\nrequires pre\t//前置条件\nmodifies frame  //框架\nensures post\t//后置条件\ndecreases terminationmetric //变体函数\n{\nbody //函数体`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * pre: 表示方法 前提条件 的 布尔表达式\n * frame: 表示类对象的集合，可以被方法更新(frame denotes a set of objects whose fields may be updated by the method)\n * post: 是方法 后置条件 的 布尔表达式\n * terminationmetric: 是方法的变体函数(terminationmetric is the method’s variant function)\n * body: 是实现方法的语句。\n\n\n# 框架frame\n\n框架frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类c的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的“top”元素。\n\n如果省略没写的话，dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\ndafny ide 将在工具提示中显示猜测。\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 c 中的静态方法 m 可以由 c.m(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器` \nmodifies this //框架内对象的构造体 this就是this.frame？`\n\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# lemma 关键字\n\n有时，方法(method)关键字会被引理(lemmas)取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件`\n{\nx, y, z := a, b, c;\nif z < y {\ny, z := z, y;\n}\nif y < x {\n    x, y := y, x;\n  }\nif z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 函数 function\n\n函数具有以下形式：\n\nfunction f(a: a, b: b, c: c): t\nrequires pre  //前置条件pre\nreads frame\t//框架frame\nensures post //后置条件post\ndecreases terminationmetric //变体函数\n{\n  body\t//函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : 输入的形参，\n * t : 返回结果的类型，\n * pre: 表示函数前提条件的布尔表达式，\n * frame: 函数体body需要的对象列表\n * post: 函数的后置条件布尔表达式\n * terminationmetric: 变体函数\n * body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如factorial这个函数所有数字都≥1）\n\nfunction factorial(n: int): int\nrequires 0 <= n //前置条件pre\nensures 1 <= factorial(n) //后置条件post\n{\n if n == 0 then 1 else factorial(n-1) * n //函数体body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字static来删除此参数。\n\n类 c 中的静态函数 f 可以被 c.f(...) 调用。\n\n\n# 类 class\n\n一个类定义如下：\n\nclass c {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。\n\n\n# 数据类型 datatypes\n\n归纳数据类型（inductive datatype）是一种类型，其值是用一组固定的构造函数创建的。\n\n数据类型 为tree带有构造函数 leaf 和 node 的函数声明如下：\n\ndatatype tree = leaf | node(tree, int, tree)//leaf为无参构造函数 node为有参\n\n构造函数由竖线分隔。 无参数构造函数不需要使用括号，如 leaf 所示。\n\n对于每个构造函数 ct，数据类型隐式声明了一个布尔成员 ct?，对于已经使用 ct 构造函数赋的值的成员，它返回 true。 例如，在代码片段之后：\n\nvar t0 := leaf; var t1 := node(t0, 5, t0);\n\n表达式 t1.node结果为 true, t0.node结果为false。\n\n如果两个数据类型值是使用相同的构造函数和该构造函数的相同参数创建的，则它们是相等的。因此，对于像 leaf、t.leaf 这样的无参数构造函数，dafny会给出与 t == leaf 相同的结果。(没看懂，不管了)\n\n构造函数可以选择为其任何参数声明析构函数，这是通过为参数引入名称来完成的。 例如，如果 tree 被声明为：\n\ndatatype tree = leaf | node(left: tree, data: int, right: tree)\n\n那么t1.data == 5和t1.left == t0在上面的代码片段之后保持不变。(还是没懂)\n\n\n# 泛型 generics\n\ndafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型t\n\nclass mymultiset<t> {\n /*...*/\n}\t\t//类泛型\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //自定义数据泛型\nmethod find<t>(key: t, collection: tree<t>) { //方法泛型`\n /*...*/\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t {\t//函数泛型\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明 statement\n\n以下是 dafny 中最常见语句:\n\nvar localvariables := exprlist;\nlvalues := exprlist;\nassert boolexpr;\nprint exprlist;\n\nif boolexpr0 {\n  stmts0\n} else if boolexpr1 {\n  stmts1\n} else {\n  stmts2\n}\n\n  while boolexpr\n  invariant inv\n  modifies frame\n  decreases rank\n{\n  stmts\n}\n match expr {\n  case empty => stmts0\n  case node(l, d, r) => stmts1\n}\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个局部变量而已） var localvariables := exprlist; var 语句引入了局部变量。 lvalues := exprlist;\n\n赋值语句将 exprlist变量赋给lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 l 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\n第一种形式分配一个类型为 t 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了t是一维和二维数组对象的匿名构造方法\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies语句限制了循环的框架\n * reduction语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。(真没看懂）\n\nwhile boolexpr //布尔表达式-循环条件`\n  invariant inv\n  modifies frame\n  decreases rank\n\n{\n  statements\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# match语句(阿巴阿巴)\n\nmatch 语句计算源 expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。\n\n\n# 表达式 expressions\n\ndafny 中的表达式与类 java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==>低的绑定力，而后者又比 && 和 ||具有更低的绑定力。\n\ndafny 比较表达式可以是链式的，这意味着相同方向的比较可以串在一起。例如，0 <= i < j <= a.length == n\n\n含义相同： 0 <= i && i < j && j <= a.length && a.length == n\n\n请注意，布尔相等可以使用 == 和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和 %（整数模）遵循欧几里德定义，这意味着 % 总是导致非负数。 （因此，当 / 或 % 的第一个参数为负数时，结果与您在 c、java 或 c# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/modulo_operation。）\n\n# 离 散 数 学\n\ndafny 表达式包括全称量词和存在量词，其形式为：forall x :: expr 和exists x :: expr，其中x是绑定变量（可以使用显式类型声明，如x: t 中所示），而expr 是一个布尔表达式。\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 s 中的表达式 x 表示 x 是集合 s 的成员，而 x !in s 是一个方便的写法 !(x in s)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in s 和 x !in s。序列 s 的长度表示为 |s|，并且此类序列的元素具有从 0 到小于 |s| 的索引。表达式 s[j] 表示序列 s 的索引 j 处的元素。表达式 s[m..n]，其中 0 <= m <= n <= |s|，返回一个序列，其元素是s 从索引 m 开始（即，从 s[m]、s[m+1]、……直到但不包括 s[n]）。表达式 s[m..]; （通常称为“drop m”)与 s[m..|s|] 相同；也就是说，它返回除 s 的前 m 个元素之外的所有元素的序列。表达式 s[..n] ; （通常称为“take n”）与 s[0..n] 相同，即它返回由 s 的前 n 个元素组成的序列。\n\n如果 j 是序列 s 的有效索引，则表达式 s[j := x];是类似于 s 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得 [x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if boolexpr then expr0 else expr1\n\n其中 expr0 和 expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"简单上手",frontmatter:{title:"简单上手",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/39fb20/",categories:["配置"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/10.%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B.html",relativePath:"10.配置/10.用起来吧/10.简单上手.md",key:"v-4ac269ee",path:"/pages/39fb20/",headers:[{level:2,title:"实时验证",slug:"实时验证",normalizedTitle:"实时验证",charIndex:42},{level:2,title:"hello,Dafny",slug:"hello-dafny",normalizedTitle:"hello,dafny",charIndex:51}],headersStr:"实时验证 hello,Dafny",content:"# Demo\n\n配置完成，让我们来创建个简单的dafny文件来体验一下吧！\n\n\n# 实时验证\n\n\n# hello,Dafny",normalizedContent:"# demo\n\n配置完成，让我们来创建个简单的dafny文件来体验一下吧！\n\n\n# 实时验证\n\n\n# hello,dafny",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"留言板",frontmatter:{title:"留言板",date:"2022-03-24T12:22:23.000Z",permalink:"/pages/caf1f9/",categories:["社区留言板"],tags:null,article:!1,sidebar:!1,editLink:!1,readingShow:"top"},regularPath:"/100.%E7%A4%BE%E5%8C%BA%E7%95%99%E8%A8%80%E6%9D%BF/%E7%95%99%E8%A8%80%E6%9D%BF.html",relativePath:"100.社区留言板/留言板.md",key:"v-135bff0e",path:"/pages/caf1f9/",headersStr:null,content:"# Welcome Developers\n\n笔记\n\nDafny中文社区欢迎各位使用者积极反馈,我们将在此实时更新本站点主题和相关组件的版本信息及资源链接。\n\n",normalizedContent:"# welcome developers\n\n笔记\n\ndafny中文社区欢迎各位使用者积极反馈,我们将在此实时更新本站点主题和相关组件的版本信息及资源链接。\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/25, 21:08:04",lastUpdatedTimestamp:1648213684e3},{title:"基础 Basic",frontmatter:{title:"基础 Basic",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/6e15a6/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/00.%E5%9F%BA%E7%A1%80%20Basic.html",relativePath:"20.指南/00.Dafny快速入门/00.基础 Basic.md",key:"v-240065b4",path:"/pages/6e15a6/",headers:[{level:2,title:"Dafny是什么样？",slug:"dafny是什么样",normalizedTitle:"dafny是什么样？",charIndex:128},{level:2,title:"基本定义",slug:"基本定义",normalizedTitle:"基本定义",charIndex:459}],headersStr:"Dafny是什么样？ 基本定义",content:"# 基础学习\n\n提示\n\n此页面说明了 Dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 Dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\n\n# Dafny是什么样？\n\nDafny程序长这样：xxxxx.dfy，Dafny文件是以.dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main不是必须的。\n\n注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)T：\n\nvar x: T\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\nDafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<T>：不可变的无序集合\n * seq<T>：不可变的有序集合\n * array<T>、array2<T>、array3<T>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。",normalizedContent:"# 基础学习\n\n提示\n\n此页面说明了 dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\n\n# dafny是什么样？\n\ndafny程序长这样：xxxxx.dfy，dafny文件是以.dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main不是必须的。\n\n注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)t：\n\nvar x: t\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\ndafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<t>：不可变的无序集合\n * seq<t>：不可变的有序集合\n * array<t>、array2<t>、array3<t>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"方法 Method",frontmatter:{title:"方法 Method",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/eba166/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05.%E6%96%B9%E6%B3%95%20Method.html",relativePath:"20.指南/00.Dafny快速入门/05.方法 Method.md",key:"v-4fafc755",path:"/pages/eba166/",headers:[{level:2,title:"框架Frame",slug:"框架frame",normalizedTitle:"框架frame",charIndex:563},{level:2,title:"变体函数 variant function",slug:"变体函数-variant-function",normalizedTitle:"变体函数 variant function",charIndex:802}],headersStr:"框架Frame 变体函数 variant function",content:"# 方法 methods\n\n方法的声明如下：\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //输入输出参数\n\trequires Pre\t//前置条件  \n\tmodifies Frame  //框架\n\tensures Post\t//后置条件\n  decreases TerminationMetric //变体函数\n{\n \tmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //输入输出参数\n \t requires Pre\t//前置条件\t\n \t modifies Frame  //框架\t\n \t ensures Post\t//后置条件\n \t decreases TerminationMetric //变体函数\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * Pre: 表示方法 前提条件 的 布尔表达式\n * Frame: 表示类对象的集合，可以被方法更新\n * Post: 是方法 后置条件 的 布尔表达式\n * TerminationMetric: 是方法的变体函数\n\n\n# 框架Frame\n\n框架Frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架Frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类C的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的top元素。\n\n如果省略没写的话，Dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\nDafny IDE 将在工具提示中显示猜测。",normalizedContent:"# 方法 methods\n\n方法的声明如下：\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //输入输出参数\n\trequires pre\t//前置条件  \n\tmodifies frame  //框架\n\tensures post\t//后置条件\n  decreases terminationmetric //变体函数\n{\n \tmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //输入输出参数\n \t requires pre\t//前置条件\t\n \t modifies frame  //框架\t\n \t ensures post\t//后置条件\n \t decreases terminationmetric //变体函数\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * pre: 表示方法 前提条件 的 布尔表达式\n * frame: 表示类对象的集合，可以被方法更新\n * post: 是方法 后置条件 的 布尔表达式\n * terminationmetric: 是方法的变体函数\n\n\n# 框架frame\n\n框架frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类c的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的top元素。\n\n如果省略没写的话，dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\ndafny ide 将在工具提示中显示猜测。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"关键字 Keyword",frontmatter:{title:"关键字 Keyword",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/83cdf9/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/10.%E5%85%B3%E9%94%AE%E5%AD%97%20Keyword.html",relativePath:"20.指南/00.Dafny快速入门/10.关键字 Keyword.md",key:"v-350b180b",path:"/pages/83cdf9/",headers:[{level:2,title:"ghost 关键字",slug:"ghost-关键字",normalizedTitle:"ghost 关键字",charIndex:12},{level:2,title:"this 关键字",slug:"this-关键字",normalizedTitle:"this 关键字",charIndex:75},{level:2,title:"构造函数/构造体 constructor",slug:"构造函数-构造体-constructor",normalizedTitle:"构造函数/构造体 constructor",charIndex:179},{level:2,title:"lemma 关键字",slug:"lemma-关键字",normalizedTitle:"lemma 关键字",charIndex:496}],headersStr:"ghost 关键字 this 关键字 构造函数/构造体 constructor lemma 关键字",content:"# 特殊关键字\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 C 中的静态方法 M 可以由 C.M(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器\nmodifies this //框架内对象的构造体 this就是this.frame？\n{\n  Body\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# lemma 关键字\n\n有时，方法method关键字会被引理lemmas取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件\n\n{\n  x, y, z := a, b, c;\n  if z < y {\n    y, z := z, y;\n  }\n  if y < x {\n    x, y := y, x;\n  }\n  if z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# 特殊关键字\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 c 中的静态方法 m 可以由 c.m(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器\nmodifies this //框架内对象的构造体 this就是this.frame？\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# lemma 关键字\n\n有时，方法method关键字会被引理lemmas取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件\n\n{\n  x, y, z := a, b, c;\n  if z < y {\n    y, z := z, y;\n  }\n  if y < x {\n    x, y := y, x;\n  }\n  if z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"函数 Function",frontmatter:{title:"函数 Function",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/01d76e/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/15.%E5%87%BD%E6%95%B0%20Function.html",relativePath:"20.指南/00.Dafny快速入门/15.函数 Function.md",key:"v-e0d76c86",path:"/pages/01d76e/",headersStr:null,content:"# 函数 function\n\n函数具有以下形式：\n\nfunction F(a: A, b: B, c: C): T\n  requires Pre  //前置条件pre\n  reads Frame\t//框架frame\n  ensures Post //后置条件post\n  decreases TerminationMetric //变体函数\n{\n  Body\t//函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : 输入的形参，\n * T : 返回结果的类型，\n * Pre: 表示函数前提条件的布尔表达式，\n * Frame: 函数体body需要的对象列表\n * Post: 函数的后置条件布尔表达式\n * TerminationMetric: 变体函数\n * Body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 Dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如Factorial这个函数所有数字都≥1）\n\nfunction Factorial(n: int): int\n requires 0 <= n //前置条件pre\n\n ensures 1 <= Factorial(n) //后置条件post\n\n{\n if n == 0 then 1 else Factorial(n-1) * n //函数体body\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字 static 来删除此参数。\n\n类 C 中的静态函数 F 可以被 C.F(...) 调用。",normalizedContent:"# 函数 function\n\n函数具有以下形式：\n\nfunction f(a: a, b: b, c: c): t\n  requires pre  //前置条件pre\n  reads frame\t//框架frame\n  ensures post //后置条件post\n  decreases terminationmetric //变体函数\n{\n  body\t//函数体\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : 输入的形参，\n * t : 返回结果的类型，\n * pre: 表示函数前提条件的布尔表达式，\n * frame: 函数体body需要的对象列表\n * post: 函数的后置条件布尔表达式\n * terminationmetric: 变体函数\n * body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如factorial这个函数所有数字都≥1）\n\nfunction factorial(n: int): int\n requires 0 <= n //前置条件pre\n\n ensures 1 <= factorial(n) //后置条件post\n\n{\n if n == 0 then 1 else factorial(n-1) * n //函数体body\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字 static 来删除此参数。\n\n类 c 中的静态函数 f 可以被 c.f(...) 调用。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"类 Class",frontmatter:{title:"类 Class",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/0fadc1/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/20.%E7%B1%BB%20Class.html",relativePath:"20.指南/00.Dafny快速入门/20.类 Class.md",key:"v-a626afce",path:"/pages/0fadc1/",headersStr:null,content:"# 类 class\n\n一个类定义如下：\n\nclass C {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。",normalizedContent:"# 类 class\n\n一个类定义如下：\n\nclass c {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"泛型 Generics",frontmatter:{title:"泛型 Generics",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/a010ab/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/30.%E6%B3%9B%E5%9E%8B%20Generics.html",relativePath:"20.指南/00.Dafny快速入门/30.泛型 Generics.md",key:"v-57bdc255",path:"/pages/a010ab/",headersStr:null,content:"# 泛型 Generics\n\nDafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型T\n\nclass MyMultiset<T> {\n /*...*/\n}\t\t//类泛型\n\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //自定义数据泛型\nmethod Find<T>(key: T, collection: Tree<T>) { //方法泛型\n /*...*/\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T {\t//函数泛型\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# 泛型 generics\n\ndafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型t\n\nclass mymultiset<t> {\n /*...*/\n}\t\t//类泛型\n\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //自定义数据泛型\nmethod find<t>(key: t, collection: tree<t>) { //方法泛型\n /*...*/\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t {\t//函数泛型\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"声明 Statement",frontmatter:{title:"声明 Statement",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/c4fda3/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/35.%E5%A3%B0%E6%98%8E%20Statement.html",relativePath:"20.指南/00.Dafny快速入门/35.声明 Statement.md",key:"v-96b41596",path:"/pages/c4fda3/",headers:[{level:2,title:"函数/方法的返回值赋值给变量",slug:"函数-方法的返回值赋值给变量",normalizedTitle:"函数/方法的返回值赋值给变量",charIndex:467},{level:2,title:"assert 声明",slug:"assert-声明",normalizedTitle:"assert 声明",charIndex:905},{level:2,title:"print 打印语句",slug:"print-打印语句",normalizedTitle:"print 打印语句",charIndex:953},{level:2,title:"if 选择语句",slug:"if-选择语句",normalizedTitle:"if 选择语句",charIndex:1037},{level:2,title:"while 循环语句",slug:"while-循环语句",normalizedTitle:"while 循环语句",charIndex:1108},{level:2,title:"match语句",slug:"match语句",normalizedTitle:"match语句",charIndex:1369},{level:2,title:"break语句",slug:"break语句",normalizedTitle:"break语句",charIndex:1503}],headersStr:"函数/方法的返回值赋值给变量 assert 声明 print 打印语句 if 选择语句 while 循环语句 match语句 break语句",content:"# 声明 Statement\n\n以下是 Dafny 中最常见语句:\n\nvar LocalVariables := ExprList;\n Lvalues := ExprList;\n assert BoolExpr;\n print ExprList;\n if BoolExpr0 {\n  Stmts0\n } else if BoolExpr1 {\n  Stmts1\n } else {\n  Stmts2\n }\n\n while BoolExpr\n\n  invariant Inv\n\n  modifies Frame\n\n  decreases Rank\n\n {\n  Stmts\n }\n\nmatch Expr {\n  case Empty => Stmts0\n  case Node(l, d, r) => Stmts1\n}\n\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个 局部变量 而已）\n\nvar LocalVariables := ExprList;\n\nvar 语句引入了局部变量。\n\nLvalues := ExprList; 赋值语句将 ExprList变量赋给Lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 L 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\n第一种形式分配一个类型为 T 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了T是一维和二维数组对象的匿名构造方法\n\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies 语句限制了循环的框架\n * reduction 语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。\n\nwhile BoolExpr //布尔表达式-循环条件 invariant Inv modifies Frame decreases Rank { Statements }\n\n\n# match语句\n\nmatch 语句计算源Expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。",normalizedContent:"# 声明 statement\n\n以下是 dafny 中最常见语句:\n\nvar localvariables := exprlist;\n lvalues := exprlist;\n assert boolexpr;\n print exprlist;\n if boolexpr0 {\n  stmts0\n } else if boolexpr1 {\n  stmts1\n } else {\n  stmts2\n }\n\n while boolexpr\n\n  invariant inv\n\n  modifies frame\n\n  decreases rank\n\n {\n  stmts\n }\n\nmatch expr {\n  case empty => stmts0\n  case node(l, d, r) => stmts1\n}\n\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个 局部变量 而已）\n\nvar localvariables := exprlist;\n\nvar 语句引入了局部变量。\n\nlvalues := exprlist; 赋值语句将 exprlist变量赋给lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 l 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\n第一种形式分配一个类型为 t 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了t是一维和二维数组对象的匿名构造方法\n\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies 语句限制了循环的框架\n * reduction 语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。\n\nwhile boolexpr //布尔表达式-循环条件 invariant inv modifies frame decreases rank { statements }\n\n\n# match语句\n\nmatch 语句计算源expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"表达式 Expression",frontmatter:{title:"表达式 Expression",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/e8438e/",categories:["指南"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/40.%E8%A1%A8%E8%BE%BE%E5%BC%8F%20Expression.html",relativePath:"20.指南/00.Dafny快速入门/40.表达式 Expression.md",key:"v-6de99164",path:"/pages/e8438e/",headers:[{level:2,title:"基本运算符",slug:"基本运算符",normalizedTitle:"基本运算符",charIndex:68},{level:2,title:"整数运算",slug:"整数运算",normalizedTitle:"整数运算",charIndex:527},{level:2,title:"离散数学",slug:"离散数学",normalizedTitle:"离散数学",charIndex:695},{level:2,title:"集合运算",slug:"集合运算",normalizedTitle:"集合运算",charIndex:814},{level:2,title:"序列运算",slug:"序列运算",normalizedTitle:"序列运算",charIndex:1036},{level:2,title:"if-then-else判断语句",slug:"if-then-else判断语句",normalizedTitle:"if-then-else判断语句",charIndex:1582},{level:2,title:"match匹配表达式",slug:"match匹配表达式",normalizedTitle:"match匹配表达式",charIndex:1746}],headersStr:"基本运算符 整数运算 离散数学 集合运算 序列运算 if-then-else判断语句 match匹配表达式",content:"# 表达式 Expressions\n\nDafny 中的表达式与类 Java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），Dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==> 低的绑定力，而后者又比 && 和 || 具有更低的绑定力。\n\nDafny 比较表达式可以是链式的，这意味着“相同方向”的比较可以串在一起。例如，0 <= i < j <= a.Length == N\n\n含义相同： 0 <= i && i < j && j <= a.Length && a.Length == N\n\n请注意，布尔相等可以使用 ==和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和%（整数模）遵循欧几里德定义，这意味着% 总是导致非负数。\n\n> 因此，当 / 或 % 的第一个参数为负数时，结果与您在 C、Java 或 C# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/Modulo_operation。）\n\n\n# 离散数学\n\nDafny 表达式包括全称量词和存在量词，其形式为：forall x :: Expr 和exists x :: Expr，其中x 是绑定变量（可以使用显式类型声明，如x: T 中所示），而Expr 是一个布尔表达式。\n\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 S 中的表达式 x 表示 x 是集合 S 的成员，而 x !in S 是一个方便的写法 !(x in S)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in S 和 x !in S。序列 S 的长度表示为 |S|，并且此类序列的元素具有从 0 到小于 |S| 的索引。表达式 S[j] 表示序列 S 的索引 j 处的元素。表达式 S[m..n]，其中 0 <= m <= n <= |S|，返回一个序列，其元素是S 从索引 m 开始（即，从 S[m]、S[m+1]、……直到但不包括 S[n]）。表达式 S[m..]; （通常称为“drop m”）与 S[m..|S|] 相同；也就是说，它返回除 S 的前 m 个元素之外的所有元素的序列。表达式 S[..n] ; （通常称为“take n”）与 S[0..n] 相同，即它返回由 S 的前 n 个元素组成的序列。\n\n如果 j 是序列 S 的有效索引，则表达式 S[j := x];是类似于 S 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得[x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if BoolExpr then Expr0 else Expr1\n\n其中 Expr0 和 Expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",normalizedContent:"# 表达式 expressions\n\ndafny 中的表达式与类 java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==> 低的绑定力，而后者又比 && 和 || 具有更低的绑定力。\n\ndafny 比较表达式可以是链式的，这意味着“相同方向”的比较可以串在一起。例如，0 <= i < j <= a.length == n\n\n含义相同： 0 <= i && i < j && j <= a.length && a.length == n\n\n请注意，布尔相等可以使用 ==和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和%（整数模）遵循欧几里德定义，这意味着% 总是导致非负数。\n\n> 因此，当 / 或 % 的第一个参数为负数时，结果与您在 c、java 或 c# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/modulo_operation。）\n\n\n# 离散数学\n\ndafny 表达式包括全称量词和存在量词，其形式为：forall x :: expr 和exists x :: expr，其中x 是绑定变量（可以使用显式类型声明，如x: t 中所示），而expr 是一个布尔表达式。\n\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 s 中的表达式 x 表示 x 是集合 s 的成员，而 x !in s 是一个方便的写法 !(x in s)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in s 和 x !in s。序列 s 的长度表示为 |s|，并且此类序列的元素具有从 0 到小于 |s| 的索引。表达式 s[j] 表示序列 s 的索引 j 处的元素。表达式 s[m..n]，其中 0 <= m <= n <= |s|，返回一个序列，其元素是s 从索引 m 开始（即，从 s[m]、s[m+1]、……直到但不包括 s[n]）。表达式 s[m..]; （通常称为“drop m”）与 s[m..|s|] 相同；也就是说，它返回除 s 的前 m 个元素之外的所有元素的序列。表达式 s[..n] ; （通常称为“take n”）与 s[0..n] 相同，即它返回由 s 的前 n 个元素组成的序列。\n\n如果 j 是序列 s 的有效索引，则表达式 s[j := x];是类似于 s 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得[x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if boolexpr then expr0 else expr1\n\n其中 expr0 和 expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"寻找最大和最小数",frontmatter:{title:"寻找最大和最小数",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/0978ce/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/00.%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E5%92%8C%E6%9C%80%E5%B0%8F%E6%95%B0.html",relativePath:"20.指南/10.简单例子/00.寻找最大和最小数.md",key:"v-fb6a0bc6",path:"/pages/0978ce/",headersStr:null,content:"# 寻找最大和最小数\n\n输入两个整数，返回两个值，它们经过+/-运算后较大的数和较小的数。\n\n我们在函数体中定义较大值为两者加和，较小值为两者相减。\n\n在返回值returns里我们可以定义变量more，less，以便在函数体中使用它们。\n\nmethod Maxmin(x:int, y:int) returns (more:int, less:int)    \nensures y > 0 ==> less < x < more\nensures y < 0 ==> more < x < less  \n{\n    more := x + y;\n    less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中，ensures代表后置条件，这里需要确保第二个数大于0时，较大数大于第一个数；第二个数小于0时，较小数大于第一个数。由于我们在函数体中定义较大值为两者加和，较小值为两者相减，显然在y < 0时是不成立的，利用这两个限定条件可以帮助Dafny判断该程序的正确性。",normalizedContent:"# 寻找最大和最小数\n\n输入两个整数，返回两个值，它们经过+/-运算后较大的数和较小的数。\n\n我们在函数体中定义较大值为两者加和，较小值为两者相减。\n\n在返回值returns里我们可以定义变量more，less，以便在函数体中使用它们。\n\nmethod maxmin(x:int, y:int) returns (more:int, less:int)    \nensures y > 0 ==> less < x < more\nensures y < 0 ==> more < x < less  \n{\n    more := x + y;\n    less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n其中，ensures代表后置条件，这里需要确保第二个数大于0时，较大数大于第一个数；第二个数小于0时，较小数大于第一个数。由于我们在函数体中定义较大值为两者加和，较小值为两者相减，显然在y < 0时是不成立的，利用这两个限定条件可以帮助dafny判断该程序的正确性。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"斐波那契数列",frontmatter:{title:"斐波那契数列",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/e3e481/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/05.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",relativePath:"20.指南/10.简单例子/05.斐波那契数列.md",key:"v-022af798",path:"/pages/e3e481/",headersStr:null,content:"# 斐波那契数列\n\n输入一个整数n，返回斐波那契数列第n项的值。\n\n斐波那契数列的第一、二项是1，1，后面的项是其前两项的加和，容易写出一个递归的式子。\n\nfunction Fibonacci(n:int):int   \nrequires n > 0\ndecreases n\n{\n    if n == 1 || n == 2 then 1 else Fibonacci(n - 2) + Fibonacci(n - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，斐波那契数列的项显然是从1开始的整数，为了规范程序的正确性，需要加入前置条件requires，限定的布尔表达式为n > 0。\n\n由于返回值是一个整数，我们可以用一条简洁的式子表示斐波那契数列的返回值。注意，由于存在递归项Fibonacci(n - 2)，Fibonacci(n - 1)，我们需要再加上decreases n表示n是逐次减小的(但是不会减为0)，Dafny在执行递归时每次都会检测该条件以保证程序的正确性。",normalizedContent:"# 斐波那契数列\n\n输入一个整数n，返回斐波那契数列第n项的值。\n\n斐波那契数列的第一、二项是1，1，后面的项是其前两项的加和，容易写出一个递归的式子。\n\nfunction fibonacci(n:int):int   \nrequires n > 0\ndecreases n\n{\n    if n == 1 || n == 2 then 1 else fibonacci(n - 2) + fibonacci(n - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，斐波那契数列的项显然是从1开始的整数，为了规范程序的正确性，需要加入前置条件requires，限定的布尔表达式为n > 0。\n\n由于返回值是一个整数，我们可以用一条简洁的式子表示斐波那契数列的返回值。注意，由于存在递归项fibonacci(n - 2)，fibonacci(n - 1)，我们需要再加上decreases n表示n是逐次减小的(但是不会减为0)，dafny在执行递归时每次都会检测该条件以保证程序的正确性。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"线性查询",frontmatter:{title:"线性查询",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/02fdef/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/10.%E7%BA%BF%E6%80%A7%E6%9F%A5%E8%AF%A2.html",relativePath:"20.指南/10.简单例子/10.线性查询.md",key:"v-9ec8b0e0",path:"/pages/02fdef/",headersStr:null,content:"# 线性查询\n\n输入一个整型数组和一个整数key，返回该数组中等于key的元素所在的位置，显然数组的下标从0开始。\n\n算法上，直接遍历该数组，判断当前元素是否等于key即可，若等于则程序返回，所得的n就是要求的位置，若不等于则往后寻找。\n\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)   \nensures 0 <= n <= a.Length\nensures n == a.Length || a[n] == key\n{\n    n := 0;\n    while n < a.Length\n    invariant n <= a.Length\n    decreases a.Length - n      //需保证该表达式递减且不小于0\n    {\n        if a[n] == key \n        {\n            return;\n        }\n        n := n + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n容易想到，n的数值是大于等于0的整数，且不能超过数组的长度，否则产生越界问题，所以要有ensures 0 <= n <= a.Length。\n\n其次，程序返回的条件要么是找到了对应的位置，查找成功；要么是n的值达到了数组的长度还没有找到相应元素，查找失败。因此要有ensures n == a.Length || a[n] == key\n\n函数主体部分，我们在遍历时使用的是while语句，这里涉及到循环不变体invariant的使用，Dafny在执行循环时每次都会判断循环不变体是否满足条件，以判断循环内是否有错误，因此我们加上invariant n <= a.Length是更严谨的做法。同时，由于每次循环后n增大，需要加上decreases a.Length - n保证数组长度 - n是减小的，同时不会比0小。",normalizedContent:"# 线性查询\n\n输入一个整型数组和一个整数key，返回该数组中等于key的元素所在的位置，显然数组的下标从0开始。\n\n算法上，直接遍历该数组，判断当前元素是否等于key即可，若等于则程序返回，所得的n就是要求的位置，若不等于则往后寻找。\n\nmethod linearsearch(a: array<int>, key: int) returns (n: nat)   \nensures 0 <= n <= a.length\nensures n == a.length || a[n] == key\n{\n    n := 0;\n    while n < a.length\n    invariant n <= a.length\n    decreases a.length - n      //需保证该表达式递减且不小于0\n    {\n        if a[n] == key \n        {\n            return;\n        }\n        n := n + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n容易想到，n的数值是大于等于0的整数，且不能超过数组的长度，否则产生越界问题，所以要有ensures 0 <= n <= a.length。\n\n其次，程序返回的条件要么是找到了对应的位置，查找成功；要么是n的值达到了数组的长度还没有找到相应元素，查找失败。因此要有ensures n == a.length || a[n] == key\n\n函数主体部分，我们在遍历时使用的是while语句，这里涉及到循环不变体invariant的使用，dafny在执行循环时每次都会判断循环不变体是否满足条件，以判断循环内是否有错误，因此我们加上invariant n <= a.length是更严谨的做法。同时，由于每次循环后n增大，需要加上decreases a.length - n保证数组长度 - n是减小的，同时不会比0小。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"引理-计算序列中非负元素的个数",frontmatter:{title:"引理-计算序列中非负元素的个数",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/9b332b/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/15.%20%E5%BC%95%E7%90%86-%E8%AE%A1%E7%AE%97%E5%BA%8F%E5%88%97%E4%B8%AD%E9%9D%9E%E8%B4%9F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.html",relativePath:"20.指南/10.简单例子/15. 引理-计算序列中非负元素的个数.md",key:"v-78a1ec51",path:"/pages/9b332b/",headersStr:null,content:"# 引理-计算序列中非负元素的个数\n\n方法count(a)的作用是：输入一个整型序列a，返回a中非负元素的个数。\n\n在Dafny中表示序列a长度的方法为|a|，再结合序列的切片和递归的思路，容易写出下面的count()方法：当a的长度为0时返回0，否则将a分割成第一个元素和剩下的元素，对单个元素可直接判断它的非负性，对多个元素则对它递归求解，最后返回它们的和。\n\nfunction count(a :seq<int>): nat   // 返回序列a中非负元素个数\n{\n    if |a| == 0 then 0 else\n    (if a[0] >= 0 then 1 else 0) + count(a[1..])\n}\n\nmethod m1(){\n    assert count([0, -1, 1] + [-1, 2]) == 3;    // error!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于上面的count()用类似assert count([1, -1, 0]) == 2这样的断言是可以验证通过的，但是如果用类似assert count([0, -1, 1] + [-1, 2]) == 3这样涉及序列拼接的断言是不能验证通过的，其原因在于序列拼接的+和count()中整型的+含义不同，count()并没有规定参数中序列的“相加”。\n\n为了让Dafny能够验证上述断言，我们需要引进引理lemma，一种用于证明某种性质以供后续验证的方法。\n\n在上述断言中，我们使用count()时默认了它对于+的分配性质，因此我们需要对于它的分配性先给出证明，以使Dafny能够正确识别有关断言，如下。\n\n// 引理\nlemma Distributive(a: seq<int>, b: seq<int>)    // 证明'+'对于count()是可分配的\n    ensures count(a + b) == count(a) + count(b)\n{\n    if a == []\n    {\n        assert a + b == b;\n    }   \n    else\n    {\n        Distributive(a[1..], b);\n        assert a + b == [a[0]] + (a[1..] + b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n分配律性质需要确保count(a + b) == count(a) + count(b)，这是我们想要的结果。首先，若序列a为空，则验证断言a + b == b，否则切去a的首位元素，递归调用Distributive()，即验证后面所有序列的分配性，验证断言assert a + b == [a[0]] + (a[1..] + b)即序列拼接的正确性。整个递归的流程相当于是为Dafny提供了验证思路。\n\n方法m1中，我们先调用Distributive()证明count()对于相关序列的分配律，再验证断言。\n\nmethod m1(){\n    Distributive([0, -1, 1], [-1, 2]);  // 先用引理证明分配律\n    assert count([0, -1, 1] + [-1, 2]) == 3;    \n}\n\n\n1\n2\n3\n4\n\n\n验证通过。",normalizedContent:"# 引理-计算序列中非负元素的个数\n\n方法count(a)的作用是：输入一个整型序列a，返回a中非负元素的个数。\n\n在dafny中表示序列a长度的方法为|a|，再结合序列的切片和递归的思路，容易写出下面的count()方法：当a的长度为0时返回0，否则将a分割成第一个元素和剩下的元素，对单个元素可直接判断它的非负性，对多个元素则对它递归求解，最后返回它们的和。\n\nfunction count(a :seq<int>): nat   // 返回序列a中非负元素个数\n{\n    if |a| == 0 then 0 else\n    (if a[0] >= 0 then 1 else 0) + count(a[1..])\n}\n\nmethod m1(){\n    assert count([0, -1, 1] + [-1, 2]) == 3;    // error!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于上面的count()用类似assert count([1, -1, 0]) == 2这样的断言是可以验证通过的，但是如果用类似assert count([0, -1, 1] + [-1, 2]) == 3这样涉及序列拼接的断言是不能验证通过的，其原因在于序列拼接的+和count()中整型的+含义不同，count()并没有规定参数中序列的“相加”。\n\n为了让dafny能够验证上述断言，我们需要引进引理lemma，一种用于证明某种性质以供后续验证的方法。\n\n在上述断言中，我们使用count()时默认了它对于+的分配性质，因此我们需要对于它的分配性先给出证明，以使dafny能够正确识别有关断言，如下。\n\n// 引理\nlemma distributive(a: seq<int>, b: seq<int>)    // 证明'+'对于count()是可分配的\n    ensures count(a + b) == count(a) + count(b)\n{\n    if a == []\n    {\n        assert a + b == b;\n    }   \n    else\n    {\n        distributive(a[1..], b);\n        assert a + b == [a[0]] + (a[1..] + b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n分配律性质需要确保count(a + b) == count(a) + count(b)，这是我们想要的结果。首先，若序列a为空，则验证断言a + b == b，否则切去a的首位元素，递归调用distributive()，即验证后面所有序列的分配性，验证断言assert a + b == [a[0]] + (a[1..] + b)即序列拼接的正确性。整个递归的流程相当于是为dafny提供了验证思路。\n\n方法m1中，我们先调用distributive()证明count()对于相关序列的分配律，再验证断言。\n\nmethod m1(){\n    distributive([0, -1, 1], [-1, 2]);  // 先用引理证明分配律\n    assert count([0, -1, 1] + [-1, 2]) == 3;    \n}\n\n\n1\n2\n3\n4\n\n\n验证通过。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"集合",frontmatter:{title:"集合",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/3d1110/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/20.%E9%9B%86%E5%90%88.html",relativePath:"20.指南/10.简单例子/20.集合.md",key:"v-0c0b0a3c",path:"/pages/3d1110/",headersStr:null,content:"# 集合\n\nDafny的集合为有限集set，无限集iset，下面是它们的一些例子。\n\nmethod m2(){\n   var s1 := {1, 2, 3};\n   var s2 := {1, 3, 6};\n   assert s1 + s2 == {1, 2, 3, 6}; // set union\n   assert s1 * s2 == {1, 3}; // set intersection\n   assert s1 - s2 == {2}; // set difference\n\n   assert s2 - {1} in (iset s3 : set<int> | forall x :: x in s3 ==> x % 3 == 0); // 集合的另一种形式\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n集合的并、交、差可以用+, *, -来表示\n\n集合的另一种表现形式是set x: T | p(x) :: f(x),即该集合的元素x类型为T，满足p(x)，并应用f(x)。这里给出的例子中的集合含义是：该无限集的所有元素是整型集合，且对于任意的元素(称之为s3)都有：该整型集合中的元素能被3整除。由于s2 - {1}的结果为{3, 6}显然属于该集合，故该断言正确。",normalizedContent:"# 集合\n\ndafny的集合为有限集set，无限集iset，下面是它们的一些例子。\n\nmethod m2(){\n   var s1 := {1, 2, 3};\n   var s2 := {1, 3, 6};\n   assert s1 + s2 == {1, 2, 3, 6}; // set union\n   assert s1 * s2 == {1, 3}; // set intersection\n   assert s1 - s2 == {2}; // set difference\n\n   assert s2 - {1} in (iset s3 : set<int> | forall x :: x in s3 ==> x % 3 == 0); // 集合的另一种形式\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n集合的并、交、差可以用+, *, -来表示\n\n集合的另一种表现形式是set x: t | p(x) :: f(x),即该集合的元素x类型为t，满足p(x)，并应用f(x)。这里给出的例子中的集合含义是：该无限集的所有元素是整型集合，且对于任意的元素(称之为s3)都有：该整型集合中的元素能被3整除。由于s2 - {1}的结果为{3, 6}显然属于该集合，故该断言正确。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"终止",frontmatter:{title:"终止",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/2146d4/",categories:["指南","简单例子"],tags:["教学例子"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/25.%E7%BB%88%E6%AD%A2.html",relativePath:"20.指南/10.简单例子/25.终止.md",key:"v-af1f7912",path:"/pages/2146d4/",headersStr:null,content:"# 终止\n\nDafny中的关键字predicate表示函数终止。\n\n下面是一个奇偶校验的例子。对于正整数n，当n为偶数时对n - 1进行奇校验，当n为奇数时对n - 1进行偶校验。当n减小到0时，若为偶校验调用则返回真，为奇校验调用则返回假。\n\npredicate even(n: nat)  // 偶校验\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\n\npredicate odd(n: nat)   //奇校验\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上述两个方法缺一不可，因为它们要达到终止条件就必须互相调用直至其中一个方法递归返回。",normalizedContent:"# 终止\n\ndafny中的关键字predicate表示函数终止。\n\n下面是一个奇偶校验的例子。对于正整数n，当n为偶数时对n - 1进行奇校验，当n为奇数时对n - 1进行偶校验。当n减小到0时，若为偶校验调用则返回真，为奇校验调用则返回假。\n\npredicate even(n: nat)  // 偶校验\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\n\npredicate odd(n: nat)   //奇校验\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上述两个方法缺一不可，因为它们要达到终止条件就必须互相调用直至其中一个方法递归返回。",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"介绍",frontmatter:{title:"介绍",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/877eb3/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/00.%E4%BB%8B%E7%BB%8D.html",relativePath:"30.教程/00.Dafny教程/00.介绍.md",key:"v-3dbdb6b8",path:"/pages/877eb3/",headersStr:null,content:"# 介绍\n\nDafny是一种旨在简化编写正确代码的语言。这意味着不存在任何运行时的错误，同时在实际做程序员希望它做的事情上也是正确的。为了实现这一点，Dafny依赖于高级注释来推理和证明代码的正确性。一段代码的效果可以抽象地给出，使用期望行为的自然、高级表达式，这更容易编写，也更不容易出错。Dafny然后生成代码与注释匹配的证明(当然，假设它们是正确的!)。Dafny将编写无bug的代码的变成了编写无bug的。这通常比编写代码更容易，因为注释更短、更直接。例如，Dafny中下面的注释片段表示数组中的每个元素都是严格正的:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\n这意味着对于数组中所有的索引为k的整数，索引处的值大于0。通过编写这些注释，可以确信代码是正确的。此外，编写注释的行为可以帮助人们在更深的层次上理解代码正在做什么。 除了证明与用户提供的注释的对应关系外，Dafny还证明没有运行时错误，比如索引越界、空解引用、除零等。这是一个强有力的保证，是使用Dafny和类似工具的一个强有力的例子。Dafny也证明了代码的终止，除了在特殊指定的循环中。 让我们开始编写一些Dafny程序。",normalizedContent:"# 介绍\n\ndafny是一种旨在简化编写正确代码的语言。这意味着不存在任何运行时的错误，同时在实际做程序员希望它做的事情上也是正确的。为了实现这一点，dafny依赖于高级注释来推理和证明代码的正确性。一段代码的效果可以抽象地给出，使用期望行为的自然、高级表达式，这更容易编写，也更不容易出错。dafny然后生成代码与注释匹配的证明(当然，假设它们是正确的!)。dafny将编写无bug的代码的变成了编写无bug的。这通常比编写代码更容易，因为注释更短、更直接。例如，dafny中下面的注释片段表示数组中的每个元素都是严格正的:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\n这意味着对于数组中所有的索引为k的整数，索引处的值大于0。通过编写这些注释，可以确信代码是正确的。此外，编写注释的行为可以帮助人们在更深的层次上理解代码正在做什么。 除了证明与用户提供的注释的对应关系外，dafny还证明没有运行时错误，比如索引越界、空解引用、除零等。这是一个强有力的保证，是使用dafny和类似工具的一个强有力的例子。dafny也证明了代码的终止，除了在特殊指定的循环中。 让我们开始编写一些dafny程序。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"方法",frontmatter:{title:"方法",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/bf40c0/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/05.%E6%96%B9%E6%B3%95.html",relativePath:"30.教程/00.Dafny教程/05.方法.md",key:"v-5e14a608",path:"/pages/bf40c0/",headersStr:null,content:"# 方法\n\nDafny在许多方面类似于典型的命令式编程语言。有方法、变量、类型、循环、if语句、数组、整数等等。任何Dafny程序的基本单元之一就是方法。方法是一段命令式的、可执行的代码。在其他语言中，它们可能被称为过程或函数，但在Dafny中，这个术语是为一个不同的概念保留的，我们稍后将讨论这个概念。方法的声明方式如下:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n它声明了一个名为Abs的方法，它接受一个名为x的整数参数，并返回一个名为y的整数。请注意，每个参数和返回值都需要类型，并在每个名称后面跟一个冒号(:)。同样，返回值是命名的，并且可以有多个返回值，如下所示:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n方法主体是包含在大括号中的代码，到目前为止，它被简明地表示为 ... (这不是Dafny的语法). 主体由一系列语句组成,例如熟悉的命令式赋值, if语句, 循环，其他方法调用, return语句等等。例如, MultipleReturns方法可以声明为:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n赋值不使用=, 而是使用:=. (事实上Dafny使用 == 表示相等, Dafny的表达式中没有使用单个的等号。) 简单语句后面必须有分号，空格和注释 (//和 /**/) 将会被忽略. 为了从方法中返回值, 该值在return语句之前的某个时间被分配给一个指定的返回值。实际上，返回值的行为非常类似于局部变量，并且可以被赋值不止一次。但是，输入参数是只读的。return语句用于在到达方法的主体块结束之前返回。return语句可以只是return关键字 (其中使用了out参数的当前值), 也可以获取要返回的值列表。也有复合语句，如if语句。if语句不需要在布尔条件周围加上括号，其作用正如人们所期望的那样:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n需要注意的是，它们总是需要在分支周围使用大括号，即使分支只包含一个语句(复合语句或其他语句)。这里的if语句使用熟悉的比较运算符语法检查x是否小于零，并返回适当的绝对值。(其他比较运算符 <=, >, >=, !=和==, 具有预期的含义。有关操作符的更多信息，请参见参考资料。)",normalizedContent:"# 方法\n\ndafny在许多方面类似于典型的命令式编程语言。有方法、变量、类型、循环、if语句、数组、整数等等。任何dafny程序的基本单元之一就是方法。方法是一段命令式的、可执行的代码。在其他语言中，它们可能被称为过程或函数，但在dafny中，这个术语是为一个不同的概念保留的，我们稍后将讨论这个概念。方法的声明方式如下:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n它声明了一个名为abs的方法，它接受一个名为x的整数参数，并返回一个名为y的整数。请注意，每个参数和返回值都需要类型，并在每个名称后面跟一个冒号(:)。同样，返回值是命名的，并且可以有多个返回值，如下所示:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n方法主体是包含在大括号中的代码，到目前为止，它被简明地表示为 ... (这不是dafny的语法). 主体由一系列语句组成,例如熟悉的命令式赋值, if语句, 循环，其他方法调用, return语句等等。例如, multiplereturns方法可以声明为:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n赋值不使用=, 而是使用:=. (事实上dafny使用 == 表示相等, dafny的表达式中没有使用单个的等号。) 简单语句后面必须有分号，空格和注释 (//和 /**/) 将会被忽略. 为了从方法中返回值, 该值在return语句之前的某个时间被分配给一个指定的返回值。实际上，返回值的行为非常类似于局部变量，并且可以被赋值不止一次。但是，输入参数是只读的。return语句用于在到达方法的主体块结束之前返回。return语句可以只是return关键字 (其中使用了out参数的当前值), 也可以获取要返回的值列表。也有复合语句，如if语句。if语句不需要在布尔条件周围加上括号，其作用正如人们所期望的那样:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n需要注意的是，它们总是需要在分支周围使用大括号，即使分支只包含一个语句(复合语句或其他语句)。这里的if语句使用熟悉的比较运算符语法检查x是否小于零，并返回适当的绝对值。(其他比较运算符 <=, >, >=, !=和==, 具有预期的含义。有关操作符的更多信息，请参见参考资料。)",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"前置和后置条件",frontmatter:{title:"前置和后置条件",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/2e0c73/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/10.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6.html",relativePath:"30.教程/00.Dafny教程/10.前置和后置条件.md",key:"v-4f011ddc",path:"/pages/2e0c73/",headersStr:null,content:"# 前置和后置条件\n\n到目前为止，我们所看到的所有代码都没有任何规范:代码几乎可以用任何命令式语言编写(适当考虑多个返回值)。Dafny的真正强大之处在于能够注释这些方法来指定它们的行为。例如，我们使用Abs方法观察到的一个属性是，不管输入是什么，结果总是大于或等于零。我们可以把这个观察结果放在注释中，但是我们没有办法知道这个方法是否真的有这个属性。而且，如果有人改变了方法，我们不能保证注释也会相应改变。通过注释，我们可以让Dafny证明我们声明的方法的属性是真的。有几种方法可以给出注解，但最常见和最基本的是方法的前置条件和后置条件。 Abs方法的这个属性，即结果总是非负的，是后置条件的一个例子:它是在方法返回后为真。用ensures关键字声明的后置条件，作为方法声明的一部分，在返回值之后(如果存在)和方法体之前给出。关键字后面跟着布尔表达式。像if或 while条件和大多数规范一样，后置条件总是一个布尔表达式:可以是true或 false. 在Abs方法的情况下，一个合理的后置条件如下:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你可以在这里看到为什么返回值被赋予名称。这使得它们很容易在方法的后置条件中引用。当表达式为真时，我们说后置条件保留。后置条件必须适用于函数的每次调用，以及每个可能的返回点 (包括函数体末尾的隐式返回点)。在这种情况下，我们唯一要表达的属性是返回值总是至少为零。 有时，我们需要为代码建立多个属性。在这种情况下，我们有两个选择。我们可以用布尔型的and操作符(&&), 将这两个条件连接起来，或者可以编写多个ensures表达式。后者与前者基本相同，但它区分了不同的属性。例如，MultipleReturns 方法的返回值名称可能会导致人们猜测以下后置条件:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n后置条件也可以这样写:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n甚至是这样：\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n因为Dafny中使用了链接比较运算符语法。(一般来说，大多数比较运算符可以串联，但只能同相连接，即不能混合使用大于和小于。详情请参阅参考资料。) 表示后置条件的第一种方式将less部分与more部分分开，这可能是可取的。另一件需要注意的事情是，我们在后置条件中包含了一个输入参数。这是有用的，因为它允许我们将方法的输入和输出相互关联(这是因为输入参数是只读的，所以在末尾和开始时是一样的)。 Dafny实际上拒绝了这个程序，声称第一个后置条件不成立 (即不为真)。这意味着Dafny不能证明该注释在每次方法返回时都有效。通常，Dafny验证错误有两个主要原因:规范与代码不一致，以及它不够聪明来证明所需属性的情况。区分这两种可能性可能是一项困难的任务，但幸运的是，Dafny和它所基于的Boogie/Z3系统非常聪明，并且将证明代码和规范的匹配非常简单。 在这种情况下，Dafny说代码有错误是正确的。问题的关键在于y是整数，所以它可以是负的。如果y为负(或为零)，那么more可以小于或等于x。除非y严格大于零，否则我们的方法将无法正常工作。这正是的概念。前置条件类似于后置条件，除了它必须在方法被调用之前为真。当您调用一个方法时，您的工作是建立(使)先决条件为真，这是Dafny使用证明来实现的。同样，当您编写一个方法时，您可以假定先决条件，但是您必须建立后置条件。然后，方法的调用者可以假定方法返回后置条件保持不变。 前提条件有自己的关键字requires。我们可以给予多次返回必要的先决条件如下:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n与后置条件一样，多个前置条件可以用布尔型的and操作符(&&)或多个require关键字来写。传统上，源代码中的requires优先于ensure，尽管这并不是绝对必要的(尽管requires和ensure注释相对于其他同类型注释的顺序有时会很重要，我们将在后面看到)。添加了这个条件后，Dafny现在验证代码是否正确，只需要保证这个假设正确，就可以保证方法体中的代码是正确的。\n\n练习0\n\n点击查看题目及代码\n\n编写一个方法Max，它接受两个整数参数并返回它们的最大值。添加适当的注释，并确保对代码进行验证。\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并不是所有的方法都有先决条件。例如，我们已经看到的Abs方法是为所有整数定义的，因此没有任何先决条件(除了它的参数是整数这一琐碎的要求，这是由类型系统强制执行的)。尽管它不需要先决条件，Abs函数目前的情况下并不是很有用。为了探究其中的原因，我们需要使用另一种注释，即断言。",normalizedContent:"# 前置和后置条件\n\n到目前为止，我们所看到的所有代码都没有任何规范:代码几乎可以用任何命令式语言编写(适当考虑多个返回值)。dafny的真正强大之处在于能够注释这些方法来指定它们的行为。例如，我们使用abs方法观察到的一个属性是，不管输入是什么，结果总是大于或等于零。我们可以把这个观察结果放在注释中，但是我们没有办法知道这个方法是否真的有这个属性。而且，如果有人改变了方法，我们不能保证注释也会相应改变。通过注释，我们可以让dafny证明我们声明的方法的属性是真的。有几种方法可以给出注解，但最常见和最基本的是方法的前置条件和后置条件。 abs方法的这个属性，即结果总是非负的，是后置条件的一个例子:它是在方法返回后为真。用ensures关键字声明的后置条件，作为方法声明的一部分，在返回值之后(如果存在)和方法体之前给出。关键字后面跟着布尔表达式。像if或 while条件和大多数规范一样，后置条件总是一个布尔表达式:可以是true或 false. 在abs方法的情况下，一个合理的后置条件如下:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你可以在这里看到为什么返回值被赋予名称。这使得它们很容易在方法的后置条件中引用。当表达式为真时，我们说后置条件保留。后置条件必须适用于函数的每次调用，以及每个可能的返回点 (包括函数体末尾的隐式返回点)。在这种情况下，我们唯一要表达的属性是返回值总是至少为零。 有时，我们需要为代码建立多个属性。在这种情况下，我们有两个选择。我们可以用布尔型的and操作符(&&), 将这两个条件连接起来，或者可以编写多个ensures表达式。后者与前者基本相同，但它区分了不同的属性。例如，multiplereturns 方法的返回值名称可能会导致人们猜测以下后置条件:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n后置条件也可以这样写:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n甚至是这样：\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n因为dafny中使用了链接比较运算符语法。(一般来说，大多数比较运算符可以串联，但只能同相连接，即不能混合使用大于和小于。详情请参阅参考资料。) 表示后置条件的第一种方式将less部分与more部分分开，这可能是可取的。另一件需要注意的事情是，我们在后置条件中包含了一个输入参数。这是有用的，因为它允许我们将方法的输入和输出相互关联(这是因为输入参数是只读的，所以在末尾和开始时是一样的)。 dafny实际上拒绝了这个程序，声称第一个后置条件不成立 (即不为真)。这意味着dafny不能证明该注释在每次方法返回时都有效。通常，dafny验证错误有两个主要原因:规范与代码不一致，以及它不够聪明来证明所需属性的情况。区分这两种可能性可能是一项困难的任务，但幸运的是，dafny和它所基于的boogie/z3系统非常聪明，并且将证明代码和规范的匹配非常简单。 在这种情况下，dafny说代码有错误是正确的。问题的关键在于y是整数，所以它可以是负的。如果y为负(或为零)，那么more可以小于或等于x。除非y严格大于零，否则我们的方法将无法正常工作。这正是的概念。前置条件类似于后置条件，除了它必须在方法被调用之前为真。当您调用一个方法时，您的工作是建立(使)先决条件为真，这是dafny使用证明来实现的。同样，当您编写一个方法时，您可以假定先决条件，但是您必须建立后置条件。然后，方法的调用者可以假定方法返回后置条件保持不变。 前提条件有自己的关键字requires。我们可以给予多次返回必要的先决条件如下:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n与后置条件一样，多个前置条件可以用布尔型的and操作符(&&)或多个require关键字来写。传统上，源代码中的requires优先于ensure，尽管这并不是绝对必要的(尽管requires和ensure注释相对于其他同类型注释的顺序有时会很重要，我们将在后面看到)。添加了这个条件后，dafny现在验证代码是否正确，只需要保证这个假设正确，就可以保证方法体中的代码是正确的。\n\n练习0\n\n点击查看题目及代码\n\n编写一个方法max，它接受两个整数参数并返回它们的最大值。添加适当的注释，并确保对代码进行验证。\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n并不是所有的方法都有先决条件。例如，我们已经看到的abs方法是为所有整数定义的，因此没有任何先决条件(除了它的参数是整数这一琐碎的要求，这是由类型系统强制执行的)。尽管它不需要先决条件，abs函数目前的情况下并不是很有用。为了探究其中的原因，我们需要使用另一种注释，即断言。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"断言",frontmatter:{title:"断言",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/36c1b4/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/15.%E6%96%AD%E8%A8%80.html",relativePath:"30.教程/00.Dafny教程/15.断言.md",key:"v-8af21fba",path:"/pages/36c1b4/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# 断言\n\n与前置条件和后置条件不同，断言被放置在方法的中间。像前面两个注释一样，断言有一个关键字assert，后面跟着布尔表达式和结束简单语句的分号。断言表示，当控制到达代码的这一部分时，特定的表达式总是保持不变。例如，下面是一个在虚拟方法中使用断言的简单例子:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try \"asserting\" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny证明了这种方法是正确的，因为2总是小于3。断言有几个用途，但其中最主要的是检查你的期望在不同的点上是否真的是真的。如上所述，您可以使用它来检查基本的算术事实，但它们也可以用于更复杂的情况。通过检查Dafny能够证明您的代码，断言是调试注释的强大工具。例如，我们可以用它来研究Dafny对Abs函数的了解。 为此，我们还需要一个概念:局部变量。局部变量的行为与您所期望的完全一样，除了可能存在一些与遮蔽有关的问题。(详见参考资料)局部变量用var关键字声明，并且可以有类型声明。与需要类型的方法参数不同，Dafny几乎可以在所有情况下推断出局部变量的类型。下面是一个初始化的显式类型变量声明的例子:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\n在这种情况下，可以删除类型注释:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\n可以同时声明多个变量:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\n显式类型声明只适用于紧接在前面的变量，因此这里的bool声明只适用于z，而不适用于x或y，它们都被推断为int。我们需要变量，因为我们想讨论Abs方法的返回值。我们不能直接将Abs放入规范中，因为该方法可能会改变内存状态以及其他问题。因此，我们捕获调用Abs的返回值如下:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这是一个例子，我们可以问Dafny它知道代码中的值，在这个例子中是v。我们通过添加断言来实现，就像上面的断言一样。每当Dafny遇到断言时，它都会试图证明该条件适用于代码的所有执行。在本例中，通过该方法只有一条控制路径，Dafny能够轻松地证明注释，因为它正是Abs方法的后向条件。Abs保证返回值是非负的，所以它很容易跟随v，也就是这个值，在调用Abs之后是非负的。\n\n练习1\n\n点击查看题目及代码\n\n编写一个测试方法，调用练习0中的Max方法，然后对结果进行断言处理。\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但我们对Abs法有更深的了解。特别是对于非负的x，Abs(x) == x。具体来说，在上面的程序中，v的值为3。如果我们尝试添加一个断言(或更改现有的断言):\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们发现Dafny不能证明我们的断言，并给出一个错误。发生这种情况的原因是，Dafny忘记了除当前正在处理的方法之外的所有方法的主体。这极大地简化了Dafny的工作，也是它能够以合理速度运行的原因之一。它还通过将程序分解来帮助我们对程序进行推理，这样我们就可以单独分析每个方法*(给出其他方法的注释)*。当我们调用每个方法时，我们根本不关心它内部发生了什么，只要它满足它的注解。这是可行的，因为Dafny将证明所有的方法都满足它们的注释，并拒绝编译我们的代码，直到它们满足。\n\n对于Abs方法，这意味着Dafny在test方法中所知道的关于Abs返回值的唯一信息就是后置条件对它的说明，仅此而已。这意味着Dafny不知道关于Abs和非负整数的好属性，除非我们把它放在Abs方法的后置条件中。另一种方法是将方法注释(以及参数和返回值的类型)视为修复方法行为的方法。在任何使用该方法的地方，我们假定它是满足前置和后置条件的任何一种可想象的方法。在Abs情况下，我们可以这样写:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n该方法满足后置条件，但显然满足程序片段:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在这个例子中是不成立的。Dafny正在以一种抽象的方式考虑带有这些注释的所有方法。数学绝对值当然是这样一种方法，但是所有返回正常数的方法也是这样。我们需要更强的后置条件来消除这些其他可能性，并将方法修正为我们想要的方法。我们可以通过以下方法部分地做到这一点:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这正好表达了我们之前讨论过的性质，即非负整数的绝对值是相同的。第二个确保是通过隐含操作符表示的，它基本上说，在数学意义上，左边意味着右边(它的绑定比布尔and和比较更弱，所以上面说，0 <= x意味着y == x)。左右两边必须都是布尔表达式。 后置条件是，在Abs被调用后，如果x的值是非负的，那么y等于x。这个暗示的一个警告是，如果左部分(先行词)为假，它仍然为真。所以当x为负时第二个后置条件是成立的。事实上，注解说的唯一一件事是当x为负时，结果y为正。但这仍然不足以修复该方法，所以我们必须添加另一个后置条件，以使以下完整的注释覆盖所有情况:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这些注释足以要求我们的方法实际计算x的绝对值。这些后置条件并不是表示该属性的唯一方法。例如，这是表达同一件事的一种不同的，稍微简短的方式:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n一般来说，有很多方法可以写出一个给定的性质。大多数时候，选择哪一个并不重要，但是一个好的选择可以使您更容易理解所述的属性并验证其正确性。 但我们仍然有一个问题:似乎有很多重复。方法的主体在注释中得到了非常密切的反映。虽然这是正确的代码，但我们希望消除这种冗余。正如您可能猜到的，Dafny提供了一种实现这一点的方法:函数。\n\n练习2\n\n点击查看题目及代码\n\n使用前置条件，改变Abs，说它只能调用负值。将Abs的主体简化为一个返回语句，并确保该方法仍然被验证。\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n练习3\n\n点击查看题目及代码\n\n保持Abs的后置条件与上面相同，将Abs的主体更改为y:= x + 2。为了进行验证，您需要使用什么前提条件来注释方法?如果主体是y:= x + 1，你需要什么前提条件?当你可以调用这个方法时，先决条件说了什么?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n#",normalizedContent:"# 断言\n\n与前置条件和后置条件不同，断言被放置在方法的中间。像前面两个注释一样，断言有一个关键字assert，后面跟着布尔表达式和结束简单语句的分号。断言表示，当控制到达代码的这一部分时，特定的表达式总是保持不变。例如，下面是一个在虚拟方法中使用断言的简单例子:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try \"asserting\" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny证明了这种方法是正确的，因为2总是小于3。断言有几个用途，但其中最主要的是检查你的期望在不同的点上是否真的是真的。如上所述，您可以使用它来检查基本的算术事实，但它们也可以用于更复杂的情况。通过检查dafny能够证明您的代码，断言是调试注释的强大工具。例如，我们可以用它来研究dafny对abs函数的了解。 为此，我们还需要一个概念:局部变量。局部变量的行为与您所期望的完全一样，除了可能存在一些与遮蔽有关的问题。(详见参考资料)局部变量用var关键字声明，并且可以有类型声明。与需要类型的方法参数不同，dafny几乎可以在所有情况下推断出局部变量的类型。下面是一个初始化的显式类型变量声明的例子:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\n在这种情况下，可以删除类型注释:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\n可以同时声明多个变量:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\n显式类型声明只适用于紧接在前面的变量，因此这里的bool声明只适用于z，而不适用于x或y，它们都被推断为int。我们需要变量，因为我们想讨论abs方法的返回值。我们不能直接将abs放入规范中，因为该方法可能会改变内存状态以及其他问题。因此，我们捕获调用abs的返回值如下:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这是一个例子，我们可以问dafny它知道代码中的值，在这个例子中是v。我们通过添加断言来实现，就像上面的断言一样。每当dafny遇到断言时，它都会试图证明该条件适用于代码的所有执行。在本例中，通过该方法只有一条控制路径，dafny能够轻松地证明注释，因为它正是abs方法的后向条件。abs保证返回值是非负的，所以它很容易跟随v，也就是这个值，在调用abs之后是非负的。\n\n练习1\n\n点击查看题目及代码\n\n编写一个测试方法，调用练习0中的max方法，然后对结果进行断言处理。\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但我们对abs法有更深的了解。特别是对于非负的x，abs(x) == x。具体来说，在上面的程序中，v的值为3。如果我们尝试添加一个断言(或更改现有的断言):\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们发现dafny不能证明我们的断言，并给出一个错误。发生这种情况的原因是，dafny忘记了除当前正在处理的方法之外的所有方法的主体。这极大地简化了dafny的工作，也是它能够以合理速度运行的原因之一。它还通过将程序分解来帮助我们对程序进行推理，这样我们就可以单独分析每个方法*(给出其他方法的注释)*。当我们调用每个方法时，我们根本不关心它内部发生了什么，只要它满足它的注解。这是可行的，因为dafny将证明所有的方法都满足它们的注释，并拒绝编译我们的代码，直到它们满足。\n\n对于abs方法，这意味着dafny在test方法中所知道的关于abs返回值的唯一信息就是后置条件对它的说明，仅此而已。这意味着dafny不知道关于abs和非负整数的好属性，除非我们把它放在abs方法的后置条件中。另一种方法是将方法注释(以及参数和返回值的类型)视为修复方法行为的方法。在任何使用该方法的地方，我们假定它是满足前置和后置条件的任何一种可想象的方法。在abs情况下，我们可以这样写:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n该方法满足后置条件，但显然满足程序片段:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在这个例子中是不成立的。dafny正在以一种抽象的方式考虑带有这些注释的所有方法。数学绝对值当然是这样一种方法，但是所有返回正常数的方法也是这样。我们需要更强的后置条件来消除这些其他可能性，并将方法修正为我们想要的方法。我们可以通过以下方法部分地做到这一点:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这正好表达了我们之前讨论过的性质，即非负整数的绝对值是相同的。第二个确保是通过隐含操作符表示的，它基本上说，在数学意义上，左边意味着右边(它的绑定比布尔and和比较更弱，所以上面说，0 <= x意味着y == x)。左右两边必须都是布尔表达式。 后置条件是，在abs被调用后，如果x的值是非负的，那么y等于x。这个暗示的一个警告是，如果左部分(先行词)为假，它仍然为真。所以当x为负时第二个后置条件是成立的。事实上，注解说的唯一一件事是当x为负时，结果y为正。但这仍然不足以修复该方法，所以我们必须添加另一个后置条件，以使以下完整的注释覆盖所有情况:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这些注释足以要求我们的方法实际计算x的绝对值。这些后置条件并不是表示该属性的唯一方法。例如，这是表达同一件事的一种不同的，稍微简短的方式:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n一般来说，有很多方法可以写出一个给定的性质。大多数时候，选择哪一个并不重要，但是一个好的选择可以使您更容易理解所述的属性并验证其正确性。 但我们仍然有一个问题:似乎有很多重复。方法的主体在注释中得到了非常密切的反映。虽然这是正确的代码，但我们希望消除这种冗余。正如您可能猜到的，dafny提供了一种实现这一点的方法:函数。\n\n练习2\n\n点击查看题目及代码\n\n使用前置条件，改变abs，说它只能调用负值。将abs的主体简化为一个返回语句，并确保该方法仍然被验证。\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n练习3\n\n点击查看题目及代码\n\n保持abs的后置条件与上面相同，将abs的主体更改为y:= x + 2。为了进行验证，您需要使用什么前提条件来注释方法?如果主体是y:= x + 1，你需要什么前提条件?当你可以调用这个方法时，先决条件说了什么?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"函数",frontmatter:{title:"函数",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/a1d5a4/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/20.%E5%87%BD%E6%95%B0.html",relativePath:"30.教程/00.Dafny教程/20.函数.md",key:"v-305b9b44",path:"/pages/a1d5a4/",headersStr:null,content:"# 函数\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n这声明了一个名为' abs '的函数，它接受一个整数，并返回一个整数(第二个' int ')。与方法不同，方法的体中可以有各种各样的语句，函数体必须由一个正确类型的表达式组成。这里我们的body必须是一个整数表达式。为了实现绝对值函数，我们需要使用一个 ' if '表达式。' if '表达式类似于其他语言中的三元运算符。\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\n显然，条件必须是布尔表达式，两个分支必须具有相同的类型。您可能会想，如果与方法相比，函数的功能如此有限，为什么还会有人为函数费心呢?函数的强大之处在于它们可以直接在规范中使用。我们可以这样写:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n事实上，我们不仅可以直接编写这个语句而不捕获一个局部变量，甚至不需要编写方法中所做的所有后置条件(尽管函数通常可以并且确实有前置条件和后置条件)。正是函数的局限性让Dafny做到了这一点。与方法不同，在考虑其他函数时，Dafny不会忘记函数体。因此，它可以扩展上述断言中的“abs”的定义，并确定结果实际上是“3”。\n\n练习4. 编写一个函数' max '，返回两个给定整数参数中较大的一个。使用' assert '编写测试方法，检查函数是否正确。\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关于函数的一个警告是，它们不仅可以出现在注释中，而且只能出现在注释中。你不能这样写:\n\n   var v := abs(3);\n\n\n1\n\n\n因为这不是注释。函数从来不是最终编译的程序的一部分，它们只是帮助我们验证代码的工具。有时在实际代码中使用函数是很方便的，所以可以定义一个“函数方法”，它可以从实际代码中调用。请注意，对于哪些函数可以是函数方法有一些限制(详细信息请参阅参考资料)。\n\n练习5. 将练习4中的测试方法更改为将' max '的值捕获到一个变量，然后使用该变量执行练习4中的检查。Dafny会拒绝这个程序，因为你正在从真正的代码中调用' max '。使用“函数方法”修复这个问题。\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n练习6. 现在我们有了一个' abs '函数，改变' abs '方法的后置条件来使用' abs '。在确认该方法之后仍然进行验证，将' Abs '的主体更改为也使用' Abs '。(这样做之后，您将会意识到，使用一个方法来做与函数方法完全相同的事情并没有多大意义。)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n与方法不同，函数可以出现在表达式中。因此，我们可以做一些事情，比如实现数学斐波纳契函数:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里我们使用“nat”，即自然数(非负整数)的类型，这通常比将所有内容都注释为非负更方便。我们可以把这个函数变成函数方法。但这将是非常缓慢的，因为这个版本的计算斐波纳契数具有指数复杂度。有很多更好的方法来计算斐波那契函数。但是这个函数仍然有用，因为我们可以让Dafny证明一个快速版本确实符合数学定义。我们可以两全其美:保证正确性和我们想要的性能。 我们可以像下面这样定义一个方法:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们还没有编写主体，所以Dafny会抱怨后置条件不成立。我们需要一个算法来计算第n个斐波那契数。其基本思想是保持一个计数器，并重复计算相邻的斐波那契数对，直到达到所需的数。为此，我们需要一个循环。在Dafny中，这是通过一个 ' while '循环完成的。while循环如下所示:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这是一个简单的循环，只增加' i '直到' n '。这将构成我们计算斐波那契数列的循环的核心。",normalizedContent:"# 函数\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\n这声明了一个名为' abs '的函数，它接受一个整数，并返回一个整数(第二个' int ')。与方法不同，方法的体中可以有各种各样的语句，函数体必须由一个正确类型的表达式组成。这里我们的body必须是一个整数表达式。为了实现绝对值函数，我们需要使用一个 ' if '表达式。' if '表达式类似于其他语言中的三元运算符。\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\n显然，条件必须是布尔表达式，两个分支必须具有相同的类型。您可能会想，如果与方法相比，函数的功能如此有限，为什么还会有人为函数费心呢?函数的强大之处在于它们可以直接在规范中使用。我们可以这样写:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n事实上，我们不仅可以直接编写这个语句而不捕获一个局部变量，甚至不需要编写方法中所做的所有后置条件(尽管函数通常可以并且确实有前置条件和后置条件)。正是函数的局限性让dafny做到了这一点。与方法不同，在考虑其他函数时，dafny不会忘记函数体。因此，它可以扩展上述断言中的“abs”的定义，并确定结果实际上是“3”。\n\n练习4. 编写一个函数' max '，返回两个给定整数参数中较大的一个。使用' assert '编写测试方法，检查函数是否正确。\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关于函数的一个警告是，它们不仅可以出现在注释中，而且只能出现在注释中。你不能这样写:\n\n   var v := abs(3);\n\n\n1\n\n\n因为这不是注释。函数从来不是最终编译的程序的一部分，它们只是帮助我们验证代码的工具。有时在实际代码中使用函数是很方便的，所以可以定义一个“函数方法”，它可以从实际代码中调用。请注意，对于哪些函数可以是函数方法有一些限制(详细信息请参阅参考资料)。\n\n练习5. 将练习4中的测试方法更改为将' max '的值捕获到一个变量，然后使用该变量执行练习4中的检查。dafny会拒绝这个程序，因为你正在从真正的代码中调用' max '。使用“函数方法”修复这个问题。\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n练习6. 现在我们有了一个' abs '函数，改变' abs '方法的后置条件来使用' abs '。在确认该方法之后仍然进行验证，将' abs '的主体更改为也使用' abs '。(这样做之后，您将会意识到，使用一个方法来做与函数方法完全相同的事情并没有多大意义。)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n与方法不同，函数可以出现在表达式中。因此，我们可以做一些事情，比如实现数学斐波纳契函数:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里我们使用“nat”，即自然数(非负整数)的类型，这通常比将所有内容都注释为非负更方便。我们可以把这个函数变成函数方法。但这将是非常缓慢的，因为这个版本的计算斐波纳契数具有指数复杂度。有很多更好的方法来计算斐波那契函数。但是这个函数仍然有用，因为我们可以让dafny证明一个快速版本确实符合数学定义。我们可以两全其美:保证正确性和我们想要的性能。 我们可以像下面这样定义一个方法:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们还没有编写主体，所以dafny会抱怨后置条件不成立。我们需要一个算法来计算第n个斐波那契数。其基本思想是保持一个计数器，并重复计算相邻的斐波那契数对，直到达到所需的数。为此，我们需要一个循环。在dafny中，这是通过一个 ' while '循环完成的。while循环如下所示:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这是一个简单的循环，只增加' i '直到' n '。这将构成我们计算斐波那契数列的循环的核心。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"循环不变式",frontmatter:{title:"循环不变式",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/d89435/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/25.%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F.html",relativePath:"30.教程/00.Dafny教程/25.循环不变式.md",key:"v-2b81695b",path:"/pages/d89435/",headersStr:null,content:"# 循环不变式\n\n“while”循环给Dafny带来了一个问题。Dafny无法提前知道代码将循环多少次。但是Dafny需要考虑程序中的所有路径，这可能包括循环任意次数。为了使Dafny能够使用循环，您需要提供循环不变式，这是另一种注释。 循环不变式是在进入循环时以及每次循环体执行后保存的表达式。它捕获了一些不变的东西，也就是说，在循环的每一步中都是不变的。现在，很明显，我们需要在每次循环的时候改变变量，等等，否则我们就不需要循环了。像前置条件和后置条件一样，不变量是一个属性，它在每次循环执行时都被保留，使用我们已经看到的布尔表达式表示。例如，我们在上面的循环中看到，如果' i '一开始是正的，那么它就一直是正的。因此，我们可以使用它自己的关键字将不变量添加到循环中:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当您指定一个不变量时，Dafny证明了两件事:不变量在进入循环时保持不变，并且被循环保存。通过保留，我们的意思是假设在循环开始时不变式保持不变，我们必须证明执行循环体一次使不变式再次保持不变。Dafny只能在分析循环体时知道不变量说了什么，除了循环保护(循环条件)。就像Dafny自己不会发现方法的属性一样，除非通过一个不变量告诉它，否则它只会知道循环的最基本属性被保留。 在我们的例子中，循环的重点是每次建立一个(好吧，两个)斐波那契数，直到我们达到想要的数。退出循环后，我们将得到' i == n '，因为当i达到' n '时，' i '将停止递增。我们可以使用断言技巧来检查Dafny是否也看到了这个事实:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们发现这个断言失败了。据Dafny所知，在循环过程中的某个点上，“i”可能以某种方式变得比“n”大得多。在循环退出后(即在循环结束后的代码中)，它所知道的是循环保护失败，不变量保持不变。在本例中，这相当于' n <= i '和' 0 <= i '。但这并不足以保证' i == n '，只保证' n <= i '。我们需要消除i超过n的可能性。解决这个问题的第一个猜想可能是:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这并不验证，因为Dafny会报错循环没有保存(也称为没有维护)不变式。我们希望能够说，在循环结束后，所有不变式都保留下来。我们的不变式适用于循环的每一次执行，除了最后一次。因为循环体只有在循环保护生效时才执行，所以在最后一次迭代中，‘i’从‘n - 1’到‘n’，但在循环退出时不会进一步增加。因此，我们只从我们的不变量中省略了一种情况，修复它相对容易:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n现在，我们可以说，‘n <= i’来自循环保护，‘0 <= i <= n’来自不变量，这允许Dafny证明‘i == n’断言。选择循环不变量的挑战在于找到一个被循环保留的不变量，而且它还能让您证明在循环执行后需要什么。\n\n练习7. 将循环不变量改为' 0 <= i <= n+2 '。循环是否仍然验证?断言' i == n '在循环之后仍然验证吗?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n练习8. 使用原来的循环不变式，将循环守卫从' i < n '更改为' i != n '。循环和循环后的断言仍然进行验证吗?为什么或为什么不?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n除了计数器之外，我们的算法还需要一对表示序列中相邻斐波那契数列的数字。不出所料，我们将有另外一两个不变式来将这些数字和计数器联系起来。为了找到这些不变量，我们使用了一种常见的Dafny技巧:从后置条件向后计算。 斐波那契方法的后置条件是返回值' b '等于' fib(n) '。但是在循环之后，我们有了' i == n '，所以在循环的最后我们需要' b == fib(i) '。这可能是一个很好的不变量，因为它与循环计数器相关。这种现象在Dafny的程序中非常普遍。通常，一个方法只是一个循环，当它结束时，通过使计数器达到另一个数字，通常是一个参数或数组或序列的长度，使后置条件为真。变量b，也就是我们的输出参数，将会是当前的斐波那契数列:\n\n   invariant b == fib(i)\n\n\n1\n\n\n我们还注意到，在我们的算法中，我们可以通过跟踪一对数字来计算任何斐波那契数，并将它们相加得到下一个数字。我们想要一种方法来追踪之前的斐波那契数，我们称之为' a '另一个不变式将表示该数字与循环计数器的关系。不变量有:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\n在循环的每一步，对这两个值求和以得到下一个前导数，而后面的数字是旧的前导数。使用并行赋值，我们可以编写一个循环来执行以下操作:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里' a '是结尾数，' b '是前导数。并行赋值意味着在对变量赋值之前计算整个右手边。因此，“a”将得到“b”的旧值，而“b”将得到两个旧值的和，这正是我们想要的行为。 我们还对循环计数器' i '进行了更改。因为我们还想跟踪后面的数字，所以我们不能从0开始计数器，否则我们将不得不计算一个负的斐波那契数。这样做的问题是，当我们进入循环时，循环计数器不变式可能不成立。唯一的问题是当n为0时。这可以作为一种特殊情况消除，方法是在循环开始时测试该条件。完成的斐波那契方法变成:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafny不再报错循环不变式不成立，因为如果' n '为零，它将在到达循环之前返回。Dafny还能够使用循环不变量来证明，在循环之后，' i == n '和' b == fib(i) '，它们一起隐含了后置条件' b == fib(n) '。\n\n练习9. 上面的' ComputeFib '方法比必要的要复杂得多。写一个简单的程序，不引入' a '作为' b '前面的斐波那契数，而是引入一个变量' c '在' b '后面。根据斐波那契数列的数学定义来验证你的程序是正确的。\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n练习10. 从上面完成的' ComputeFib '方法开始，删除' if '语句，并将' i '初始化为' 0 '，' a '初始化为' 1 '，' b '初始化为' 0 '。通过调整循环不变量来匹配新的行为来验证这个新程序。\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用不变量的一个问题是，很容易忘记让循环“取得进展”，即在每一步做工作。例如，我们可以在前面的程序中省略整个循环体。这些不变量是正确的，因为它们在进入循环时仍然为真，而且由于循环没有改变任何东西，它们将被循环保存下来。我们知道，如果退出循环，那么我们可以假设守卫和不变量为负值，但这并没有说明如果我们永远不退出循环会发生什么。因此，我们希望确保循环在某个点结束，这给了我们一个更强的正确性保证(技术术语是完全正确性)。",normalizedContent:"# 循环不变式\n\n“while”循环给dafny带来了一个问题。dafny无法提前知道代码将循环多少次。但是dafny需要考虑程序中的所有路径，这可能包括循环任意次数。为了使dafny能够使用循环，您需要提供循环不变式，这是另一种注释。 循环不变式是在进入循环时以及每次循环体执行后保存的表达式。它捕获了一些不变的东西，也就是说，在循环的每一步中都是不变的。现在，很明显，我们需要在每次循环的时候改变变量，等等，否则我们就不需要循环了。像前置条件和后置条件一样，不变量是一个属性，它在每次循环执行时都被保留，使用我们已经看到的布尔表达式表示。例如，我们在上面的循环中看到，如果' i '一开始是正的，那么它就一直是正的。因此，我们可以使用它自己的关键字将不变量添加到循环中:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当您指定一个不变量时，dafny证明了两件事:不变量在进入循环时保持不变，并且被循环保存。通过保留，我们的意思是假设在循环开始时不变式保持不变，我们必须证明执行循环体一次使不变式再次保持不变。dafny只能在分析循环体时知道不变量说了什么，除了循环保护(循环条件)。就像dafny自己不会发现方法的属性一样，除非通过一个不变量告诉它，否则它只会知道循环的最基本属性被保留。 在我们的例子中，循环的重点是每次建立一个(好吧，两个)斐波那契数，直到我们达到想要的数。退出循环后，我们将得到' i == n '，因为当i达到' n '时，' i '将停止递增。我们可以使用断言技巧来检查dafny是否也看到了这个事实:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们发现这个断言失败了。据dafny所知，在循环过程中的某个点上，“i”可能以某种方式变得比“n”大得多。在循环退出后(即在循环结束后的代码中)，它所知道的是循环保护失败，不变量保持不变。在本例中，这相当于' n <= i '和' 0 <= i '。但这并不足以保证' i == n '，只保证' n <= i '。我们需要消除i超过n的可能性。解决这个问题的第一个猜想可能是:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这并不验证，因为dafny会报错循环没有保存(也称为没有维护)不变式。我们希望能够说，在循环结束后，所有不变式都保留下来。我们的不变式适用于循环的每一次执行，除了最后一次。因为循环体只有在循环保护生效时才执行，所以在最后一次迭代中，‘i’从‘n - 1’到‘n’，但在循环退出时不会进一步增加。因此，我们只从我们的不变量中省略了一种情况，修复它相对容易:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n现在，我们可以说，‘n <= i’来自循环保护，‘0 <= i <= n’来自不变量，这允许dafny证明‘i == n’断言。选择循环不变量的挑战在于找到一个被循环保留的不变量，而且它还能让您证明在循环执行后需要什么。\n\n练习7. 将循环不变量改为' 0 <= i <= n+2 '。循环是否仍然验证?断言' i == n '在循环之后仍然验证吗?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n练习8. 使用原来的循环不变式，将循环守卫从' i < n '更改为' i != n '。循环和循环后的断言仍然进行验证吗?为什么或为什么不?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n除了计数器之外，我们的算法还需要一对表示序列中相邻斐波那契数列的数字。不出所料，我们将有另外一两个不变式来将这些数字和计数器联系起来。为了找到这些不变量，我们使用了一种常见的dafny技巧:从后置条件向后计算。 斐波那契方法的后置条件是返回值' b '等于' fib(n) '。但是在循环之后，我们有了' i == n '，所以在循环的最后我们需要' b == fib(i) '。这可能是一个很好的不变量，因为它与循环计数器相关。这种现象在dafny的程序中非常普遍。通常，一个方法只是一个循环，当它结束时，通过使计数器达到另一个数字，通常是一个参数或数组或序列的长度，使后置条件为真。变量b，也就是我们的输出参数，将会是当前的斐波那契数列:\n\n   invariant b == fib(i)\n\n\n1\n\n\n我们还注意到，在我们的算法中，我们可以通过跟踪一对数字来计算任何斐波那契数，并将它们相加得到下一个数字。我们想要一种方法来追踪之前的斐波那契数，我们称之为' a '另一个不变式将表示该数字与循环计数器的关系。不变量有:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\n在循环的每一步，对这两个值求和以得到下一个前导数，而后面的数字是旧的前导数。使用并行赋值，我们可以编写一个循环来执行以下操作:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里' a '是结尾数，' b '是前导数。并行赋值意味着在对变量赋值之前计算整个右手边。因此，“a”将得到“b”的旧值，而“b”将得到两个旧值的和，这正是我们想要的行为。 我们还对循环计数器' i '进行了更改。因为我们还想跟踪后面的数字，所以我们不能从0开始计数器，否则我们将不得不计算一个负的斐波那契数。这样做的问题是，当我们进入循环时，循环计数器不变式可能不成立。唯一的问题是当n为0时。这可以作为一种特殊情况消除，方法是在循环开始时测试该条件。完成的斐波那契方法变成:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafny不再报错循环不变式不成立，因为如果' n '为零，它将在到达循环之前返回。dafny还能够使用循环不变量来证明，在循环之后，' i == n '和' b == fib(i) '，它们一起隐含了后置条件' b == fib(n) '。\n\n练习9. 上面的' computefib '方法比必要的要复杂得多。写一个简单的程序，不引入' a '作为' b '前面的斐波那契数，而是引入一个变量' c '在' b '后面。根据斐波那契数列的数学定义来验证你的程序是正确的。\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n练习10. 从上面完成的' computefib '方法开始，删除' if '语句，并将' i '初始化为' 0 '，' a '初始化为' 1 '，' b '初始化为' 0 '。通过调整循环不变量来匹配新的行为来验证这个新程序。\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用不变量的一个问题是，很容易忘记让循环“取得进展”，即在每一步做工作。例如，我们可以在前面的程序中省略整个循环体。这些不变量是正确的，因为它们在进入循环时仍然为真，而且由于循环没有改变任何东西，它们将被循环保存下来。我们知道，如果退出循环，那么我们可以假设守卫和不变量为负值，但这并没有说明如果我们永远不退出循环会发生什么。因此，我们希望确保循环在某个点结束，这给了我们一个更强的正确性保证(技术术语是完全正确性)。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"终止",frontmatter:{title:"终止",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/af29e4/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/30.%E7%BB%88%E6%AD%A2.html",relativePath:"30.教程/00.Dafny教程/30.终止.md",key:"v-d588bd04",path:"/pages/af29e4/",headers:[{level:2,title:"终止",slug:"终止",normalizedTitle:"终止",charIndex:2}],headersStr:"终止",content:"# 终止\n\nDafny通过使用减注释证明了代码的终止，即不会永远循环。对于许多事情，Dafny能够猜出正确的注释，但有时需要明确说明。事实上，对于我们到目前为止看到的所有代码，Dafny都能够自己进行这种证明，这就是为什么我们还没有看到显式的减小注释。Dafny在两个地方证明了终止:循环和递归。这两种情况都需要Dafny明确的注释或正确的猜测。 减小注释，顾名思义，为Dafny提供了一个表达式，该表达式在每次循环迭代或递归调用时都会减小。在使用减小表达式时，Dafny需要验证两个条件:表达式实际上变得更小，以及它是有界的。很多时候，整数值(自然或普通整数)是减少的量，但也可以使用其他东西。(详见参考资料)在整数的情况下，假定边界为零。例如，下面是在循环中正确使用(当然是用它自己的关键字):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这里Dafny拥有证明终止所需的所有条件。变量i在每次循环迭代中都会变小，并且小于0。这很好，除了循环是向后的大多数循环，这往往是向上而不是向下计数。在这种情况下，减少的不是计数器本身，而是计数器与上界之间的距离。下面是一个处理这种情况的简单技巧:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这实际上是Dafny对这种情况的猜测，因为它看到i < n，并假设n - i是减少的数量。循环不变量的上界意味着0 <= n - i，并给了Dafny一个数量的下界。当n的边界不是常量时，这也适用，例如在二分搜索算法中，两个量彼此接近，且都不是固定的。\n\n练习11.\n\n点击查看题目\n\n在上面的循环中，不变量i <= n和循环保护的否定允许我们在循环结束后结束i == n(正如我们之前用assert检查过的那样)。请注意，如果循环守卫被写成i != n(如练习8中所示)，那么无论循环不变量是什么，守卫的否定都会在循环之后立即给出i == n。将循环守卫更改为i != n，并删除不变注释。程序验证了吗?发生了什么事?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另一种需要终止证明的情况是递归方法或函数。与无限循环类似，这些方法可能永远调用自己，永远不会返回到它们的原始调用者。当Dafny无法猜出终止条件时，可以给出显式的减小子句以及前置和后置条件，就像对fib函数的不必要注释一样:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n与前面一样，Dafny可以自己猜测这个条件，但有时递减条件隐藏在对象的某个字段中或其他Dafny自己无法找到的地方，它需要一个显式注释。",normalizedContent:"# 终止\n\ndafny通过使用减注释证明了代码的终止，即不会永远循环。对于许多事情，dafny能够猜出正确的注释，但有时需要明确说明。事实上，对于我们到目前为止看到的所有代码，dafny都能够自己进行这种证明，这就是为什么我们还没有看到显式的减小注释。dafny在两个地方证明了终止:循环和递归。这两种情况都需要dafny明确的注释或正确的猜测。 减小注释，顾名思义，为dafny提供了一个表达式，该表达式在每次循环迭代或递归调用时都会减小。在使用减小表达式时，dafny需要验证两个条件:表达式实际上变得更小，以及它是有界的。很多时候，整数值(自然或普通整数)是减少的量，但也可以使用其他东西。(详见参考资料)在整数的情况下，假定边界为零。例如，下面是在循环中正确使用(当然是用它自己的关键字):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这里dafny拥有证明终止所需的所有条件。变量i在每次循环迭代中都会变小，并且小于0。这很好，除了循环是向后的大多数循环，这往往是向上而不是向下计数。在这种情况下，减少的不是计数器本身，而是计数器与上界之间的距离。下面是一个处理这种情况的简单技巧:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这实际上是dafny对这种情况的猜测，因为它看到i < n，并假设n - i是减少的数量。循环不变量的上界意味着0 <= n - i，并给了dafny一个数量的下界。当n的边界不是常量时，这也适用，例如在二分搜索算法中，两个量彼此接近，且都不是固定的。\n\n练习11.\n\n点击查看题目\n\n在上面的循环中，不变量i <= n和循环保护的否定允许我们在循环结束后结束i == n(正如我们之前用assert检查过的那样)。请注意，如果循环守卫被写成i != n(如练习8中所示)，那么无论循环不变量是什么，守卫的否定都会在循环之后立即给出i == n。将循环守卫更改为i != n，并删除不变注释。程序验证了吗?发生了什么事?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另一种需要终止证明的情况是递归方法或函数。与无限循环类似，这些方法可能永远调用自己，永远不会返回到它们的原始调用者。当dafny无法猜出终止条件时，可以给出显式的减小子句以及前置和后置条件，就像对fib函数的不必要注释一样:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n与前面一样，dafny可以自己猜测这个条件，但有时递减条件隐藏在对象的某个字段中或其他dafny自己无法找到的地方，它需要一个显式注释。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"数组",frontmatter:{title:"数组",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/828a83/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/35.%E6%95%B0%E7%BB%84.html",relativePath:"30.教程/00.Dafny教程/35.数组.md",key:"v-2cd59290",path:"/pages/828a83/",headersStr:null,content:"# 数组\n\n我们所考虑的一切对于简单的函数和少量的数学练习来说都很好，但是对于真正的程序来说却毫无帮助。到目前为止，我们一次只考虑了局部变量中的几个值。现在我们把注意力转向数据数组。数组是语言的内置部分，有自己的类型array<T>，其中T是另一种类型。现在我们只考虑整数数组，array<int>。数组可以为null，并有一个内置的长度字段a. length。元素访问使用标准的括号语法，并从0开始索引，所以a[3]前面是3个元素 a[0]，a[1]和a[2]，按这个顺序。所有的数组访问必须被证明在边界内，这是Dafny无运行时错误安全保证的一部分。因为边界检查是在验证时验证的，所以不需要进行运行时检查。要创建一个新数组，它必须使用new关键字进行分配，但目前我们只使用以先前分配的数组为参数的方法。(有关分配的更多信息，请参阅内存教程。) 对于一个数组，我们可能想要做的最基本的事情之一是在数组中搜索一个特定的键，并返回一个位置的索引，如果键存在，我们可以找到它。我们有两个搜索结果，每个结果都有不同的正确性条件。如果算法返回一个索引(即非负整数)，那么该键应该存在于该索引处。这可以表示为:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的数组索引是安全的，因为隐含操作符是短路。短路意味着如果左部分为假，那么不管第二部分的真值是多少，暗示已经为真，因此不需要求值。使用隐含运算符的短路特性，以及布尔值and(&&)，这也是一种短路，是Dafny的常见实践。条件index < a. length是必要的，否则该方法可能返回一个大整数，而不是数组的下标。总之，短路行为意味着当时间控制到达数组访问时，index必须是一个有效的索引。 如果该键不在数组中，那么我们希望方法返回一个负数。在这个例子中，我们想说这个方法没有丢失一个键的出现;换句话说，这个键不在数组中。为了表达这个属性，我们求助于另一个常用的Dafny工具:量词。",normalizedContent:"# 数组\n\n我们所考虑的一切对于简单的函数和少量的数学练习来说都很好，但是对于真正的程序来说却毫无帮助。到目前为止，我们一次只考虑了局部变量中的几个值。现在我们把注意力转向数据数组。数组是语言的内置部分，有自己的类型array<t>，其中t是另一种类型。现在我们只考虑整数数组，array<int>。数组可以为null，并有一个内置的长度字段a. length。元素访问使用标准的括号语法，并从0开始索引，所以a[3]前面是3个元素 a[0]，a[1]和a[2]，按这个顺序。所有的数组访问必须被证明在边界内，这是dafny无运行时错误安全保证的一部分。因为边界检查是在验证时验证的，所以不需要进行运行时检查。要创建一个新数组，它必须使用new关键字进行分配，但目前我们只使用以先前分配的数组为参数的方法。(有关分配的更多信息，请参阅内存教程。) 对于一个数组，我们可能想要做的最基本的事情之一是在数组中搜索一个特定的键，并返回一个位置的索引，如果键存在，我们可以找到它。我们有两个搜索结果，每个结果都有不同的正确性条件。如果算法返回一个索引(即非负整数)，那么该键应该存在于该索引处。这可以表示为:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的数组索引是安全的，因为隐含操作符是短路。短路意味着如果左部分为假，那么不管第二部分的真值是多少，暗示已经为真，因此不需要求值。使用隐含运算符的短路特性，以及布尔值and(&&)，这也是一种短路，是dafny的常见实践。条件index < a. length是必要的，否则该方法可能返回一个大整数，而不是数组的下标。总之，短路行为意味着当时间控制到达数组访问时，index必须是一个有效的索引。 如果该键不在数组中，那么我们希望方法返回一个负数。在这个例子中，我们想说这个方法没有丢失一个键的出现;换句话说，这个键不在数组中。为了表达这个属性，我们求助于另一个常用的dafny工具:量词。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"量词",frontmatter:{title:"量词",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/17e8d1/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/40.%E9%87%8F%E8%AF%8D.html",relativePath:"30.教程/00.Dafny教程/40.量词.md",key:"v-380fb48e",path:"/pages/17e8d1/",headersStr:null,content:"# 量词\n\nDafny中的量词通常采用forall表达式的形式，也称为通用量词。顾名思义，如果某个属性对某个集合的所有元素都成立，则该表达式为真。现在，我们将考虑整数的集合。全称量词的例子，包装在一个断言中，如下所示:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\n量词为它所考虑的集合中的每个元素引入一个临时名称。这叫做绑定变量，在这里是k。绑定变量有一个类型，它几乎总是推断出来的，而不是显式给出的，而且通常是int。(一般来说，一个人可以有任意数量的绑定变量，这个主题我们将在后面返回。)一对冒号(::)将绑定变量及其可选类型与量化属性分隔开(量化属性的类型必须为bool)。在本例中，属性是对任何整数加1都是一个严格的更大的整数。Dafny能够自动证明这个简单的性质。一般来说，对无限集进行量化不是很有用，比如所有的整数。量词通常用于量化数组或数据结构中的所有元素。对于数组，我们可以使用隐含运算符，使得量化属性对于非索引的值很平凡地为真:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\n这说明数组的每个元素都有一个属性。它的含义是，在计算表达式的第二部分之前，确保k实际上是数组中的有效下标。Dafny不仅可以使用这个事实来证明数组是安全访问的，而且还可以将必须考虑的整数集减少到只考虑数组中的下标。 对于量词，说明键不在数组中是很简单的:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\n因此，我们的方法后置条件变成(加上a上的非零条件): method Find(a: array<int>, key: int) returns (index: int)\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们可以用多种方式填充这个方法的主体，但也许最简单的是线性搜索，实现如下:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n正如您所看到的，我们在while循环中省略了循环不变量，因此Dafny在其中一个后置条件上给出了一个验证错误。我们得到错误的原因是Dafny不知道循环实际上覆盖了所有的元素。为了让Dafny相信这一点，我们必须编写一个不变式，说明当前索引之前的所有内容都已经被查看过了(并且不是键)。就像后置条件一样，我们可以使用一个量词来表达这个属性:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这说明，除了之前的一切，当前的指数并不是关键。请注意，在进入循环时，i为零，因此隐含的第一部分总是假的，因此量化属性总是真的。这种常见的情况被称为空洞真理”:量词之所以成立，是因为它量化了一组空的对象。这意味着它在进入循环时为真。我们在扩展数组的非键部分之前测试数组的值，因此Dafny可以证明这个不变量是保留的。当我们试图添加这个不变量时，出现了一个问题:Dafny抱怨索引超出了不变量中数组访问的范围。 这段代码没有验证，因为在index上没有不变式，所以它可能大于数组的长度。那么绑定变量k可能会超过数组的长度。为了解决这个问题，我们将标准边界放在index上，0 <= index <= a.Length。注意，因为我们使用了k < index，所以即使在index == a.Length时，数组访问也不会出现错误。在处理数组时，使用超出增长范围末尾一处的变量是一种常见模式，在数组中，通常使用它每次构建一个元素的属性。完整的方法如下:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n练习12.\n\n点击查看题目及代码\n\n编写一个接受整数数组的方法，该方法要求数组至少有一个元素，并返回数组中最大元素的索引。用表示方法意图的前置和后置条件来注释方法，并用循环不变式来注释其主体以验证方法。\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n线性搜索不是很有效，特别是当许多查询由相同的数据组成时。如果数组是有序的，那么我们可以使用非常有效的二进制搜索过程来找到键。但是为了能够证明我们的实现是正确的，我们需要一些方法来要求输入的数组实际上是有序的。我们可以在方法的require子句中直接使用量词来实现这一点，但更模块化的表达方式是通过一个predicate。",normalizedContent:"# 量词\n\ndafny中的量词通常采用forall表达式的形式，也称为通用量词。顾名思义，如果某个属性对某个集合的所有元素都成立，则该表达式为真。现在，我们将考虑整数的集合。全称量词的例子，包装在一个断言中，如下所示:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\n量词为它所考虑的集合中的每个元素引入一个临时名称。这叫做绑定变量，在这里是k。绑定变量有一个类型，它几乎总是推断出来的，而不是显式给出的，而且通常是int。(一般来说，一个人可以有任意数量的绑定变量，这个主题我们将在后面返回。)一对冒号(::)将绑定变量及其可选类型与量化属性分隔开(量化属性的类型必须为bool)。在本例中，属性是对任何整数加1都是一个严格的更大的整数。dafny能够自动证明这个简单的性质。一般来说，对无限集进行量化不是很有用，比如所有的整数。量词通常用于量化数组或数据结构中的所有元素。对于数组，我们可以使用隐含运算符，使得量化属性对于非索引的值很平凡地为真:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\n这说明数组的每个元素都有一个属性。它的含义是，在计算表达式的第二部分之前，确保k实际上是数组中的有效下标。dafny不仅可以使用这个事实来证明数组是安全访问的，而且还可以将必须考虑的整数集减少到只考虑数组中的下标。 对于量词，说明键不在数组中是很简单的:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\n因此，我们的方法后置条件变成(加上a上的非零条件): method find(a: array<int>, key: int) returns (index: int)\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n我们可以用多种方式填充这个方法的主体，但也许最简单的是线性搜索，实现如下:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n正如您所看到的，我们在while循环中省略了循环不变量，因此dafny在其中一个后置条件上给出了一个验证错误。我们得到错误的原因是dafny不知道循环实际上覆盖了所有的元素。为了让dafny相信这一点，我们必须编写一个不变式，说明当前索引之前的所有内容都已经被查看过了(并且不是键)。就像后置条件一样，我们可以使用一个量词来表达这个属性:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这说明，除了之前的一切，当前的指数并不是关键。请注意，在进入循环时，i为零，因此隐含的第一部分总是假的，因此量化属性总是真的。这种常见的情况被称为空洞真理”:量词之所以成立，是因为它量化了一组空的对象。这意味着它在进入循环时为真。我们在扩展数组的非键部分之前测试数组的值，因此dafny可以证明这个不变量是保留的。当我们试图添加这个不变量时，出现了一个问题:dafny抱怨索引超出了不变量中数组访问的范围。 这段代码没有验证，因为在index上没有不变式，所以它可能大于数组的长度。那么绑定变量k可能会超过数组的长度。为了解决这个问题，我们将标准边界放在index上，0 <= index <= a.length。注意，因为我们使用了k < index，所以即使在index == a.length时，数组访问也不会出现错误。在处理数组时，使用超出增长范围末尾一处的变量是一种常见模式，在数组中，通常使用它每次构建一个元素的属性。完整的方法如下:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n练习12.\n\n点击查看题目及代码\n\n编写一个接受整数数组的方法，该方法要求数组至少有一个元素，并返回数组中最大元素的索引。用表示方法意图的前置和后置条件来注释方法，并用循环不变式来注释其主体以验证方法。\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n线性搜索不是很有效，特别是当许多查询由相同的数据组成时。如果数组是有序的，那么我们可以使用非常有效的二进制搜索过程来找到键。但是为了能够证明我们的实现是正确的，我们需要一些方法来要求输入的数组实际上是有序的。我们可以在方法的require子句中直接使用量词来实现这一点，但更模块化的表达方式是通过一个predicate。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"谓词",frontmatter:{title:"谓词",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/cc01af/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/45.%E8%B0%93%E8%AF%8D.html",relativePath:"30.教程/00.Dafny教程/45.谓词.md",key:"v-a6041e50",path:"/pages/cc01af/",headersStr:null,content:"# 谓词\n\n谓词是一个返回布尔值的函数。这是一个简单但强大的想法，发生在Dafny的程序。例如，我们将整数数组上的sorted谓词定义为一个函数，该函数接受一个数组作为参数，当且仅当该数组按递增顺序排序时，返回true。谓词的使用使我们的代码更短，因为我们不需要一遍又一遍地写出一个很长的属性。它还可以通过给一个公共属性命名来使我们的代码更容易阅读。 我们有很多方法可以写sorted谓词，但最简单的是在数组的下标上使用一个量词。我们可以写一个量词来表示属性“如果数组中x在y之前，那么x <= y，作为一个量词在两个绑定变量上:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\n这里我们有两个绑定变量，j和k，都是整数。两者之间的比较保证了它们在数组中都是有效的下标，并且j在k之前。然后第二部分说它们彼此之间的顺序是正确的。量词在Dafny中只是一种布尔值表达式，所以我们可以将排序谓词写为:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意，没有返回类型，因为谓词总是返回布尔值。 Dafny拒绝给出的这段代码，声称谓词读不出a。修复此问题需要另一个注释，读取注释。",normalizedContent:"# 谓词\n\n谓词是一个返回布尔值的函数。这是一个简单但强大的想法，发生在dafny的程序。例如，我们将整数数组上的sorted谓词定义为一个函数，该函数接受一个数组作为参数，当且仅当该数组按递增顺序排序时，返回true。谓词的使用使我们的代码更短，因为我们不需要一遍又一遍地写出一个很长的属性。它还可以通过给一个公共属性命名来使我们的代码更容易阅读。 我们有很多方法可以写sorted谓词，但最简单的是在数组的下标上使用一个量词。我们可以写一个量词来表示属性“如果数组中x在y之前，那么x <= y，作为一个量词在两个绑定变量上:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\n这里我们有两个绑定变量，j和k，都是整数。两者之间的比较保证了它们在数组中都是有效的下标，并且j在k之前。然后第二部分说它们彼此之间的顺序是正确的。量词在dafny中只是一种布尔值表达式，所以我们可以将排序谓词写为:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意，没有返回类型，因为谓词总是返回布尔值。 dafny拒绝给出的这段代码，声称谓词读不出a。修复此问题需要另一个注释，读取注释。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"框架",frontmatter:{title:"框架",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/13bbcd/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/50.%E6%A1%86%E6%9E%B6.html",relativePath:"30.教程/00.Dafny教程/50.框架.md",key:"v-56398717",path:"/pages/13bbcd/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# 框架\n\n排序后的谓词不能访问数组，因为该数组不包含在函数的读取帧中。函数(或谓词)的读取框架是函数允许读取的所有内存位置。限制函数可读内容的原因是，当写入内存时，可以确保没有读取该内存部分的函数具有与之前相同的值。例如，我们可能有两个数组，我们知道其中一个是有序的。如果没有在已排序的谓词上放置reads注释，那么当修改未排序的数组时，就无法确定另一个数组是否停止排序。虽然在这种情况下，我们可以提供不变量来保存它，但在操作数据结构时，它会变得更加复杂。在这种情况下，框架是使核查过程可行的关键。\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreads注释不是布尔表达式，就像我们看到的其他注释一样，它可以与前置条件和后置条件一起出现在任何地方。它指定了函数允许访问的一组内存位置，而不是应该为真的属性。数组的名称，就像上面例子中的a，代表该数组的所有元素。也可以指定对象字段和对象集，但我们在这里不讨论这些主题。Dafny将检查您没有读取读取帧中没有声明的任何内存位置。这意味着函数内的函数调用必须具有作为调用函数读取帧子集的读取帧。需要注意的一点是，函数的参数如果不是内存位置，则不需要声明。 框架也会影响方法。正如您可能已经猜到的，它们不需要列出它们所读取的内容，因为我们已经编写了一个方法来访问没有reads注释的数组。方法可以读取它们想要的任何内存，但它们需要用modifies annotation列出它们修改的内存的哪些部分。它们几乎和它们的读取表亲一样，除了它们说的是可以改变什么，而不是函数的值取决于什么。结合读取，修改限制允许Dafny证明代码的属性，否则将非常困难或不可能。读取和修改是允许Dafny一次只处理一个方法的工具之一，因为它们限制了对内存的任意修改，使Dafny能够推理。 请注意，帧化只适用于堆，或通过引用访问的内存。局部变量不是存储在上的，所以它们不能在reads注释中被提及。还请注意，像集合、序列和多集这样的类型都是值类型，它们被视为整数或局部变量。数组和对象是堆引用类型，它们存储在堆上(尽管引用本身和它所指向的值之间总是有微妙的区别)。\n\n练习13\n\n点击查看题目及代码\n\n修改' sorted '谓词的定义，以便当数组被排序且其所有元素都不相同时，它准确地返回true。\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n练习14\n\n点击查看题目及代码\n\n如果移除前置条件' a != null '会发生什么?更改' sorted '的定义，使其允许参数为null，但如果是则返回false。\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as \"not sorted\".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n#",normalizedContent:"# 框架\n\n排序后的谓词不能访问数组，因为该数组不包含在函数的读取帧中。函数(或谓词)的读取框架是函数允许读取的所有内存位置。限制函数可读内容的原因是，当写入内存时，可以确保没有读取该内存部分的函数具有与之前相同的值。例如，我们可能有两个数组，我们知道其中一个是有序的。如果没有在已排序的谓词上放置reads注释，那么当修改未排序的数组时，就无法确定另一个数组是否停止排序。虽然在这种情况下，我们可以提供不变量来保存它，但在操作数据结构时，它会变得更加复杂。在这种情况下，框架是使核查过程可行的关键。\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreads注释不是布尔表达式，就像我们看到的其他注释一样，它可以与前置条件和后置条件一起出现在任何地方。它指定了函数允许访问的一组内存位置，而不是应该为真的属性。数组的名称，就像上面例子中的a，代表该数组的所有元素。也可以指定对象字段和对象集，但我们在这里不讨论这些主题。dafny将检查您没有读取读取帧中没有声明的任何内存位置。这意味着函数内的函数调用必须具有作为调用函数读取帧子集的读取帧。需要注意的一点是，函数的参数如果不是内存位置，则不需要声明。 框架也会影响方法。正如您可能已经猜到的，它们不需要列出它们所读取的内容，因为我们已经编写了一个方法来访问没有reads注释的数组。方法可以读取它们想要的任何内存，但它们需要用modifies annotation列出它们修改的内存的哪些部分。它们几乎和它们的读取表亲一样，除了它们说的是可以改变什么，而不是函数的值取决于什么。结合读取，修改限制允许dafny证明代码的属性，否则将非常困难或不可能。读取和修改是允许dafny一次只处理一个方法的工具之一，因为它们限制了对内存的任意修改，使dafny能够推理。 请注意，帧化只适用于堆，或通过引用访问的内存。局部变量不是存储在上的，所以它们不能在reads注释中被提及。还请注意，像集合、序列和多集这样的类型都是值类型，它们被视为整数或局部变量。数组和对象是堆引用类型，它们存储在堆上(尽管引用本身和它所指向的值之间总是有微妙的区别)。\n\n练习13\n\n点击查看题目及代码\n\n修改' sorted '谓词的定义，以便当数组被排序且其所有元素都不相同时，它准确地返回true。\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n练习14\n\n点击查看题目及代码\n\n如果移除前置条件' a != null '会发生什么?更改' sorted '的定义，使其允许参数为null，但如果是则返回false。\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as \"not sorted\".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"二分查找",frontmatter:{title:"二分查找",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/1319be/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/55.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"30.教程/00.Dafny教程/55.二分查找.md",key:"v-29984e8a",path:"/pages/1319be/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# 二分查找\n\n谓词通常用于使其他注释更清晰:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们有和线性搜索一样的后置条件，因为目标是一样的。不同的是，现在我们知道数组是有序的。因为Dafny可以展开函数，所以在方法体中它也知道这一点。然后我们可以用这个性质来证明搜索的正确性。方法体如下所示:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n这是一个相当标准的二分查找实现。首先，我们声明要搜索的范围。这可以被认为是钥匙可能存在的剩余空间。范围是包含-排他的，意味着它包括指数[low，high)。第一个不变量表示这个范围在数组内。第二个表示键不在这个范围之外的任何地方。在if链的前两个分支中，我们发现区间中间的元素不是键，因此我们移动区间以排除该元素及其相应一侧的所有其他元素。当移动范围的下端时，我们需要加上1，因为它在低端是包含的。如果不加1，那么当mid == low时，循环可能会永远继续下去，当low + 1 == high时就会发生这种情况。我们可以改变它，当low和high相差1时，循环退出，但这意味着我们需要在循环之后进行额外的检查，以确定是否在剩下的一个索引中找到键。在上面的公式中，这是不必要的，因为当low == high时，循环退出。但这意味着搜索范围内没有元素留下，因此没有找到键。这可以从循环不变量推导出来:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\n当low == high时，含义的第一部分的否定条件总是为真(因为没有i可以至少或严格小于相同的值)。因此，不变量表示数组中的所有元素都不是键，第二个后置条件成立。正如您所看到的，在这段代码中很容易出现一个错误。有了这些不变量，Dafny不仅可以证明代码是正确的，而且我们自己也可以更容易地理解代码的操作。\n\n练习15.\n\n点击查看题目及代码\n\n修改BinarySearch函数体中的赋值，将low设置为mid，或将high设置为mid - 1。在每种情况下，哪里出了问题?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n#",normalizedContent:"# 二分查找\n\n谓词通常用于使其他注释更清晰:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们有和线性搜索一样的后置条件，因为目标是一样的。不同的是，现在我们知道数组是有序的。因为dafny可以展开函数，所以在方法体中它也知道这一点。然后我们可以用这个性质来证明搜索的正确性。方法体如下所示:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n这是一个相当标准的二分查找实现。首先，我们声明要搜索的范围。这可以被认为是钥匙可能存在的剩余空间。范围是包含-排他的，意味着它包括指数[low，high)。第一个不变量表示这个范围在数组内。第二个表示键不在这个范围之外的任何地方。在if链的前两个分支中，我们发现区间中间的元素不是键，因此我们移动区间以排除该元素及其相应一侧的所有其他元素。当移动范围的下端时，我们需要加上1，因为它在低端是包含的。如果不加1，那么当mid == low时，循环可能会永远继续下去，当low + 1 == high时就会发生这种情况。我们可以改变它，当low和high相差1时，循环退出，但这意味着我们需要在循环之后进行额外的检查，以确定是否在剩下的一个索引中找到键。在上面的公式中，这是不必要的，因为当low == high时，循环退出。但这意味着搜索范围内没有元素留下，因此没有找到键。这可以从循环不变量推导出来:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\n当low == high时，含义的第一部分的否定条件总是为真(因为没有i可以至少或严格小于相同的值)。因此，不变量表示数组中的所有元素都不是键，第二个后置条件成立。正如您所看到的，在这段代码中很容易出现一个错误。有了这些不变量，dafny不仅可以证明代码是正确的，而且我们自己也可以更容易地理解代码的操作。\n\n练习15.\n\n点击查看题目及代码\n\n修改binarysearch函数体中的赋值，将low设置为mid，或将high设置为mid - 1。在每种情况下，哪里出了问题?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"结论",frontmatter:{title:"结论",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/30a8c2/",categories:["教程"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/60.%E7%BB%93%E8%AE%BA.html",relativePath:"30.教程/00.Dafny教程/60.结论.md",key:"v-3a5a84d4",path:"/pages/30a8c2/",headersStr:null,content:"# 结论\n\n我们已经看到了Dafny的主要功能，并将其用于一些有趣的例子，如果是在小方面的话，说明Dafny可以做什么。但是，要真正利用Dafny提供的功能，需要深入学习高级主题:对象、序列和集合、数据结构、引理等。现在您已经熟悉了Dafny的基础知识，您可以在闲暇时阅读关于这些主题的教程。每个教程都被设计成相对独立的主题指南，尽管有些教程可以从事先阅读其他教程中受益。这些例子也是寻找Dafny模型程序的好地方。最后，引用包含了Dafny语法和语义的详细信息，当您只需要知道不相交集合操作符是什么(它是!!)。\n\ntips\n\n即使您不经常使用Dafny，以一种精确的方式准确地写下代码所做的事情，并使用它来证明代码是正确的，这是一种有用的技能。不变量、前置和后置条件以及注释在调试代码中非常有用，也可以作为将来开发人员的文档。当修改或添加代码库时，它们确认现有代码的保证没有被破坏。他们还通过形式化行为和需求并强制执行正确的用法，确保api被正确使用。从不变量推理、考虑前置和后置条件，以及编写断言来检查假设，这些都是通用的计算机科学技能，无论使用哪种语言，这些技能都将使您受益。",normalizedContent:"# 结论\n\n我们已经看到了dafny的主要功能，并将其用于一些有趣的例子，如果是在小方面的话，说明dafny可以做什么。但是，要真正利用dafny提供的功能，需要深入学习高级主题:对象、序列和集合、数据结构、引理等。现在您已经熟悉了dafny的基础知识，您可以在闲暇时阅读关于这些主题的教程。每个教程都被设计成相对独立的主题指南，尽管有些教程可以从事先阅读其他教程中受益。这些例子也是寻找dafny模型程序的好地方。最后，引用包含了dafny语法和语义的详细信息，当您只需要知道不相交集合操作符是什么(它是!!)。\n\ntips\n\n即使您不经常使用dafny，以一种精确的方式准确地写下代码所做的事情，并使用它来证明代码是正确的，这是一种有用的技能。不变量、前置和后置条件以及注释在调试代码中非常有用，也可以作为将来开发人员的文档。当修改或添加代码库时，它们确认现有代码的保证没有被破坏。他们还通过形式化行为和需求并强制执行正确的用法，确保api被正确使用。从不变量推理、考虑前置和后置条件，以及编写断言来检查假设，这些都是通用的计算机科学技能，无论使用哪种语言，这些技能都将使您受益。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"引理和归纳",frontmatter:{title:"引理和归纳",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/273cac/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/00.%E5%BC%95%E7%90%86%E5%92%8C%E5%BD%92%E7%BA%B3.html",relativePath:"30.教程/10.Dafny进阶语法/00.引理和归纳.md",key:"v-5546a966",path:"/pages/273cac/",headers:[{level:2,title:"引言",slug:"引言",normalizedTitle:"引言",charIndex:12},{level:2,title:"零搜索",slug:"零搜索",normalizedTitle:"零搜索",charIndex:340},{level:2,title:"引理",slug:"引理",normalizedTitle:"引理",charIndex:2},{level:2,title:"计数",slug:"计数",normalizedTitle:"计数",charIndex:6679},{level:2,title:"证明分配性质",slug:"证明分配性质",normalizedTitle:"证明分配性质",charIndex:8547},{level:2,title:"归纳",slug:"归纳",normalizedTitle:"归纳",charIndex:5},{level:2,title:"有向图的路径",slug:"有向图的路径",normalizedTitle:"有向图的路径",charIndex:12097}],headersStr:"引言 零搜索 引理 计数 证明分配性质 归纳 有向图的路径",content:"# 引理和归纳\n\n\n# 引言\n\n有时需要一些逻辑步骤来证明一个程序是正确的，但是对于Dafny来说，这些步骤太复杂了。当这种情况发生时，我们通常可以通过提供引理来帮助Dafny证明程序。\n\n引理是用来证明另一个结果的定理，而不是用来证明本身。他们允许Dafny将证明分成两部分:证明引理，然后用引理来证明最终结果;最后的结果就是程序正确性的证明。通过这样分割它，你可以防止Dafny试图证明远超它证明能力的程序。总的来说，Dafny和计算机在处理一堆具体细节情况方面都做得很好，但它缺乏看到能使证明过程变得更容易的中间步骤的能力。\n\n通过使用引理，你可以找出这些中间步骤是什么，以及什么时候在程序使用它们。对于有关归纳论证的问题来说，lemma无疑是对症下药的一剂良方。\n\n\n# 零搜索\n\n我们首次接触引理，先来学习一个简单的例子:在数组中搜索零。这个问题有趣在于我们正在搜索的这个数组有两个特殊的属性: 所有元素都是非负的。 每个连续元素最多比前一个元素小一。 在代码:\n\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n{\n}\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n有这样的一堆要求条件，我们可以用一些聪明的方法:我们可以跳过元素。假设我们正在遍历数组，看到a[j] == 7。然后我们知道6 <= a[j+1]，5 <= a[j+2]，等等。事实上，下一个0要等到数组中7个元素全部走一遍时才会出现。所以我们甚至不需要刻意寻找0只用一直a[j+a[j]]就行了。所以我们可以这样写一个循环:\n\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这段代码将计算得到正确的结果，但是Dafny在第二个循环不变量报错。Dafny并不认为跳过所有这些元素是合理的。原因是，前置条件说的是：每个连续的元素最多减一，但它没有说间隔更远的元素是如何关联的。为了让Dafny相信这事实，我们需要使用引理。\n\n\n# 引理\n\n引理其实就是个ghost方法。引理(更准确地说，引理的结论)所要求的性质被声明为后置条件，就像在普通方法声明的一样。与方法不同，引理永远不会被改变状态。因为引理是ghost方法，所以不需要在运行时调用它，所以编译器在生成可执行代码之前会删除、无视它。因此，引理的存在仅仅是因为它对程序验证有一定作用。一个典型的引理长这样的:\n\nlemma Lemma(...)\n   ensures (desirable property)\n{\n   ...\n}\t\t\t\t\n\n\n1\n2\n3\n4\n5\n\n\n对于零搜索问题，理想的性质是在index + a[index]之前，index中的元素都不能为零。按照FindZero的requierments，我们将数组和起始索引作为参数:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   //...\n}\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n后置条件就是我们想要的属性。i有额外限制是因为j + a[j]可能超过了数组的末尾。我们只想讨论这个范围内的下标也就是数组中的下标。然后我们做了一个关键的步骤:检查我们的引理是否足以证明循环不变量。通过在填充引理体之前进行检查，我们确保我们试图证明的是正确的东西。FindZero方法变成:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   //...\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n现在，Dafny没有报错FindZero方法，因为引理的后置条件显示循环不变式被保留了。但它对引理本身报错，这并不奇怪，因为主体是空的。为了让Dafny接受引理，我们必须证明后置条件为真。就像我们在Dafny中做的所有事情一样:编写代码。\n\n我们从数组的关键属性开始，因为零搜索问题中的元素都只会缓慢下降。我们可以通过使用断言来询问某些属性是否存在。例如，我们可以看到Dafny知道:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length - 3\n   // Note: the above has been changed so that the array indices below are good.\n{\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n\n\n1\n2\n3\n4\n5\n\n\n因此，我们可以看到，Dafny可以跟随任何单独的步骤，甚至可以适当地链。但是我们需要的步数不是恒定的:它可能取决于a[j]的值。但是我们已经有了一个用于处理可变数量步骤的构造:while循环!\n\n我们可以用同样的结构让Dafny把步骤连在一起。我们想要从j迭代到j + a[j]，同时跟踪下界。我们还会跟踪到我们目前看到的所有元素都不为零的事实:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n   var i := j;\n   while i < j + a[j] && i < a.Length\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第一个不变式给出当前元素的边界，如果我们还没有跑到数组的末尾。对于超过j的每一个索引(其中有i-j)，数组元素可以小一，因此从a[j]中减去这个值。这只是说当前元素不能为零，所以如果没有第二个不变量，Dafny就不能知道数组里没有零。Dafny忘记了循环执行的所有内容，除了在不变量中给出的内容，所以我们需要建立这样一个事实，即到目前为止，任何地方都没有零。 循环体只是使计数器加1。正如我们之前看到的，Dafny能够自己计算出每一步，所以我们不需要做任何进一步的操作。我们只需要给它一个需要证明的结构。有时，单个步骤本身就足够复杂到它们需要自己的子证明，通过使用一系列断言语句或整个其他引理。\n\n在使用数组时，迭代是许多问题的自然解决方案。但是，有时会使用递归来定义函数或属性。在这些情况下，引理通常具有相同的递归结构。为了看一个例子，我们将考虑计数的问题。\n\n\n# 计数\n\n我们将使用count函数在一个bool序列中计算true的数量，如下所示:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m()\n{\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n...\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n代码非常简单，但需要注意的一点是，该函数是递归定义的。像这样的递归函数很容易需要引理。我们希望在验证使用此函数的程序时能够使用count的一个属性:它应用于加法上。我们的意思是:\n\nforall a, b :: count(a + b) == count(a) + count(b)\n\n\n1\n\n\n这里，第一个加号(+)是序列拼接，第二个加号是整数相加。显然，我们可以将任意序列分解为两个序列a和b，分别计算它们，并将结果相加。这是事实，但Dafny无法直接证明。问题是函数并没有以这种方式分割序列。该函数取第一个元素，计算其计数，然后将其添加到序列的其余部分。如果a很长，那么在这个展开过程实际到达count(b)之前可能需要一段时间，因此Dafny只尝试展开几个递归调用。(确切地说，是两个。参见Amin, Leino, and Rompf的论文Computing with an SMT solver, TAP 2014。)这是一个需要引理来证明的性质的例子。\n\n在我们的例子中,我们有两个选择引理:我们也可以写全称量词,或者我们可以使引理特定序列a和b。事实证明,当我们想要分配律,我们不需要完整的通用属性。我们感兴趣的是，对于程序中已知的两个特定的a和b, count(a + b) == count(a) + count(b)。因此，当我们调用引理来得到这个性质时，我们可以告诉它我们感兴趣的是哪两个序列。如果我们在其他地方有不同的序列，我们可以用不同的参数调用方法，就像普通方法一样。事实证明，证明完整的全称性质，虽然是可能的，但比证明具体的，具体的情况要复杂得多，所以我们先来处理这个情况。\n\n因此引理应该将感兴趣的序列作为参数，后置条件如下:\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\n\n\n1\n2\n3\n4\n\n\n\n# 证明分配性质\n\n为了写出引理，我们必须想出一个证明它的方法。正如您可以在上面验证的(没有双关语)，引理还不能工作，否则引理将是不必要的。为了做到这一点，我们注意到Dafny无法首先证明这一点的原因是count函数从序列的开始定义，而分配律则在序列的中间操作。因此，如果我们能找到一种从序列的前面开始工作的方法，那么Dafny就可以直接使用函数的定义。这个序列的第一个元素是什么?在一些情况下，a和b是空序列(如果有的话)。因此我们的引理必须考虑多种情况，引理的共同特征。我们注意到，如果a ==[]，那么a+ b == b，不管b是多少。引理处理情况的方式与代码处理情况的方式相同:if语句。下面使用断言给出了所需属性的简短证明。\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n      assert count(a) == 0;\n      assert count(a + b) == count(b);\n      assert count(a + b) == count(a) + count(b);\n   }\n   else\n   {\n      //...\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nif a == []\n{\n   assert a + b == b;\n   assert count(a) == 0;\n   assert count(a + b) == count(b);\n   assert count(a + b) == count(a) + count(b);\n}\nelse\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在这种情况下，我们可以通过添加一个requires子句来检验引理。我们发现代码验证。这意味着如果a ==[]，则引理将正确地证明后置条件。在这种情况下，只需要上面的第一个断言;Dafny自己完成了剩下的步骤(试试吧!)现在我们可以考虑另一种情况，当0 < |a|。\n\n我们的目标是将count(a + b)与count(a)和count(b)联系起来。如果a不是空序列，那么当我们按照定义展开count(a + b)时，我们得到:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert a + b == [a[0]] + (a[1..] + b);\n   assert count(a + b) == count([a[0]]) + count(a[1..] + b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nassert a + b == [a[0]] + (a[1..] + b);\nassert count(a + b) == count([a[0]]) + count(a[1..] + b);\n\n\n1\n2\n\n\n注意，我们得到count([a[0]])和a[1..]。如果我们扩展count(a)，这两项也会出现。具体地说:\n\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert count(a) == count([a[0]]) + count(a[1..]);\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nassert count(a) == count([a[0]]) + count(a[1..]);\n\n\n1\n\n\n最后，我们可以将count(a)的定义替换为后置条件，以获得:\n\nassert count(a + b) == count(a) + count(b); // postcondition\nassert count(a + b) == count([a[0]]) + count(a[1..]) + count(b);\n\n\n1\n2\n\n\n现在这看起来很像我们展开count(a + b)后得到的表达式。唯一的区别是count(a[1.. .) + count(a[1..]) + count(b)。但这正是我们要证明的性质!\n\n\n# 归纳\n\n我们试图提出的论点是归纳的。我们可以证明我们的目标，只要这个问题的一个小版本是正确的。这正是归纳法的概念:用一个小问题来证明一个大问题。为此，我们在代码中调用递归属性。它是一个方法，所以我们可以在需要它的时候调用它。\n\nDafny将假定递归调用满足规范。这就是归纳假设，所有引理的递归调用都是有效的。这关键取决于Dafny也证明了终止。这意味着最终，引理不会再进行递归调用。在本例中，这是if语句的第一个分支。如果没有递归调用，那么引理必须直接证明这种情况。然后，堆栈中的每个调用都是合理的，假设引理适用于较小的情况。如果Dafny没有证明链终止，那么链可以永远继续，并且对于每个调用的假设都是不合理的。\n\n归纳法通常是寻找一种方法，一步一步地建立你的目标。从另一个角度来看，它证明了你的目标是一个更小的版本。通过一次分解一个元素，直到第一个序列完全消失，证明了分配引理。这种情况被证明是一个基本情况，然后整个链的解构被验证。\n\n成功的关键是Dafny从来不用考虑整个通话链。通过检验终止，得到链是有限的。然后它要做的就是检查一步。如果任意一步是有效的，那么整个链也是有效的。这与Dafny在循环中使用的逻辑相同:检查初始不变项是否成立，任意一个步骤是否保持不变，然后检查整个循环，不管循环循环了多少次。这种相似性不仅仅是表面的。这两种引理(以及Dafny对程序的两种推理)都是归纳的。考虑到迭代和递归作为实现同一目标的两种方法之间的关系，这也不足为奇。\n\n记住这一点，我们可以通过在if语句的else分支中递归地调用引理来完成引理:\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      DistributiveLemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n  if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      DistributiveLemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n现在这个引理得到了验证。但是如果我们想要表达每一对序列都是这样联系的呢?为了做到这一点，我们必须看看引理在Dafny中的另一种用法，我们将用另一个例子来探索。\n\n\n# 有向图的路径\n\n作为最后一个更高级的例子，我们将证明一个关于有向图中路径的性质。为此，我们有机会称一个引理在所有节点序列上是普遍的。一个有向图由若干个节点组成，每个节点都有一些到其他节点的链接。这些链接是单向的，对它们的唯一限制是节点不能链接到自己。节点定义为:\n\nclass Node\n{\n   // a single field giving the nodes linked to\n   var next: seq<Node>\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们将图表示为一组节点，这些节点只指向图中的其他节点，而不指向自己。我们称这样一组节点为封闭的:\n\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==>\n      forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们将路径表示为非空节点序列，其中每个节点都与路径中的前一个节点相连。我们定义了两个谓词，一个用于定义有效路径，另一个用于确定给定路径是否为图中两个特定节点之间的有效路径:\n\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n现在我们准备好陈述我们要证明的引理了。我们考虑一个图和一个子图:一个也构成一个图的节点的子集。这个子图必须是封闭的，即不包含自身之外的链接。如果我们有这样的情况，那么从子图中的一个节点到子图之外的一个节点不可能有一条有效的路径。我们将这个事实称为闭合引理，我们在Dafny中这样表述:\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   //...\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n前提条件说明了所有的要求:图和子图都是有效的，根节点在子图中但目标不在，所有内容都包含在主图中。后置条件声明没有从根到目标的有效路径。这里我们只对特定的开始/结束节点对证明它。\n\n证明某物不存在的一种方法是证明给定的任意节点序列它不是一个有效路径。我们可以用，你猜对了，另一个引理。这个引理将证明，对于任何给定的序列，它不是从根root到目标goal的有效路径。路径引理的反证如下:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n前提与闭引理相同。要在闭引理ClosedLemma中使用反证明引理DisproofLemma，我们需要对每个节点序列调用它一次。这可以通过Dafny的forall语句来完成，该语句聚合了给定绑定变量的所有值对其主体的影响。\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph =\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   ...\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如你所见，这使得闭引理ClosedLemma得到验证，所以我们对引理的测试是成功的。因此，反证明引理DisproofLemma是足够强的，我们的工作仅仅是证明它。\n\n有几种不同的方式可以使节点序列成为无效路径。如果路径为空，则它不能是有效路径。此外，路径的第一个元素必须是根root，最后一个元素必须是目标goal。因为root in subgraph，goal !in subgraph，我们必须有root != goal，所以序列必须至少有两个元素。为了验证Dafny是否看到了这一点，我们可以临时在引理上加上先决条件，如下所示:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires ...  // as before\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ...\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，这将导致闭引理ClosedLemma停止验证，因为引理现在只对一些序列有效。我们将忽略闭合引理ClosedLemma，直到我们完成反驳引理DisproofLemma。这就证明了，这意味着Dafny能够在这些情况下证明后置条件。因此，我们只需要证明当这些条件不成立时，路径是无效的。我们可以用if语句来表达:\n\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      (further proof)\n   }\n\n\n1\n2\n3\n\n\n如果路径至少有两个元素长，第一个元素是根root元素，最后一个元素是目标goal元素，那么我们就有了进一步的证明。如果这些条件没有满足(也就是说，如果if语句的保护为false，并且控制在隐式else分支中继续)，Dafny将自己证明后置条件(高级备注:你可以通过临时添加语句assume false来检查这一点;在if的then分支中)。现在我们只需要填入进一步的证明部分。在这样做时，我们可以假定if语句的保护条件。我们现在可以使用和上面一样的归纳技巧。\n\n如果序列从根root节点开始，并在目标节点goal结束，则它不能有效，因为序列必须在某个点上有一个不在前一个节点下一个列表中的节点。当我们得到任何像这样的特定序列时，我们可以将它分为两种情况:要么序列在从第一个节点到第二个节点的链接中无效，要么它在一行中的某个地方被打断了。就像在计数示例中一样，Dafny可以看到，如果第一个到第二个节点链接无效，那么序列就不能是路径，因为这反映了路径path的定义。因此，只有当第一个链接有效时，我们才有进一步的工作要做。我们可以用另一个if语句来表达:\n\nif 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         (yet further proof)\n      }\n   }\n\n\n1\n2\n3\n4\n5\n\n\n这里是归纳induction。我们知道p[0] == root, p[1] in p[0].next.中。我们还从子图的根root in subgraph的先决条件知道。因此，由于闭子图 closed(subgraph)，我们知道p[1] in subgraph 。这些条件和我们开始时是一样的!我们现在面对的是同一个问题的一个小版本。我们可以递归地调用反证明引理DisproofLemma来证明p[1..不是一条路。这意味着，根据路径path的定义，p不能是路径，并且满足第二个后置条件。这可以实现为:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n现在闭引理DisproofLemma被验证了，随着测试前提的移除，我们看到闭引理ClosedLemma也被验证了。由此证明了封闭子图不存在从内部到外部的路径。\n\n当一个引理需要无限次实例化时，forall语句是有用的。这个例子展示了forall语句的一个简单版本。要了解更高级的版本，请参见Leino的《Dafny中的良好基础函数和极端谓词:教程》，iwill -2015，或Dafny测试套件中的示例。\n\n永远记得检查你的引理是否足以证明你需要的。没有什么比花时间做引理验证，结果发现你需要更强大的东西更令人沮丧的了。这也可以让你避免创建一个带有前置条件的引理，因为前置条件的限制太大，以至于你不能在需要的地方调用它。",normalizedContent:"# 引理和归纳\n\n\n# 引言\n\n有时需要一些逻辑步骤来证明一个程序是正确的，但是对于dafny来说，这些步骤太复杂了。当这种情况发生时，我们通常可以通过提供引理来帮助dafny证明程序。\n\n引理是用来证明另一个结果的定理，而不是用来证明本身。他们允许dafny将证明分成两部分:证明引理，然后用引理来证明最终结果;最后的结果就是程序正确性的证明。通过这样分割它，你可以防止dafny试图证明远超它证明能力的程序。总的来说，dafny和计算机在处理一堆具体细节情况方面都做得很好，但它缺乏看到能使证明过程变得更容易的中间步骤的能力。\n\n通过使用引理，你可以找出这些中间步骤是什么，以及什么时候在程序使用它们。对于有关归纳论证的问题来说，lemma无疑是对症下药的一剂良方。\n\n\n# 零搜索\n\n我们首次接触引理，先来学习一个简单的例子:在数组中搜索零。这个问题有趣在于我们正在搜索的这个数组有两个特殊的属性: 所有元素都是非负的。 每个连续元素最多比前一个元素小一。 在代码:\n\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n{\n}\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n有这样的一堆要求条件，我们可以用一些聪明的方法:我们可以跳过元素。假设我们正在遍历数组，看到a[j] == 7。然后我们知道6 <= a[j+1]，5 <= a[j+2]，等等。事实上，下一个0要等到数组中7个元素全部走一遍时才会出现。所以我们甚至不需要刻意寻找0只用一直a[j+a[j]]就行了。所以我们可以这样写一个循环:\n\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这段代码将计算得到正确的结果，但是dafny在第二个循环不变量报错。dafny并不认为跳过所有这些元素是合理的。原因是，前置条件说的是：每个连续的元素最多减一，但它没有说间隔更远的元素是如何关联的。为了让dafny相信这事实，我们需要使用引理。\n\n\n# 引理\n\n引理其实就是个ghost方法。引理(更准确地说，引理的结论)所要求的性质被声明为后置条件，就像在普通方法声明的一样。与方法不同，引理永远不会被改变状态。因为引理是ghost方法，所以不需要在运行时调用它，所以编译器在生成可执行代码之前会删除、无视它。因此，引理的存在仅仅是因为它对程序验证有一定作用。一个典型的引理长这样的:\n\nlemma lemma(...)\n   ensures (desirable property)\n{\n   ...\n}\t\t\t\t\n\n\n1\n2\n3\n4\n5\n\n\n对于零搜索问题，理想的性质是在index + a[index]之前，index中的元素都不能为零。按照findzero的requierments，我们将数组和起始索引作为参数:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   //...\n}\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n后置条件就是我们想要的属性。i有额外限制是因为j + a[j]可能超过了数组的末尾。我们只想讨论这个范围内的下标也就是数组中的下标。然后我们做了一个关键的步骤:检查我们的引理是否足以证明循环不变量。通过在填充引理体之前进行检查，我们确保我们试图证明的是正确的东西。findzero方法变成:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   //...\n}\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n现在，dafny没有报错findzero方法，因为引理的后置条件显示循环不变式被保留了。但它对引理本身报错，这并不奇怪，因为主体是空的。为了让dafny接受引理，我们必须证明后置条件为真。就像我们在dafny中做的所有事情一样:编写代码。\n\n我们从数组的关键属性开始，因为零搜索问题中的元素都只会缓慢下降。我们可以通过使用断言来询问某些属性是否存在。例如，我们可以看到dafny知道:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length - 3\n   // note: the above has been changed so that the array indices below are good.\n{\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n\n\n1\n2\n3\n4\n5\n\n\n因此，我们可以看到，dafny可以跟随任何单独的步骤，甚至可以适当地链。但是我们需要的步数不是恒定的:它可能取决于a[j]的值。但是我们已经有了一个用于处理可变数量步骤的构造:while循环!\n\n我们可以用同样的结构让dafny把步骤连在一起。我们想要从j迭代到j + a[j]，同时跟踪下界。我们还会跟踪到我们目前看到的所有元素都不为零的事实:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall k :: j <= k < j + a[j] && k < a.length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.length\n      invariant i < a.length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n   var i := j;\n   while i < j + a[j] && i < a.length\n      invariant i < a.length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n第一个不变式给出当前元素的边界，如果我们还没有跑到数组的末尾。对于超过j的每一个索引(其中有i-j)，数组元素可以小一，因此从a[j]中减去这个值。这只是说当前元素不能为零，所以如果没有第二个不变量，dafny就不能知道数组里没有零。dafny忘记了循环执行的所有内容，除了在不变量中给出的内容，所以我们需要建立这样一个事实，即到目前为止，任何地方都没有零。 循环体只是使计数器加1。正如我们之前看到的，dafny能够自己计算出每一步，所以我们不需要做任何进一步的操作。我们只需要给它一个需要证明的结构。有时，单个步骤本身就足够复杂到它们需要自己的子证明，通过使用一系列断言语句或整个其他引理。\n\n在使用数组时，迭代是许多问题的自然解决方案。但是，有时会使用递归来定义函数或属性。在这些情况下，引理通常具有相同的递归结构。为了看一个例子，我们将考虑计数的问题。\n\n\n# 计数\n\n我们将使用count函数在一个bool序列中计算true的数量，如下所示:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m()\n{\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n...\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n代码非常简单，但需要注意的一点是，该函数是递归定义的。像这样的递归函数很容易需要引理。我们希望在验证使用此函数的程序时能够使用count的一个属性:它应用于加法上。我们的意思是:\n\nforall a, b :: count(a + b) == count(a) + count(b)\n\n\n1\n\n\n这里，第一个加号(+)是序列拼接，第二个加号是整数相加。显然，我们可以将任意序列分解为两个序列a和b，分别计算它们，并将结果相加。这是事实，但dafny无法直接证明。问题是函数并没有以这种方式分割序列。该函数取第一个元素，计算其计数，然后将其添加到序列的其余部分。如果a很长，那么在这个展开过程实际到达count(b)之前可能需要一段时间，因此dafny只尝试展开几个递归调用。(确切地说，是两个。参见amin, leino, and rompf的论文computing with an smt solver, tap 2014。)这是一个需要引理来证明的性质的例子。\n\n在我们的例子中,我们有两个选择引理:我们也可以写全称量词,或者我们可以使引理特定序列a和b。事实证明,当我们想要分配律,我们不需要完整的通用属性。我们感兴趣的是，对于程序中已知的两个特定的a和b, count(a + b) == count(a) + count(b)。因此，当我们调用引理来得到这个性质时，我们可以告诉它我们感兴趣的是哪两个序列。如果我们在其他地方有不同的序列，我们可以用不同的参数调用方法，就像普通方法一样。事实证明，证明完整的全称性质，虽然是可能的，但比证明具体的，具体的情况要复杂得多，所以我们先来处理这个情况。\n\n因此引理应该将感兴趣的序列作为参数，后置条件如下:\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\n\n\n1\n2\n3\n4\n\n\n\n# 证明分配性质\n\n为了写出引理，我们必须想出一个证明它的方法。正如您可以在上面验证的(没有双关语)，引理还不能工作，否则引理将是不必要的。为了做到这一点，我们注意到dafny无法首先证明这一点的原因是count函数从序列的开始定义，而分配律则在序列的中间操作。因此，如果我们能找到一种从序列的前面开始工作的方法，那么dafny就可以直接使用函数的定义。这个序列的第一个元素是什么?在一些情况下，a和b是空序列(如果有的话)。因此我们的引理必须考虑多种情况，引理的共同特征。我们注意到，如果a ==[]，那么a+ b == b，不管b是多少。引理处理情况的方式与代码处理情况的方式相同:if语句。下面使用断言给出了所需属性的简短证明。\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n      assert count(a) == 0;\n      assert count(a + b) == count(b);\n      assert count(a + b) == count(a) + count(b);\n   }\n   else\n   {\n      //...\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nif a == []\n{\n   assert a + b == b;\n   assert count(a) == 0;\n   assert count(a + b) == count(b);\n   assert count(a + b) == count(a) + count(b);\n}\nelse\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在这种情况下，我们可以通过添加一个requires子句来检验引理。我们发现代码验证。这意味着如果a ==[]，则引理将正确地证明后置条件。在这种情况下，只需要上面的第一个断言;dafny自己完成了剩下的步骤(试试吧!)现在我们可以考虑另一种情况，当0 < |a|。\n\n我们的目标是将count(a + b)与count(a)和count(b)联系起来。如果a不是空序列，那么当我们按照定义展开count(a + b)时，我们得到:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert a + b == [a[0]] + (a[1..] + b);\n   assert count(a + b) == count([a[0]]) + count(a[1..] + b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nassert a + b == [a[0]] + (a[1..] + b);\nassert count(a + b) == count([a[0]]) + count(a[1..] + b);\n\n\n1\n2\n\n\n注意，我们得到count([a[0]])和a[1..]。如果我们扩展count(a)，这两项也会出现。具体地说:\n\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert count(a) == count([a[0]]) + count(a[1..]);\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nassert count(a) == count([a[0]]) + count(a[1..]);\n\n\n1\n\n\n最后，我们可以将count(a)的定义替换为后置条件，以获得:\n\nassert count(a + b) == count(a) + count(b); // postcondition\nassert count(a + b) == count([a[0]]) + count(a[1..]) + count(b);\n\n\n1\n2\n\n\n现在这看起来很像我们展开count(a + b)后得到的表达式。唯一的区别是count(a[1.. .) + count(a[1..]) + count(b)。但这正是我们要证明的性质!\n\n\n# 归纳\n\n我们试图提出的论点是归纳的。我们可以证明我们的目标，只要这个问题的一个小版本是正确的。这正是归纳法的概念:用一个小问题来证明一个大问题。为此，我们在代码中调用递归属性。它是一个方法，所以我们可以在需要它的时候调用它。\n\ndafny将假定递归调用满足规范。这就是归纳假设，所有引理的递归调用都是有效的。这关键取决于dafny也证明了终止。这意味着最终，引理不会再进行递归调用。在本例中，这是if语句的第一个分支。如果没有递归调用，那么引理必须直接证明这种情况。然后，堆栈中的每个调用都是合理的，假设引理适用于较小的情况。如果dafny没有证明链终止，那么链可以永远继续，并且对于每个调用的假设都是不合理的。\n\n归纳法通常是寻找一种方法，一步一步地建立你的目标。从另一个角度来看，它证明了你的目标是一个更小的版本。通过一次分解一个元素，直到第一个序列完全消失，证明了分配引理。这种情况被证明是一个基本情况，然后整个链的解构被验证。\n\n成功的关键是dafny从来不用考虑整个通话链。通过检验终止，得到链是有限的。然后它要做的就是检查一步。如果任意一步是有效的，那么整个链也是有效的。这与dafny在循环中使用的逻辑相同:检查初始不变项是否成立，任意一个步骤是否保持不变，然后检查整个循环，不管循环循环了多少次。这种相似性不仅仅是表面的。这两种引理(以及dafny对程序的两种推理)都是归纳的。考虑到迭代和递归作为实现同一目标的两种方法之间的关系，这也不足为奇。\n\n记住这一点，我们可以通过在if语句的else分支中递归地调用引理来完成引理:\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      distributivelemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n  if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      distributivelemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n现在这个引理得到了验证。但是如果我们想要表达每一对序列都是这样联系的呢?为了做到这一点，我们必须看看引理在dafny中的另一种用法，我们将用另一个例子来探索。\n\n\n# 有向图的路径\n\n作为最后一个更高级的例子，我们将证明一个关于有向图中路径的性质。为此，我们有机会称一个引理在所有节点序列上是普遍的。一个有向图由若干个节点组成，每个节点都有一些到其他节点的链接。这些链接是单向的，对它们的唯一限制是节点不能链接到自己。节点定义为:\n\nclass node\n{\n   // a single field giving the nodes linked to\n   var next: seq<node>\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们将图表示为一组节点，这些节点只指向图中的其他节点，而不指向自己。我们称这样一组节点为封闭的:\n\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==>\n      forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们将路径表示为非空节点序列，其中每个节点都与路径中的前一个节点相连。我们定义了两个谓词，一个用于定义有效路径，另一个用于确定给定路径是否为图中两个特定节点之间的有效路径:\n\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n现在我们准备好陈述我们要证明的引理了。我们考虑一个图和一个子图:一个也构成一个图的节点的子集。这个子图必须是封闭的，即不包含自身之外的链接。如果我们有这样的情况，那么从子图中的一个节点到子图之外的一个节点不可能有一条有效的路径。我们将这个事实称为闭合引理，我们在dafny中这样表述:\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   //...\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n前提条件说明了所有的要求:图和子图都是有效的，根节点在子图中但目标不在，所有内容都包含在主图中。后置条件声明没有从根到目标的有效路径。这里我们只对特定的开始/结束节点对证明它。\n\n证明某物不存在的一种方法是证明给定的任意节点序列它不是一个有效路径。我们可以用，你猜对了，另一个引理。这个引理将证明，对于任何给定的序列，它不是从根root到目标goal的有效路径。路径引理的反证如下:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n前提与闭引理相同。要在闭引理closedlemma中使用反证明引理disprooflemma，我们需要对每个节点序列调用它一次。这可以通过dafny的forall语句来完成，该语句聚合了给定绑定变量的所有值对其主体的影响。\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph =\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   ...\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如你所见，这使得闭引理closedlemma得到验证，所以我们对引理的测试是成功的。因此，反证明引理disprooflemma是足够强的，我们的工作仅仅是证明它。\n\n有几种不同的方式可以使节点序列成为无效路径。如果路径为空，则它不能是有效路径。此外，路径的第一个元素必须是根root，最后一个元素必须是目标goal。因为root in subgraph，goal !in subgraph，我们必须有root != goal，所以序列必须至少有两个元素。为了验证dafny是否看到了这一点，我们可以临时在引理上加上先决条件，如下所示:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires ...  // as before\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ...\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，这将导致闭引理closedlemma停止验证，因为引理现在只对一些序列有效。我们将忽略闭合引理closedlemma，直到我们完成反驳引理disprooflemma。这就证明了，这意味着dafny能够在这些情况下证明后置条件。因此，我们只需要证明当这些条件不成立时，路径是无效的。我们可以用if语句来表达:\n\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      (further proof)\n   }\n\n\n1\n2\n3\n\n\n如果路径至少有两个元素长，第一个元素是根root元素，最后一个元素是目标goal元素，那么我们就有了进一步的证明。如果这些条件没有满足(也就是说，如果if语句的保护为false，并且控制在隐式else分支中继续)，dafny将自己证明后置条件(高级备注:你可以通过临时添加语句assume false来检查这一点;在if的then分支中)。现在我们只需要填入进一步的证明部分。在这样做时，我们可以假定if语句的保护条件。我们现在可以使用和上面一样的归纳技巧。\n\n如果序列从根root节点开始，并在目标节点goal结束，则它不能有效，因为序列必须在某个点上有一个不在前一个节点下一个列表中的节点。当我们得到任何像这样的特定序列时，我们可以将它分为两种情况:要么序列在从第一个节点到第二个节点的链接中无效，要么它在一行中的某个地方被打断了。就像在计数示例中一样，dafny可以看到，如果第一个到第二个节点链接无效，那么序列就不能是路径，因为这反映了路径path的定义。因此，只有当第一个链接有效时，我们才有进一步的工作要做。我们可以用另一个if语句来表达:\n\nif 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         (yet further proof)\n      }\n   }\n\n\n1\n2\n3\n4\n5\n\n\n这里是归纳induction。我们知道p[0] == root, p[1] in p[0].next.中。我们还从子图的根root in subgraph的先决条件知道。因此，由于闭子图 closed(subgraph)，我们知道p[1] in subgraph 。这些条件和我们开始时是一样的!我们现在面对的是同一个问题的一个小版本。我们可以递归地调用反证明引理disprooflemma来证明p[1..不是一条路。这意味着，根据路径path的定义，p不能是路径，并且满足第二个后置条件。这可以实现为:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         disprooflemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         disprooflemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n现在闭引理disprooflemma被验证了，随着测试前提的移除，我们看到闭引理closedlemma也被验证了。由此证明了封闭子图不存在从内部到外部的路径。\n\n当一个引理需要无限次实例化时，forall语句是有用的。这个例子展示了forall语句的一个简单版本。要了解更高级的版本，请参见leino的《dafny中的良好基础函数和极端谓词:教程》，iwill -2015，或dafny测试套件中的示例。\n\n永远记得检查你的引理是否足以证明你需要的。没有什么比花时间做引理验证，结果发现你需要更强大的东西更令人沮丧的了。这也可以让你避免创建一个带有前置条件的引理，因为前置条件的限制太大，以至于你不能在需要的地方调用它。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"模块",frontmatter:{title:"模块",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/9d19b8/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/05.%E6%A8%A1%E5%9D%97.html",relativePath:"30.教程/10.Dafny进阶语法/05.模块.md",key:"v-2472a78b",path:"/pages/9d19b8/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:9},{level:2,title:"声明新模块",slug:"声明新模块",normalizedTitle:"声明新模块",charIndex:145},{level:2,title:"导入和导出模块",slug:"导入和导出模块",normalizedTitle:"导入和导出模块",charIndex:1598},{level:3,title:"导出集合",slug:"导出集合",normalizedTitle:"导出集合",charIndex:2417},{level:3,title:"导出一致性",slug:"导出一致性",normalizedTitle:"导出一致性",charIndex:5402},{level:2,title:"开放模板",slug:"开放模板",normalizedTitle:"开放模板",charIndex:6683},{level:2,title:"抽象模块",slug:"抽象模块",normalizedTitle:"抽象模块",charIndex:8019},{level:2,title:"模块排序和依赖关系",slug:"模块排序和依赖关系",normalizedTitle:"模块排序和依赖关系",charIndex:9359},{level:2,title:"名字分解",slug:"名字分解",normalizedTitle:"名字分解",charIndex:10172}],headersStr:"介绍 声明新模块 导入和导出模块 导出集合 导出一致性 开放模板 抽象模块 模块排序和依赖关系 名字分解",content:"# 模块\n\n\n# 介绍\n\n将程序分解成多个部分来构造它是创建大型程序的重要部分。在Dafny中，这是通过模块实现的。模块提供了一种将相关类型、类、方法、函数和其他模块组合在一起的方法，以及控制声明的作用域。模块可以相互导入以实现代码重用，并且可以对模块进行抽象以将实现与接口分离。\n\n\n# 声明新模块\n\nDeclaring New Modules声明新模块 一个新模块是用module关键字声明的，后面跟着新模块的名字，还有一对括住模块主体的花括号({}):\n\nmodule Mod {\n  ...\n}\n\n\n1\n2\n3\n\n\n模块主体可以包含任何可以放在顶层的内容。这包括类、数据类型、类型、方法、函数等。\n\nmodule Mod {\n  class C {\n    var f: int;\n    method m()\n  }\n  datatype Option = A(int) | B(int)\n  type T\n  method m()\n  function f(): int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n你也可以将一个模块嵌套到另一个模块中:\n\nmodule Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后，你可以在Mod模块中引用Helpers模块的成员，方法是在它们前面加上\" Helpers \"。例如:\n\nmodule Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int;\n    }\n  }\n  method m() {\n    var x := new Helpers.C;\n    x.doIt();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmodule Mod {\n  module Helpers { ... }\n  method m() {\n    var x := new Helpers.C;\n    x.doIt();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在模块级别定义的方法和函数可以像类一样使用，只是模块名作为前缀。它们也可以在同一个模块中的类的方法和函数中使用。\n\nmodule Mod {\n  module Helpers {\n    function method addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x); // x is now 6\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n默认情况下，函数(和谓词)的定义在定义它们的模块外部公开。这可以通过导出集进行更精确的控制，我们将在下一节中看到。所以增加\n\nmodule Mod {\n  module Helpers {\n    function method addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x);\n    assert x == 6; // this will succeed\n  }\n}\n\n  assert x == 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以m()结尾将进行验证。\n\n\n# 导入和导出模块\n\n声明新的子模块是有用的，但有时您希望引用来自现有模块的内容，比如库。在这种情况下，您可以将一个模块导入另一个模块。这是通过import关键字完成的，有几种不同的形式，每一种都有不同的含义。最简单的形式是具体的导入,导入形式A = B这个模块声明创建一个引用B(必须已经存在),并结合新名称注意这个新名称,例如 A,,只有绑定模块包含导入声明;它不会创建全局别名。例如，如果helper是在Mod之外定义的，那么我们可以导入它:\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n\nmodule Helpers {\n  ...\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意，在m()中，我们必须使用A而不是helper，因为我们将它绑定到一个不同的名称。名称Helpers在m()中不可用，因为只有在Mod中绑定的名称才可用。为了使用来自另一个模块的成员，它要么必须用module声明，要么用import导入。\n\n不过，如果我们不想给Helpers起个新名字，也不必。如果需要，可以编写import Helpers = Helpers, Dafny甚至为这种行为提供了简便的import Helpers。您不能同时绑定两个具有相同名称的模块，因此有时必须使用= 版本号以确保名称不会冲突。\n\n\n# 导出集合\n\n默认情况下，导入import将允许访问被导入模块的所有声明(及其定义)。为了更精确地控制这一点，我们可以使用导出export集。每个导出export集可能有当前模块的声明列表，以provides或reveals的形式给出。没有名称的导出export被认为是该模块的默认导出，并且在没有显式命名集合时使用。\n\nmodule Helpers {\n  export Spec provides addOne, addOne_result\n  export Body reveals addOne\n  export extends Spec\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addOne_result(n : nat)\n     ensures addOne(n) == n + 1\n  { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在这个例子中，我们声明了3个导出集，Spec 集授予了对addOne函数的访问权，但是由于它是用provides声明的，所以它没有授予对其定义的访问权。Body导出集将addOne声明为reveals，现在可以访问addOne的bdoy部分。最后，默认导出作为Spec的扩展extends给出，这表明它只是给出Spec所声明的所有导出。\n\n我们现在可以在导入helper时选择这些导出集中的任何一个，并获得它的不同视图。\n\nmodule Helpers {\n  export Spec provides addOne, addOne_result\n  export Body reveals addOne\n  export extends Spec\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addOne_result(n: nat)\n     ensures addOne(n) == n + 1\n  { }\n}\n\nmodule Mod1 {\n  import A = Helpers`Body\n  method m() {\n    assert A.addOne(5) == 6; // succeeds, we have access to addOne's body\n  }\n  method m2() {\n    //A.addOne_result(5); // error, addOne_result is not exported from Body\n    assert A.addOne(5) == 6;\n  }\n}\nmodule Mod2 {\n  import A = Helpers`Spec\n  method m() {\n    assert A.addOne(5) == 6; // fails, we don't have addOne's body\n  }\n  method m2() {\n    A.addOne_result(5);\n    assert A.addOne(5) == 6; // succeeds due to result from addOne_result\n  }\n}\nmodule Mod3 {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6; // fails, we don't have addOne's body\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n我们还可以使用导出集export sets 来控制可用的类型定义。所有类型声明(如newtype、type、datatype等)都可以导出为提供provides或显示。在前一种情况下，导入该类型的模块将其视为不透明类型。\n\nmodule Helpers {\n  export provides f, T\n  export Body reveals f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  import A = Helpers\n  function g(): A.T { 0 } // error, T is not known to be int, or even numeric\n  function h(): A.T { A.f() } // okay\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一旦导入export了显示reveals以前不透明类型的导出，则已知对它的所有现有使用都是内部类型。\n\nmodule Helpers {\n  export provides f, T\n  export Body reveals f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\nmodule Mod2 {\n  import M = Mod\n  import A = Helpers`Body\n  function j(): int\n    ensures j() == 0 //succeeds\n  { M.h() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n作为一种方便的简写方式，特殊标识符“*”可以在提供provides或揭示reveals之后给出，以表示所有声明都应该提供或揭示。\n\nmodule A {\n   export All reveals * // reveals T, f, g\n   export Spec provides * // provides T, f, g\n   export Some provides * reveals g // provides T, f reveals g\n   type T = int\n   function f(): T { 0 }\n   function g(): int { 2 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们还可以一次提供多个导出来创建一个聚合导入(aggregate import).\n\nmodule A {\n  export Justf reveals f\n  export JustT reveals T\n  type T = int\n  function f(): int { 0 }\n}\nmodule B {\n  import A`{Justf,JustT}\n  function g(): A.T { A.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 导出一致性\n\n导出集(export set)必须始终呈现模块的一致视图:任何出现在导出声明中的内容都必须被导出。回顾前面的示例，我们不能创建一个既显示f(reveals f)又显示T的导出集export set。原因很简单，我们将创建一个类型约束0:T，如果T是不透明的，则无法解决这个约束。类似地，如果不提供T，则不能创建提供provides或揭示f reveals f的导出集。\n\nmodule Helpers {\n  export provides f, T // good\n  export Body reveals f, T // good\n  export BadSpec reveals f, provides T // bad\n  export BadSpec2 provides f // bad\n  type T = int\n  function f(): T { 0 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于我们可以定义同时包含导入import和导出export声明的模块，因此我们可能需要从外部模块导出声明，以创建一致的导出集export set。外部模块的声明不能直接包含在导出export中，但是提供它们的导入import可以。\n\nmodule Helpers {\n  export provides f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  export Try1 reveals h // error\n  export Try2 reveals h, provides A.f, A.T // error, can't provide these directly\n  export reveals h, provides A // good\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当导入Mod时，我们现在也获得了对其导入a import a中所提供的内容的合格访问权。我们也可以选择直接导入这些内容，给它们一个更短的名称。\n\nmodule Helpers {\n  export provides f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  export reveals h, provides A\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\nmodule Mod2 {\n  import M = Mod\n  import MA = M.A\n  function j(): M.A.T { M.h() }\n  function k(): MA.T { j() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 开放模板\n\n有时，为导入的模块的成员加上名称前缀是乏味且难看的，即使您在导入时选择了一个简短的名称。在这种情况下，您可以将模块导入为“opened”，这将使其所有成员都可用，而无需添加模块名称。opened关键字必须紧跟在import之后，如果它存在的话。例如，我们可以将前面的addOne示例写为:\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\n\nmodule Mod {\n  import opened Helpers\n  method m() {\n    assert addOne(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当打开模块时，新绑定的成员将具有较低的优先级，因此它们将被局部定义隐藏。这意味着，如果您定义了一个名为addOne的局部函数，则helper中的函数将不再以该名称提供。当模块被打开时，原始的名称绑定仍然存在，所以您总是可以使用绑定的名称来获取任何隐藏的内容。\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened Helpers\n  function addOne(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert Helpers.addOne(5) == 6; // this is still true\n  }\n}\n\nmodule Mod {\n  import opened Helpers\n  function addOne(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert Helpers.addOne(5) == 6; // this is still true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n如果打开两个都声明具有相同名称的成员的模块，那么在没有模块前缀的情况下，这两个成员都不能被引用，因为哪个成员的含义是不明确的。不过，只要您不试图使用具有共同名称的成员，仅仅打开这两个模块就不会出现错误。opened关键字可以用于任何类型的导入import声明，包括模块抽象形式。\n\n\n# 抽象模块\n\n有时，使用特定的实现是不必要的;相反，所需要的只是一个实现某些接口的模块。在这种情况下，您可以使用抽象模块导入。在Dafny,这是写import A : B.。这意味着绑定名称A,而是得到确切的模块B,你得到任何模块的细化B .通常情况下,模块B可能抽象类型定义,包含脱胎方法的类,或者直接不适合使用。由于细化的定义方式，B的任何细化都可以安全地使用。例如，如果我们以:\n\nabstract module Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果我们知道addSome实际上正好加了1，我们就可以更精确了。下面的模块具有这种行为。此外，后置条件更强，因此这实际上是对Interface模块的改进。\n\nmodule Implementation refines Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后，我们可以在一个新的模块中用Implementation代替A，通过声明Mod的精炼，它定义了A的Implementation。\n\nabstract module Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\nmodule Implementation refines Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule Mod2 refines Mod {\n  import A = Implementation\n  method m() {\n    ...;\n    // this is now provable, because we know A is Implementation\n    assert 6 == A.addSome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n当你将一个抽象导入细化到一个具体的导入时，具体模块必须是抽象模块的显式细化(例如，用refines声明)。\n\n\n# 模块排序和依赖关系\n\nDafny并不特别关注模块出现的顺序，但它们必须遵循一些规则才能形成良好的结构。作为一个经验法则，应该有一种方法来对程序中的模块进行排序，以便每个模块只引用源文本中在它之前定义的东西。这并不意味着模块必须按这个顺序排列。如果你没有做任何循环引用，Dafny会帮你弄清楚顺序的。例如，这显然毫无意义:\n\nimport A = B\nimport B = A\n\n\n1\n2\n\n\n你可以在顶层有import语句，也可以导入在同一层定义的模块:\n\nimport A = B\nmethod m() {\n  A.whatever();\n}\nmodule B {\n  method whatever() {}\n}\n\nimport A = B\nmethod m() {\n  A.whatever();\n}\nmodule B { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在本例中，所有内容都定义得很好，因为我们可以先放B，然后是A导入，最后是m()。如果没有顺序，那么Dafny将给出一个错误，抱怨循环依赖关系。 请注意，当重新排列模块和导入时，它们必须保持在相同的包含模块中，这就不允许一些病态的模块结构。此外，导入和子模块总是被认为是最前面的，即使在顶层也是如此。这意味着以下内容不是很好的格式:\n\nmethod doIt() { }\nmodule M {\n  method m() {\n    doIt();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为模块M必须出现在任何其他类型的成员之前，比如方法。要像这样定义全局函数，您可以将它们放在一个模块(比如称为Globals)中，并将其打开到任何需要其功能的模块中。最后，如果您通过路径导入，例如import a = B.C那么这将创建a对B的依赖关系，因为我们需要知道B是什么(它是抽象的还是具体的，还是细化的?)\n\n\n# 名字分解\n\n(待办事项:以下内容已在Dafny更改。这里的描述应该改变以反映新的规则。)\n\n当Dafny看到像A.B.C这样的东西时，它怎么知道每个部分指的是什么?Dafny用来确定这样的标识符序列所引用的是名称解析。虽然规则可能看起来很复杂，但它们通常都符合您的预期。Dafny首先查找初始标识符。根据第一个标识符引用的内容，将在适当的上下文中查找标识符的其余部分。具体规则如下: 局部变量、参数和绑定变量。这些是x y和i在var x;，... returns (y: int)，forall i :: ... 数据类型和模块名(如果这不是标识符的唯一部分)。类允许以这种方式访问它们的静态成员，数据类型允许访问它们的构造函数。模块允许像这样引用它们的任何成员 构造函数名称(如果没有歧义)。任何不需要限定的数据类型(因此数据类型名称本身不需要前缀)，以及具有唯一命名构造函数的数据类型，都可以通过其名称引用。所以如果datatype List = Cons(List) | Nil是唯一声明 Cons和Nil构造函数的数据类型，那么你可以写Cons(Cons(Nil))。如果构造函数名不是唯一的，则需要在其前面加上数据类型的名称(例如List.Cons(List.Nil))。这是每个构造函数完成的，而不是每个数据类型。 当前类的字段、函数和方法(如果在静态上下文中，则只允许静态方法和函数)。您可以这样引用当前类的字段this.f或者f，当然假设f没有被上面的任何一个隐藏。如果需要，您总是可以加上前缀this，但不能隐藏它。(注意，名称是数字字符串的字段必须总是有一些前缀。) 封闭模块中的静态函数和方法。注意，这只引用在模块级声明的函数和方法，而不是命名类的静态成员。 打开的模块在每一层处理，在当前模块的声明之后。打开的模块只影响步骤2、3和5。如果发现有歧义的名称，将生成一个错误，而不是继续沿着列表向下。在第一个标识符之后，规则基本上是相同的，除了在新的上下文中。例如，如果第一个标识符是一个模块，那么下一个标识符将查看该模块。打开的模块只适用于它被打开的模块。在查找另一个模块时，只考虑在该模块中显式声明的内容。",normalizedContent:"# 模块\n\n\n# 介绍\n\n将程序分解成多个部分来构造它是创建大型程序的重要部分。在dafny中，这是通过模块实现的。模块提供了一种将相关类型、类、方法、函数和其他模块组合在一起的方法，以及控制声明的作用域。模块可以相互导入以实现代码重用，并且可以对模块进行抽象以将实现与接口分离。\n\n\n# 声明新模块\n\ndeclaring new modules声明新模块 一个新模块是用module关键字声明的，后面跟着新模块的名字，还有一对括住模块主体的花括号({}):\n\nmodule mod {\n  ...\n}\n\n\n1\n2\n3\n\n\n模块主体可以包含任何可以放在顶层的内容。这包括类、数据类型、类型、方法、函数等。\n\nmodule mod {\n  class c {\n    var f: int;\n    method m()\n  }\n  datatype option = a(int) | b(int)\n  type t\n  method m()\n  function f(): int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n你也可以将一个模块嵌套到另一个模块中:\n\nmodule mod {\n  module helpers {\n    class c {\n      method doit()\n      var f: int;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后，你可以在mod模块中引用helpers模块的成员，方法是在它们前面加上\" helpers \"。例如:\n\nmodule mod {\n  module helpers {\n    class c {\n      method doit()\n      var f: int;\n    }\n  }\n  method m() {\n    var x := new helpers.c;\n    x.doit();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmodule mod {\n  module helpers { ... }\n  method m() {\n    var x := new helpers.c;\n    x.doit();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在模块级别定义的方法和函数可以像类一样使用，只是模块名作为前缀。它们也可以在同一个模块中的类的方法和函数中使用。\n\nmodule mod {\n  module helpers {\n    function method addone(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := helpers.addone(x); // x is now 6\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n默认情况下，函数(和谓词)的定义在定义它们的模块外部公开。这可以通过导出集进行更精确的控制，我们将在下一节中看到。所以增加\n\nmodule mod {\n  module helpers {\n    function method addone(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := helpers.addone(x);\n    assert x == 6; // this will succeed\n  }\n}\n\n  assert x == 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以m()结尾将进行验证。\n\n\n# 导入和导出模块\n\n声明新的子模块是有用的，但有时您希望引用来自现有模块的内容，比如库。在这种情况下，您可以将一个模块导入另一个模块。这是通过import关键字完成的，有几种不同的形式，每一种都有不同的含义。最简单的形式是具体的导入,导入形式a = b这个模块声明创建一个引用b(必须已经存在),并结合新名称注意这个新名称,例如 a,,只有绑定模块包含导入声明;它不会创建全局别名。例如，如果helper是在mod之外定义的，那么我们可以导入它:\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule mod {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6;\n  }\n}\n\nmodule helpers {\n  ...\n}\nmodule mod {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意，在m()中，我们必须使用a而不是helper，因为我们将它绑定到一个不同的名称。名称helpers在m()中不可用，因为只有在mod中绑定的名称才可用。为了使用来自另一个模块的成员，它要么必须用module声明，要么用import导入。\n\n不过，如果我们不想给helpers起个新名字，也不必。如果需要，可以编写import helpers = helpers, dafny甚至为这种行为提供了简便的import helpers。您不能同时绑定两个具有相同名称的模块，因此有时必须使用= 版本号以确保名称不会冲突。\n\n\n# 导出集合\n\n默认情况下，导入import将允许访问被导入模块的所有声明(及其定义)。为了更精确地控制这一点，我们可以使用导出export集。每个导出export集可能有当前模块的声明列表，以provides或reveals的形式给出。没有名称的导出export被认为是该模块的默认导出，并且在没有显式命名集合时使用。\n\nmodule helpers {\n  export spec provides addone, addone_result\n  export body reveals addone\n  export extends spec\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addone_result(n : nat)\n     ensures addone(n) == n + 1\n  { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在这个例子中，我们声明了3个导出集，spec 集授予了对addone函数的访问权，但是由于它是用provides声明的，所以它没有授予对其定义的访问权。body导出集将addone声明为reveals，现在可以访问addone的bdoy部分。最后，默认导出作为spec的扩展extends给出，这表明它只是给出spec所声明的所有导出。\n\n我们现在可以在导入helper时选择这些导出集中的任何一个，并获得它的不同视图。\n\nmodule helpers {\n  export spec provides addone, addone_result\n  export body reveals addone\n  export extends spec\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addone_result(n: nat)\n     ensures addone(n) == n + 1\n  { }\n}\n\nmodule mod1 {\n  import a = helpers`body\n  method m() {\n    assert a.addone(5) == 6; // succeeds, we have access to addone's body\n  }\n  method m2() {\n    //a.addone_result(5); // error, addone_result is not exported from body\n    assert a.addone(5) == 6;\n  }\n}\nmodule mod2 {\n  import a = helpers`spec\n  method m() {\n    assert a.addone(5) == 6; // fails, we don't have addone's body\n  }\n  method m2() {\n    a.addone_result(5);\n    assert a.addone(5) == 6; // succeeds due to result from addone_result\n  }\n}\nmodule mod3 {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6; // fails, we don't have addone's body\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n我们还可以使用导出集export sets 来控制可用的类型定义。所有类型声明(如newtype、type、datatype等)都可以导出为提供provides或显示。在前一种情况下，导入该类型的模块将其视为不透明类型。\n\nmodule helpers {\n  export provides f, t\n  export body reveals f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  import a = helpers\n  function g(): a.t { 0 } // error, t is not known to be int, or even numeric\n  function h(): a.t { a.f() } // okay\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n一旦导入export了显示reveals以前不透明类型的导出，则已知对它的所有现有使用都是内部类型。\n\nmodule helpers {\n  export provides f, t\n  export body reveals f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\nmodule mod2 {\n  import m = mod\n  import a = helpers`body\n  function j(): int\n    ensures j() == 0 //succeeds\n  { m.h() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n作为一种方便的简写方式，特殊标识符“*”可以在提供provides或揭示reveals之后给出，以表示所有声明都应该提供或揭示。\n\nmodule a {\n   export all reveals * // reveals t, f, g\n   export spec provides * // provides t, f, g\n   export some provides * reveals g // provides t, f reveals g\n   type t = int\n   function f(): t { 0 }\n   function g(): int { 2 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们还可以一次提供多个导出来创建一个聚合导入(aggregate import).\n\nmodule a {\n  export justf reveals f\n  export justt reveals t\n  type t = int\n  function f(): int { 0 }\n}\nmodule b {\n  import a`{justf,justt}\n  function g(): a.t { a.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 导出一致性\n\n导出集(export set)必须始终呈现模块的一致视图:任何出现在导出声明中的内容都必须被导出。回顾前面的示例，我们不能创建一个既显示f(reveals f)又显示t的导出集export set。原因很简单，我们将创建一个类型约束0:t，如果t是不透明的，则无法解决这个约束。类似地，如果不提供t，则不能创建提供provides或揭示f reveals f的导出集。\n\nmodule helpers {\n  export provides f, t // good\n  export body reveals f, t // good\n  export badspec reveals f, provides t // bad\n  export badspec2 provides f // bad\n  type t = int\n  function f(): t { 0 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于我们可以定义同时包含导入import和导出export声明的模块，因此我们可能需要从外部模块导出声明，以创建一致的导出集export set。外部模块的声明不能直接包含在导出export中，但是提供它们的导入import可以。\n\nmodule helpers {\n  export provides f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  export try1 reveals h // error\n  export try2 reveals h, provides a.f, a.t // error, can't provide these directly\n  export reveals h, provides a // good\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当导入mod时，我们现在也获得了对其导入a import a中所提供的内容的合格访问权。我们也可以选择直接导入这些内容，给它们一个更短的名称。\n\nmodule helpers {\n  export provides f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  export reveals h, provides a\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\nmodule mod2 {\n  import m = mod\n  import ma = m.a\n  function j(): m.a.t { m.h() }\n  function k(): ma.t { j() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 开放模板\n\n有时，为导入的模块的成员加上名称前缀是乏味且难看的，即使您在导入时选择了一个简短的名称。在这种情况下，您可以将模块导入为“opened”，这将使其所有成员都可用，而无需添加模块名称。opened关键字必须紧跟在import之后，如果它存在的话。例如，我们可以将前面的addone示例写为:\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\n\nmodule mod {\n  import opened helpers\n  method m() {\n    assert addone(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当打开模块时，新绑定的成员将具有较低的优先级，因此它们将被局部定义隐藏。这意味着，如果您定义了一个名为addone的局部函数，则helper中的函数将不再以该名称提供。当模块被打开时，原始的名称绑定仍然存在，所以您总是可以使用绑定的名称来获取任何隐藏的内容。\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule mod {\n  import opened helpers\n  function addone(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addone(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert helpers.addone(5) == 6; // this is still true\n  }\n}\n\nmodule mod {\n  import opened helpers\n  function addone(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addone(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert helpers.addone(5) == 6; // this is still true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n如果打开两个都声明具有相同名称的成员的模块，那么在没有模块前缀的情况下，这两个成员都不能被引用，因为哪个成员的含义是不明确的。不过，只要您不试图使用具有共同名称的成员，仅仅打开这两个模块就不会出现错误。opened关键字可以用于任何类型的导入import声明，包括模块抽象形式。\n\n\n# 抽象模块\n\n有时，使用特定的实现是不必要的;相反，所需要的只是一个实现某些接口的模块。在这种情况下，您可以使用抽象模块导入。在dafny,这是写import a : b.。这意味着绑定名称a,而是得到确切的模块b,你得到任何模块的细化b .通常情况下,模块b可能抽象类型定义,包含脱胎方法的类,或者直接不适合使用。由于细化的定义方式，b的任何细化都可以安全地使用。例如，如果我们以:\n\nabstract module interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) > n\n}\nabstract module mod {\n  import a : interface\n  method m() {\n    assert 6 <= a.addsome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果我们知道addsome实际上正好加了1，我们就可以更精确了。下面的模块具有这种行为。此外，后置条件更强，因此这实际上是对interface模块的改进。\n\nmodule implementation refines interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) == n + 1\n  {\n    n + 1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后，我们可以在一个新的模块中用implementation代替a，通过声明mod的精炼，它定义了a的implementation。\n\nabstract module interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) > n\n}\nabstract module mod {\n  import a : interface\n  method m() {\n    assert 6 <= a.addsome(5);\n  }\n}\nmodule implementation refines interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule mod2 refines mod {\n  import a = implementation\n  method m() {\n    ...;\n    // this is now provable, because we know a is implementation\n    assert 6 == a.addsome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n当你将一个抽象导入细化到一个具体的导入时，具体模块必须是抽象模块的显式细化(例如，用refines声明)。\n\n\n# 模块排序和依赖关系\n\ndafny并不特别关注模块出现的顺序，但它们必须遵循一些规则才能形成良好的结构。作为一个经验法则，应该有一种方法来对程序中的模块进行排序，以便每个模块只引用源文本中在它之前定义的东西。这并不意味着模块必须按这个顺序排列。如果你没有做任何循环引用，dafny会帮你弄清楚顺序的。例如，这显然毫无意义:\n\nimport a = b\nimport b = a\n\n\n1\n2\n\n\n你可以在顶层有import语句，也可以导入在同一层定义的模块:\n\nimport a = b\nmethod m() {\n  a.whatever();\n}\nmodule b {\n  method whatever() {}\n}\n\nimport a = b\nmethod m() {\n  a.whatever();\n}\nmodule b { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在本例中，所有内容都定义得很好，因为我们可以先放b，然后是a导入，最后是m()。如果没有顺序，那么dafny将给出一个错误，抱怨循环依赖关系。 请注意，当重新排列模块和导入时，它们必须保持在相同的包含模块中，这就不允许一些病态的模块结构。此外，导入和子模块总是被认为是最前面的，即使在顶层也是如此。这意味着以下内容不是很好的格式:\n\nmethod doit() { }\nmodule m {\n  method m() {\n    doit();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为模块m必须出现在任何其他类型的成员之前，比如方法。要像这样定义全局函数，您可以将它们放在一个模块(比如称为globals)中，并将其打开到任何需要其功能的模块中。最后，如果您通过路径导入，例如import a = b.c那么这将创建a对b的依赖关系，因为我们需要知道b是什么(它是抽象的还是具体的，还是细化的?)\n\n\n# 名字分解\n\n(待办事项:以下内容已在dafny更改。这里的描述应该改变以反映新的规则。)\n\n当dafny看到像a.b.c这样的东西时，它怎么知道每个部分指的是什么?dafny用来确定这样的标识符序列所引用的是名称解析。虽然规则可能看起来很复杂，但它们通常都符合您的预期。dafny首先查找初始标识符。根据第一个标识符引用的内容，将在适当的上下文中查找标识符的其余部分。具体规则如下: 局部变量、参数和绑定变量。这些是x y和i在var x;，... returns (y: int)，forall i :: ... 数据类型和模块名(如果这不是标识符的唯一部分)。类允许以这种方式访问它们的静态成员，数据类型允许访问它们的构造函数。模块允许像这样引用它们的任何成员 构造函数名称(如果没有歧义)。任何不需要限定的数据类型(因此数据类型名称本身不需要前缀)，以及具有唯一命名构造函数的数据类型，都可以通过其名称引用。所以如果datatype list = cons(list) | nil是唯一声明 cons和nil构造函数的数据类型，那么你可以写cons(cons(nil))。如果构造函数名不是唯一的，则需要在其前面加上数据类型的名称(例如list.cons(list.nil))。这是每个构造函数完成的，而不是每个数据类型。 当前类的字段、函数和方法(如果在静态上下文中，则只允许静态方法和函数)。您可以这样引用当前类的字段this.f或者f，当然假设f没有被上面的任何一个隐藏。如果需要，您总是可以加上前缀this，但不能隐藏它。(注意，名称是数字字符串的字段必须总是有一些前缀。) 封闭模块中的静态函数和方法。注意，这只引用在模块级声明的函数和方法，而不是命名类的静态成员。 打开的模块在每一层处理，在当前模块的声明之后。打开的模块只影响步骤2、3和5。如果发现有歧义的名称，将生成一个错误，而不是继续沿着列表向下。在第一个标识符之后，规则基本上是相同的，除了在新的上下文中。例如，如果第一个标识符是一个模块，那么下一个标识符将查看该模块。打开的模块只适用于它被打开的模块。在查找另一个模块时，只考虑在该模块中显式声明的内容。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"集合",frontmatter:{title:"集合",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/b9300a/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/10.%E9%9B%86%E5%90%88.html",relativePath:"30.教程/10.Dafny进阶语法/10.集合.md",key:"v-51317608",path:"/pages/b9300a/",headersStr:null,content:"# 集合\n\n笔记\n\n各种类型的集合构成了Dafny验证的核心工具之一。集合表示元素的无序集合，集合中没有重复。与序列一样，集合也是不可变的值类型。这使得它们可以很容易地在注释中使用，而不涉及堆，因为set一旦创建就无法修改。集合的类型为:\n\n  set<int>\n\n\n1\n\n\n例如，对于一组整数。通常，集合几乎可以是任何类型，包括对象。具体集合可以通过使用显示符号来指定:\n\nmethod m()\n{\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n}\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例子演示中展示的set正是我们想要的：只包含指定元素。上面我们还看到为集合定义了相等符号，如果两个集合有完全相同的元素，那么它们就是相等的。也可以使用集合运算符从现有的集创建新的集:\n\nmethod m()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n}\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，因为集合中的最多只有一个，不能重复。所以得到的并集不会将重复元素计数超过一次。如果两个集合都是有限的，那么通过这些操作符将得到一个有限集，不能生成一个无限集。与算术运算符不同，集合运算符都是有自己定义的。除了通常的集合操作符外，还有一些比较操作符，它们通常具有以下含义:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n}\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n与序列一样，集合也支持in和!in操作符来测试元素的成员关系。例如:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n集合用于一些注释，包括读取和修改子句。在本例中，它们可以是特定对象类型的集合(如链表中的nodes)，也可以是泛型引用类型对象object的集合。尽管它的名字是这样的，但它可以指向任何对象或数组。这对于将函数或方法可能读取或写入的所有不同类型的位置捆绑在一起非常有用。 在decreases子句中使用时，集合按真子集排序。要在decreases子句中使用set，连续的值在某种意义上必须是“相关的”，这通常意味着它们是递归计算的，或类似的。 您可以通过将一个集合与空集合进行比较来测试它是否为空(当且仅当s没有元素时，s =={}为真)。 创建集合的一个有用方法是使用set comprehension。通过将f(x)包含到所有满足p(x)的T类型的x的集合中，它定义了一个新集合:\n\n   set x: T | p(x) :: f(x)\n\n\n1\n\n\n它以一种让人想起全称量词(forall)的方式来定义集合。与限定符一样，该类型通常可以推断出来。与量词相反，bar语法(|)需要将谓词(p)与绑定变量(x)分离。结果集合元素的类型是f(x)的返回值的类型。构造的集合的值是f(x)的返回值:x本身只充当谓词p和函数f之间的桥梁。它通常具有与结果集相同的类型，但它不是必须要相同。作为一个例子:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n}\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\n如果函数是恒等式，那么能以很优美的形式写出表达式\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\n一般的集合推导中的非恒等函数容易混淆Dafny。例如，以下是正确的，但Dafny无法证明它:\n\nmethod m()\n{\n   // assert {0*1, 1*1, 2*1} == {0,1,2};  // include this assertion as a lemma to prove the next line\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\nassert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n6\n\n\n为了帮助Dafny证明这个断言，可以在它前面加上断言assert {0*1, 1*1, 2*1} == {0,1,2};这让Dafny解决了两个断言。\n\n如果没注意，用集合set comprehension将集合规定为无限数量的元素，但集合只允许有有限数量的元素。例如，如果您尝试将set x | x % 2 == 0作为所有偶数的集合，那么您将得到一个错误。(如果你真的想要一个无限集，可以使用iset类型。例如，iset x | x % 2 == 0在ghost环境中是合法的。)为了确保集合推导得到有限集合，Dafny采用了一些启发式方法。创建整数集时，可以通过将整数限定在谓词的至少一个连接词中来完成(类似于0 <= x < n)来实现。要求限定变量在现有集合中也可以，如上面的x in {0,1,2}.",normalizedContent:"# 集合\n\n笔记\n\n各种类型的集合构成了dafny验证的核心工具之一。集合表示元素的无序集合，集合中没有重复。与序列一样，集合也是不可变的值类型。这使得它们可以很容易地在注释中使用，而不涉及堆，因为set一旦创建就无法修改。集合的类型为:\n\n  set<int>\n\n\n1\n\n\n例如，对于一组整数。通常，集合几乎可以是任何类型，包括对象。具体集合可以通过使用显示符号来指定:\n\nmethod m()\n{\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n}\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例子演示中展示的set正是我们想要的：只包含指定元素。上面我们还看到为集合定义了相等符号，如果两个集合有完全相同的元素，那么它们就是相等的。也可以使用集合运算符从现有的集创建新的集:\n\nmethod m()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n}\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，因为集合中的最多只有一个，不能重复。所以得到的并集不会将重复元素计数超过一次。如果两个集合都是有限的，那么通过这些操作符将得到一个有限集，不能生成一个无限集。与算术运算符不同，集合运算符都是有自己定义的。除了通常的集合操作符外，还有一些比较操作符，它们通常具有以下含义:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n}\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n与序列一样，集合也支持in和!in操作符来测试元素的成员关系。例如:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n集合用于一些注释，包括读取和修改子句。在本例中，它们可以是特定对象类型的集合(如链表中的nodes)，也可以是泛型引用类型对象object的集合。尽管它的名字是这样的，但它可以指向任何对象或数组。这对于将函数或方法可能读取或写入的所有不同类型的位置捆绑在一起非常有用。 在decreases子句中使用时，集合按真子集排序。要在decreases子句中使用set，连续的值在某种意义上必须是“相关的”，这通常意味着它们是递归计算的，或类似的。 您可以通过将一个集合与空集合进行比较来测试它是否为空(当且仅当s没有元素时，s =={}为真)。 创建集合的一个有用方法是使用set comprehension。通过将f(x)包含到所有满足p(x)的t类型的x的集合中，它定义了一个新集合:\n\n   set x: t | p(x) :: f(x)\n\n\n1\n\n\n它以一种让人想起全称量词(forall)的方式来定义集合。与限定符一样，该类型通常可以推断出来。与量词相反，bar语法(|)需要将谓词(p)与绑定变量(x)分离。结果集合元素的类型是f(x)的返回值的类型。构造的集合的值是f(x)的返回值:x本身只充当谓词p和函数f之间的桥梁。它通常具有与结果集相同的类型，但它不是必须要相同。作为一个例子:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n}\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\n如果函数是恒等式，那么能以很优美的形式写出表达式\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\n一般的集合推导中的非恒等函数容易混淆dafny。例如，以下是正确的，但dafny无法证明它:\n\nmethod m()\n{\n   // assert {0*1, 1*1, 2*1} == {0,1,2};  // include this assertion as a lemma to prove the next line\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\nassert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n6\n\n\n为了帮助dafny证明这个断言，可以在它前面加上断言assert {0*1, 1*1, 2*1} == {0,1,2};这让dafny解决了两个断言。\n\n如果没注意，用集合set comprehension将集合规定为无限数量的元素，但集合只允许有有限数量的元素。例如，如果您尝试将set x | x % 2 == 0作为所有偶数的集合，那么您将得到一个错误。(如果你真的想要一个无限集，可以使用iset类型。例如，iset x | x % 2 == 0在ghost环境中是合法的。)为了确保集合推导得到有限集合，dafny采用了一些启发式方法。创建整数集时，可以通过将整数限定在谓词的至少一个连接词中来完成(类似于0 <= x < n)来实现。要求限定变量在现有集合中也可以，如上面的x in {0,1,2}.",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"序列",frontmatter:{title:"序列",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/cb3d21/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/15.%E5%BA%8F%E5%88%97.html",relativePath:"30.教程/10.Dafny进阶语法/15.序列.md",key:"v-3957ebbe",path:"/pages/cb3d21/",headersStr:null,content:"# 序列\n\n序列是一种表示有序列表的内置Dafny类型。它们可以用来表示许多有序集合，包括列表、队列、堆栈等。序列是一种不可变的值类型:它们一旦创建就不能被修改。从这个意义上说，它们类似于Java和Python等语言中的字符串，只是它们可以是任意类型的序列，而不仅仅是字符。序列类型如下:\n\n   seq<int>\n\n\n1\n\n\n例如，对于一个整数序列。例如，这个函数将一个序列作为参数:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\n序列的长度写成|s|，如上量词所示。使用与数组相同的方括号语法访问序列的特定元素。还请注意，该函数不需要读取子句来访问序列。这是因为序列不是存储在堆上的;它们是值，因此函数在访问它们时不需要声明。序列最强大的属性是注释和函数可以创建和操作序列。例如，另一种表示排序性的方法是递归:如果第一个元素比其他元素小，而其余元素都已排序，则整个数组都已排序:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\n年代的符号(1 . .是将序列切片。它的意思是从第一个元素开始，取元素直到最后。这不会修改s，因为序列是不可变的。相反，它创建了一个新的序列，除了第一个元素之外，所有元素都按相同的顺序排列。这类似于整数的加法，因为原始值没有改变，只是创建了新的值。切片表示法是:\n\n   s[i..j]\n\n\n1\n\n\n在0 <= i <= j <= |s|这个范围中Dafny将强制执行这些索引边界。结果序列将恰好有j-i元素，并且将从元素s[i]开始，如果结果非空，则将连续地遍历序列。这意味着索引j处的元素被排除在切片之外，这反映了用于常规索引的相同的半开区间。\n\n序列也可以使用显示表示法从其元素构造:\n\n var s := [1, 2, 3];\n\n\n1\n\n\n在这里，我们在一些命令式代码中有一个整数序列变量，其中包含元素1、2和3。这里使用了类型推断来获得序列是整数之一的事实。这种表示法允许我们构造空序列和单例序列:\n\n[] // the empty sequence, which can be a sequence of any type\n   [true] // a singleton sequence of type seq<bool>\n\n\n1\n2\n\n\n切片表示法和显示表示法可以用来检查序列的属性:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // the whole sequence\n}\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n到目前为止，对序列最常见的操作是获取第一个和最后一个元素，以及获取除第一个和最后一个元素以外的所有元素，因为这些通常用于递归函数，如上面的sorted2。除了通过访问或切片来解构序列外，序列还可以使用加号(+)进行连接: 但是Z3定理证明者不会意识到这一点，除非它被一个声明事实的断言提示(关于为什么这是必要的更多信息，请参阅引理/归纳法)。 序列还支持in和!in操作符，用于测试序列中的包含情况:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这还允许我们在不关心索引的情况下，对序列中的元素进行量化。例如，我们可以要求一个序列只包含该序列的下标元素:\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这是序列中每个单独元素的属性。如果我们想让多个元素相互关联，就需要量化指标，如第一个例子所示。\n\n有时我们想使用序列来模拟数组的可更新特性。虽然我们不能改变原来的序列，但我们可以创建一个新序列，其中除了更新的元素外，所有元素都是相同的:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然，下标i必须是数组的下标。这个语法只是可以通过常规切片和访问操作完成的操作的快捷方式。你能填写下面的代码吗?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // This works by concatenating everything that doesn't\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以用数组的元素组成一个序列。这是使用与上面相同的“slice”表示法完成的:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获得数组的一部分，可以像常规切片操作一样给出边界:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为序列支持in和!in，这个操作为我们提供了一种简单的方法来表示“element not in array”属性，即将这个转变为\n\nforall k :: 0 <= k < a.Length ==> elem != a[k]\n\n\n1\n\n\n这个：\n\nelem !in a[..]\n\n\n1\n\n\n此外，边界很容易包括:\n\nforall k :: 0 <= k < i ==> elem != a[k]\n\n\n1\n\n\n和以下这个是一样的：\n\nelem !in a[..i]\n\n\n1\n",normalizedContent:"# 序列\n\n序列是一种表示有序列表的内置dafny类型。它们可以用来表示许多有序集合，包括列表、队列、堆栈等。序列是一种不可变的值类型:它们一旦创建就不能被修改。从这个意义上说，它们类似于java和python等语言中的字符串，只是它们可以是任意类型的序列，而不仅仅是字符。序列类型如下:\n\n   seq<int>\n\n\n1\n\n\n例如，对于一个整数序列。例如，这个函数将一个序列作为参数:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\n序列的长度写成|s|，如上量词所示。使用与数组相同的方括号语法访问序列的特定元素。还请注意，该函数不需要读取子句来访问序列。这是因为序列不是存储在堆上的;它们是值，因此函数在访问它们时不需要声明。序列最强大的属性是注释和函数可以创建和操作序列。例如，另一种表示排序性的方法是递归:如果第一个元素比其他元素小，而其余元素都已排序，则整个数组都已排序:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\n年代的符号(1 . .是将序列切片。它的意思是从第一个元素开始，取元素直到最后。这不会修改s，因为序列是不可变的。相反，它创建了一个新的序列，除了第一个元素之外，所有元素都按相同的顺序排列。这类似于整数的加法，因为原始值没有改变，只是创建了新的值。切片表示法是:\n\n   s[i..j]\n\n\n1\n\n\n在0 <= i <= j <= |s|这个范围中dafny将强制执行这些索引边界。结果序列将恰好有j-i元素，并且将从元素s[i]开始，如果结果非空，则将连续地遍历序列。这意味着索引j处的元素被排除在切片之外，这反映了用于常规索引的相同的半开区间。\n\n序列也可以使用显示表示法从其元素构造:\n\n var s := [1, 2, 3];\n\n\n1\n\n\n在这里，我们在一些命令式代码中有一个整数序列变量，其中包含元素1、2和3。这里使用了类型推断来获得序列是整数之一的事实。这种表示法允许我们构造空序列和单例序列:\n\n[] // the empty sequence, which can be a sequence of any type\n   [true] // a singleton sequence of type seq<bool>\n\n\n1\n2\n\n\n切片表示法和显示表示法可以用来检查序列的属性:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // the whole sequence\n}\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n到目前为止，对序列最常见的操作是获取第一个和最后一个元素，以及获取除第一个和最后一个元素以外的所有元素，因为这些通常用于递归函数，如上面的sorted2。除了通过访问或切片来解构序列外，序列还可以使用加号(+)进行连接: 但是z3定理证明者不会意识到这一点，除非它被一个声明事实的断言提示(关于为什么这是必要的更多信息，请参阅引理/归纳法)。 序列还支持in和!in操作符，用于测试序列中的包含情况:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这还允许我们在不关心索引的情况下，对序列中的元素进行量化。例如，我们可以要求一个序列只包含该序列的下标元素:\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这是序列中每个单独元素的属性。如果我们想让多个元素相互关联，就需要量化指标，如第一个例子所示。\n\n有时我们想使用序列来模拟数组的可更新特性。虽然我们不能改变原来的序列，但我们可以创建一个新序列，其中除了更新的元素外，所有元素都是相同的:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然，下标i必须是数组的下标。这个语法只是可以通过常规切片和访问操作完成的操作的快捷方式。你能填写下面的代码吗?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // this works by concatenating everything that doesn't\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以用数组的元素组成一个序列。这是使用与上面相同的“slice”表示法完成的:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获得数组的一部分，可以像常规切片操作一样给出边界:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为序列支持in和!in，这个操作为我们提供了一种简单的方法来表示“element not in array”属性，即将这个转变为\n\nforall k :: 0 <= k < a.length ==> elem != a[k]\n\n\n1\n\n\n这个：\n\nelem !in a[..]\n\n\n1\n\n\n此外，边界很容易包括:\n\nforall k :: 0 <= k < i ==> elem != a[k]\n\n\n1\n\n\n和以下这个是一样的：\n\nelem !in a[..i]\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"终止",frontmatter:{title:"终止",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/fc6196/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/20.%E7%BB%88%E6%AD%A2.html",relativePath:"30.教程/10.Dafny进阶语法/20.终止.md",key:"v-d1f85536",path:"/pages/fc6196/",headersStr:null,content:"# 终止\n\nDafny证明所有程序终止。有两个潜在的非终止(发散)行为来源:循环，递归函数和方法。Dafny使用一种技术来处理这两种情况，减少注释。\n\n递减注释指定一个称为终止度量的值，该值在每次遍历循环或每次调用递归函数或方法时严格变小。这个值也是有界的，因此它不会永远减小。这样，如果值从任意有限值开始，循环或递归必须停止。为了证明这一点，Dafny证明了终止度量在每次迭代中变得更小。如果Dafny无法证明这一点，它表示没有减少终止措施。因为每一种终止措施都有一个内置的下界，这就是Dafny需要做的，以证明终止。\n\nDafny可以在递减注释中使用几种类型的值，但最常见的是整数。整数有一个自然的下界，0，而且通常很容易证明它们是递减的。由于许多循环遍历索引，这类终止证明非常常见。例如，我们可能有以下循环:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      // do something interesting\n      i := i + 1;\n   }\n}\n\nwhile i < n\n   invariant 0 <= i <= n\n{\n   // do something interesting\n   i := i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果我们把这个交给Dafny，就能立即证实。但是它是怎么知道它会终止的呢?因为这是如此常见的循环形式，Dafny有一个猜测终止度量的特殊规则。Dafny看到没有显式的递减注释，所以它尝试猜测一个。它看到循环条件是A < B形式的比较，对于某些A和B，所以它做出猜测:\n\n  decreases B - A\n\n\n1\n\n\n如果这样的话\n\n  decreases n - i\n\n\n1\n\n\n如果我们将这个注释添加到循环中，它将继续进行验证。Dafny实际上没有那么严格要求终止测度为0。它真正需要的是，当终止度量为负时，循环不会再次执行。所以我们可以这样写:\n\nmethod m()\n{\n   var i, n := 0, 11;\n   while i < n\n      decreases n - i\n   {\n      // do something interesting\n      i := i + 5;\n   }\n}\n\nvar i, n := 0, 11;\nwhile i < n\n   decreases n - i\n{\n   // do something interesting\n   i := i + 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里，在最后一次迭代中，i变成了15，所以终止测度是-4。但在这里，循环保护为假，所以循环不会再次执行。注意，我们必须删除循环不变式，因为i现在可以超过n。\n\nDafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。Dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的: Dafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。Dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的:\n\nfunction fac(n: nat): nat\n{\n   if n == 0 then 1 else n * fac(n-1)\n\n\n1\n2\n3\n\n\nDafny接受了这个计划。对于大多数递归函数来说，它们只是用更小的参数值来调用自己，所以参数减少是默认的猜测。可以通过添加以下内容:\n\ndecreases n\n\n\n1\n\n\n到函数声明来明确decreases注释\n\n有时，具有可能不会终止的循环或终止证明未知的循环是有益的。例如，考虑以下方法:\n\nmethod hail(N: nat)\n   decreases *\n{\n   var n := N;\n   while 1 < n\n      decreases *\n   {\n      n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个程序终止当且仅当Collatz猜想为真时，这是一个数学上的开放问题，所以你不能期望Dafny能够证明终止。您还可以编写流处理器之类的代码，以便永远运行。因此，Dafny提供了一个“out”，一个特殊的注释，指示Dafny不要试图证明终止，这在前面的hail方法中已经给出。这可以用于所有非鬼循环。注意，如果一个方法包含一个标记为decreases *的循环，那么它本身也必须被标记为decreases *。\n\nDafny可以使用整数以外的值作为终止度量。当指定序列时，Dafny自动使用长度作为终止度量。如果一个集合是另一个集合的严格子集，则认为这个集合更小，因此每个集合必须包含在前面的集合中。对于集合，空集合是尽可能小的，序列有自然数长度，所以这两个都有下界。虽然不是非常有用，但也可以在递减子句中使用bool和references。(如果你想了解细节，请参阅参考资料。)最后的终止度量是其他类型度量的元组。例如，下面的Ackermann函数的实现使用一对整数来证明终止\n\nfunction Ack(m: nat, n: nat): nat\n   decreases m, n\n{\n   if m == 0 then n + 1\n   else if n == 0 then Ack(m - 1, 1)\n   else Ack(m - 1, Ack(m, n - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在这里，递减子句被明确地写了出来，尽管Dafny会猜出完全相同的事情。元组使用组件值的大小比较来确定度量值是否缩水。在这种情况下，它使用两个整数，但一般来说，不同的部分可以属于不同的类别。这种比较是按词典编纂的。如果第一个元素，在这里是m，比其他的值小没关系。它们可以增加，减少，或保持不变。只有当第一个元素不变时，才考虑第二个元素。然后，第二个值需要减小。如果没有，则第三个元素必须减少，以此类推。最终，必有一种元素会减少。过了这个点，其他元素就可以自由增加或做它们想做的事。 在Ack函数中，有三个递归调用。在第一种情况下，m变小1，但n增大。这很好，因为在元组中n在m后面。在第二个调用中，m也减少了，因此第二个参数允许是任何值(这很好，因为Dafny实际上并没有证明关于第三个递归调用的结果的任何东西)。Dafny确实需要证明第三通电话符合终止措施。对于这个调用，m保持不变，但n减小，因此总体度量也减小了。 终止不仅适用于单个函数/方法，还适用于多个相互递归的函数/方法。例如，考虑这对递归定义的奇偶校验谓词:\n\npredicate even(n: nat)\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\npredicate odd(n: nat)\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny通过考虑两个函数中所有可能的路径证明了它们的终止。",normalizedContent:"# 终止\n\ndafny证明所有程序终止。有两个潜在的非终止(发散)行为来源:循环，递归函数和方法。dafny使用一种技术来处理这两种情况，减少注释。\n\n递减注释指定一个称为终止度量的值，该值在每次遍历循环或每次调用递归函数或方法时严格变小。这个值也是有界的，因此它不会永远减小。这样，如果值从任意有限值开始，循环或递归必须停止。为了证明这一点，dafny证明了终止度量在每次迭代中变得更小。如果dafny无法证明这一点，它表示没有减少终止措施。因为每一种终止措施都有一个内置的下界，这就是dafny需要做的，以证明终止。\n\ndafny可以在递减注释中使用几种类型的值，但最常见的是整数。整数有一个自然的下界，0，而且通常很容易证明它们是递减的。由于许多循环遍历索引，这类终止证明非常常见。例如，我们可能有以下循环:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      // do something interesting\n      i := i + 1;\n   }\n}\n\nwhile i < n\n   invariant 0 <= i <= n\n{\n   // do something interesting\n   i := i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果我们把这个交给dafny，就能立即证实。但是它是怎么知道它会终止的呢?因为这是如此常见的循环形式，dafny有一个猜测终止度量的特殊规则。dafny看到没有显式的递减注释，所以它尝试猜测一个。它看到循环条件是a < b形式的比较，对于某些a和b，所以它做出猜测:\n\n  decreases b - a\n\n\n1\n\n\n如果这样的话\n\n  decreases n - i\n\n\n1\n\n\n如果我们将这个注释添加到循环中，它将继续进行验证。dafny实际上没有那么严格要求终止测度为0。它真正需要的是，当终止度量为负时，循环不会再次执行。所以我们可以这样写:\n\nmethod m()\n{\n   var i, n := 0, 11;\n   while i < n\n      decreases n - i\n   {\n      // do something interesting\n      i := i + 5;\n   }\n}\n\nvar i, n := 0, 11;\nwhile i < n\n   decreases n - i\n{\n   // do something interesting\n   i := i + 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里，在最后一次迭代中，i变成了15，所以终止测度是-4。但在这里，循环保护为假，所以循环不会再次执行。注意，我们必须删除循环不变式，因为i现在可以超过n。\n\ndafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的: dafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的:\n\nfunction fac(n: nat): nat\n{\n   if n == 0 then 1 else n * fac(n-1)\n\n\n1\n2\n3\n\n\ndafny接受了这个计划。对于大多数递归函数来说，它们只是用更小的参数值来调用自己，所以参数减少是默认的猜测。可以通过添加以下内容:\n\ndecreases n\n\n\n1\n\n\n到函数声明来明确decreases注释\n\n有时，具有可能不会终止的循环或终止证明未知的循环是有益的。例如，考虑以下方法:\n\nmethod hail(n: nat)\n   decreases *\n{\n   var n := n;\n   while 1 < n\n      decreases *\n   {\n      n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个程序终止当且仅当collatz猜想为真时，这是一个数学上的开放问题，所以你不能期望dafny能够证明终止。您还可以编写流处理器之类的代码，以便永远运行。因此，dafny提供了一个“out”，一个特殊的注释，指示dafny不要试图证明终止，这在前面的hail方法中已经给出。这可以用于所有非鬼循环。注意，如果一个方法包含一个标记为decreases *的循环，那么它本身也必须被标记为decreases *。\n\ndafny可以使用整数以外的值作为终止度量。当指定序列时，dafny自动使用长度作为终止度量。如果一个集合是另一个集合的严格子集，则认为这个集合更小，因此每个集合必须包含在前面的集合中。对于集合，空集合是尽可能小的，序列有自然数长度，所以这两个都有下界。虽然不是非常有用，但也可以在递减子句中使用bool和references。(如果你想了解细节，请参阅参考资料。)最后的终止度量是其他类型度量的元组。例如，下面的ackermann函数的实现使用一对整数来证明终止\n\nfunction ack(m: nat, n: nat): nat\n   decreases m, n\n{\n   if m == 0 then n + 1\n   else if n == 0 then ack(m - 1, 1)\n   else ack(m - 1, ack(m, n - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在这里，递减子句被明确地写了出来，尽管dafny会猜出完全相同的事情。元组使用组件值的大小比较来确定度量值是否缩水。在这种情况下，它使用两个整数，但一般来说，不同的部分可以属于不同的类别。这种比较是按词典编纂的。如果第一个元素，在这里是m，比其他的值小没关系。它们可以增加，减少，或保持不变。只有当第一个元素不变时，才考虑第二个元素。然后，第二个值需要减小。如果没有，则第三个元素必须减少，以此类推。最终，必有一种元素会减少。过了这个点，其他元素就可以自由增加或做它们想做的事。 在ack函数中，有三个递归调用。在第一种情况下，m变小1，但n增大。这很好，因为在元组中n在m后面。在第二个调用中，m也减少了，因此第二个参数允许是任何值(这很好，因为dafny实际上并没有证明关于第三个递归调用的结果的任何东西)。dafny确实需要证明第三通电话符合终止措施。对于这个调用，m保持不变，但n减小，因此总体度量也减小了。 终止不仅适用于单个函数/方法，还适用于多个相互递归的函数/方法。例如，考虑这对递归定义的奇偶校验谓词:\n\npredicate even(n: nat)\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\npredicate odd(n: nat)\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny通过考虑两个函数中所有可能的路径证明了它们的终止。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"值类型",frontmatter:{title:"值类型",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/a2a107/",categories:["教程","Dafny进阶语法"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/25.%E5%80%BC%E7%B1%BB%E5%9E%8B.html",relativePath:"30.教程/10.Dafny进阶语法/25.值类型.md",key:"v-5b4bcfa3",path:"/pages/a2a107/",headers:[{level:2,title:"集合",slug:"集合",normalizedTitle:"集合",charIndex:2},{level:2,title:"序列",slug:"序列",normalizedTitle:"序列",charIndex:50},{level:2,title:"多重集合",slug:"多重集合",normalizedTitle:"多重集合",charIndex:8593},{level:2,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:367}],headersStr:"集合 序列 多重集合 映射",content:'# 集合类型\n\n值类型表示不依赖于堆状态的某些信息。这些值具有数学特性:一旦创建，就无法修改。比如在序列或者集合中，你不能像将数组更改索引那样更改集合。相反，要在set集合中插入元素，需要创建一个原始set集合和包含新元素的单例集的并集。当然，原始set集合还在。集合对堆的独立性使得值类型在规范中特别好用。\n\n这并不是说你当有值类型在里面时不能更新集合。包含值类型的变量可以更新为同样值类型的新数值。而任何其他具有相同set集合的变量或字段将保持它们的旧值。值类型在超类set<object>中可以包含对堆的引用。在本例中，值类型中的信息是集合中的对象，而不依赖于存储在这些对象中的任何字段的值。而且，所有Dafny的值类型都可以存储在堆上的字段中，除了在规范中，还可以在实际代码中使用。Dafny的内建值类型有集合、序列、多集合和映射。\n\n有关各种集合类型及其操作的完整指南，请参阅Dafny type system文档。注意，如果您想在执行程序中使用这些类型，并且还要考虑性能的话，请在编译时使用Dafny的/optimize选项。\n\n\n# 集合\n\n各种类型的集合构成了Dafny验证的核心工具之一。集合表示没有重复元素的无序集合。与序列一样，集合也是不可变的值类型。这使得它们可以很轻松地在不涉及堆的情况下在注释中使用，因为set一旦创建就无法修改。集合的类型为:\n\n set<int>\n\n\n1\n\n\n例如，对于一组整数。通常，集合几乎可以是任何类型，包括对象。具体集合可以通过使用显示符号来指定:\n\nmethod()\n{\n   var s1 := {}; // the empty set 空集\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 包含集合1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before 跟上个一样\n   var s3, s4 := {1,2}, {1,4};// 平行赋值\n}\n  \n   var s1 := {}; // the empty set 空集\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 包含集合1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before 跟上个一样\n   var s3, s4 := {1,2}, {1,4}; //平行赋值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n例子演示中展示的set正是我们想要的：只包含指定元素。上面我们还看到为集合定义了相等符号，如果两个集合有完全相同的元素，那么它们就是相等的。也可以使用集合运算符从现有的集创建新的集:\n\nmethod m ()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // 集合相加 并集\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // 集合相交 交集\n   assert s2 - s3 == {3}; // 集合相减 差集\n}\n\nassert s2 + s4 == {1,2,3,4}; // 集合相加 并集\nassert s2 * s3 == {1,2} && s2 * s4 == {1}; // 集合相交 交集\nassert s2 - s3 == {3}; // 集合相减 差集\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，因为集合中的最多只有一个，不能重复。所以得到的并集只会记录一次重复元素。如果两个集合都是有限的，那么通过这些操作符将得到一个有限集，不能生成一个无限集。与算术运算符不同，集合运算符都是有属于自己的定义。除了通常的集合操作符外，还有一些比较操作符，它们一般具有以下含义:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // 子集\n   assert {} < {1, 2} && !({1} < {1}); //真子集\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // 无关集合\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // 相等与不相等\n}\n\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // 子集\n   assert {} < {1, 2} && !({1} < {1}); // 真子集\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // 无关集合\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // 相等与不相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n集合与序列一样，集合也支持in和!in操作符来测试元素的成员关系。例如:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\t\n\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n集合用于一些注释，包括读取和修改子句。在本例中，它们可以是特定对象类型的集合(如链表中的Nodes)，也可以是泛型引用类型对象的集合。尽管它的名字是这样的，但它可以指向任何对象或数组。这对于将函数或方法可能读取或写入的所有不同类型的位置捆绑在一起非常有用。 在递减子句中使用时，集合sets按子集排序。这与仅按长度排序的序列sequences不同。为了在递减子句decreases中使用集合，连续值在某种意义上必须是“相关的”，这通常表示它们是递归计算。这个“相关”要求是因为在Dafny中，我们无法获得集合的基数(大小)。他的到大小是某个有限的自然数给出的，但它不可被访问。您可以通过将集合与空集合进行比较来测试它是否为空(当且仅当s没有元素时，s =={}为真)。 创建集合的一个有用方法是使用set comprehension（包含集？）。通过将所有满足p(x)的T类型的x包含到f(x)中，它定义了一个新集合:\n\n   set x: T | p(x) :: f(x)\n\n\n1\n\n\n它以一种让人想起全称量词(forall)的方式来定义集合。与量词quanifiers相同的是，该类型通常可以推断出来。与量词相反，符号(|)将谓词(p)与变量(x)分离。返回的集合元素类型是f(x)集合的返回值类型。返回集合的值是f(x)的返回值：x本身只充当p和函数f之间的桥梁。它通常具有与返回集相同的数值类型，但也不一定。\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};// assertion violation\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果函数是恒等式，那么能以很优美的形式写出表达式\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};//对的\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般的集合推导中的非恒等函数容易混淆Dafny。例如，以下式子是正确的，但Dafny无法证明它:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};\n}\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};// assertion violation\n\n\n1\n2\n3\n4\n5\n\n\n这种写法有可能创建无限集，这在Dafny中是不允许的。为了防止这种情况发生，Dafny使用启发式方法试图证明结果集是有限的。当创建整数集时，可以通过将整数限定在谓词的至少一个子句中(类似于0 <= x < n)来实现,就写在双冒号::前面就行。要求限定变量在现有的集合中也可以，如上面的x in {0,1,2}。这只在包含部分与谓词的其余部分连接(&&等)时起作用，因为它需要限制要考虑的可能值。\n\n\n# 序列\n\n序列是一种表示有序列表的Dafny内置数据类型。它们可以用来表示许多有序集合，包括列表、队列、堆栈等。序列是一种不可变的值类型:它们一旦创建就不能被修改。从这个意义上说，它们类似于Java和Python等语言中的string字符串，只是它们可以是任意类型的序列，而不仅仅是字符。序列类型如下:\n\nseq<int>\n\n\n1\n\n\n例如，对于一个整数序列。(注意，在Dafny中有一个已知的错误，它阻止你创建自然的序列nat。)例如，这个函数将一个序列作为传入参数:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\n序列的长度写成|s|，如上量词所示。使用与数组相同的方括号语法访问序列的特定元素。注意，该函数不需要读取子句来访问序列。这是因为序列不是存储在堆上的;它们是值，因此函数在访问它们时不需要声明。序列最强大的属性是注释annotations和函数functions可以创建和操作序列。例如，另一种表示排序性的方法是递归:如果第一个元素比其他元素小，而其余元素都已排序，则整个数组都已排序:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\ns[1..]是将序列切片。它的意思是从第一个元素开始，取元素直到序列末尾。这不会修改s序列，因为序列是不可变的。相反，它创建了一个新的序列，除了第一个元素之外，所有元素都按相同的顺序排列。这类似于整数的加法，因为原始值没有改变，只是创建了新的值。切片表示为:s[i..j]\n\n也就是在0 <= i <= j <= |s|中Dafny将强制执行这些索引边界。最终序列将恰好有j-i个元素，并且将从元素s[i]开始，如果结果非空，则将连续地遍历序列。这意味着索引j处的元素被排除在切片之外，这反映了用于常规索引的相同的半开区间。 序列也可以使display注释从自己的元素中构造:\n\n  var s := [1, 2, 3];\n\n\n1\n\n\n在这里，我们在一些命令式代码中有一个整数序列变量，其中包含元素1、2和3。这里使用了类型推断得知序列是其中的一些整数。这种表示法允许我们构造空序列和单例序列:\n\n [] //空序列，可以成为任何类型\n [true] // bool类型的单例序列\t\n\n\n1\n2\n\n\n切片表示法slice notation和显示表示法display notation可以用来检查序列的属性:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //访问序列最后一个元素\n   assert s[|s|-1..|s|] == [5]; //切片最后一个元素作为单例序列\n   assert s[1..] == [2, 3, 4, 5]; // 除了第一个元素的序列\n   assert s[..|s|-1] == [1, 2, 3, 4]; // 除了最后一个元素的序列\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // 整个序列\n}\n\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n到目前为止，对序列最常见的操作是获取第一个和最后一个元素，以及获取除第一个和最后一个元素以外的所有元素，因为这些通常用于递归函数，如上面的sorted2。除了通过访问或切片来解构序列外，序列还可以使用加号(+)进行连接:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n}\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n第二个断言给出了连接和切片之间的关系。因为切片操作在一边是排他的，在另一边是包含的，所以元素在连接中只出现一次。注意，连接操作是有关联的:\n\nmethod m()\n{\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n}\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是Z3定理证明者不会意识到这一点，除非它被一个声明事实的断言提示(关于为什么这是必要的更多信息，请参阅引理/归纳法)。\n\n序列还支持in和!in操作符，用于测试序列中的包含情况:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这还允许我们在不关心索引的情况下，对序列中的元素进行量化。例如，我们可以要求一个序列只包含该序列的下标元素:\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这是序列中每个单独元素的属性。如果我们想让多个元素相互关联，就需要量化指标，如第一个例子所示。 有时我们想使用序列来模拟数组的可更新特性。虽然我们不能改变原来的序列，但我们可以创建一个新序列，其中除了更新的元素外，所有元素都是相同的:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然，下标i必须是数组的下标。这个语法只是可以通过常规切片和访问操作完成的操作符的快捷方式。你能填写下面的代码吗?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // This works by concatenating everything that doesn\'t\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以用数组的元素组成一个序列。这是使用与上面相同的“slice”表示法完成的:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获得数组的一部分，可以像常规切片操作一样给出边界:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为序列支持in和!in，这个操作为我们提供了一种简单的方法来表达" element not in array "属性，即将下面这个:forall k :: 0 <= k < a.Length ==> elem != a[k] 转化为：elem !in a[..]\n\n此外，边界很容易包括:forall k :: 0 <= k < i ==> elem != a[k] 和这个一样elem !in a[..i]\n\n\n# 多重集合\n\n多重集合几乎在所有方面都与集合相似，除了它们跟踪每个元素的拷贝数。这使得它们在存储数组中的元素集合时特别有用，例如，当每个元素的拷贝数量相同时。multiset类型几乎与set类型相同:\n\n   multiset<int>\n\n\n1\n\n\n类似地，要给出一个multiset字面值，你要写花括号，除非前面有multiset关键字:\n\n  multiset{3,5,7,3}\n\n\n1\n\n\n小心!Multiset({3,3})不是带有两个3的多集和字面值。大括号必须与关键字相邻，以使其如期望那样运行。\n\n和集合一样，多集合也是无序的。然而，因为它们跟踪每个元素的数量，上面的文字实际上有两个3。\n\n在集合上定义的许多操作也可用于多集合。您可以使用in来测试某个元素是否在multiset中(in表示它至少具有给定值的一个成员)。多集并集(+)意味着从两者中取元素，并将它们相加。如果一个多集有两个3而另一个有一个3，那么它们的多集并集就会有三个3。多集差异(-)的工作原理类似，因为元素的双重性(即每个元素在多集中有多少个)很重要。所以以下:\n\nmethod test()\n{\n   assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n}\n  assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n\n\n成立，因为我们开始有三个1，然后拿走两个，剩下一个。 Multiset disjoint(!!)按预期工作，当且仅当两个多集没有共同成员时为真。同样，如果两个多集的每个元素的计数完全相同，那么它们是相等的。 最后，通过使用带括号的multiset可以从序列和集合中创建多集:\n\nmethod test()\n{\n   assert multiset([1,1]) == multiset{1,1};\n   assert multiset({1,1}) == multiset{1};\n}\n  assert multiset([1,1]) == multiset{1,1};\n  assert multiset({1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这两个断言都是正确的，因为序列的multiset分别考虑每个元素，而set最多只考虑每个元素中的一个。Dafny允许您编写{1,1}，但这与{1}相同，因为重复的代码会被忽略。因此，当从一个集合生成一个多集合时，多集合中的每个元素都将具有精确的双重性。从序列生成多集特别有用，因为当与数组切片结合时，允许您讨论数组中的元素集(如multiset(a[..]))，这对验证排序算法和一些数据结构非常有帮助。\n\n\n# 映射\n\nDafny中的映射表示关联数组。与目前为止的其他类型不同，它们有两种类型:键类型和值类型。可以根据键检索或查找值。映射类型如下:\n\n  map<U, V>\n\n\n1\n\n\n其中U是键类型，V是值类型。例如，我们可以有一个从整数到整数的映射map<int, int>。这种类型的字面值可能是map[4 := 5, 5 := 6]。这张地图把4和5联系起来，把5和6联系起来。您可以使用m[key]访问给定键的值，如果m是一个map而key是一个键。所以我们可以这样写:\n\nmethod test() {\n  var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n}\n var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为4作为m的键值，会产生5。我们还知道m[5] == 6，因为这是另一个映射。 每个映射都有一个域，域是该映射具有值的所有键。向地图请求其域外的键是不正确的。所以m[7]没有任何意义，因为m没有给7定义任何值。要测试一个键是否在映射的域中，可以使用in操作符。例如，4在m中，5在m中，但是7 不在m中。有了量词，你可以说定义域是某个集合，如forall i :: i in m <==> 0 <= i < 100(当m的定义域恰好是数字0-99时，结果为真)。另外，如果两个映射的域作为集合是不相交的，那么它们就是不相交的(!!) 如果m是一个map，那么m[i:= j]是一个新的map，它是将i加到m的域中，然后将键i与值j关联起来的结果。如果i已经有一个值，那么它将在新的map中被覆盖。这也意味着当使用map字面值时，允许重复一个键，但随后第一个值将被重写。所以map[3 := 5, 3 := 4] == map[3 := 4]。注意，如果两个映射具有相同的域，则它们是相等的，并且它们将相同的键映射为相同的值。同样，映射的域必须总是有限的。 像集合一样，map有map的comprehension。语法几乎和set一样:\n\nmap i: T | p(i) :: f(i)\n\n\n1\n\n\n区别在于，i是键，它被映射到f(i),P(i)用来确定新映射的定义域是什么。所以:\n\nmethod test() {\n  var m := map i | 0 <= i < 10 :: 2*i;\n}\n  map i | 0 <= i < 10 :: 2*i\n\n\n1\n2\n3\n4\n\n\n就是把0-9的数字变成双打数字的地图。这也是从映射中删除键的方法。例如，这个表达式将键3从一个int到int的映射m中删除:\n\nmethod test() {\n  var m := map[3 := 5, 4 := 6, 1 := 4];\n  var l := map i | i in m && i != 3 :: m[i];\n  assert l == map[4:= 6, 1 := 4];\n}\n  map i | i in m && i != 3 :: m[i]\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# 集合类型\n\n值类型表示不依赖于堆状态的某些信息。这些值具有数学特性:一旦创建，就无法修改。比如在序列或者集合中，你不能像将数组更改索引那样更改集合。相反，要在set集合中插入元素，需要创建一个原始set集合和包含新元素的单例集的并集。当然，原始set集合还在。集合对堆的独立性使得值类型在规范中特别好用。\n\n这并不是说你当有值类型在里面时不能更新集合。包含值类型的变量可以更新为同样值类型的新数值。而任何其他具有相同set集合的变量或字段将保持它们的旧值。值类型在超类set<object>中可以包含对堆的引用。在本例中，值类型中的信息是集合中的对象，而不依赖于存储在这些对象中的任何字段的值。而且，所有dafny的值类型都可以存储在堆上的字段中，除了在规范中，还可以在实际代码中使用。dafny的内建值类型有集合、序列、多集合和映射。\n\n有关各种集合类型及其操作的完整指南，请参阅dafny type system文档。注意，如果您想在执行程序中使用这些类型，并且还要考虑性能的话，请在编译时使用dafny的/optimize选项。\n\n\n# 集合\n\n各种类型的集合构成了dafny验证的核心工具之一。集合表示没有重复元素的无序集合。与序列一样，集合也是不可变的值类型。这使得它们可以很轻松地在不涉及堆的情况下在注释中使用，因为set一旦创建就无法修改。集合的类型为:\n\n set<int>\n\n\n1\n\n\n例如，对于一组整数。通常，集合几乎可以是任何类型，包括对象。具体集合可以通过使用显示符号来指定:\n\nmethod()\n{\n   var s1 := {}; // the empty set 空集\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 包含集合1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before 跟上个一样\n   var s3, s4 := {1,2}, {1,4};// 平行赋值\n}\n  \n   var s1 := {}; // the empty set 空集\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 包含集合1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before 跟上个一样\n   var s3, s4 := {1,2}, {1,4}; //平行赋值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n例子演示中展示的set正是我们想要的：只包含指定元素。上面我们还看到为集合定义了相等符号，如果两个集合有完全相同的元素，那么它们就是相等的。也可以使用集合运算符从现有的集创建新的集:\n\nmethod m ()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // 集合相加 并集\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // 集合相交 交集\n   assert s2 - s3 == {3}; // 集合相减 差集\n}\n\nassert s2 + s4 == {1,2,3,4}; // 集合相加 并集\nassert s2 * s3 == {1,2} && s2 * s4 == {1}; // 集合相交 交集\nassert s2 - s3 == {3}; // 集合相减 差集\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，因为集合中的最多只有一个，不能重复。所以得到的并集只会记录一次重复元素。如果两个集合都是有限的，那么通过这些操作符将得到一个有限集，不能生成一个无限集。与算术运算符不同，集合运算符都是有属于自己的定义。除了通常的集合操作符外，还有一些比较操作符，它们一般具有以下含义:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // 子集\n   assert {} < {1, 2} && !({1} < {1}); //真子集\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // 无关集合\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // 相等与不相等\n}\n\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // 子集\n   assert {} < {1, 2} && !({1} < {1}); // 真子集\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // 无关集合\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // 相等与不相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n集合与序列一样，集合也支持in和!in操作符来测试元素的成员关系。例如:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\t\n\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n集合用于一些注释，包括读取和修改子句。在本例中，它们可以是特定对象类型的集合(如链表中的nodes)，也可以是泛型引用类型对象的集合。尽管它的名字是这样的，但它可以指向任何对象或数组。这对于将函数或方法可能读取或写入的所有不同类型的位置捆绑在一起非常有用。 在递减子句中使用时，集合sets按子集排序。这与仅按长度排序的序列sequences不同。为了在递减子句decreases中使用集合，连续值在某种意义上必须是“相关的”，这通常表示它们是递归计算。这个“相关”要求是因为在dafny中，我们无法获得集合的基数(大小)。他的到大小是某个有限的自然数给出的，但它不可被访问。您可以通过将集合与空集合进行比较来测试它是否为空(当且仅当s没有元素时，s =={}为真)。 创建集合的一个有用方法是使用set comprehension（包含集？）。通过将所有满足p(x)的t类型的x包含到f(x)中，它定义了一个新集合:\n\n   set x: t | p(x) :: f(x)\n\n\n1\n\n\n它以一种让人想起全称量词(forall)的方式来定义集合。与量词quanifiers相同的是，该类型通常可以推断出来。与量词相反，符号(|)将谓词(p)与变量(x)分离。返回的集合元素类型是f(x)集合的返回值类型。返回集合的值是f(x)的返回值：x本身只充当p和函数f之间的桥梁。它通常具有与返回集相同的数值类型，但也不一定。\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};// assertion violation\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果函数是恒等式，那么能以很优美的形式写出表达式\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};//对的\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般的集合推导中的非恒等函数容易混淆dafny。例如，以下式子是正确的，但dafny无法证明它:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};\n}\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};// assertion violation\n\n\n1\n2\n3\n4\n5\n\n\n这种写法有可能创建无限集，这在dafny中是不允许的。为了防止这种情况发生，dafny使用启发式方法试图证明结果集是有限的。当创建整数集时，可以通过将整数限定在谓词的至少一个子句中(类似于0 <= x < n)来实现,就写在双冒号::前面就行。要求限定变量在现有的集合中也可以，如上面的x in {0,1,2}。这只在包含部分与谓词的其余部分连接(&&等)时起作用，因为它需要限制要考虑的可能值。\n\n\n# 序列\n\n序列是一种表示有序列表的dafny内置数据类型。它们可以用来表示许多有序集合，包括列表、队列、堆栈等。序列是一种不可变的值类型:它们一旦创建就不能被修改。从这个意义上说，它们类似于java和python等语言中的string字符串，只是它们可以是任意类型的序列，而不仅仅是字符。序列类型如下:\n\nseq<int>\n\n\n1\n\n\n例如，对于一个整数序列。(注意，在dafny中有一个已知的错误，它阻止你创建自然的序列nat。)例如，这个函数将一个序列作为传入参数:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\n序列的长度写成|s|，如上量词所示。使用与数组相同的方括号语法访问序列的特定元素。注意，该函数不需要读取子句来访问序列。这是因为序列不是存储在堆上的;它们是值，因此函数在访问它们时不需要声明。序列最强大的属性是注释annotations和函数functions可以创建和操作序列。例如，另一种表示排序性的方法是递归:如果第一个元素比其他元素小，而其余元素都已排序，则整个数组都已排序:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\ns[1..]是将序列切片。它的意思是从第一个元素开始，取元素直到序列末尾。这不会修改s序列，因为序列是不可变的。相反，它创建了一个新的序列，除了第一个元素之外，所有元素都按相同的顺序排列。这类似于整数的加法，因为原始值没有改变，只是创建了新的值。切片表示为:s[i..j]\n\n也就是在0 <= i <= j <= |s|中dafny将强制执行这些索引边界。最终序列将恰好有j-i个元素，并且将从元素s[i]开始，如果结果非空，则将连续地遍历序列。这意味着索引j处的元素被排除在切片之外，这反映了用于常规索引的相同的半开区间。 序列也可以使display注释从自己的元素中构造:\n\n  var s := [1, 2, 3];\n\n\n1\n\n\n在这里，我们在一些命令式代码中有一个整数序列变量，其中包含元素1、2和3。这里使用了类型推断得知序列是其中的一些整数。这种表示法允许我们构造空序列和单例序列:\n\n [] //空序列，可以成为任何类型\n [true] // bool类型的单例序列\t\n\n\n1\n2\n\n\n切片表示法slice notation和显示表示法display notation可以用来检查序列的属性:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //访问序列最后一个元素\n   assert s[|s|-1..|s|] == [5]; //切片最后一个元素作为单例序列\n   assert s[1..] == [2, 3, 4, 5]; // 除了第一个元素的序列\n   assert s[..|s|-1] == [1, 2, 3, 4]; // 除了最后一个元素的序列\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // 整个序列\n}\n\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n到目前为止，对序列最常见的操作是获取第一个和最后一个元素，以及获取除第一个和最后一个元素以外的所有元素，因为这些通常用于递归函数，如上面的sorted2。除了通过访问或切片来解构序列外，序列还可以使用加号(+)进行连接:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n}\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n第二个断言给出了连接和切片之间的关系。因为切片操作在一边是排他的，在另一边是包含的，所以元素在连接中只出现一次。注意，连接操作是有关联的:\n\nmethod m()\n{\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n}\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是z3定理证明者不会意识到这一点，除非它被一个声明事实的断言提示(关于为什么这是必要的更多信息，请参阅引理/归纳法)。\n\n序列还支持in和!in操作符，用于测试序列中的包含情况:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这还允许我们在不关心索引的情况下，对序列中的元素进行量化。例如，我们可以要求一个序列只包含该序列的下标元素:\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这是序列中每个单独元素的属性。如果我们想让多个元素相互关联，就需要量化指标，如第一个例子所示。 有时我们想使用序列来模拟数组的可更新特性。虽然我们不能改变原来的序列，但我们可以创建一个新序列，其中除了更新的元素外，所有元素都是相同的:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然，下标i必须是数组的下标。这个语法只是可以通过常规切片和访问操作完成的操作符的快捷方式。你能填写下面的代码吗?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // this works by concatenating everything that doesn\'t\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n你也可以用数组的元素组成一个序列。这是使用与上面相同的“slice”表示法完成的:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获得数组的一部分，可以像常规切片操作一样给出边界:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因为序列支持in和!in，这个操作为我们提供了一种简单的方法来表达" element not in array "属性，即将下面这个:forall k :: 0 <= k < a.length ==> elem != a[k] 转化为：elem !in a[..]\n\n此外，边界很容易包括:forall k :: 0 <= k < i ==> elem != a[k] 和这个一样elem !in a[..i]\n\n\n# 多重集合\n\n多重集合几乎在所有方面都与集合相似，除了它们跟踪每个元素的拷贝数。这使得它们在存储数组中的元素集合时特别有用，例如，当每个元素的拷贝数量相同时。multiset类型几乎与set类型相同:\n\n   multiset<int>\n\n\n1\n\n\n类似地，要给出一个multiset字面值，你要写花括号，除非前面有multiset关键字:\n\n  multiset{3,5,7,3}\n\n\n1\n\n\n小心!multiset({3,3})不是带有两个3的多集和字面值。大括号必须与关键字相邻，以使其如期望那样运行。\n\n和集合一样，多集合也是无序的。然而，因为它们跟踪每个元素的数量，上面的文字实际上有两个3。\n\n在集合上定义的许多操作也可用于多集合。您可以使用in来测试某个元素是否在multiset中(in表示它至少具有给定值的一个成员)。多集并集(+)意味着从两者中取元素，并将它们相加。如果一个多集有两个3而另一个有一个3，那么它们的多集并集就会有三个3。多集差异(-)的工作原理类似，因为元素的双重性(即每个元素在多集中有多少个)很重要。所以以下:\n\nmethod test()\n{\n   assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n}\n  assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n\n\n成立，因为我们开始有三个1，然后拿走两个，剩下一个。 multiset disjoint(!!)按预期工作，当且仅当两个多集没有共同成员时为真。同样，如果两个多集的每个元素的计数完全相同，那么它们是相等的。 最后，通过使用带括号的multiset可以从序列和集合中创建多集:\n\nmethod test()\n{\n   assert multiset([1,1]) == multiset{1,1};\n   assert multiset({1,1}) == multiset{1};\n}\n  assert multiset([1,1]) == multiset{1,1};\n  assert multiset({1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这两个断言都是正确的，因为序列的multiset分别考虑每个元素，而set最多只考虑每个元素中的一个。dafny允许您编写{1,1}，但这与{1}相同，因为重复的代码会被忽略。因此，当从一个集合生成一个多集合时，多集合中的每个元素都将具有精确的双重性。从序列生成多集特别有用，因为当与数组切片结合时，允许您讨论数组中的元素集(如multiset(a[..]))，这对验证排序算法和一些数据结构非常有帮助。\n\n\n# 映射\n\ndafny中的映射表示关联数组。与目前为止的其他类型不同，它们有两种类型:键类型和值类型。可以根据键检索或查找值。映射类型如下:\n\n  map<u, v>\n\n\n1\n\n\n其中u是键类型，v是值类型。例如，我们可以有一个从整数到整数的映射map<int, int>。这种类型的字面值可能是map[4 := 5, 5 := 6]。这张地图把4和5联系起来，把5和6联系起来。您可以使用m[key]访问给定键的值，如果m是一个map而key是一个键。所以我们可以这样写:\n\nmethod test() {\n  var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n}\n var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为4作为m的键值，会产生5。我们还知道m[5] == 6，因为这是另一个映射。 每个映射都有一个域，域是该映射具有值的所有键。向地图请求其域外的键是不正确的。所以m[7]没有任何意义，因为m没有给7定义任何值。要测试一个键是否在映射的域中，可以使用in操作符。例如，4在m中，5在m中，但是7 不在m中。有了量词，你可以说定义域是某个集合，如forall i :: i in m <==> 0 <= i < 100(当m的定义域恰好是数字0-99时，结果为真)。另外，如果两个映射的域作为集合是不相交的，那么它们就是不相交的(!!) 如果m是一个map，那么m[i:= j]是一个新的map，它是将i加到m的域中，然后将键i与值j关联起来的结果。如果i已经有一个值，那么它将在新的map中被覆盖。这也意味着当使用map字面值时，允许重复一个键，但随后第一个值将被重写。所以map[3 := 5, 3 := 4] == map[3 := 4]。注意，如果两个映射具有相同的域，则它们是相等的，并且它们将相同的键映射为相同的值。同样，映射的域必须总是有限的。 像集合一样，map有map的comprehension。语法几乎和set一样:\n\nmap i: t | p(i) :: f(i)\n\n\n1\n\n\n区别在于，i是键，它被映射到f(i),p(i)用来确定新映射的定义域是什么。所以:\n\nmethod test() {\n  var m := map i | 0 <= i < 10 :: 2*i;\n}\n  map i | 0 <= i < 10 :: 2*i\n\n\n1\n2\n3\n4\n\n\n就是把0-9的数字变成双打数字的地图。这也是从映射中删除键的方法。例如，这个表达式将键3从一个int到int的映射m中删除:\n\nmethod test() {\n  var m := map[3 := 5, 4 := 6, 1 := 4];\n  var l := map i | i in m && i != 3 :: m[i];\n  assert l == map[4:= 6, 1 := 4];\n}\n  map i | i in m && i != 3 :: m[i]\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"自动归纳",frontmatter:{title:"自动归纳",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/718207/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/1.%E8%87%AA%E5%8A%A8%E5%BD%92%E7%BA%B3.html",relativePath:"40.资源/00.实践探索/1.自动归纳.md",key:"v-7a49265a",path:"/pages/718207/",headers:[{level:2,title:"运行实例",slug:"运行实例",normalizedTitle:"运行实例",charIndex:274},{level:3,title:"列表和函数定义",slug:"列表和函数定义",normalizedTitle:"列表和函数定义",charIndex:283},{level:3,title:"引理和证明",slug:"引理和证明",normalizedTitle:"引理和证明",charIndex:712},{level:3,title:"终止的细节",slug:"终止的细节",normalizedTitle:"终止的细节",charIndex:2263},{level:3,title:"RangeLength的其他终止度量",slug:"rangelength的其他终止度量",normalizedTitle:"rangelength的其他终止度量",charIndex:3416},{level:3,title:"一个较短的证明",slug:"一个较短的证明",normalizedTitle:"一个较短的证明",charIndex:4534},{level:3,title:"强感应",slug:"强感应",normalizedTitle:"强感应",charIndex:5182},{level:2,title:"自动归纳",slug:"自动归纳-2",normalizedTitle:"自动归纳",charIndex:2},{level:3,title:"自动归纳的详细情况",slug:"自动归纳的详细情况",normalizedTitle:"自动归纳的详细情况",charIndex:6522},{level:3,title:"例如:缺少decreases",slug:"例如-缺少decreases",normalizedTitle:"例如:缺少decreases",charIndex:7369},{level:3,title:"例如:只对 len 进行量化",slug:"例如-只对len进行量化",normalizedTitle:"例如:只对 len 进行量化",charIndex:null},{level:4,title:"致谢",slug:"致谢",normalizedTitle:"致谢",charIndex:8537},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:8597}],headersStr:"运行实例 列表和函数定义 引理和证明 终止的细节 RangeLength的其他终止度量 一个较短的证明 强感应 自动归纳 自动归纳的详细情况 例如:缺少decreases 例如:只对 len 进行量化 致谢 参考文献",content:'# 自动归纳\n\n> K. Rustan M. Leino Manuscript KRML 269, 31 May 2019\n\n摘要\n\n对于简单的例子，Dafny的自动归纳法足够强大，可以在不需要人工输入的情况下证明一些引理，并帮助减少证明其他引理所需的人工输入。本说明解释了自动感应是如何应用的，以及如何使用两个主要旋钮来调整自动化的功能。\n\n> Dafny不仅支持手工编写的引理，而且还提供了一些自动化功能，帮助通过归纳来证明引理[0]。让我们从手动证明的变化开始，然后看看自动感应如何提供或无法提供证明，最后看看如何调整自动化的功能。\n\n\n# 运行实例\n\n\n# 列表和函数定义\n\n考虑以下递归定义列表的标准定义，以及一个Length函数和一个构造递增整数列表的函数。\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Range(start: int, len: nat): List<int>\n  decreases len\n{\n  if len == 0 then Nil else Cons(start, Range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n有了这些定义，我们开始证明列表Range(start, len)的长度是len。\n\n\n# 引理和证明\n\n我们要证明list Range(start, len)的长度是len。我们从手工验证开始。为了确保在第一个示例中自动归纳不会对我们有帮助，我用属性{:induction false}标记了引理。\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      Length(Range(start, len));\n    ==  // def. Range, since len > 0\n      Length(Cons(start, Range(start+1, len-1)));\n    ==  // def. Length on Cons\n      1 + Length(Range(start+1, len-1));\n    ==  { RangeLength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n出于本文的目的，我假设您已经基本了解如何手动编写这样的证明，无论是在Dafny还是在纸上。我将在这里描述证明的要素，但不会试图解释所有可能的考虑因素。\n\n引理称为RangeLength，由start和len参数化，就像Range函数一样。引理证明的属性在ensures子句中陈述。它也被称为“证明目标”。\n\n引理的签名部分还定义了一个decreases子句，该子句表示表达式len将被用作引理的任何递归调用的终止度量。这个终止度规与“范围”函数的终止度规相同。这很常见，因为在引理的证明目标中，证明的结构通常遵循函数的结构。\n\n引理主体分为两种情况，遵循“范围”定义中的情况。第一个例子是len == 0，它给出了一个非常简单的证明:当len == 0时，Range返回长度为0的Nil。\n\n另一种情况是使用已验证的计算，通常称为calc语句[1]。这个计算从表达式Length(Range(start, len))开始，并使用保持等式的转换来得到len，这正是证明目标所说的引理必须证明的。计算的前两个步骤应用Range和Length的定义，将表达式重写为我们可以看到表达式的形式\n\nLength(Range(start+1, len-1))\n\n\n1\n\n\n这就是证明过程中有趣的一步。我们想用len - 1替换这个表达式，这需要证明表达式确实等于len - 1。用正确的参数，这就是我们要证明的引理。因此，我们使用calc语句提示并调用引理:\n\nRangeLength(start+1, len-1);\n\n\n1\n\n\n因为这是对我们要证明的引理的递归调用，我们必须证明终止。对引理的递归调用通常被称为“归纳假设”的应用。这样，我们的终止检查对应于确保归纳是“有根据的”。在Dafny中，通过显示每个递归调用都会减少一些终止度量来证明终止，也就是说，递归调用的某个表达式的计算值比调用者的值要小。这个更小的终止度规表达式是什么“更小”是什么意思?表达式是len，由decreases子句给出，由于len是一个整数，Dafny使用“小于，以0为界的整数”作为顺序。\n\n\n# 终止的细节\n\n这太拗口了。让我们再回顾一下最后一部分，关于终止的部分。\n\n为了证明对一个(函数、方法或)引理的递归调用会终止，我们将引理的每次调用按照合理的顺序与一个值关联起来。有充分的理由意味着不存在无限的降序链。也就是说，存在固定的排序，并且在该排序中，每一个连续的小值序列都是有限的。例如，在“小于，以“0”为界的整数”排序中，一个降序链是\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\n这个链是有限的。无论您写下的降序链是什么，它都是有限的(否则，您最终会得到一个负数，但请记住我们说过“以‘0’为界”0)。\n\nDafny为每种类型构建了一个固定的、基于良好基础的顺序。1它还支持值的字典元组，这种元组的良好基础顺序是每个组件上类型的字典顺序。\n\n我们将引理调用与这个固定的、有根据的顺序的值关联的方式是声明一个decreases子句。它的参数是一个表达式列表，这些表达式构成一个字典元组。对于“RangeLength”引理，我们使用了“减小len”。这意味着每次对引理的调用都将与传入参数len的相同值相关联。\n\n函数Range也是递归的，对于它的调用，我们还使用len作为终止度量。函数Length也是递归的，但显然我们没有给它一个decreases子句。在缺少decreases子句的情况下，Dafny为我们提供了一个子句，即按给定顺序由函数/方法/引词的参数组成的字典元组。2Length的终止度量是list(Dafny的有理有据的归纳数据类型的顺序是结构包含)。Dafny的ide提供了一个工具提示(你可以在函数/方法/引理声明上看到)，告诉你它为递归函数/方法/引理选择了哪个“减小”子句。\n\n到目前为止，我已经说过Dafny定义了一个固定的、有根据的排序，而将引理调用与该排序中的值关联的方法是声明一个“减小”子句。验证者如何使用这些东西来证明终止?它证明了与被调用方关联的值严格低于与调用方关联的值。换句话说，它证明了每个递归调用都在递减链中采取了一步。因为每个链都是有限的，所以不存在无限递归。换句话说，递归调用终止。\n\n在这个例子中，有一个从RangeLength(start, len)到RangeLength(start+1, len-1)的递归调用。引理使用了decreases len，所以验证器检查len-1 < len，这证明了终止。\n\n类似地，有一个从Range(start, len)到Range(start+1, len-1)的递归调用。验证器检查len-1 < len，这证明了终止。\n\n最后，有一个从Length(list)到Length(tail)的递归调用，其中tail在结构上包含在list中。因此，验证者也可以在这里证明终止。\n\n\n# RangeLength的其他终止度量\n\n考虑一下如果我们为“RangeLength”选择不同的终止度量会发生什么是有指导意义的。对于我们考虑的每一个元素，证明义务的构造方式都是相同的:RangeLength(start+1, len-1)的值必须小于RangeLength(start, len)的值。\n\n假设我们声明RangeLength带有decreases 10*len + 28。是的，这个终止度规足以证明终止，因为10*len + 18小于10*len + 28。\n\ndecreases len - 6呢?不，Dafny会抱怨不能证明终止，如果你给它这个终止度量。它将无法证明在整数排序中lens -7低于lens -6，因为它们可能是负的。3\n\n让我们试试decreases start + len。不，因为start+1 + len-1不小于start+ len。\n\ndecreases start + 2*len怎么样?是的，这证明了终止，因为start+1 + 2*(len-1)小于start+ 2*len。\n\n使用字典元组start, len怎么样?不，这不会证明终止，因为start+1, len-1在字典上并不小于start, len(事实上，它在字典上更大)。如果我们把“RangeLength”中的“减小”去掉，Dafny会为我们生成一个。它生成的值是decreases start, len，因为RangeLength的参数是start和len，按这个顺序。因此，如果没有明确的“减少”条款，Dafny会抱怨无法证明终止合同。\n\n如何切换参数的顺序，比如len, start ?是的，这证明了终止，因为len-1, start+1小于len, start。\n\n如果你改变RangeLength来交换它的参数start和len(并且对RangeLength做同样的交换递归调用)，那么你可以忽略decreases子句。在本例中，Dafny将生成decreases len, start，这证明了终止。然而，通常建议坚持参数顺序，这是手边函数/方法/引理最自然的顺序。\n\n最后，这个奇怪的终止指标decreases 7,len怎么样?当你第一次大声读到这个的时候，你可能会说\n\n> 减少7 ?什么东西能减少呢?7是我曾祖父母在世时的数字，7将永远是这个数字。没有办法降低!\n\n你是对的，但“减少”条款不是这么说的。“减小”子句只是简单地说明了如何将每个引理调用以合理的顺序映射到一个值。所以，有了这个奇怪的终止度量，证明的义务是检查7,len-1在字典上小于7,len，它确实是。其实也没那么古怪。\n\n\n# 一个较短的证明\n\n让我们简化我们为RangeLength编写的手动证明。当我们写一个证明的时候，calc语句是很有用的，它也提供了一个可读的证明。但一旦我们找到了一个证明，我们有时会选择缩短它，也许是因为回想起来，我们发现自己太拘谨了，即使是对我们自己的口味来说。\n\n我们上面写的calc陈述实际上只有一个重要步骤，即归纳假设的应用。事实上，我们可以用一个调用来替换整个calc语句:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n因为if的" then "分支是空的，我们当然也可以否定守卫，交换分支，并省略空的else:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 强感应\n\n我们还能比这个if语句做得更好吗?那要看你觉得什么更好了，但在达芙妮有办法消除这个分支。我们可以通过替换整个if语句和它对RangeLength的一次调用，用forall语句调用RangeLength来获取一大堆值。\n\n首先，假设我们尝试使用以下代码作为RangeLength的主体:\n\nforall start`, len` {\n  RangeLength(start`, len`);\n}\n\n\n1\n2\n3\n\n\n这个漫不经心的语句对所有可能的start和len值调用RangeLength。这是行不通的，因为很多递归调用都不会终止。我们需要限制自己的值为start和len，以减少终止度量。\n\n那么，让我们试试这个:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  forall start`, len` | 0 <= len` < len {\n    RangeLength(start`, len`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于所有的start值和所有小于len值，调用RangeLength。也就是说，这个forall语句一次性对RangeLength进行了无数次递归调用。由于len 的值小于len，这无数次调用中的每一次都会终止。4\n\n这个版本的RangeLength进行验证。对于所有这样的小值的归纳假设的数学名称叫做“强归纳”。\n\n好的，start的值可以大于start(在这一点上，它对于证明start + 1是其中一个值是至关重要的)。所以，你可能认为上面的“为所有人”的陈述不仅仅是强归纳。事实上，有些人可能会争辩说，这个forall语句也执行了所谓的“泛化”引理到所有的start值。但是如果你认为决定smaller的排序只是比较len组件，那么start， len decreases确实比start, len 小，只要len 小于len。不管你想怎么想，或者你想给它起什么数学名字，Dafny都接受上面的“所有人”的说法作为证明。在编程术语中，我们所做的就是证明每个递归调用都会终止，这与我们定义终止度规的方式是一样的，即decreases len。\n\n\n# 自动归纳\n\n有了这些背景知识，我们终于可以了解Dafny是如何实现自动感应的了。简而言之:如果你删除属性{:inducerfalse}(我引入这个属性只是为了禁用自动感应，而我们在一开始讨论什么是证明)，那么Dafny在默认情况下所做的就是插入我们刚才看到的forall语句。这意味着你可以删除手动插入的forall语句，因为Dafny会为你添加它。换句话说，Dafny接受了下面这个引理的证明:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\n简洁明了\n\n\n# 自动归纳的详细情况\n\nDafny自动归纳法归根结底就是在每个引理的开头自动生成一个forall语句。这并不能解决所有的归纳法问题，但我很惊讶，这个简单的方法确实解决了这么多简单的归纳法问题。让我们来看看这个动作的组成部分。\n\n对于带有形式参数args、前置条件P(args)、5和终止度量T(args)的引理L， Dafny自动归纳在L的主体开头插入以下forall语句:\n\nforall aa` | P(args`) && T(args`) < T(args) {\n  L(args`);\n}\n\n\n1\n2\n3\n\n\n此处\n\n * aa是形式参数args的子集，\n * aa ’是aa，适当地重命名有新的名字，\n * args’表示args，但是aa ’中的每个变量都被aa中的相应变量替换，并且\n * <表示Dafny的字典顺序是有根据的。\n\n变量args的子集aa可以通过在引理上放置属性{:induction aa}来定制。如果没有给出这样的属性，那么Dafny启发式地选择aa。当您将鼠标悬停在引理的名称上时，Dafny会在工具提示中报告它所选择的内容。\n\n我们可以把{:induction x}看作是‘对x进行归纳法’，但是要小心一点。我发现“归纳法胜过……”这个短语在数学上的常用用法合并了几个概念。因此，准确地说，{:induction aa}属性指定的是哪些参数要在上统一量化。\n\n还有一个很容易忘记的微妙之处:“减少”条款很重要。当我们写一个类似于RangeLength的引理时，我们可能期望证明足够简单，以至于Dafny的自动归纳法会自动处理它。如果是这样，我们可以写下引理的类型签名和(前置和后置条件)。这通常是所有需要的，但在RangeLength的情况下，还需要提供减少子句。通常，如果引理所涉及的主函数(运行示例中的Range)需要一个显式的减小子句，那么引理也需要。唉，这很容易被忘记。\n\n接下来，让我们考虑一些自定义RangeLength自动归纳的方法。\n\n\n# 例如:缺少decreases\n\n如果你忘记了“RangeLength”的“减小”子句会发生什么?引理看起来是这样的:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\n对于这个引理，Dafny提出了{:induction start，len}和decreases start，len.6这意味着诱导操作插入隐含的forall语句\n\nforall start`: nat, len`: nat |\n  start` < start || (start` == start && len` < len)\n{\n  RangeLength(start`, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\n正如我们在前一节中所探讨的，这并不能证明这个引理，因为关键的调用RangeLength(start+1, len-1)不在执行的调用中。\n\n\n# 例如:只对len进行量化\n\n如果我们手动覆盖量化变量，只列出len会怎么样?\n\nlemma {:induction len} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\n然后我们得到下面的forall语句:\n\nforall len`: nat |\n  start < start || (start == start && len` < len)\n{\n  RangeLength(start, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意，这个例子中没有start。相反，原始的形式参数start用于公式化的范围表达式\n\nP(start, len`) && T(start, len`) < T(start, len)\n\n\n1\n\n\n在这个例子中没有先决条件，所以P部分是true。因为我们没有提供一个明确的减少条款，Dafny生成了decreases start，len。因此，限制全局量化变量(即len ’)的范围表达式是\n\nstart < start || (start == start && len` < len)\n\n\n1\n\n\n简化为len ’ < len\n\n同样，由于forall语句所包含的递归调用不包括关键的调用RangeLength(start+1, len-1)，Dafny将报告一个错误，引理的后置条件可能不成立。\n\n即使我们手动提供了一个“减少”条款，结果也是一样的。这仍然会将len ’限制为小于len的值，这是可以的，但问题仍然是归纳假设只考虑给定的start值。\n\n# 致谢\n\n我很感谢Sean McLaughlin，他提供了跑步的例子和关于RangeLength自动感应的问题。\n\n\n# 参考文献\n\n[0]K. Rustan M. Leino. Automating induction with an SMT solver. In Viktor Kuncak and Andrey Rybalchenko, editors, Verification, Model Checking, and Abstract Interpretation — 13th International Conference, VMCAI 2012, volume 7148 of Lecture Notes in Computer Science, pages 315–331. Springer, January 2012. 🔎\n\n[1]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments — 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170–190. Springer, 2014. 🔎\n\n----------------------------------------\n\n0.我化简了一下。Dafny对整数的合理排序实际上是“小于，且不超过一个负数的整数”。所以，一条链允许下降到0以下，但一旦它包含一个负数，它就必须停止。这个扩展是一个有根据的顺序，因为仍然没有办法做出一个无限递减链。[↩](http://leino.science/papers/krml269.html # back-fn-fn-int-order)\n\n1.我化简了一下。Dafny的固定的有根据的顺序也对不同类型的值进行排序。[↩](http://leino.science/papers/krml269.html # back-fn-fn-across-types)\n\n2.这是一个轻微的简化。Dafny为递归函数/方法/引理提出“减小”子句的启发式方法省略了类型对证明终止没有帮助的参数。例如，类型为类型参数的参数会在自动生成的“减小”子句中被省略。[↩](http://leino.science/papers/krml269.html # back-fn-fn-auto-decr)\n\n3.在前面的例子中，我把握得很准，因为我也应该指出10*len + 18是非负的。)作者系\n\n4.“无数个电话?!”你对自己说。"即使每个调用都终止了，终止是怎么回事? "我不会在这里深入研究，但我至少要指出，我们调用的是一个引理，而不是一个编译的方法。因此，您不需要担心是否有足够的计算资源来进行无限次调用。[↩](http://leino.science/papers/krml269.html # back-fn-fn-inf-calls)\n\n5.引理的前提条件是使用关键字requires声明的。它就像引理的一个先行词，在每个呼叫点都要检查它是否成立。运行的示例不包含前置条件。一个简单的方法是将start的类型从nat更改为int，并添加require 0 <= start。[↩](http://leino.science/papers/krml269.html # back-fn-fn-pre)\n\n6.我提到过Dafny ide中的工具提示会告诉你Dafny选择了哪些“减少”条款。在撰写本文时，只有当函数/方法/引理的主体包含显式递归调用时，才会显示这样的工具提示。特别是，如果引理的主体是空的，则没有工具提示显示生成了什么“减小”子句。[↩](http://leino.science/papers/krml269.html # back-fn-fn-no-decr-tooltip)',normalizedContent:'# 自动归纳\n\n> k. rustan m. leino manuscript krml 269, 31 may 2019\n\n摘要\n\n对于简单的例子，dafny的自动归纳法足够强大，可以在不需要人工输入的情况下证明一些引理，并帮助减少证明其他引理所需的人工输入。本说明解释了自动感应是如何应用的，以及如何使用两个主要旋钮来调整自动化的功能。\n\n> dafny不仅支持手工编写的引理，而且还提供了一些自动化功能，帮助通过归纳来证明引理[0]。让我们从手动证明的变化开始，然后看看自动感应如何提供或无法提供证明，最后看看如何调整自动化的功能。\n\n\n# 运行实例\n\n\n# 列表和函数定义\n\n考虑以下递归定义列表的标准定义，以及一个length函数和一个构造递增整数列表的函数。\n\ndatatype list<a> = nil | cons(a, list<a>)\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method range(start: int, len: nat): list<int>\n  decreases len\n{\n  if len == 0 then nil else cons(start, range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n有了这些定义，我们开始证明列表range(start, len)的长度是len。\n\n\n# 引理和证明\n\n我们要证明list range(start, len)的长度是len。我们从手工验证开始。为了确保在第一个示例中自动归纳不会对我们有帮助，我用属性{:induction false}标记了引理。\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      length(range(start, len));\n    ==  // def. range, since len > 0\n      length(cons(start, range(start+1, len-1)));\n    ==  // def. length on cons\n      1 + length(range(start+1, len-1));\n    ==  { rangelength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n出于本文的目的，我假设您已经基本了解如何手动编写这样的证明，无论是在dafny还是在纸上。我将在这里描述证明的要素，但不会试图解释所有可能的考虑因素。\n\n引理称为rangelength，由start和len参数化，就像range函数一样。引理证明的属性在ensures子句中陈述。它也被称为“证明目标”。\n\n引理的签名部分还定义了一个decreases子句，该子句表示表达式len将被用作引理的任何递归调用的终止度量。这个终止度规与“范围”函数的终止度规相同。这很常见，因为在引理的证明目标中，证明的结构通常遵循函数的结构。\n\n引理主体分为两种情况，遵循“范围”定义中的情况。第一个例子是len == 0，它给出了一个非常简单的证明:当len == 0时，range返回长度为0的nil。\n\n另一种情况是使用已验证的计算，通常称为calc语句[1]。这个计算从表达式length(range(start, len))开始，并使用保持等式的转换来得到len，这正是证明目标所说的引理必须证明的。计算的前两个步骤应用range和length的定义，将表达式重写为我们可以看到表达式的形式\n\nlength(range(start+1, len-1))\n\n\n1\n\n\n这就是证明过程中有趣的一步。我们想用len - 1替换这个表达式，这需要证明表达式确实等于len - 1。用正确的参数，这就是我们要证明的引理。因此，我们使用calc语句提示并调用引理:\n\nrangelength(start+1, len-1);\n\n\n1\n\n\n因为这是对我们要证明的引理的递归调用，我们必须证明终止。对引理的递归调用通常被称为“归纳假设”的应用。这样，我们的终止检查对应于确保归纳是“有根据的”。在dafny中，通过显示每个递归调用都会减少一些终止度量来证明终止，也就是说，递归调用的某个表达式的计算值比调用者的值要小。这个更小的终止度规表达式是什么“更小”是什么意思?表达式是len，由decreases子句给出，由于len是一个整数，dafny使用“小于，以0为界的整数”作为顺序。\n\n\n# 终止的细节\n\n这太拗口了。让我们再回顾一下最后一部分，关于终止的部分。\n\n为了证明对一个(函数、方法或)引理的递归调用会终止，我们将引理的每次调用按照合理的顺序与一个值关联起来。有充分的理由意味着不存在无限的降序链。也就是说，存在固定的排序，并且在该排序中，每一个连续的小值序列都是有限的。例如，在“小于，以“0”为界的整数”排序中，一个降序链是\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\n这个链是有限的。无论您写下的降序链是什么，它都是有限的(否则，您最终会得到一个负数，但请记住我们说过“以‘0’为界”0)。\n\ndafny为每种类型构建了一个固定的、基于良好基础的顺序。1它还支持值的字典元组，这种元组的良好基础顺序是每个组件上类型的字典顺序。\n\n我们将引理调用与这个固定的、有根据的顺序的值关联的方式是声明一个decreases子句。它的参数是一个表达式列表，这些表达式构成一个字典元组。对于“rangelength”引理，我们使用了“减小len”。这意味着每次对引理的调用都将与传入参数len的相同值相关联。\n\n函数range也是递归的，对于它的调用，我们还使用len作为终止度量。函数length也是递归的，但显然我们没有给它一个decreases子句。在缺少decreases子句的情况下，dafny为我们提供了一个子句，即按给定顺序由函数/方法/引词的参数组成的字典元组。2length的终止度量是list(dafny的有理有据的归纳数据类型的顺序是结构包含)。dafny的ide提供了一个工具提示(你可以在函数/方法/引理声明上看到)，告诉你它为递归函数/方法/引理选择了哪个“减小”子句。\n\n到目前为止，我已经说过dafny定义了一个固定的、有根据的排序，而将引理调用与该排序中的值关联的方法是声明一个“减小”子句。验证者如何使用这些东西来证明终止?它证明了与被调用方关联的值严格低于与调用方关联的值。换句话说，它证明了每个递归调用都在递减链中采取了一步。因为每个链都是有限的，所以不存在无限递归。换句话说，递归调用终止。\n\n在这个例子中，有一个从rangelength(start, len)到rangelength(start+1, len-1)的递归调用。引理使用了decreases len，所以验证器检查len-1 < len，这证明了终止。\n\n类似地，有一个从range(start, len)到range(start+1, len-1)的递归调用。验证器检查len-1 < len，这证明了终止。\n\n最后，有一个从length(list)到length(tail)的递归调用，其中tail在结构上包含在list中。因此，验证者也可以在这里证明终止。\n\n\n# rangelength的其他终止度量\n\n考虑一下如果我们为“rangelength”选择不同的终止度量会发生什么是有指导意义的。对于我们考虑的每一个元素，证明义务的构造方式都是相同的:rangelength(start+1, len-1)的值必须小于rangelength(start, len)的值。\n\n假设我们声明rangelength带有decreases 10*len + 28。是的，这个终止度规足以证明终止，因为10*len + 18小于10*len + 28。\n\ndecreases len - 6呢?不，dafny会抱怨不能证明终止，如果你给它这个终止度量。它将无法证明在整数排序中lens -7低于lens -6，因为它们可能是负的。3\n\n让我们试试decreases start + len。不，因为start+1 + len-1不小于start+ len。\n\ndecreases start + 2*len怎么样?是的，这证明了终止，因为start+1 + 2*(len-1)小于start+ 2*len。\n\n使用字典元组start, len怎么样?不，这不会证明终止，因为start+1, len-1在字典上并不小于start, len(事实上，它在字典上更大)。如果我们把“rangelength”中的“减小”去掉，dafny会为我们生成一个。它生成的值是decreases start, len，因为rangelength的参数是start和len，按这个顺序。因此，如果没有明确的“减少”条款，dafny会抱怨无法证明终止合同。\n\n如何切换参数的顺序，比如len, start ?是的，这证明了终止，因为len-1, start+1小于len, start。\n\n如果你改变rangelength来交换它的参数start和len(并且对rangelength做同样的交换递归调用)，那么你可以忽略decreases子句。在本例中，dafny将生成decreases len, start，这证明了终止。然而，通常建议坚持参数顺序，这是手边函数/方法/引理最自然的顺序。\n\n最后，这个奇怪的终止指标decreases 7,len怎么样?当你第一次大声读到这个的时候，你可能会说\n\n> 减少7 ?什么东西能减少呢?7是我曾祖父母在世时的数字，7将永远是这个数字。没有办法降低!\n\n你是对的，但“减少”条款不是这么说的。“减小”子句只是简单地说明了如何将每个引理调用以合理的顺序映射到一个值。所以，有了这个奇怪的终止度量，证明的义务是检查7,len-1在字典上小于7,len，它确实是。其实也没那么古怪。\n\n\n# 一个较短的证明\n\n让我们简化我们为rangelength编写的手动证明。当我们写一个证明的时候，calc语句是很有用的，它也提供了一个可读的证明。但一旦我们找到了一个证明，我们有时会选择缩短它，也许是因为回想起来，我们发现自己太拘谨了，即使是对我们自己的口味来说。\n\n我们上面写的calc陈述实际上只有一个重要步骤，即归纳假设的应用。事实上，我们可以用一个调用来替换整个calc语句:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n因为if的" then "分支是空的，我们当然也可以否定守卫，交换分支，并省略空的else:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 强感应\n\n我们还能比这个if语句做得更好吗?那要看你觉得什么更好了，但在达芙妮有办法消除这个分支。我们可以通过替换整个if语句和它对rangelength的一次调用，用forall语句调用rangelength来获取一大堆值。\n\n首先，假设我们尝试使用以下代码作为rangelength的主体:\n\nforall start`, len` {\n  rangelength(start`, len`);\n}\n\n\n1\n2\n3\n\n\n这个漫不经心的语句对所有可能的start和len值调用rangelength。这是行不通的，因为很多递归调用都不会终止。我们需要限制自己的值为start和len，以减少终止度量。\n\n那么，让我们试试这个:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  forall start`, len` | 0 <= len` < len {\n    rangelength(start`, len`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于所有的start值和所有小于len值，调用rangelength。也就是说，这个forall语句一次性对rangelength进行了无数次递归调用。由于len 的值小于len，这无数次调用中的每一次都会终止。4\n\n这个版本的rangelength进行验证。对于所有这样的小值的归纳假设的数学名称叫做“强归纳”。\n\n好的，start的值可以大于start(在这一点上，它对于证明start + 1是其中一个值是至关重要的)。所以，你可能认为上面的“为所有人”的陈述不仅仅是强归纳。事实上，有些人可能会争辩说，这个forall语句也执行了所谓的“泛化”引理到所有的start值。但是如果你认为决定smaller的排序只是比较len组件，那么start， len decreases确实比start, len 小，只要len 小于len。不管你想怎么想，或者你想给它起什么数学名字，dafny都接受上面的“所有人”的说法作为证明。在编程术语中，我们所做的就是证明每个递归调用都会终止，这与我们定义终止度规的方式是一样的，即decreases len。\n\n\n# 自动归纳\n\n有了这些背景知识，我们终于可以了解dafny是如何实现自动感应的了。简而言之:如果你删除属性{:inducerfalse}(我引入这个属性只是为了禁用自动感应，而我们在一开始讨论什么是证明)，那么dafny在默认情况下所做的就是插入我们刚才看到的forall语句。这意味着你可以删除手动插入的forall语句，因为dafny会为你添加它。换句话说，dafny接受了下面这个引理的证明:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\n简洁明了\n\n\n# 自动归纳的详细情况\n\ndafny自动归纳法归根结底就是在每个引理的开头自动生成一个forall语句。这并不能解决所有的归纳法问题，但我很惊讶，这个简单的方法确实解决了这么多简单的归纳法问题。让我们来看看这个动作的组成部分。\n\n对于带有形式参数args、前置条件p(args)、5和终止度量t(args)的引理l， dafny自动归纳在l的主体开头插入以下forall语句:\n\nforall aa` | p(args`) && t(args`) < t(args) {\n  l(args`);\n}\n\n\n1\n2\n3\n\n\n此处\n\n * aa是形式参数args的子集，\n * aa ’是aa，适当地重命名有新的名字，\n * args’表示args，但是aa ’中的每个变量都被aa中的相应变量替换，并且\n * <表示dafny的字典顺序是有根据的。\n\n变量args的子集aa可以通过在引理上放置属性{:induction aa}来定制。如果没有给出这样的属性，那么dafny启发式地选择aa。当您将鼠标悬停在引理的名称上时，dafny会在工具提示中报告它所选择的内容。\n\n我们可以把{:induction x}看作是‘对x进行归纳法’，但是要小心一点。我发现“归纳法胜过……”这个短语在数学上的常用用法合并了几个概念。因此，准确地说，{:induction aa}属性指定的是哪些参数要在上统一量化。\n\n还有一个很容易忘记的微妙之处:“减少”条款很重要。当我们写一个类似于rangelength的引理时，我们可能期望证明足够简单，以至于dafny的自动归纳法会自动处理它。如果是这样，我们可以写下引理的类型签名和(前置和后置条件)。这通常是所有需要的，但在rangelength的情况下，还需要提供减少子句。通常，如果引理所涉及的主函数(运行示例中的range)需要一个显式的减小子句，那么引理也需要。唉，这很容易被忘记。\n\n接下来，让我们考虑一些自定义rangelength自动归纳的方法。\n\n\n# 例如:缺少decreases\n\n如果你忘记了“rangelength”的“减小”子句会发生什么?引理看起来是这样的:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\n对于这个引理，dafny提出了{:induction start，len}和decreases start，len.6这意味着诱导操作插入隐含的forall语句\n\nforall start`: nat, len`: nat |\n  start` < start || (start` == start && len` < len)\n{\n  rangelength(start`, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\n正如我们在前一节中所探讨的，这并不能证明这个引理，因为关键的调用rangelength(start+1, len-1)不在执行的调用中。\n\n\n# 例如:只对len进行量化\n\n如果我们手动覆盖量化变量，只列出len会怎么样?\n\nlemma {:induction len} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\n然后我们得到下面的forall语句:\n\nforall len`: nat |\n  start < start || (start == start && len` < len)\n{\n  rangelength(start, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意，这个例子中没有start。相反，原始的形式参数start用于公式化的范围表达式\n\np(start, len`) && t(start, len`) < t(start, len)\n\n\n1\n\n\n在这个例子中没有先决条件，所以p部分是true。因为我们没有提供一个明确的减少条款，dafny生成了decreases start，len。因此，限制全局量化变量(即len ’)的范围表达式是\n\nstart < start || (start == start && len` < len)\n\n\n1\n\n\n简化为len ’ < len\n\n同样，由于forall语句所包含的递归调用不包括关键的调用rangelength(start+1, len-1)，dafny将报告一个错误，引理的后置条件可能不成立。\n\n即使我们手动提供了一个“减少”条款，结果也是一样的。这仍然会将len ’限制为小于len的值，这是可以的，但问题仍然是归纳假设只考虑给定的start值。\n\n# 致谢\n\n我很感谢sean mclaughlin，他提供了跑步的例子和关于rangelength自动感应的问题。\n\n\n# 参考文献\n\n[0]k. rustan m. leino. automating induction with an smt solver. in viktor kuncak and andrey rybalchenko, editors, verification, model checking, and abstract interpretation — 13th international conference, vmcai 2012, volume 7148 of lecture notes in computer science, pages 315–331. springer, january 2012. 🔎\n\n[1]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments — 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170–190. springer, 2014. 🔎\n\n----------------------------------------\n\n0.我化简了一下。dafny对整数的合理排序实际上是“小于，且不超过一个负数的整数”。所以，一条链允许下降到0以下，但一旦它包含一个负数，它就必须停止。这个扩展是一个有根据的顺序，因为仍然没有办法做出一个无限递减链。[↩](http://leino.science/papers/krml269.html # back-fn-fn-int-order)\n\n1.我化简了一下。dafny的固定的有根据的顺序也对不同类型的值进行排序。[↩](http://leino.science/papers/krml269.html # back-fn-fn-across-types)\n\n2.这是一个轻微的简化。dafny为递归函数/方法/引理提出“减小”子句的启发式方法省略了类型对证明终止没有帮助的参数。例如，类型为类型参数的参数会在自动生成的“减小”子句中被省略。[↩](http://leino.science/papers/krml269.html # back-fn-fn-auto-decr)\n\n3.在前面的例子中，我把握得很准，因为我也应该指出10*len + 18是非负的。)作者系\n\n4.“无数个电话?!”你对自己说。"即使每个调用都终止了，终止是怎么回事? "我不会在这里深入研究，但我至少要指出，我们调用的是一个引理，而不是一个编译的方法。因此，您不需要担心是否有足够的计算资源来进行无限次调用。[↩](http://leino.science/papers/krml269.html # back-fn-fn-inf-calls)\n\n5.引理的前提条件是使用关键字requires声明的。它就像引理的一个先行词，在每个呼叫点都要检查它是否成立。运行的示例不包含前置条件。一个简单的方法是将start的类型从nat更改为int，并添加require 0 <= start。[↩](http://leino.science/papers/krml269.html # back-fn-fn-pre)\n\n6.我提到过dafny ide中的工具提示会告诉你dafny选择了哪些“减少”条款。在撰写本文时，只有当函数/方法/引理的主体包含显式递归调用时，才会显示这样的工具提示。特别是，如果引理的主体是空的，则没有工具提示显示生成了什么“减小”子句。[↩](http://leino.science/papers/krml269.html # back-fn-fn-no-decr-tooltip)',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"自动调用引理",frontmatter:{title:"自动调用引理",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1f579f/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/2.%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%BC%95%E7%90%86.html",relativePath:"40.资源/00.实践探索/2.自动调用引理.md",key:"v-1b6b0b30",path:"/pages/1f579f/",headers:[{level:2,title:"超级引理",slug:"超级引理",normalizedTitle:"超级引理",charIndex:998},{level:2,title:"聚合引理调用",slug:"聚合引理调用",normalizedTitle:"聚合引理调用",charIndex:1349},{level:2,title:"函数后置条件",slug:"函数后置条件",normalizedTitle:"函数后置条件",charIndex:1863},{level:2,title:"基本/高级函数对",slug:"基本-高级函数对",normalizedTitle:"基本/高级函数对",charIndex:2555},{level:2,title:"致谢",slug:"致谢",normalizedTitle:"致谢",charIndex:3123}],headersStr:"超级引理 聚合引理调用 函数后置条件 基本/高级函数对 致谢",content:"# 自动调用引理\n\n> K. Rustan M. Leino Manuscript KRML 265, 8 June 2019\n\n摘要 函数的某些性质比其他性质更有用。如果你已经证明了这样一个性质作为一个引理，你可能想让它自动应用。本文将讨论在Dafny中实现这类目标的方法。\n\n在https://github.com/Microsoft/dafny/issues/231上，一名Dafny用户问道:\n\n> 有一种方法在Dafny标记一个引理为“自动”，并将其添加到z3的知识库?\n> \n> 对于学生的家庭作业，我们经常会遇到一些对于Dafny来说过于复杂的规范，并且需要一些手工制作的断言或引理。\n> \n> 如果我们能够定义那些引理来用特定领域的知识来扩充boogie/z3搜索空间，那就太好了，这样我们就不必向学生解释引理是如何工作的，以及查找和使用所需引理的繁琐和困难的任务。\n\n类似于{:auto}注释的东西是可行的吗?我们能否增强。bpl的公理化?\n\n下面的例子说明了这个问题。假设你声明了一个函数，并证明了它的属性:\n\nfunction FibFib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else FibFib(n-2) + FibFib(n-1)\n}\n\nlemma FibFibIsEven(n: nat)\n  ensures FibFib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对于您的应用程序，FibFib总是返回一个偶数可能是至关重要的。使用上面的声明，你将不得不在每次使用函数时调用引理FibFibIsEven。这是乏味的。是否有一些方法来指示Dafny自动应用FibFibIsEven当它需要的时候?\n\n不，Dafny没有这样的特色。(例如，VCC就有这样一个功能。)在某些情况下，这种自动化可能工作得很好。在其他情况下，它可能会导致引理被调用太多次(比如，无限次)，这是有问题的。\n\n如果您有兴趣尝试一些{:autoLemma}特性，请随意使用开放的Dafny源代码。在目前的状态下，我有四个建议你可以尝试，这些建议可能会减轻你正在经历的一些乏味。\n\n\n# 超级引理\n\n一个建议是创建一个“超级引理”来收集其他几个引理的陈述。例如，如果你已经有了:\n\nlemma Lemma0(x: X) ensures P0(x) { ... }\nlemma Lemma1(x: X) ensures P1(x) { ... }\nlemma Lemma2(x: X) ensures P2(x) { ... }\n\n\n1\n2\n3\n\n\n然后你可以把它们合并成一个:\n\nlemma Everything(x: X)\n  ensures P0(x) && P1(x) && P2(x)\n{\n  Lemma0(x: X);\n  Lemma1(x: X);\n  Lemma2(x: X);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这让您可以通过调用一个引理来获得所有3个属性。\n\n\n# 聚合引理调用\n\n另一个建议是在同一时间对多个值调用引理。考虑到:\n\nlemma LemmaForOneX(x: X) ensures P(x) { ... }\n\n\n1\n\n\n你可以对X的所有值同时调用这个引理:\n\nforall x {\n  LemmaForOneX(x);\n}\n\n\n1\n2\n3\n\n\n通过把这个forall语句放在你要证明的一些代码的开头，你实际上已经为每一个可能的X值调用了它。当然，你也可以把这个表述放入一个引理中，然后称之为这个引理:\n\nlemma LemmaForEveryX()\n  ensures forall x :: P(x)\n{\n  forall x {\n    LemmaForOneX(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在许多情况下，这将很好地工作。在其他情况下，验证者可能没有意识到你调用了需要单个引理的值上的引理，所以你可能仍然需要手动调用LemmaForOneX。此外，Dafny还采取措施避免在为上面的引理调用生成的量词中出现“匹配循环”(“匹配循环”会导致引理的无限次使用)。然而，这种机制并不完美，因此这种增加的自动化在某些情况下可能会导致性能下降。\n\n\n# 函数后置条件\n\n第三个建议是在函数的后置条件中声明函数的一些最有用的属性，而不是在单独的引理中声明。例如，代替:\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\n你可以声明为：\n\nfunction F(x: X): int\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\n要获得引理所声明的属性，必须调用引理。相反，在函数的后置条件中声明的任何属性都会在每次调用函数时自动应用。\n\n正如我所提到的，更多的信息可以帮助验证者自动地做更多的事情，但是过多的信息也会让验证者不知所措。因此，我的建议是只对那些您认为每个函数用户都需要的属性使用函数后置条件。很少需要的属性最好在必须手动调用的引理中声明。\n\n此外，在函数后置条件中可以编写的内容也有限制。特别是，你写的东西必须“终止”。在实践中，这意味着在后置条件中提到函数应用于其他参数时可能会遇到问题。例如,\n\npredicate R(x: X, y: X)\n  // commutativity:\n  ensures R(x, y) <==> R(y, x)\n  // transitivity:\n  ensures forall z :: R(x, z) && R(z, y) ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n\n\n不被允许，因为后置条件中存在自引用非终止(即无限递归)调用。因此，像交换性和及物性这样的性质总是需要表述为独立的引理。\n\n\n# 基本/高级函数对\n\n函数后置条件方便地为函数的所有用户提供它所声明的属性，从而减少了显式调用引理的需要。如果不是所有用户都对该属性感兴趣，那么第四个建议是声明两个函数。基本函数给出了函数的实际定义，附带的引理说明了它的性质。premium函数调用基本函数并将属性声明为后置条件，这是通过调用引理来证明的。\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\nfunction F_premium(x: X): int\n  ensures F_premium(x) % 2 == 0\n{ AboutF(x); F(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用户现在可以选择:调用F_premium可以获得函数的值和被证明的属性，而调用F只能获得函数的值。如果你希望高级版本比基础版本更受欢迎，你当然可以将F和F_premium分别重命名为F_basic和F。\n\n除了后置条件之外，这两个函数是同义词。语义。需要注意的是，验证器用来指导其量词使用的机制是语法上的。因此，当验证者决定实例化量词时，你在量词主体中使用的两个函数中的哪一个可以产生差异。出于这个原因，我建议您在编写的任何量词中使用函数的基本版本。\n\n\n# 致谢\n\nBryan Parno提出了第四个建议，将函数的基本版本及其引理包装成函数的高级版本。",normalizedContent:"# 自动调用引理\n\n> k. rustan m. leino manuscript krml 265, 8 june 2019\n\n摘要 函数的某些性质比其他性质更有用。如果你已经证明了这样一个性质作为一个引理，你可能想让它自动应用。本文将讨论在dafny中实现这类目标的方法。\n\n在https://github.com/microsoft/dafny/issues/231上，一名dafny用户问道:\n\n> 有一种方法在dafny标记一个引理为“自动”，并将其添加到z3的知识库?\n> \n> 对于学生的家庭作业，我们经常会遇到一些对于dafny来说过于复杂的规范，并且需要一些手工制作的断言或引理。\n> \n> 如果我们能够定义那些引理来用特定领域的知识来扩充boogie/z3搜索空间，那就太好了，这样我们就不必向学生解释引理是如何工作的，以及查找和使用所需引理的繁琐和困难的任务。\n\n类似于{:auto}注释的东西是可行的吗?我们能否增强。bpl的公理化?\n\n下面的例子说明了这个问题。假设你声明了一个函数，并证明了它的属性:\n\nfunction fibfib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else fibfib(n-2) + fibfib(n-1)\n}\n\nlemma fibfibiseven(n: nat)\n  ensures fibfib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对于您的应用程序，fibfib总是返回一个偶数可能是至关重要的。使用上面的声明，你将不得不在每次使用函数时调用引理fibfibiseven。这是乏味的。是否有一些方法来指示dafny自动应用fibfibiseven当它需要的时候?\n\n不，dafny没有这样的特色。(例如，vcc就有这样一个功能。)在某些情况下，这种自动化可能工作得很好。在其他情况下，它可能会导致引理被调用太多次(比如，无限次)，这是有问题的。\n\n如果您有兴趣尝试一些{:autolemma}特性，请随意使用开放的dafny源代码。在目前的状态下，我有四个建议你可以尝试，这些建议可能会减轻你正在经历的一些乏味。\n\n\n# 超级引理\n\n一个建议是创建一个“超级引理”来收集其他几个引理的陈述。例如，如果你已经有了:\n\nlemma lemma0(x: x) ensures p0(x) { ... }\nlemma lemma1(x: x) ensures p1(x) { ... }\nlemma lemma2(x: x) ensures p2(x) { ... }\n\n\n1\n2\n3\n\n\n然后你可以把它们合并成一个:\n\nlemma everything(x: x)\n  ensures p0(x) && p1(x) && p2(x)\n{\n  lemma0(x: x);\n  lemma1(x: x);\n  lemma2(x: x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这让您可以通过调用一个引理来获得所有3个属性。\n\n\n# 聚合引理调用\n\n另一个建议是在同一时间对多个值调用引理。考虑到:\n\nlemma lemmaforonex(x: x) ensures p(x) { ... }\n\n\n1\n\n\n你可以对x的所有值同时调用这个引理:\n\nforall x {\n  lemmaforonex(x);\n}\n\n\n1\n2\n3\n\n\n通过把这个forall语句放在你要证明的一些代码的开头，你实际上已经为每一个可能的x值调用了它。当然，你也可以把这个表述放入一个引理中，然后称之为这个引理:\n\nlemma lemmaforeveryx()\n  ensures forall x :: p(x)\n{\n  forall x {\n    lemmaforonex(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在许多情况下，这将很好地工作。在其他情况下，验证者可能没有意识到你调用了需要单个引理的值上的引理，所以你可能仍然需要手动调用lemmaforonex。此外，dafny还采取措施避免在为上面的引理调用生成的量词中出现“匹配循环”(“匹配循环”会导致引理的无限次使用)。然而，这种机制并不完美，因此这种增加的自动化在某些情况下可能会导致性能下降。\n\n\n# 函数后置条件\n\n第三个建议是在函数的后置条件中声明函数的一些最有用的属性，而不是在单独的引理中声明。例如，代替:\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\n你可以声明为：\n\nfunction f(x: x): int\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\n要获得引理所声明的属性，必须调用引理。相反，在函数的后置条件中声明的任何属性都会在每次调用函数时自动应用。\n\n正如我所提到的，更多的信息可以帮助验证者自动地做更多的事情，但是过多的信息也会让验证者不知所措。因此，我的建议是只对那些您认为每个函数用户都需要的属性使用函数后置条件。很少需要的属性最好在必须手动调用的引理中声明。\n\n此外，在函数后置条件中可以编写的内容也有限制。特别是，你写的东西必须“终止”。在实践中，这意味着在后置条件中提到函数应用于其他参数时可能会遇到问题。例如,\n\npredicate r(x: x, y: x)\n  // commutativity:\n  ensures r(x, y) <==> r(y, x)\n  // transitivity:\n  ensures forall z :: r(x, z) && r(z, y) ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n\n\n不被允许，因为后置条件中存在自引用非终止(即无限递归)调用。因此，像交换性和及物性这样的性质总是需要表述为独立的引理。\n\n\n# 基本/高级函数对\n\n函数后置条件方便地为函数的所有用户提供它所声明的属性，从而减少了显式调用引理的需要。如果不是所有用户都对该属性感兴趣，那么第四个建议是声明两个函数。基本函数给出了函数的实际定义，附带的引理说明了它的性质。premium函数调用基本函数并将属性声明为后置条件，这是通过调用引理来证明的。\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\nfunction f_premium(x: x): int\n  ensures f_premium(x) % 2 == 0\n{ aboutf(x); f(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n用户现在可以选择:调用f_premium可以获得函数的值和被证明的属性，而调用f只能获得函数的值。如果你希望高级版本比基础版本更受欢迎，你当然可以将f和f_premium分别重命名为f_basic和f。\n\n除了后置条件之外，这两个函数是同义词。语义。需要注意的是，验证器用来指导其量词使用的机制是语法上的。因此，当验证者决定实例化量词时，你在量词主体中使用的两个函数中的哪一个可以产生差异。出于这个原因，我建议您在编写的任何量词中使用函数的基本版本。\n\n\n# 致谢\n\nbryan parno提出了第四个建议，将函数的基本版本及其引理包装成函数的高级版本。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"定义、证明、算法正确性的案例研究GCD",frontmatter:{title:"定义、证明、算法正确性的案例研究GCD",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/f6638c/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/3.%E5%AE%9A%E4%B9%89%E3%80%81%E8%AF%81%E6%98%8E%E3%80%81%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6GCD.html",relativePath:"40.资源/00.实践探索/3.定义、证明、算法正确性的案例研究GCD.md",key:"v-ad783cd0",path:"/pages/f6638c/",headers:[{level:2,title:"问题描述",slug:"问题描述",normalizedTitle:"问题描述",charIndex:167},{level:2,title:"正整数",slug:"正整数",normalizedTitle:"正整数",charIndex:474},{level:2,title:"因素",slug:"因素",normalizedTitle:"因素",charIndex:902},{level:2,title:"集合的最大值",slug:"集合的最大值",normalizedTitle:"集合的最大值",charIndex:2214},{level:2,title:"GCD",slug:"gcd",normalizedTitle:"gcd",charIndex:19},{level:2,title:"GCD的性质",slug:"gcd的性质",normalizedTitle:"gcd的性质",charIndex:4858},{level:2,title:"欧几里德算法",slug:"欧几里德算法",normalizedTitle:"欧几里德算法",charIndex:6436},{level:2,title:"GCD减性质",slug:"gcd减性质",normalizedTitle:"gcd减性质",charIndex:8181},{level:2,title:"更多的对称",slug:"更多的对称",normalizedTitle:"更多的对称",charIndex:9359},{level:2,title:"主方法",slug:"主方法",normalizedTitle:"主方法",charIndex:10320},{level:2,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:10706},{level:2,title:"致谢",slug:"致谢",normalizedTitle:"致谢",charIndex:10998},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:11039}],headersStr:"问题描述 正整数 因素 集合的最大值 GCD GCD的性质 欧几里德算法 GCD减性质 更多的对称 主方法 结论 致谢 参考文献",content:'# 定义、证明、算法正确性的案例研究:GCD\n\n> K. Rustan M. Leino Manuscript KRML 279, 22 June 2021\n\n摘要 本文的目的是展示一个程序开发的示例，介绍支持程序规范的定义，陈述和证明那些定义的引理，并使用引理来证明程序的正确性。以欧几里得的计算最大公约数的减法算法为例。\n\n\n# 问题描述\n\n让我们指定并验证一个算法来计算两个数的最大公约数(GCD)。在规范中，我们将引入一个函数，它的定义“显然是正确的”。我们不会使用这个函数来计算GCD，因为如果直接编译的话，“明显正确”的定义会给出非常低效的代码。相反，我们将使用Euclid算法来计算“明显正确”函数定义的值。我们将证明这个算法确实计算出了这个值。\n\n本质上，我们有\n\nfunction Gcd(x: pos, y: pos): pos\n\nmethod EuclidGcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\n其中pos表示正整数的类型。\n\n\n# 正整数\n\n我们所做的一切都与正整数有关。Dafny为自然数(即非负整数)而非正整数构建了一种类型。我们可以在Dafny中使用子集类型来定义它们:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\nDafny想知道这种类型是否有居民，但它自己不知道。对于我们的示例来说，这无关紧要，但是我们确实需要处理我们得到的错误。为此，我们提供了witness条款:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\n如果我们真的不愿意显示显示该类型为非空的witness，我们可以写witness *，这导致Dafny将pos类型视为可能为空。对于我们的例子，你可以选择其中一种，但因为提供一个实际的证人很容易，所以我们就这么做。\n\n在续集中，当我指的是正整数时，我会说number。\n\n\n# 因素\n\n一个数的除数是它的因数。我们定义了一个谓词，它说明了数字p是数字x的因数是什么意思:\n\npredicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\n换句话说，p是x的因子，如果存在一个被乘数q，那么x就是p * q的乘积。\n\n为了讨论一个数字的所有因子，我们引入了一个函数factors，我们使用集合理解来定义它。一个简单的定义是:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | IsFactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\n在Dafny中，set表示一个有限的集合(对于可能的无限集合，使用isset)。在这种情况下，Dafny并没有立即发现这个理解会生成一个有限集。幸运的是，我们可以简单地在理解中添加另一个连词，让Dafny看到集合是有限的:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\n\n\n1\n2\n3\n\n\n在添加这个连词时，我们可能会犯一个错误，因为新的集合可能没有包含我们想要的所有因素。我们的结合点p <= x当然看起来很简单，但为什么不证明加上它不会意外遗漏任何因子呢?我们可以证明这个集合的元素与可能无限集相同:\n\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\n引理的证明是在引理主体中给出的(也就是说，在引理规范后面的一对花括号之间)。在这种情况下，证明是空的，因为Dafny自动地证明了引理，而不需要我们提供任何进一步的帮助。\n\n在离开因子的定义之前，让我们说明和证明两个简单的引理。这些引理可以作为对我们定义的检查，它们在以后的开发中也会很有帮助。\n\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了证明一个数字n(这里是1或x)在集合Factors(x)中，我们需要确定n满足集合理解的条件(在Factors(x)主体中)。连词n <= x被自动证明，但IsFactor(n, x)不是。根据IsFactor的定义，我们需要证明n * q == x的被乘数q的存在性。这种证明通常包括证明证人，这就是上面两个引理中的断言陈述所做的。由这些断言，验证者完成了引理的证明。\n\n\n# 集合的最大值\n\n为了讨论最大公约数，我们需要一个函数来挑选集合中最大的数。一种有点声明性的方法是使用such-that结构。特别地，对于集合s, let-such-that表达式\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\n表示将x绑定到满足条件x在s &&中的所有y:: y在s ==> y <= x的值，然后返回表达式x的值。这个条件说x在集合s中，并且在集合s中，x是最大的。\n\n使用such-that结构有一个证明义务，即满足给定条件的值存在。如果我们要求s为非空，那么x in s条件很容易满足，但它需要更多的工作来说服验证者x的值满足量词。为此，我们将定义一个引理。我们将引理命名为MaxExists，然后我们可以这样写我们的函数Max:\n\nfunction Max(s: set<pos>): pos\n  requires s != {}\n{\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafny使用引理调用MaxExists(s)来建立后续表达式的格式良好性。顺便说一下，注意Max(以及引理MaxExists)有一个前置条件s !={}(关键字requires)。这意味着函数(以及引理)只能在非空集合中调用。\n\n那么我们如何证明MaxExists呢?证明这样一个x存在的最直接的方法是计算一个满足所需性质的x。我们将引入另一个计算最大值的函数，称为FindMax，并在MaxExists引理的证明中使用它。函数FindMax将被递归实现。\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := FindMax(s);\n}\n \nfunction FindMax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= FindMax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们现在不是在兜圈子吗?是的，在某些方面，我们让生活变得比必要的更困难。如果我们有FindMax，我们不需要Max，然后我们也不需要引理MaxExists。事实上，我们可以只编写和使用FindMax，而不引入Max或MaxExists。但在这个例子中，我希望主要的定义尽可能清晰，而不考虑如何计算。从这个意义上说，Max的主体比我们将要为FindMax编写的主体更具声明性。\n\n以下是FindMax的完整定义:\n\nfunction FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s\' := s - {x};\n    assert s == s\' + {x};\n    var y := FindMax(s\');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当函数的后置条件想要提到函数的结果值时，你可以使用函数本身，给出参数:FindMax(s)。我在上面第一次介绍FindMax时就这样做了。在完整的定义中，我展示了另一种方法，即为结果值引入一个名称:max。该名称只能在函数的后置条件中使用。很多时候，为结果引入这样的名称会导致更短的规范。\n\n\n# GCD\n\n有了我们定义的函数，现在就可以定义GCD了。取x的因子与y的因子，与之相交，得到它们的公因式，取其最大值:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  Max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\n对于这个简单的定义，验证者报告了一个前提条件的违反，因为它无法证明common满足Max的前提条件。我们知道公因数是非空的，因为我们知道1是任意两个数x和y的公因数。为了引起验证者的注意，我们写了一个断言:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common;  // error: assertion violation\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\n唉，验证者不能证明这个断言。但我们可以看到，这一主张的存在足以消除先决条件的违反。现在我们来证明这个断言。这就是我们使用前面介绍的FactorsContains1引理的地方。对该引理的两次调用将证明断言，在程序文本中最好的捕获方法是将assert更改为assert by，并在by块中给出断言的证明:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n够了!我们现在已经给出了Gcd的一个格式良好的定义。\n\n\n# GCD的性质\n\n我们将证明我们的Gcd函数的三个属性——如果你愿意，可以称之为健全检查。(我们还需要第四个属性，稍后再介绍。)\n\n作为第一个完整性检查，我们期望Gcd(x, y)返回一个同时是x和y因子的数字。此外，在所有同时是x和y因数的数字中，Gcd(x, y)的收益应该是最大的。\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\n这个引理的前两个后置条件是自动证明的，但第三个不是。我们如何证明一个全称量词(也就是forall表达式)是成立的?我们使用达夫尼的forall语句。当用于证明时，forall命题对应于逻辑中的“普遍引入”规则。这个规则说的是"如果你想要证明对于所有的x:: P(x)，那么你所需要做的就是任意选择一个x，然后对那个x证明P(x)。\n\n我们像这样引入forall语句:\n\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n\n\n1\n2\n\n\n为了证明它，我们只需要提出这样一个事实，即p，既是x和y的因子，又是x和y的因子的交集。验证者就能够完成证明。\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafny验证器经常需要这样的属性帮助。要证明它们，就把它们写成断言。换句话说，验证者知道集合交集的这个性质，但它没有足够的创意将这个性质引入证明中。通过断言该属性，我们要求验证者确认该属性(它能够这样做)，然后在其余的证明中使用该属性(在本例中，这就完成了证明)。\n\n作为第二个完整性检查，我们证明了Gcd是对称的。\n\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个证明归结到集合交点是对称的这个事实，我们把它写成引理来引起验证者的注意。\n\n作为第三个健全的检验，我们证明Gcd是幂等的。也就是说，如果你给它相同的参数两次，它会返回那个参数。\n\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个性质的证明可以归结为集合交点是幂等的，以及一个数是它自己的因子之一的性质。\n\n\n# 欧几里德算法\n\n欧几里得的求取两个数的GCD的减法算法是将两个数中的较大数反复减去较小的数，直到它们相等。每一个这样的减法都保留了GCD——一个我们需要证明的不变量——两个相等的数的GCD就是那个数——这个数是我们通过上面的“GCD幂等”引理建立的。\n\n该算法具有循环不变量和幂等引理，其结果如下:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n此方法使用while - case循环。(如果您熟悉Dijkstra的保护命令[1]，这是do-od循环。)这个循环的每次迭代都会选择一个case来执行。所选的case必须是一个其守护条件求值为true的对象(如果几个case的守护条件求值为true，则循环在这些case之间任意选择)。如果没有这样的保护条件，则循环停止迭代。EuclidGcd中的循环当然可以是一个普通的while x != y循环，但while - case循环提供的两种情况的对称性使其美观。\n\n除了一个循环不变式外，循环还声明了一个终止度量(关键字decreases)。证明循环终止归结为证明每次迭代使终止度量的值减小(按照Dafny内置的基于良好基础的整数顺序)。\n\n上面的EuclidGcd方法没有验证，因为验证器无法证明每次迭代都保持循环不变。为此，我们需要我在上面提到的GCD的第四个性质:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n\n\n1\n2\n3\n\n\n利用这个引理和GCD的对称性，我们可以完成GCD的证明:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个版本在循环的第一个分支中添加了对GcdSubtract的调用。在循环的第二个分支中，证明计算使用保持等式的步骤将表达式Gcd(x, y)转换为Gcd(x - y, y)。步骤中给出的提示求助于GcdSubtract和GcdSymmetric引理。\n\n\n# GCD减性质\n\n在这个案例中，GcdSubtract的证明比其他任何定义和引理都要复杂。\n\n证明首先引入Gcd(x, y)的名称:\n\n  var p := Gcd(x, y);\n\n\n1\n\n\n由Gcd的定义可知，p是x和y的因子，我们可以证明p也是y - x的因子:\n\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了证明IsFactor(p, y - x)，我们对IsFactor的定义告诉我们存在的被乘数引入a和b名称(因为p是x和y的因子)。用基本的算术步骤进行简单的计算，我们就可以得到p可以乘上另一个数(即b - A)得到y - x。\n\n因为p同时是x和y - x的因子，所以它是x和y - x的公因式。我们写了两行代码来确保验证器使用了这个属性，用集合交集来表达:\n\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\n最后，我们需要证明p是这个公因式的最大。我们使用forall语句来声明这个属性:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\n为了证明这个性质，我们填充了forall语句体。对于表示“公共性”集合中的任意数字q，我们分别将生成x和y - x乘积的被乘数命名为:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\n使用简单的算术步骤，我们可以用一个证明计算来确定q也是y的因子:\n\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所以，因为q既是x又是y的因子，所以Gcd(x, y)的定义告诉我们q <= Gcd(x, y)通过给出另一个关于集合交集的提示:\n\n    assert q in Factors(x) * Factors(y);\n  }\n\n\n1\n2\n\n\n验证者完成验证。\n\n\n# 更多的对称\n\n虽然我们现在已经有了GCD算法的完整证明，但您的美感可能会因为我们在两种情况下提供证明的方式的不对称性而受到影响。既然while - case循环为我们提供了这两种情况的对称表述，如果我们也能使这两种情况的证明更加相似就好了。\n\n有几种方法可以改善这种情况。一种是重构第二个case的证明计算到它自己的引理中。然后，每个“案例”都有一行证明。\n\n为了好玩，让我来描述另一个“技巧”，让这两种情况(不完全对称，但至少)更相似。诀窍在于使(已经不对称的)GcdSubtract引理也把参数转换为Gcd。我们将其改写为:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x)\n{\n  GcdSymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意后置条件的左边现在是Gcd(y, x)，而不是Gcd(x, y)就像我们在这个引理的第一个版本中一样。这个证明所需要的唯一改变就是诉诸于Gcd的对称性，我们可以通过引理内部的一个引理来做到这一点。这给了我们一个重新表述的“GcdSubtract”引理的证明。\n\n通过这种重新表述，我们可以简化EuclidGcd的第二个“情形”，以使第一个“情形”更加复杂为代价。本质上，我们把一个引理调用从第二种情况移到第一种情况，所以不是有1和3个引理调用在两种情况下，我们会有2和2。\n\n    case x < y =>\n      GcdSubtract(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n它不是完全对称的，但也许你还是喜欢它。或者你可能会在另一种情况下记住这个技巧，当鞋子非常合适的时候。如果没有别的，您可以坚持使用我们在上面开发的第一个完整的证明。\n\n\n# 主方法\n\n如果证明本身不满足你，你仍然想看到算法的运行，你可以写一个Main方法，编译并运行程序。(在命令行中使用dafny工具的/compile:3选项是一种简单的方法。它将验证然后运行程序。)\n\n下面是一个Main的例子:\n\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\n\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, " gcd ", y, "  =  ", gcd, "\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 结论\n\n这个案例研究展示了如何定义一个感兴趣的领域(这里是数字因子，导致了GCD的定义)，陈述和证明关于这些定义的一些引理，然后在一个小程序的证明中使用这些引理。\n\n该程序，包括所有引理和其他与定义相关的证明义务，只需要少于3秒的Dafny验证器验证。您可以在Dafny测试套件[3]中找到整个程序。\n\n欧几里德的GCD算法是一个常见的教科书例子。它在不同的验证器中以不同的形式被证明。例如，TLA+教程以这个程序为例[0]。它假设了我们在这里证明的GCD的数学性质。Why3程序库包含欧几里德GCD算法的一个版本，它在每一步中使用模而不是减法，这样可以减少迭代次数[2]。\n\n\n# 致谢\n\n我感谢Reto Kramer提出这个问题作为一个有用的案例研究。\n\n\n# 参考文献\n\n[0]TLA proof system. https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html. 🔎\n\n[1]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. 🔎\n\n[2]Jean-Christophe Filliâtre and Claude Marché. Greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. 🔎\n\n[3]K. Rustan M. Leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy, June 2021. 🔎',normalizedContent:'# 定义、证明、算法正确性的案例研究:gcd\n\n> k. rustan m. leino manuscript krml 279, 22 june 2021\n\n摘要 本文的目的是展示一个程序开发的示例，介绍支持程序规范的定义，陈述和证明那些定义的引理，并使用引理来证明程序的正确性。以欧几里得的计算最大公约数的减法算法为例。\n\n\n# 问题描述\n\n让我们指定并验证一个算法来计算两个数的最大公约数(gcd)。在规范中，我们将引入一个函数，它的定义“显然是正确的”。我们不会使用这个函数来计算gcd，因为如果直接编译的话，“明显正确”的定义会给出非常低效的代码。相反，我们将使用euclid算法来计算“明显正确”函数定义的值。我们将证明这个算法确实计算出了这个值。\n\n本质上，我们有\n\nfunction gcd(x: pos, y: pos): pos\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n\n\n1\n2\n3\n4\n\n\n其中pos表示正整数的类型。\n\n\n# 正整数\n\n我们所做的一切都与正整数有关。dafny为自然数(即非负整数)而非正整数构建了一种类型。我们可以在dafny中使用子集类型来定义它们:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\ndafny想知道这种类型是否有居民，但它自己不知道。对于我们的示例来说，这无关紧要，但是我们确实需要处理我们得到的错误。为此，我们提供了witness条款:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\n如果我们真的不愿意显示显示该类型为非空的witness，我们可以写witness *，这导致dafny将pos类型视为可能为空。对于我们的例子，你可以选择其中一种，但因为提供一个实际的证人很容易，所以我们就这么做。\n\n在续集中，当我指的是正整数时，我会说number。\n\n\n# 因素\n\n一个数的除数是它的因数。我们定义了一个谓词，它说明了数字p是数字x的因数是什么意思:\n\npredicate isfactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\n换句话说，p是x的因子，如果存在一个被乘数q，那么x就是p * q的乘积。\n\n为了讨论一个数字的所有因子，我们引入了一个函数factors，我们使用集合理解来定义它。一个简单的定义是:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | isfactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\n在dafny中，set表示一个有限的集合(对于可能的无限集合，使用isset)。在这种情况下，dafny并没有立即发现这个理解会生成一个有限集。幸运的是，我们可以简单地在理解中添加另一个连词，让dafny看到集合是有限的:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | p <= x && isfactor(p, x)\n}\n\n\n1\n2\n3\n\n\n在添加这个连词时，我们可能会犯一个错误，因为新的集合可能没有包含我们想要的所有因素。我们的结合点p <= x当然看起来很简单，但为什么不证明加上它不会意外遗漏任何因子呢?我们可以证明这个集合的元素与可能无限集相同:\n\nlemma factorshasallfactors(x: pos)\n  ensures forall n :: n in factors(x) <==> n in iset p: pos | isfactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\n引理的证明是在引理主体中给出的(也就是说，在引理规范后面的一对花括号之间)。在这种情况下，证明是空的，因为dafny自动地证明了引理，而不需要我们提供任何进一步的帮助。\n\n在离开因子的定义之前，让我们说明和证明两个简单的引理。这些引理可以作为对我们定义的检查，它们在以后的开发中也会很有帮助。\n\nlemma factorscontains1(x: pos)\n  ensures 1 in factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma factorscontainsself(x: pos)\n  ensures x in factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了证明一个数字n(这里是1或x)在集合factors(x)中，我们需要确定n满足集合理解的条件(在factors(x)主体中)。连词n <= x被自动证明，但isfactor(n, x)不是。根据isfactor的定义，我们需要证明n * q == x的被乘数q的存在性。这种证明通常包括证明证人，这就是上面两个引理中的断言陈述所做的。由这些断言，验证者完成了引理的证明。\n\n\n# 集合的最大值\n\n为了讨论最大公约数，我们需要一个函数来挑选集合中最大的数。一种有点声明性的方法是使用such-that结构。特别地，对于集合s, let-such-that表达式\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\n表示将x绑定到满足条件x在s &&中的所有y:: y在s ==> y <= x的值，然后返回表达式x的值。这个条件说x在集合s中，并且在集合s中，x是最大的。\n\n使用such-that结构有一个证明义务，即满足给定条件的值存在。如果我们要求s为非空，那么x in s条件很容易满足，但它需要更多的工作来说服验证者x的值满足量词。为此，我们将定义一个引理。我们将引理命名为maxexists，然后我们可以这样写我们的函数max:\n\nfunction max(s: set<pos>): pos\n  requires s != {}\n{\n  maxexists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafny使用引理调用maxexists(s)来建立后续表达式的格式良好性。顺便说一下，注意max(以及引理maxexists)有一个前置条件s !={}(关键字requires)。这意味着函数(以及引理)只能在非空集合中调用。\n\n那么我们如何证明maxexists呢?证明这样一个x存在的最直接的方法是计算一个满足所需性质的x。我们将引入另一个计算最大值的函数，称为findmax，并在maxexists引理的证明中使用它。函数findmax将被递归实现。\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := findmax(s);\n}\n \nfunction findmax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= findmax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们现在不是在兜圈子吗?是的，在某些方面，我们让生活变得比必要的更困难。如果我们有findmax，我们不需要max，然后我们也不需要引理maxexists。事实上，我们可以只编写和使用findmax，而不引入max或maxexists。但在这个例子中，我希望主要的定义尽可能清晰，而不考虑如何计算。从这个意义上说，max的主体比我们将要为findmax编写的主体更具声明性。\n\n以下是findmax的完整定义:\n\nfunction findmax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s\' := s - {x};\n    assert s == s\' + {x};\n    var y := findmax(s\');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当函数的后置条件想要提到函数的结果值时，你可以使用函数本身，给出参数:findmax(s)。我在上面第一次介绍findmax时就这样做了。在完整的定义中，我展示了另一种方法，即为结果值引入一个名称:max。该名称只能在函数的后置条件中使用。很多时候，为结果引入这样的名称会导致更短的规范。\n\n\n# gcd\n\n有了我们定义的函数，现在就可以定义gcd了。取x的因子与y的因子，与之相交，得到它们的公因式，取其最大值:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\n对于这个简单的定义，验证者报告了一个前提条件的违反，因为它无法证明common满足max的前提条件。我们知道公因数是非空的，因为我们知道1是任意两个数x和y的公因数。为了引起验证者的注意，我们写了一个断言:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common;  // error: assertion violation\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\n唉，验证者不能证明这个断言。但我们可以看到，这一主张的存在足以消除先决条件的违反。现在我们来证明这个断言。这就是我们使用前面介绍的factorscontains1引理的地方。对该引理的两次调用将证明断言，在程序文本中最好的捕获方法是将assert更改为assert by，并在by块中给出断言的证明:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common by {\n    factorscontains1(x);\n    factorscontains1(y);\n  }\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n够了!我们现在已经给出了gcd的一个格式良好的定义。\n\n\n# gcd的性质\n\n我们将证明我们的gcd函数的三个属性——如果你愿意，可以称之为健全检查。(我们还需要第四个属性，稍后再介绍。)\n\n作为第一个完整性检查，我们期望gcd(x, y)返回一个同时是x和y因子的数字。此外，在所有同时是x和y因数的数字中，gcd(x, y)的收益应该是最大的。\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n\n\n1\n2\n3\n4\n\n\n这个引理的前两个后置条件是自动证明的，但第三个不是。我们如何证明一个全称量词(也就是forall表达式)是成立的?我们使用达夫尼的forall语句。当用于证明时，forall命题对应于逻辑中的“普遍引入”规则。这个规则说的是"如果你想要证明对于所有的x:: p(x)，那么你所需要做的就是任意选择一个x，然后对那个x证明p(x)。\n\n我们像这样引入forall语句:\n\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n\n\n1\n2\n\n\n为了证明它，我们只需要提出这样一个事实，即p，既是x和y的因子，又是x和y的因子的交集。验证者就能够完成证明。\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n{\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n  {\n    assert p in factors(x) * factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafny验证器经常需要这样的属性帮助。要证明它们，就把它们写成断言。换句话说，验证者知道集合交集的这个性质，但它没有足够的创意将这个性质引入证明中。通过断言该属性，我们要求验证者确认该属性(它能够这样做)，然后在其余的证明中使用该属性(在本例中，这就完成了证明)。\n\n作为第二个完整性检查，我们证明了gcd是对称的。\n\nlemma gcdsymmetric(x: pos, y: pos)\n  ensures gcd(x, y) == gcd(y, x)\n{\n  assert factors(x) * factors(y) == factors(y) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个证明归结到集合交点是对称的这个事实，我们把它写成引理来引起验证者的注意。\n\n作为第三个健全的检验，我们证明gcd是幂等的。也就是说，如果你给它相同的参数两次，它会返回那个参数。\n\nlemma gcdidempotent(x: pos)\n  ensures gcd(x, x) == x\n{\n  factorscontainsself(x);\n  assert x in factors(x) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个性质的证明可以归结为集合交点是幂等的，以及一个数是它自己的因子之一的性质。\n\n\n# 欧几里德算法\n\n欧几里得的求取两个数的gcd的减法算法是将两个数中的较大数反复减去较小的数，直到它们相等。每一个这样的减法都保留了gcd——一个我们需要证明的不变量——两个相等的数的gcd就是那个数——这个数是我们通过上面的“gcd幂等”引理建立的。\n\n该算法具有循环不变量和幂等引理，其结果如下:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n此方法使用while - case循环。(如果您熟悉dijkstra的保护命令[1]，这是do-od循环。)这个循环的每次迭代都会选择一个case来执行。所选的case必须是一个其守护条件求值为true的对象(如果几个case的守护条件求值为true，则循环在这些case之间任意选择)。如果没有这样的保护条件，则循环停止迭代。euclidgcd中的循环当然可以是一个普通的while x != y循环，但while - case循环提供的两种情况的对称性使其美观。\n\n除了一个循环不变式外，循环还声明了一个终止度量(关键字decreases)。证明循环终止归结为证明每次迭代使终止度量的值减小(按照dafny内置的基于良好基础的整数顺序)。\n\n上面的euclidgcd方法没有验证，因为验证器无法证明每次迭代都保持循环不变。为此，我们需要我在上面提到的gcd的第四个性质:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(x, y) == gcd(x, y - x)\n\n\n1\n2\n3\n\n\n利用这个引理和gcd的对称性，我们可以完成gcd的证明:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)\n    decreases x + y\n  {\n    case x < y =>\n      gcdsubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        gcd(x, y);\n      ==  { gcdsymmetric(x, y); }\n        gcd(y, x);\n      ==  { gcdsubtract(y, x); }\n        gcd(y, x - y);\n      ==  { gcdsymmetric(y, x - y); }\n        gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个版本在循环的第一个分支中添加了对gcdsubtract的调用。在循环的第二个分支中，证明计算使用保持等式的步骤将表达式gcd(x, y)转换为gcd(x - y, y)。步骤中给出的提示求助于gcdsubtract和gcdsymmetric引理。\n\n\n# gcd减性质\n\n在这个案例中，gcdsubtract的证明比其他任何定义和引理都要复杂。\n\n证明首先引入gcd(x, y)的名称:\n\n  var p := gcd(x, y);\n\n\n1\n\n\n由gcd的定义可知，p是x和y的因子，我们可以证明p也是y - x的因子:\n\n  assert isfactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了证明isfactor(p, y - x)，我们对isfactor的定义告诉我们存在的被乘数引入a和b名称(因为p是x和y的因子)。用基本的算术步骤进行简单的计算，我们就可以得到p可以乘上另一个数(即b - a)得到y - x。\n\n因为p同时是x和y - x的因子，所以它是x和y - x的公因式。我们写了两行代码来确保验证器使用了这个属性，用集合交集来表达:\n\n  var common := factors(x) * factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\n最后，我们需要证明p是这个公因式的最大。我们使用forall语句来声明这个属性:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\n为了证明这个性质，我们填充了forall语句体。对于表示“公共性”集合中的任意数字q，我们分别将生成x和y - x乘积的被乘数命名为:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\n使用简单的算术步骤，我们可以用一个证明计算来确定q也是y的因子:\n\n    assert isfactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所以，因为q既是x又是y的因子，所以gcd(x, y)的定义告诉我们q <= gcd(x, y)通过给出另一个关于集合交集的提示:\n\n    assert q in factors(x) * factors(y);\n  }\n\n\n1\n2\n\n\n验证者完成验证。\n\n\n# 更多的对称\n\n虽然我们现在已经有了gcd算法的完整证明，但您的美感可能会因为我们在两种情况下提供证明的方式的不对称性而受到影响。既然while - case循环为我们提供了这两种情况的对称表述，如果我们也能使这两种情况的证明更加相似就好了。\n\n有几种方法可以改善这种情况。一种是重构第二个case的证明计算到它自己的引理中。然后，每个“案例”都有一行证明。\n\n为了好玩，让我来描述另一个“技巧”，让这两种情况(不完全对称，但至少)更相似。诀窍在于使(已经不对称的)gcdsubtract引理也把参数转换为gcd。我们将其改写为:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(y, x) == gcd(x, y - x)\n{\n  gcdsymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意后置条件的左边现在是gcd(y, x)，而不是gcd(x, y)就像我们在这个引理的第一个版本中一样。这个证明所需要的唯一改变就是诉诸于gcd的对称性，我们可以通过引理内部的一个引理来做到这一点。这给了我们一个重新表述的“gcdsubtract”引理的证明。\n\n通过这种重新表述，我们可以简化euclidgcd的第二个“情形”，以使第一个“情形”更加复杂为代价。本质上，我们把一个引理调用从第二种情况移到第一种情况，所以不是有1和3个引理调用在两种情况下，我们会有2和2。\n\n    case x < y =>\n      gcdsubtract(x, y);\n      gcdsymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      gcdsymmetric(x - y, y);\n      gcdsubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n它不是完全对称的，但也许你还是喜欢它。或者你可能会在另一种情况下记住这个技巧，当鞋子非常合适的时候。如果没有别的，您可以坚持使用我们在上面开发的第一个完整的证明。\n\n\n# 主方法\n\n如果证明本身不满足你，你仍然想看到算法的运行，你可以写一个main方法，编译并运行程序。(在命令行中使用dafny工具的/compile:3选项是一种简单的方法。它将验证然后运行程序。)\n\n下面是一个main的例子:\n\nmethod main() {\n  test(15, 9);\n  test(14, 22);\n  test(371, 1);\n  test(1, 2);\n  test(1, 1);\n  test(13, 13);\n  test(60, 60);\n}\n\nmethod test(x: pos, y: pos) {\n  var gcd := euclidgcd(x, y);\n  print x, " gcd ", y, "  =  ", gcd, "\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 结论\n\n这个案例研究展示了如何定义一个感兴趣的领域(这里是数字因子，导致了gcd的定义)，陈述和证明关于这些定义的一些引理，然后在一个小程序的证明中使用这些引理。\n\n该程序，包括所有引理和其他与定义相关的证明义务，只需要少于3秒的dafny验证器验证。您可以在dafny测试套件[3]中找到整个程序。\n\n欧几里德的gcd算法是一个常见的教科书例子。它在不同的验证器中以不同的形式被证明。例如，tla+教程以这个程序为例[0]。它假设了我们在这里证明的gcd的数学性质。why3程序库包含欧几里德gcd算法的一个版本，它在每一步中使用模而不是减法，这样可以减少迭代次数[2]。\n\n\n# 致谢\n\n我感谢reto kramer提出这个问题作为一个有用的案例研究。\n\n\n# 参考文献\n\n[0]tla proof system. https://tla.msr-inria.inria.fr/tlaps/content/documentation/tutorial/the_example.html. 🔎\n\n[1]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. 🔎\n\n[2]jean-christophe filliatre and claude marche. greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. 🔎\n\n[3]k. rustan m. leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/test/dafny4/gcd.dfy, june 2021. 🔎',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"各种推导式",frontmatter:{title:"各种推导式",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1d2420/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/4.%E5%90%84%E7%A7%8D%E6%8E%A8%E5%AF%BC%E5%BC%8F.html",relativePath:"40.资源/00.实践探索/4.各种推导式.md",key:"v-fbc707cc",path:"/pages/1d2420/",headers:[{level:2,title:"量词",slug:"量词",normalizedTitle:"量词",charIndex:239},{level:3,title:"基本的量词的语法",slug:"基本的量词的语法",normalizedTitle:"基本的量词的语法",charIndex:472},{level:3,title:"绑定变量的类型",slug:"绑定变量的类型",normalizedTitle:"绑定变量的类型",charIndex:1066},{level:3,title:"多个绑定变量",slug:"多个绑定变量",normalizedTitle:"多个绑定变量",charIndex:1415},{level:3,title:"量词主体的典型形式",slug:"量词主体的典型形式",normalizedTitle:"量词主体的典型形式",charIndex:1815},{level:3,title:"范围谓词",slug:"范围谓词",normalizedTitle:"范围谓词",charIndex:2726},{level:2,title:"用于量词推理的程序语句",slug:"用于量词推理的程序语句",normalizedTitle:"用于量词推理的程序语句",charIndex:4116},{level:3,title:"聚合语句",slug:"聚合语句",normalizedTitle:"聚合语句",charIndex:4185},{level:3,title:"存在引入与排除",slug:"存在引入与排除",normalizedTitle:"存在引入与排除",charIndex:5116},{level:3,title:"带外参数的引理",slug:"带外参数的引理",normalizedTitle:"带外参数的引理",charIndex:6897},{level:3,title:"绑定警卫",slug:"绑定警卫",normalizedTitle:"绑定警卫",charIndex:7487},{level:2,title:"集合和映射",slug:"集合和映射",normalizedTitle:"集合和映射",charIndex:7976},{level:3,title:"集合理解",slug:"集合理解",normalizedTitle:"集合理解",charIndex:8023},{level:3,title:"简化的集合理解",slug:"简化的集合理解",normalizedTitle:"简化的集合理解",charIndex:9377},{level:3,title:"映射理解",slug:"映射理解",normalizedTitle:"映射理解",charIndex:8028},{level:3,title:"Lambda expressions",slug:"lambda-expressions",normalizedTitle:"lambda expressions",charIndex:10599},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:10884},{level:2,title:"致谢",slug:"致谢",normalizedTitle:"致谢",charIndex:11186},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:11224}],headersStr:"量词 基本的量词的语法 绑定变量的类型 多个绑定变量 量词主体的典型形式 范围谓词 用于量词推理的程序语句 聚合语句 存在引入与排除 带外参数的引理 绑定警卫 集合和映射 集合理解 简化的集合理解 映射理解 Lambda expressions 总结 致谢 参考文献",content:'# 各种推导式\n\n> K. Rustan M. Leino Manuscript KRML 267, 27 May 2019\n\n摘要 Dafny有许多类似推导式的结构。本文描述并比较了这些结构，展示了它们在语法和语义上的比较。\n\nDafny支持普遍量化和存在量化，以及用于“证明”普遍量化表达式或“利用”存在量化表达式的结构。[0]节(http://leino.science/papers/krml267.html#sec-quantifiers)描述了Dafny中的这些逻辑量词。第[1]节(http://leino.science/papers/krml267.html#sec-proof-features)显示了在推理量词时可以使用的程序语句，并指出了各种语法形式的差异。\n\n集合推导式和映射推导式类似于量词，因为它们引入了范围超过特定值的绑定变量。[2]节(http://leino.science/papers/krml267.html#sec-sets-and-maps)展示了这些理解的一般和常见形式。\n\n\n# 量词\n\n\n# 基本的量词的语法\n\n在数学教科书和论文中，我们熟悉的全称量词采用了类似的符号。它说谓词对所有的值都成立。在编程语言行话中，我们说它是一个绑定变量，其作用域是量词的主体。也就是说，任何自由出现的in都被绑定到量词所引入的。\n\n在Dafny中，同一个全称量词被写成forall x:: P。从解析的角度来看，量词的主体“尽可能地”扩展。因此，程序片段\n\nforall x :: R ==> Q\n\n\n1\n\n\n解析为\n\n(forall x :: (R ==> Q))\n\n\n1\n\n\n而不是\n\n(forall x :: R) ==> Q\n\n\n1\n\n\n请注意，“尽可能”不限于行尾。例如，一个常见的陷阱是编写(这里显示的是一个前置条件)\n\nrequires\n  forall x :: R ==> Q &&\n  S\n\n\n1\n2\n3\n\n\n意图是forall x:: R ==> Q和S是两个独立的前提条件。与此相反的是，这里所写的声明的意义是\n\nrequires (forall x :: (R ==> (Q && S)))\n\n\n1\n\n\n如果你打算写量词和S的连词，那么正确的语法是\n\nrequires\n  (forall x :: R ==> Q) &&\n  S\n\n\n1\n2\n3\n\n\n存在量词的一个熟悉的数学符号是。它说谓词对于某个值成立。在Dafny中，语法是exists x:: P .0\n\n\n# 绑定变量的类型\n\nDafny中的每个变量都有一个类型。通常，绑定变量的类型是推断的，但Dafny也允许显式声明该类型。例如,\n\nforall x: X :: P\n\n\n1\n\n\n声明x的类型为x。为了简洁，并展示编写量词和推断的典型方法，我将在本文中省略类型，但请记住，如果愿意，您可以随时包含它们。\n\n当约束变量从某个集合中提取时，量词的常用数学符号是。这个表达式的dafny式表示为\n\nforall x in S :: P  // error: syntax error\n\n\n1\n\n\n然而，这是不正确的Dafny语法，因为它使用了一个集合成员谓词，其中只期望绑定变量(可选的，带有类型)。在Dafny中这样一个量词的正确写法是\n\nforall x :: x in S ==> P\n\n\n1\n\n\n\n# 多个绑定变量\n\n一个限定符可以有一个以上的绑定变量。例如,\n\nforall x, y :: P\n\n\n1\n\n\nP对于所有的x和y都成立。它在逻辑上等同于嵌套的量词\n\nforall x :: forall y :: P\n\n\n1\n\n\n就此而言，它在逻辑上也等价于\n\nforall y :: forall x :: P\n\n\n1\n\n\nDafny的常见做法是使用多个变量的量词，而不是嵌套的形式，如果没有其他原因，只是为了更简洁。1\n\n如果您编写了一个绑定变量列表并显式地给出了类型，请注意，每个给定的类型只适用于它之前的变量。例如,\n\nforall x: X, y: Y :: P\n\n\n1\n\n\nx的类型是x, y的类型是y。如果只包含y类型，如\n\nforall x, y: Y :: P\n\n\n1\n\n\n那么你说y的类型是y而x的类型是可以推断的。换句话说，你可以认为这个“:”比“，”具有更强的约束力。\n\n\n# 量词主体的典型形式\n\n全称量词的主体通常是一种含义，如in\n\nforall x :: R ==> P\n\n\n1\n\n\n你可以从以下几个方面来解读:\n\n> "对于所有的x，意味着R ==> P成立"\n> \n> "对于所有的x， R意味着P "\n> \n> "对于所有的x，如果R成立，那么P也成立"\n\n然而，这个含义的先行词(R)通常起到限制(不仅仅是x的类型)所考虑的x的值的作用。换句话说，“R”告诉你“x”的范围。在这种情况下，你可以从下面的一种方式来解读上面的量词:\n\n> "对于所有满足R的x， P成立\n> \n> "对于所有的x，使R成立，P "\n> \n> "对于所有的x(其中x满足R)， P保持"\n> \n> “对于所有的x[为R插入你自己的描述性阶段]，P”\n\n作为最后一个短语的具体实例，你可以读到forall x:: x in S ==> x % 2 == 0 As\n\n> "对于S中的所有x， x是偶数"\n\n你可以读到forall i:: 0 <= i < a. length ==> a[i] == 5 as\n\n> "对于数组a的每个下标i， a -sub- i是5 "\n\n和我刚才说的全称量词类似，存在量词的典型形式是连词，比如\n\nexists x :: R && P\n\n\n1\n\n\n例如：\n\nexists x :: x in S && x % 2 == 0\n\nexists i :: 0 <= i < a.Length && a[i] == 5\n\n\n1\n2\n3\n\n\n再把R看成是告诉你x的范围，你可以把这些存在量词看成\n\n> "在S中有一个x，其中x % 2 == 0适用"\n> \n> "在a中有一个索引i，使a -sub- i等于5 "\n\n在Why3 [1]之后，如果你将R ==> P作为存在量词的主体，Dafny会发出警告，因为这几乎总是一个用户错误(一个打字错误或一个思考-o)。如果这真的是你想要写的，你可以通过编写以下任何表达式来抑制警告:\n\nexists x :: (R ==> P)\nexists x :: !R || P\nexists x :: P <== R\n\n\n1\n2\n3\n\n\n\n# 范围谓词\n\n为什么我要花一页来告诉你量词的发音?因为这个讨论强调了一个事实，条件R，在任何一个\n\nforall x :: R ==> P\nexists x :: R && P\n\n\n1\n2\n\n\n扮演着特殊的角色，尽管“R”实际上只是这些量词主体的一部分。事实上，其他人已经为量词采用了一种表示法，该表示法为这个范围谓词 R设置了一个特殊的位置。下面是一些例子:\n\n                                                \nUniversal quantifier   Existential quantifier   Source\n                                                \n                                                Dijkstra [3]\n                                                Chandy and Misra [2]\n                                                Gries and Schneider [4]\n\\forall X x; R; P      \\exists X x; R; P        JML [5]\n                                                \n\n(在上面的JML中，X表示X的类型。)在使用这些符号的教科书中，经常有人说:“为了简洁，如果‘R’是‘正确’的，或者是根据上下文理解的，那么它(对于上面的一些作者来说，一些相邻的标点符号)就被省略了。”这些缩写形式是:\n\n                                                  \nRange listed separately   Range true or omitted   Source\n                                                  \n                                                  Dijkstra [3]\n                                                  Chandy and Misra [2]\n                                                  Gries and Schneider [4]\n\\forall X x; R; P         \\forall X x;; P         JML [5]\n                                                  \n\n还有更多的。通过使用一些区分“R”和“P”的符号，量词的德摩根定律看起来特别好:\n\n回到Dafny。如果您喜欢将绑定变量的范围从量词主体的其余部分分隔开的符号，那么您将很高兴地了解到，您也可以在Dafny中这样做。语法是:\n\nforall x | R :: P\nexists x | R :: P\n\n\n1\n2\n\n\n\n# 用于量词推理的程序语句\n\nDafny包含了一些在推理涉及量词的程序或定理时非常有用的证明特性。它们的语法与量词相似，但也有区别。\n\n\n# 聚合语句\n\nDafny中的forall语句是一个聚合语句:它具有执行多个同时操作的效果。当这句话用于证明时，其形式如下:\n\nforall x | R\n  ensures P\n{\n  S;\n}\n\n\n1\n2\n3\n4\n5\n\n\n它用于建立属性forall x | R:: P，即forall x:: R == >p。它是通过检验命题S为任何满足R的x建立P来实现的。在逻辑中，这个命题的结果被称为“普遍引入”。\n\n举个简单的例子，假设你有一个引理可以证明n <= Fib(n)对于任何n至少是5，其中Fib是通常的Fibonacci函数:\n\nfunction Fib(n: nat): nat {\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\nlemma FibProperty(n: nat)\n  requires 5 <= n\n  ensures n <= Fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个引理给出了一个给定n的属性n <= Fib(n)。但假设你想让这个性质以普遍量子化的形式存在。也就是说，你要证明下面的引理:\n\nlemma FibPropertyAll()\n  ensures forall n :: 5 <= n ==> n <= Fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们怎么写这个证明呢?2\n\n答案是对每个n调用FibProperty一次。一次。对于“n”有无数个不同的值。这就是你对聚合语句forall所做的:\n\nforall n | 5 <= n\n  ensures n <= Fib(n)\n{\n  FibProperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\n一般来说，forall语句的主体要比单个引理调用复杂得多。但是当主体是只是一个引理调用或只是一个calc语句时，Dafny会自动推断ensure子句，所以你可以省略它:\n\nforall n | 5 <= n {\n  FibProperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# 存在引入与排除\n\n使用存在量化还使用了一系列的证明特征。我将通过写一个证明来证明斐波那契数可以是任意大的:\n\nlemma EverBigger(k: nat)\n  ensures exists n :: k <= Fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\n让我们从一些简单的例子开始证明，比如当k很小的时候，比如0或1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\nDafny不能自动证明这两种情况，所以我们需要自己给出更多的证明。\n\n为了证明这个引理在简单的情况下，它足以向验证者证明存在量词持有的一个特定的n。也就是说，我们想给存在量词一个见证。一个这样的见证是1，因为k <= 1 == Fib(1)。另一个这样的见证是12，因为k <= 144 == Fib(12)。另一个这样的见证是k，因为在我们的简单例子中k <= k == Fib(k)。让我们继续这个，所以我们在引理主体的“if”语句的“then”分支中添加一个断言:\n\nassert k <= Fib(k);\n\n\n1\n\n\nDafny将证明这个断言3，然后会注意到k是一个证明后置条件的存在见证。在逻辑中，这被称为“存在论导言”。这意味着，如果你有一个满足特定属性的值，那么这个值就存在。换句话说，如果你有一个“在你手中”的价值，那么这个价值就存在了——这似乎是如此明显，以至于我们谈起它时几乎会感到尴尬(你的邻居听到你以这个为生肯定会认为你疯了)。\n\n那么这个棘手的案例呢?我们可以通过归纳法来证明，首先得到一个n，它的斐波那契值至少为k-1，然后再从中构建一个更大的斐波那契值。首先，我们在“k-1”上递归地调用引理:\n\nEverBigger(k-1);\n\n\n1\n\n\n这让我们获得了EverBigger(k-1)的后置条件。为了在我们的证明中明确地写下这一点——为了检查验证者是否得出了我们期望从引理调用中得到的结论，并提醒我们自己什么属性——我们可以写一个断言:\n\nassert exists n` :: k-1 <= Fib(n`);\n\n\n1\n\n\n好到目前为止。接下来，我们想构造一个至少比Fib(n)大1的斐波那契数，因为这样可以完成证明。但是我刚才提到的n是什么?上面的所有断言都告诉我们存在这样的“n”。我们希望有这样一个“n”在我们手中，这样我们就可以使用它。\n\n从我们知道存在的东西到“在我们手中”的东西被称为“Skolemization”或“existenelimination”。你在Dafny中通过assign-such-that语句实现:\n\nvar m: nat :| k-1 <= Fib(m);\n\n\n1\n\n\n这个语句引入了一个局部变量m，并给它一个任意值，满足k-1 <= Fib(m)。当然，如果不存在这样的值，这是不可能的，所以赋值-such-that语句引起了一个证明义务，证明这样的m存在。这个证明义务来自于我们上面断言的属性。\n\n差不多了。为了建立引理的后置条件，我们剩下的计划就是构造一个严格大于Fib(m)的斐波那契数。我们观察到Fib(m) + Fib(m+1)严格大于Fib(m)，因此我们有Fib(m+2)严格大于Fib(m)。\n\n好吧，我们直说了吧。也许我们并没有“观察”到这一点，而是“希望”、“猜想”或“松散地认为”它可能成立。好吧，确实如此。(唷!)我们可以通过询问验证者它是否能为我们证明来验证:\n\nassert k <= Fib(m) + Fib(m + 1) == Fib(m + 2);\n\n\n1\n\n\n验证者立即证明了这个断言。4此外，通过写下这个断言，我们也向验证者展示了见证m+2，它证明了引理的后置条件中的存在量词。\n\n我用这个例子来说明的重点是，你可以用Skolemize一个量词\n\nexists x :: P\n\n\n1\n\n\n通过assign-such-that语句\n\nvar x :| P;\n\n\n1\n\n\n注意标点符号的区别。\n\n\n# 带外参数的引理\n\n我刚刚给你们看了一个涉及存在量词的例子。这个例子表明，“EverBigger”引理的“证明”两次使用了存在性介绍(在简单情况下为Fib(k)，在困难情况下为Fib(m+2))，从而将“我们手中”的k和m+2转换为存在性量化。这个例子还展示了(递归调用)引理的调用使用存在消除来将引理的后置条件中的存在量化转换为“我们手中的”一个m。让人印象深刻的是，Dafny有这样的特性，它还有一个更有用的特性，可以让你在一开始就避免这些存在-量词转换:引理-参数。\n\n在数学中，引理是由它们所提到的变量参数化的。这些都是参数。一个数学引理很少或永远不会被认为具有外参数。在Dafny中，引理实际上就是一个幽灵方法，一个方法可以同时具有输入参数和输出参数。这是非常有用的。与其用引理来证明某个值的“存在”，还不如直接“返回”某个这样的值。\n\n下面是上面的“EverBigger”引理，但将n声明为out形参:\n\nlemma EverBigger(k: nat) returns (n: nat)\n  ensures k <= Fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := EverBigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 绑定警卫\n\nDafny还包含了另一个特性，使量词的使用更加流畅:带有*binding guard *的if语句。这样的语句回答了“如果有一个，给我一个在我手里”的命令。\n\n假设我们写一个证明，根据y是否为斐波那契数分成两种情况。然后我们可以这样写:\n\nif exists n :: y == Fib(n) {\n  var n :| y == Fib(n);\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这表达了我们想要的，但感觉有点笨拙，因为我们重复了条件y == Fib(n)。我们可以将这个“if”语句写成\n\nif n :| y == Fib(n) {\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\n:|与赋值such-that语句中的标点相同，而不是存在量词中类似位置的::。\n\n\n# 集合和映射\n\n逻辑量词和其他结构引入了一些绑定变量，并以某种方式限制了这些绑定变量的取值范围。集合理解和映射理解也是如此。\n\n\n# 集合理解\n\n很容易在Dafny写下一组。例如,\n\n{ 2, 3, 5 }\n\n\n1\n\n\n是三个最小素数的集合。这样的表达式，其中集合的元素被显式列出，称为set display。但是，如果您想要定义的集合不能写成集合显示，该怎么办?\n\n集合理解以图解的方式定义了一组元素。在普通数学符号中集合理解的一个例子是\n\n定义了最小的100个自然数的集合。另一个例子是\n\n它定义了100个最小的完全平方数。这两个推导式中的绑定变量都是，指定range的值由谓词定义。让范围超过这些值，第一个集合然后包含表单的元素，而第二个集合包含表单的元素。也就是说，在第一个集合中，元素是自身的合法值，而在第二个集合中，元素是每个合法值的平方。\n\n更一般地说，数学符号的形状是这样的。读者应该理解这是绑定变量。理解为绑定变量，我们可以通过精确描述集合何时包含一个元素来定义集合推导式:\n\n或者，使用存在函数的取值范围单独给出的符号:\n\n在Dafny中，同样的集合理解有如下形式:\n\nset x | R :: f(x)\n\n\n1\n\n\nx是绑定变量(或者，更普遍地说，一个绑定变量的列表)，R是绑定变量的范围谓词，而f(x)是集合推导的项表达式。绑定变量被显式列出，不像普通的数学符号，读者必须推断绑定变量是什么。上面给出的两个示例集在Dafny中写如下:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\n虽然乍一看不太简洁，但显式列出绑定变量的表示法有一些细微之处。\n\n一个细微之处是，就像上面一样，量词的定义显示了符号的相似性:\n\ny in (set x | R :: f(x))   <==>   exists x | R :: y == f(x)\n\n\n1\n\n\n另一个优点是可以很容易地列出附加的绑定变量。假设R是x和z的谓词，那么这里有两个例子:\n\nset x,n | Fib(n) <= x < Fib(n) + n :: f(x)\nset x,n | Fib(n) <= x < Fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\n第一个集合包含f(x)对于每个在n范围内的x对于某些n的Fib(n)。用普通的数学符号来表示它的一种等价的方式是:\n\n第二个集合包含g(x,n)对于每个x和n，使x在Fib(n)的n之内。在这里，等效的数学符号更笨拙，需要使用另一个绑定变量:\n\nDafny使绑定变量显式的一般表示法也被许多作者使用(例如，[3， 4])。它也类似于其他语言中使用的列表理解表示法。例如，Dafny系列\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\n它包含一对自然数之和为100，包含与Python列表相同的元素:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nHaskell名单:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# 简化的集合理解\n\n我刚刚花了很多文字来描述Dafny中的一般集合理解符号。然而，在实践中的许多集合推导中，只有一个约束变量，而术语表达式就是那个约束变量。例如，我们已经看到，最小的“100”自然数的集合是:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\n对于这种常见的情况，Dafny允许你省略术语表达式，只需要写:\n\nset x | 0 <= x < 100\n\n\n1\n\n\n这个表达式看起来像普通的数学符号。事实上，对于这些简化的集合推导式，很容易“理解”数学符号想要表达的约束变量是什么。\n\n作为Dafny中验证器的一个注释，自动化倾向于更好地工作于简化的集合推导式，其中术语表达式可以被省略。\n\n\n# 映射理解\n\n一个map本质上是一组对，其中对的左元素是唯一的(也就是说，每个左元素在功能上决定了相应的右元素)。与集合的显示表达式一样，map可以通过map display来定义。例如,\n\nmap[2 := `c`, 137 := `a`]\n\n\n1\n\n\n将整数2映射到字符c，将整数137映射到字符a。每一对像2:= c可以被称为一个maplet。此外，maplet的左元素称为a key，右元素获得不可描述的名称value。\n\n与集合的理解一样，映射可以通过map理解来定义。它的形式是:\n\nmap x | R :: f(x) := g(x)\n\n\n1\n\n\n例如，\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\n是从前100个完全平方数到它们各自的平方根的映射。\n\n如果您将映射理解理解为一组具有唯一键的maplets，那么您基本上已经理解了符号。不过，我将提供一些注释并指出映射特有的一些特性。\n\n需要注意的一点是，maplets必须具有唯一的键。例如，验证者会抱怨，如果你试着写一个像这样的映射理解\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\n因为它说把4映射到2和-2上，这是没用的。\n\n一般的映射理解表达是相当灵活的。例如，假设m是一个从数字到字符的映射，并假设我们想要创建一个新的映射n，从m中的键的子集到其他一些字符。更准确地说，当m中的键在函数f的图像中，比如一个键f(x)对于某个x，然后我们想让n将这个键映射到h(x)。然后我们将n定义为\n\nmap x | f(x) in m.Keys :: f(x) := h(x)\n\n\n1\n\n\n然而，大多数时候，我们倾向于写的映射理解具有这种形式\n\nmap x | R :: x := g(x)\n\n\n1\n\n\n对于这些常见的映射，Dafny允许我们省略“x:=”，只写\n\nmap x | R :: g(x)\n\n\n1\n\n\n在实践中，几乎所有的映射理解都可以用这种简化的形式来写。但是当简化形式不充分时(就像上面的maplets f(x):= h(x)的例子一样)，一般形式是可用的。\n\n\n# Lambda expressions\n\n最后，要注意映射和函数之间的区别。您可以将map看作是一个预先计算好的表，而函数则是从一个给定的键中计算出一个值。为了进行比较，让我们考虑编写映射\n\nmap x | R :: g(x)\n\n\n1\n\n\n作为一个函数。\n\n通常，函数是用名称声明的。上面的映射是沿着线写的\n\nfunction F(x: X): Y\n  requires R\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\n函数也可以是匿名的，在这种情况下，它通常被称为lambda表达式。然后编写示例映射\n\nx requires R => g(x)\n\n\n1\n\n\n\n# 总结\n\n以下是本文中讨论的语法形式:\n\nforall x :: P\nforall x | R :: P\nforall x | R ensures P { S; }\nexists x :: P\nexists x | R :: P\nvar x :| P;\nif x :| P { S; }\nset x | R :: f(x)\nset x | R\nmap x | R :: f(x) := h(x)\nmap x | R :: g(x)\nfunction F(x: X): Y { g(x) }\nx requires R => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 致谢\n\n我很感谢Jay Lorch在这张便条上的许多有帮助的评论。\n\n\n# 参考文献\n\n[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, Tests and Proofs — 8th International Conference, TAP 2014, volume 8570 of Lecture Notes in Computer Science, pages 20–35. Springer, July 2014. 🔎\n\n[1]François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich. Why3: Shepherd your herd of provers. In Boogie 2011: First International Workshop on Intermediate Verification Languages, pages 53–64, Wrocław, Poland, August 2011. https://hal.inria.fr/hal-00790310. 🔎\n\n[2]K. Mani Chandy and Jayadev Misra. Parallel Program Design: A Foundation. Addison-Wesley, 1988. 🔎\n\n[3]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. 🔎\n\n[4]David Gries and Fred B. Schneider. A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. Springer-Verlag, 1994. 🔎\n\n[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems, pages 175–188. Kluwer Academic Publishers, 1999. 🔎\n\n[6]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361–381. Springer, 2016. 🔎\n\n----------------------------------------\n\n0.用于Dafny排版的Emacs IDE某些Dafny结构的符号你更可能在论文中看到。默认情况下，它显示forall x:: P as和显示exists x:: P as。[↩](http://leino.science/papers/krml267.html # back-fn-fn-emacs)\n\n1.在内部，Dafny验证器可以更有效地使用某些量词。验证者试图检测一个给定量词的另一种形式何时可能执行得更好，并将在这些情况下自动重写量词[6]。例如，它可以选择解除某些量词的嵌套。这种重写的目标是在获得良好的验证性能的同时支持自然外观的程序。[↩](http://leino.science/papers/krml267.html # back-fn-fn-nested)\n\n2.事实证明，Dafny的自动归纳将自动证明FibProperty和FibPropertyAll。如果这是我们唯一关心的引理，那就没有什么好说或做的了。尽管如此，我还是用这个例子来展示“forall”语句。如果你想要确保我将要说的是一个证明，你可以通过使用属性{:induction false}来关闭FibPropertyAll的自动感应。[↩](http://leino.science/papers/krml267.html # back-fn-fn-fibpropertyall)\n\n3.Dafny也可以证明类似断言assert Fib(12) == 144;。在内部，Dafny使用了函数的“双轨编码”，使其能够获得Fib(12)的值(因为12是一个文字常量)和Fib(k)(其中k是一个变量)。如果您对这是如何实现的感兴趣，我建议您访问[0]。[↩](http://leino.science/papers/krml267.html # back-fn-fn-dual-rail-encoding)\n\n4.这里是断言k <= Fib(m) + Fib(m+1)的一个证明。在我们的证明中，“困难的情况”适用于当k至少为2时，所以k-1至少为1，所以我们知道Fib(m)至少为1。由此可以得出结论，对于Fib(0) == 0， m不能为0。这很重要，因为这意味着m+1至少等于2，因此适用于Fib定义的归纳情况。换句话说，我们有Fib(m+1) == Fib(m) + Fib(m-1)。我们已经得出，Fib(m)至少等于1。以Fib返回nat为例，我们知道Fib(m-1)至少为0。所以，Fib(m+1)至少等于1。换句话说，Fib(m) + Fib(m+1)至少比Fib(m)大于1，而Fib(m)至少等于k-1。因此，Fib(m) + Fib(m+1)至少等于k。\n\n如果我们把“简单的情况”和“困难的情况”分开，使“简单的情况”只包含“k == 0”，那么我们不可能在上面的论证中得出“m != 0”的结论。其他交互式证明助手的一些用户可能会对此感到困扰，因为他们会说k具有nat类型，因此对k的归纳应该使用k == 0作为基本情况。数学对归纳法没有这样的限制，事实上，正如这个证明所显示的，我们可以从将“EverBigger”的情况分成“k < 2”和“2 <= k”中获益。[↩](http://leino.science/papers/krml267.html # back-fn-fn-proof)',normalizedContent:'# 各种推导式\n\n> k. rustan m. leino manuscript krml 267, 27 may 2019\n\n摘要 dafny有许多类似推导式的结构。本文描述并比较了这些结构，展示了它们在语法和语义上的比较。\n\ndafny支持普遍量化和存在量化，以及用于“证明”普遍量化表达式或“利用”存在量化表达式的结构。[0]节(http://leino.science/papers/krml267.html#sec-quantifiers)描述了dafny中的这些逻辑量词。第[1]节(http://leino.science/papers/krml267.html#sec-proof-features)显示了在推理量词时可以使用的程序语句，并指出了各种语法形式的差异。\n\n集合推导式和映射推导式类似于量词，因为它们引入了范围超过特定值的绑定变量。[2]节(http://leino.science/papers/krml267.html#sec-sets-and-maps)展示了这些理解的一般和常见形式。\n\n\n# 量词\n\n\n# 基本的量词的语法\n\n在数学教科书和论文中，我们熟悉的全称量词采用了类似的符号。它说谓词对所有的值都成立。在编程语言行话中，我们说它是一个绑定变量，其作用域是量词的主体。也就是说，任何自由出现的in都被绑定到量词所引入的。\n\n在dafny中，同一个全称量词被写成forall x:: p。从解析的角度来看，量词的主体“尽可能地”扩展。因此，程序片段\n\nforall x :: r ==> q\n\n\n1\n\n\n解析为\n\n(forall x :: (r ==> q))\n\n\n1\n\n\n而不是\n\n(forall x :: r) ==> q\n\n\n1\n\n\n请注意，“尽可能”不限于行尾。例如，一个常见的陷阱是编写(这里显示的是一个前置条件)\n\nrequires\n  forall x :: r ==> q &&\n  s\n\n\n1\n2\n3\n\n\n意图是forall x:: r ==> q和s是两个独立的前提条件。与此相反的是，这里所写的声明的意义是\n\nrequires (forall x :: (r ==> (q && s)))\n\n\n1\n\n\n如果你打算写量词和s的连词，那么正确的语法是\n\nrequires\n  (forall x :: r ==> q) &&\n  s\n\n\n1\n2\n3\n\n\n存在量词的一个熟悉的数学符号是。它说谓词对于某个值成立。在dafny中，语法是exists x:: p .0\n\n\n# 绑定变量的类型\n\ndafny中的每个变量都有一个类型。通常，绑定变量的类型是推断的，但dafny也允许显式声明该类型。例如,\n\nforall x: x :: p\n\n\n1\n\n\n声明x的类型为x。为了简洁，并展示编写量词和推断的典型方法，我将在本文中省略类型，但请记住，如果愿意，您可以随时包含它们。\n\n当约束变量从某个集合中提取时，量词的常用数学符号是。这个表达式的dafny式表示为\n\nforall x in s :: p  // error: syntax error\n\n\n1\n\n\n然而，这是不正确的dafny语法，因为它使用了一个集合成员谓词，其中只期望绑定变量(可选的，带有类型)。在dafny中这样一个量词的正确写法是\n\nforall x :: x in s ==> p\n\n\n1\n\n\n\n# 多个绑定变量\n\n一个限定符可以有一个以上的绑定变量。例如,\n\nforall x, y :: p\n\n\n1\n\n\np对于所有的x和y都成立。它在逻辑上等同于嵌套的量词\n\nforall x :: forall y :: p\n\n\n1\n\n\n就此而言，它在逻辑上也等价于\n\nforall y :: forall x :: p\n\n\n1\n\n\ndafny的常见做法是使用多个变量的量词，而不是嵌套的形式，如果没有其他原因，只是为了更简洁。1\n\n如果您编写了一个绑定变量列表并显式地给出了类型，请注意，每个给定的类型只适用于它之前的变量。例如,\n\nforall x: x, y: y :: p\n\n\n1\n\n\nx的类型是x, y的类型是y。如果只包含y类型，如\n\nforall x, y: y :: p\n\n\n1\n\n\n那么你说y的类型是y而x的类型是可以推断的。换句话说，你可以认为这个“:”比“，”具有更强的约束力。\n\n\n# 量词主体的典型形式\n\n全称量词的主体通常是一种含义，如in\n\nforall x :: r ==> p\n\n\n1\n\n\n你可以从以下几个方面来解读:\n\n> "对于所有的x，意味着r ==> p成立"\n> \n> "对于所有的x， r意味着p "\n> \n> "对于所有的x，如果r成立，那么p也成立"\n\n然而，这个含义的先行词(r)通常起到限制(不仅仅是x的类型)所考虑的x的值的作用。换句话说，“r”告诉你“x”的范围。在这种情况下，你可以从下面的一种方式来解读上面的量词:\n\n> "对于所有满足r的x， p成立\n> \n> "对于所有的x，使r成立，p "\n> \n> "对于所有的x(其中x满足r)， p保持"\n> \n> “对于所有的x[为r插入你自己的描述性阶段]，p”\n\n作为最后一个短语的具体实例，你可以读到forall x:: x in s ==> x % 2 == 0 as\n\n> "对于s中的所有x， x是偶数"\n\n你可以读到forall i:: 0 <= i < a. length ==> a[i] == 5 as\n\n> "对于数组a的每个下标i， a -sub- i是5 "\n\n和我刚才说的全称量词类似，存在量词的典型形式是连词，比如\n\nexists x :: r && p\n\n\n1\n\n\n例如：\n\nexists x :: x in s && x % 2 == 0\n\nexists i :: 0 <= i < a.length && a[i] == 5\n\n\n1\n2\n3\n\n\n再把r看成是告诉你x的范围，你可以把这些存在量词看成\n\n> "在s中有一个x，其中x % 2 == 0适用"\n> \n> "在a中有一个索引i，使a -sub- i等于5 "\n\n在why3 [1]之后，如果你将r ==> p作为存在量词的主体，dafny会发出警告，因为这几乎总是一个用户错误(一个打字错误或一个思考-o)。如果这真的是你想要写的，你可以通过编写以下任何表达式来抑制警告:\n\nexists x :: (r ==> p)\nexists x :: !r || p\nexists x :: p <== r\n\n\n1\n2\n3\n\n\n\n# 范围谓词\n\n为什么我要花一页来告诉你量词的发音?因为这个讨论强调了一个事实，条件r，在任何一个\n\nforall x :: r ==> p\nexists x :: r && p\n\n\n1\n2\n\n\n扮演着特殊的角色，尽管“r”实际上只是这些量词主体的一部分。事实上，其他人已经为量词采用了一种表示法，该表示法为这个范围谓词 r设置了一个特殊的位置。下面是一些例子:\n\n                                                \nuniversal quantifier   existential quantifier   source\n                                                \n                                                dijkstra [3]\n                                                chandy and misra [2]\n                                                gries and schneider [4]\n\\forall x x; r; p      \\exists x x; r; p        jml [5]\n                                                \n\n(在上面的jml中，x表示x的类型。)在使用这些符号的教科书中，经常有人说:“为了简洁，如果‘r’是‘正确’的，或者是根据上下文理解的，那么它(对于上面的一些作者来说，一些相邻的标点符号)就被省略了。”这些缩写形式是:\n\n                                                  \nrange listed separately   range true or omitted   source\n                                                  \n                                                  dijkstra [3]\n                                                  chandy and misra [2]\n                                                  gries and schneider [4]\n\\forall x x; r; p         \\forall x x;; p         jml [5]\n                                                  \n\n还有更多的。通过使用一些区分“r”和“p”的符号，量词的德摩根定律看起来特别好:\n\n回到dafny。如果您喜欢将绑定变量的范围从量词主体的其余部分分隔开的符号，那么您将很高兴地了解到，您也可以在dafny中这样做。语法是:\n\nforall x | r :: p\nexists x | r :: p\n\n\n1\n2\n\n\n\n# 用于量词推理的程序语句\n\ndafny包含了一些在推理涉及量词的程序或定理时非常有用的证明特性。它们的语法与量词相似，但也有区别。\n\n\n# 聚合语句\n\ndafny中的forall语句是一个聚合语句:它具有执行多个同时操作的效果。当这句话用于证明时，其形式如下:\n\nforall x | r\n  ensures p\n{\n  s;\n}\n\n\n1\n2\n3\n4\n5\n\n\n它用于建立属性forall x | r:: p，即forall x:: r == >p。它是通过检验命题s为任何满足r的x建立p来实现的。在逻辑中，这个命题的结果被称为“普遍引入”。\n\n举个简单的例子，假设你有一个引理可以证明n <= fib(n)对于任何n至少是5，其中fib是通常的fibonacci函数:\n\nfunction fib(n: nat): nat {\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\nlemma fibproperty(n: nat)\n  requires 5 <= n\n  ensures n <= fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个引理给出了一个给定n的属性n <= fib(n)。但假设你想让这个性质以普遍量子化的形式存在。也就是说，你要证明下面的引理:\n\nlemma fibpropertyall()\n  ensures forall n :: 5 <= n ==> n <= fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们怎么写这个证明呢?2\n\n答案是对每个n调用fibproperty一次。一次。对于“n”有无数个不同的值。这就是你对聚合语句forall所做的:\n\nforall n | 5 <= n\n  ensures n <= fib(n)\n{\n  fibproperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\n一般来说，forall语句的主体要比单个引理调用复杂得多。但是当主体是只是一个引理调用或只是一个calc语句时，dafny会自动推断ensure子句，所以你可以省略它:\n\nforall n | 5 <= n {\n  fibproperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# 存在引入与排除\n\n使用存在量化还使用了一系列的证明特征。我将通过写一个证明来证明斐波那契数可以是任意大的:\n\nlemma everbigger(k: nat)\n  ensures exists n :: k <= fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\n让我们从一些简单的例子开始证明，比如当k很小的时候，比如0或1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\ndafny不能自动证明这两种情况，所以我们需要自己给出更多的证明。\n\n为了证明这个引理在简单的情况下，它足以向验证者证明存在量词持有的一个特定的n。也就是说，我们想给存在量词一个见证。一个这样的见证是1，因为k <= 1 == fib(1)。另一个这样的见证是12，因为k <= 144 == fib(12)。另一个这样的见证是k，因为在我们的简单例子中k <= k == fib(k)。让我们继续这个，所以我们在引理主体的“if”语句的“then”分支中添加一个断言:\n\nassert k <= fib(k);\n\n\n1\n\n\ndafny将证明这个断言3，然后会注意到k是一个证明后置条件的存在见证。在逻辑中，这被称为“存在论导言”。这意味着，如果你有一个满足特定属性的值，那么这个值就存在。换句话说，如果你有一个“在你手中”的价值，那么这个价值就存在了——这似乎是如此明显，以至于我们谈起它时几乎会感到尴尬(你的邻居听到你以这个为生肯定会认为你疯了)。\n\n那么这个棘手的案例呢?我们可以通过归纳法来证明，首先得到一个n，它的斐波那契值至少为k-1，然后再从中构建一个更大的斐波那契值。首先，我们在“k-1”上递归地调用引理:\n\neverbigger(k-1);\n\n\n1\n\n\n这让我们获得了everbigger(k-1)的后置条件。为了在我们的证明中明确地写下这一点——为了检查验证者是否得出了我们期望从引理调用中得到的结论，并提醒我们自己什么属性——我们可以写一个断言:\n\nassert exists n` :: k-1 <= fib(n`);\n\n\n1\n\n\n好到目前为止。接下来，我们想构造一个至少比fib(n)大1的斐波那契数，因为这样可以完成证明。但是我刚才提到的n是什么?上面的所有断言都告诉我们存在这样的“n”。我们希望有这样一个“n”在我们手中，这样我们就可以使用它。\n\n从我们知道存在的东西到“在我们手中”的东西被称为“skolemization”或“existenelimination”。你在dafny中通过assign-such-that语句实现:\n\nvar m: nat :| k-1 <= fib(m);\n\n\n1\n\n\n这个语句引入了一个局部变量m，并给它一个任意值，满足k-1 <= fib(m)。当然，如果不存在这样的值，这是不可能的，所以赋值-such-that语句引起了一个证明义务，证明这样的m存在。这个证明义务来自于我们上面断言的属性。\n\n差不多了。为了建立引理的后置条件，我们剩下的计划就是构造一个严格大于fib(m)的斐波那契数。我们观察到fib(m) + fib(m+1)严格大于fib(m)，因此我们有fib(m+2)严格大于fib(m)。\n\n好吧，我们直说了吧。也许我们并没有“观察”到这一点，而是“希望”、“猜想”或“松散地认为”它可能成立。好吧，确实如此。(唷!)我们可以通过询问验证者它是否能为我们证明来验证:\n\nassert k <= fib(m) + fib(m + 1) == fib(m + 2);\n\n\n1\n\n\n验证者立即证明了这个断言。4此外，通过写下这个断言，我们也向验证者展示了见证m+2，它证明了引理的后置条件中的存在量词。\n\n我用这个例子来说明的重点是，你可以用skolemize一个量词\n\nexists x :: p\n\n\n1\n\n\n通过assign-such-that语句\n\nvar x :| p;\n\n\n1\n\n\n注意标点符号的区别。\n\n\n# 带外参数的引理\n\n我刚刚给你们看了一个涉及存在量词的例子。这个例子表明，“everbigger”引理的“证明”两次使用了存在性介绍(在简单情况下为fib(k)，在困难情况下为fib(m+2))，从而将“我们手中”的k和m+2转换为存在性量化。这个例子还展示了(递归调用)引理的调用使用存在消除来将引理的后置条件中的存在量化转换为“我们手中的”一个m。让人印象深刻的是，dafny有这样的特性，它还有一个更有用的特性，可以让你在一开始就避免这些存在-量词转换:引理-参数。\n\n在数学中，引理是由它们所提到的变量参数化的。这些都是参数。一个数学引理很少或永远不会被认为具有外参数。在dafny中，引理实际上就是一个幽灵方法，一个方法可以同时具有输入参数和输出参数。这是非常有用的。与其用引理来证明某个值的“存在”，还不如直接“返回”某个这样的值。\n\n下面是上面的“everbigger”引理，但将n声明为out形参:\n\nlemma everbigger(k: nat) returns (n: nat)\n  ensures k <= fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := everbigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 绑定警卫\n\ndafny还包含了另一个特性，使量词的使用更加流畅:带有*binding guard *的if语句。这样的语句回答了“如果有一个，给我一个在我手里”的命令。\n\n假设我们写一个证明，根据y是否为斐波那契数分成两种情况。然后我们可以这样写:\n\nif exists n :: y == fib(n) {\n  var n :| y == fib(n);\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这表达了我们想要的，但感觉有点笨拙，因为我们重复了条件y == fib(n)。我们可以将这个“if”语句写成\n\nif n :| y == fib(n) {\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\n:|与赋值such-that语句中的标点相同，而不是存在量词中类似位置的::。\n\n\n# 集合和映射\n\n逻辑量词和其他结构引入了一些绑定变量，并以某种方式限制了这些绑定变量的取值范围。集合理解和映射理解也是如此。\n\n\n# 集合理解\n\n很容易在dafny写下一组。例如,\n\n{ 2, 3, 5 }\n\n\n1\n\n\n是三个最小素数的集合。这样的表达式，其中集合的元素被显式列出，称为set display。但是，如果您想要定义的集合不能写成集合显示，该怎么办?\n\n集合理解以图解的方式定义了一组元素。在普通数学符号中集合理解的一个例子是\n\n定义了最小的100个自然数的集合。另一个例子是\n\n它定义了100个最小的完全平方数。这两个推导式中的绑定变量都是，指定range的值由谓词定义。让范围超过这些值，第一个集合然后包含表单的元素，而第二个集合包含表单的元素。也就是说，在第一个集合中，元素是自身的合法值，而在第二个集合中，元素是每个合法值的平方。\n\n更一般地说，数学符号的形状是这样的。读者应该理解这是绑定变量。理解为绑定变量，我们可以通过精确描述集合何时包含一个元素来定义集合推导式:\n\n或者，使用存在函数的取值范围单独给出的符号:\n\n在dafny中，同样的集合理解有如下形式:\n\nset x | r :: f(x)\n\n\n1\n\n\nx是绑定变量(或者，更普遍地说，一个绑定变量的列表)，r是绑定变量的范围谓词，而f(x)是集合推导的项表达式。绑定变量被显式列出，不像普通的数学符号，读者必须推断绑定变量是什么。上面给出的两个示例集在dafny中写如下:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\n虽然乍一看不太简洁，但显式列出绑定变量的表示法有一些细微之处。\n\n一个细微之处是，就像上面一样，量词的定义显示了符号的相似性:\n\ny in (set x | r :: f(x))   <==>   exists x | r :: y == f(x)\n\n\n1\n\n\n另一个优点是可以很容易地列出附加的绑定变量。假设r是x和z的谓词，那么这里有两个例子:\n\nset x,n | fib(n) <= x < fib(n) + n :: f(x)\nset x,n | fib(n) <= x < fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\n第一个集合包含f(x)对于每个在n范围内的x对于某些n的fib(n)。用普通的数学符号来表示它的一种等价的方式是:\n\n第二个集合包含g(x,n)对于每个x和n，使x在fib(n)的n之内。在这里，等效的数学符号更笨拙，需要使用另一个绑定变量:\n\ndafny使绑定变量显式的一般表示法也被许多作者使用(例如，[3， 4])。它也类似于其他语言中使用的列表理解表示法。例如，dafny系列\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\n它包含一对自然数之和为100，包含与python列表相同的元素:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nhaskell名单:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# 简化的集合理解\n\n我刚刚花了很多文字来描述dafny中的一般集合理解符号。然而，在实践中的许多集合推导中，只有一个约束变量，而术语表达式就是那个约束变量。例如，我们已经看到，最小的“100”自然数的集合是:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\n对于这种常见的情况，dafny允许你省略术语表达式，只需要写:\n\nset x | 0 <= x < 100\n\n\n1\n\n\n这个表达式看起来像普通的数学符号。事实上，对于这些简化的集合推导式，很容易“理解”数学符号想要表达的约束变量是什么。\n\n作为dafny中验证器的一个注释，自动化倾向于更好地工作于简化的集合推导式，其中术语表达式可以被省略。\n\n\n# 映射理解\n\n一个map本质上是一组对，其中对的左元素是唯一的(也就是说，每个左元素在功能上决定了相应的右元素)。与集合的显示表达式一样，map可以通过map display来定义。例如,\n\nmap[2 := `c`, 137 := `a`]\n\n\n1\n\n\n将整数2映射到字符c，将整数137映射到字符a。每一对像2:= c可以被称为一个maplet。此外，maplet的左元素称为a key，右元素获得不可描述的名称value。\n\n与集合的理解一样，映射可以通过map理解来定义。它的形式是:\n\nmap x | r :: f(x) := g(x)\n\n\n1\n\n\n例如，\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\n是从前100个完全平方数到它们各自的平方根的映射。\n\n如果您将映射理解理解为一组具有唯一键的maplets，那么您基本上已经理解了符号。不过，我将提供一些注释并指出映射特有的一些特性。\n\n需要注意的一点是，maplets必须具有唯一的键。例如，验证者会抱怨，如果你试着写一个像这样的映射理解\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\n因为它说把4映射到2和-2上，这是没用的。\n\n一般的映射理解表达是相当灵活的。例如，假设m是一个从数字到字符的映射，并假设我们想要创建一个新的映射n，从m中的键的子集到其他一些字符。更准确地说，当m中的键在函数f的图像中，比如一个键f(x)对于某个x，然后我们想让n将这个键映射到h(x)。然后我们将n定义为\n\nmap x | f(x) in m.keys :: f(x) := h(x)\n\n\n1\n\n\n然而，大多数时候，我们倾向于写的映射理解具有这种形式\n\nmap x | r :: x := g(x)\n\n\n1\n\n\n对于这些常见的映射，dafny允许我们省略“x:=”，只写\n\nmap x | r :: g(x)\n\n\n1\n\n\n在实践中，几乎所有的映射理解都可以用这种简化的形式来写。但是当简化形式不充分时(就像上面的maplets f(x):= h(x)的例子一样)，一般形式是可用的。\n\n\n# lambda expressions\n\n最后，要注意映射和函数之间的区别。您可以将map看作是一个预先计算好的表，而函数则是从一个给定的键中计算出一个值。为了进行比较，让我们考虑编写映射\n\nmap x | r :: g(x)\n\n\n1\n\n\n作为一个函数。\n\n通常，函数是用名称声明的。上面的映射是沿着线写的\n\nfunction f(x: x): y\n  requires r\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\n函数也可以是匿名的，在这种情况下，它通常被称为lambda表达式。然后编写示例映射\n\nx requires r => g(x)\n\n\n1\n\n\n\n# 总结\n\n以下是本文中讨论的语法形式:\n\nforall x :: p\nforall x | r :: p\nforall x | r ensures p { s; }\nexists x :: p\nexists x | r :: p\nvar x :| p;\nif x :| p { s; }\nset x | r :: f(x)\nset x | r\nmap x | r :: f(x) := h(x)\nmap x | r :: g(x)\nfunction f(x: x): y { g(x) }\nx requires r => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 致谢\n\n我很感谢jay lorch在这张便条上的许多有帮助的评论。\n\n\n# 参考文献\n\n[0]nada amin, k. rustan m. leino, and tiark rompf. computing with an smt solver. in martina seidl and nikolai tillmann, editors, tests and proofs — 8th international conference, tap 2014, volume 8570 of lecture notes in computer science, pages 20–35. springer, july 2014. 🔎\n\n[1]francois bobot, jean-christophe filliatre, claude marche, and andrei paskevich. why3: shepherd your herd of provers. in boogie 2011: first international workshop on intermediate verification languages, pages 53–64, wrocław, poland, august 2011. https://hal.inria.fr/hal-00790310. 🔎\n\n[2]k. mani chandy and jayadev misra. parallel program design: a foundation. addison-wesley, 1988. 🔎\n\n[3]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. 🔎\n\n[4]david gries and fred b. schneider. a logical approach to discrete math. texts and monographs in computer science. springer-verlag, 1994. 🔎\n\n[5]gary t. leavens, albert l. baker, and clyde ruby. jml: a notation for detailed design. in haim kilov, bernhard rumpe, and ian simmonds, editors, behavioral specifications of businesses and systems, pages 175–188. kluwer academic publishers, 1999. 🔎\n\n[6]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361–381. springer, 2016. 🔎\n\n----------------------------------------\n\n0.用于dafny排版的emacs ide某些dafny结构的符号你更可能在论文中看到。默认情况下，它显示forall x:: p as和显示exists x:: p as。[↩](http://leino.science/papers/krml267.html # back-fn-fn-emacs)\n\n1.在内部，dafny验证器可以更有效地使用某些量词。验证者试图检测一个给定量词的另一种形式何时可能执行得更好，并将在这些情况下自动重写量词[6]。例如，它可以选择解除某些量词的嵌套。这种重写的目标是在获得良好的验证性能的同时支持自然外观的程序。[↩](http://leino.science/papers/krml267.html # back-fn-fn-nested)\n\n2.事实证明，dafny的自动归纳将自动证明fibproperty和fibpropertyall。如果这是我们唯一关心的引理，那就没有什么好说或做的了。尽管如此，我还是用这个例子来展示“forall”语句。如果你想要确保我将要说的是一个证明，你可以通过使用属性{:induction false}来关闭fibpropertyall的自动感应。[↩](http://leino.science/papers/krml267.html # back-fn-fn-fibpropertyall)\n\n3.dafny也可以证明类似断言assert fib(12) == 144;。在内部，dafny使用了函数的“双轨编码”，使其能够获得fib(12)的值(因为12是一个文字常量)和fib(k)(其中k是一个变量)。如果您对这是如何实现的感兴趣，我建议您访问[0]。[↩](http://leino.science/papers/krml267.html # back-fn-fn-dual-rail-encoding)\n\n4.这里是断言k <= fib(m) + fib(m+1)的一个证明。在我们的证明中，“困难的情况”适用于当k至少为2时，所以k-1至少为1，所以我们知道fib(m)至少为1。由此可以得出结论，对于fib(0) == 0， m不能为0。这很重要，因为这意味着m+1至少等于2，因此适用于fib定义的归纳情况。换句话说，我们有fib(m+1) == fib(m) + fib(m-1)。我们已经得出，fib(m)至少等于1。以fib返回nat为例，我们知道fib(m-1)至少为0。所以，fib(m+1)至少等于1。换句话说，fib(m) + fib(m+1)至少比fib(m)大于1，而fib(m)至少等于k-1。因此，fib(m) + fib(m+1)至少等于k。\n\n如果我们把“简单的情况”和“困难的情况”分开，使“简单的情况”只包含“k == 0”，那么我们不可能在上面的论证中得出“m != 0”的结论。其他交互式证明助手的一些用户可能会对此感到困扰，因为他们会说k具有nat类型，因此对k的归纳应该使用k == 0作为基本情况。数学对归纳法没有这样的限制，事实上，正如这个证明所显示的，我们可以从将“everbigger”的情况分成“k < 2”和“2 <= k”中获益。[↩](http://leino.science/papers/krml267.html # back-fn-fn-proof)',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"不同类型的证明",frontmatter:{title:"不同类型的证明",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/20c275/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/5.%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%81%E6%98%8E.html",relativePath:"40.资源/00.实践探索/5.不同类型的证明.md",key:"v-93595222",path:"/pages/20c275/",headers:[{level:2,title:"一个示例问题",slug:"一个示例问题",normalizedTitle:"一个示例问题",charIndex:189},{level:2,title:"证明计算",slug:"证明计算",normalizedTitle:"证明计算",charIndex:1026},{level:2,title:"连接和线型计算",slug:"连接和线型计算",normalizedTitle:"连接和线型计算",charIndex:2576},{level:2,title:"最简证明",slug:"最简证明",normalizedTitle:"最简证明",charIndex:3655},{level:2,title:"结构化断言",slug:"结构化断言",normalizedTitle:"结构化断言",charIndex:4198},{level:2,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:4779},{level:2,title:"断言",slug:"断言",normalizedTitle:"断言",charIndex:1041},{level:2,title:"原型显性证明",slug:"原型显性证明",normalizedTitle:"原型显性证明",charIndex:6556},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8880},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:9183}],headersStr:"一个示例问题 证明计算 连接和线型计算 最简证明 结构化断言 作用域 断言 原型显性证明 总结 参考文献",content:"# 不同类型的证明\n\n> K. Rustan M. Leino Manuscript KRML 276, 9 March 2020\n\n摘要 就像写作和口语中有不同的句子结构来表达不同的想法一样，也有不同的证明结构来表达证明。这条注释显示了在Dafny中可能出现的一些变化。\n\n让我们考虑不同的证明写作风格。作为一个运行的例子，我们将首先定义一个函数及其行为的一些公理。\n\n\n# 一个示例问题\n\n考虑一个带有两个参数的整数函数f:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\n因为我没有为这个函数提供一个函数体，所以Dafny将它视为一个未解释的函数。也就是说我们对它一无所知。我们知道它是一个函数，这意味着它的结果值完全由它的输入决定。例如，我们不知道f(7,3)计算的是哪个整数，但是知道如果你用相同的参数再次调用f，你会继续得到相同的值。\n\n为了证明关于f的一些东西，我们想知道更多关于f的性质。下面是三个引理的声明，它们表达了这样的属性:\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n就像函数本身一样，这些引理没有实体。它是引理的主体来证明引理的后置条件。换句话说，主体是证明引理的东西。因为这些引理没有证明，所以它们实际上是“公理”(也就是说，你必须在没有证明的情况下接受它)。\n\n如果你通过Dafny 编译器运行这个函数和这些引理，你会收到抱怨，说它们没有实体。但出于本文的目的，我们并不关心从编译器获取正在执行的代码。我们的重点是证明，而Dafny 验证者对无实体声明没有异议。就验证者而言，无主体声明只是说没有什么可检查的。\n\n我们将以不同的风格来证明这个性质:\n\n> a,b, c,和x,如果c < = x = = f (a, b),然后f (a、f (b, c)) < = x。\n\n这个性质的证明使用了上面的三个公理。\n\n\n# 证明计算\n\n有时，一个简单的“断言”语句就足以提示Dafny验证器完成一个证明。其他时候，您需要调用一个引理。当情况没有这么简单时，在Dafny中编写证明的最常见方法是证明计算 [0， 3]。\n\n证明计算是一系列的证明步骤。每一步证明一个等式(例如，A == B)、不等式(例如，A <= B)或逻辑推论(例如，A ==> B)。\n\n一个步骤是垂直书写的，以给一些空间来证明为什么这个步骤是成立的。下面是一个原型步骤:\n\n  A;\n==  // explain why A equals B\n  B;\n\n\n1\n2\n3\n\n\n如本步骤所示，链中的每个公式都以分号结束。\n\n在上面的原型步骤中，我将理由(也称为hint)作为注释编写。这样的注释是有用的文档。如果验证者不能在没有帮助的情况下检查您的步骤，则提示需要不仅仅是注释。然后，用花括号写一段代码，验证者使用从代码中获得的知识来证明这一步。例如,\n\n  A;\n==  { LemmaThatJustifiesABEquality();  }\n  B;\n\n\n1\n2\n3\n\n\n是时候写证明了。这里是:\n\nlemma CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n让我们来看看这个证明计算。\n\n第一步说，根据结合律，表达式f(a, f(b, c))等于f(f(a, b)， c)注意，这个提示使用特定参数a， b和c调用结合性引理。\n\n第二步说f(f(a, b)， c)和f(x, c)是一样的，因为我们要证明的引理的前提(即先决条件)说x等于f(a, b)。验证者根据我们要证明的引理的前提知道x == f(a, b)这个等式，所以验证者在这个证明步骤中不需要明确的提示。但是，有时候用机器检查的方式来做这样的语句会很好，你可以用“assert”语句来做，就像我在这里展示的那样。\n\n第三步证明f(x, c) <= f(x, x)。这一步的理由是c <= x保持不变(它是在引理前提条件下给出的)，因此可以将引理称为单调性(这需要c <= x作为前提条件)。调用单调性(c, x)引理给了我们\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\n验证者指出，用x为w实例化这个量词给出了我们在这一步中试图证明的不等式。\n\n第四步证明了f(x, x) = x。这个属性直接遵循DiagonalIdentity公理，用参数x调用。\n\n我们的四个证明步骤证明了以下四个相应的性质:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\n通过==和<=的传递性，这四个性质给了我们\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\n这就是我们要证明的。\n\n\n# 连接和线型计算\n\n一般来说，我发现证明计算是令人信服的，容易阅读。您可以分别检查每一步，并可以看到公式是如何从一行“转换”到一行的。\n\n很多时候(但并非总是如此)，我也发现证明计算对作者来说很简单。在上面的例子中，我们从公式的左边开始计算\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\n我们要证明。然后，我们看一下证明的当前行，找出关于这个表达式我们知道什么性质，以及我们接下来可以应用什么变换。为了在这个过程中获得更多的指导，通常最好从我们试图证明的公式的更复杂的一面开始。举个例子，如果你从\n\ncalc {\n  x;\n\n\n1\n2\n\n\n现在还远不清楚下一步会怎样\n\n==  { DiagonalIdentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\n我们可以继续这个证明，将上一节的步骤按相反的顺序写下来，并在每一步中反转运算符的方向(例如，将<=更改为>=):\n\n>=  { assert c <= x; Monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\n不管我们往哪个方向走，到目前为止，我所展示的计算中的每一行都有类型int。也可以在每一行用一个布尔公式来写证明。这里有一个这样的例子:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { DiagonalIdentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { Associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; Monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过==的传递性，证明了公式f(a, f(b, c)) <= x的值为true。\n\n如果您为您的证明计算行选择这样的布尔表达式，那么每一步的操作符通常是逻辑暗示(==>，即“逻辑弱化”)或逻辑“解释”(<==，“逻辑强化”，或“从后”)。当然，你必须选择这两个方向中的一个，而不是同时使用，否则你的证明计算就没有意义了。在这些方向中，<==通常会给你一个更好的起点，因为你会从你要证明的公式开始，最后你会得到true。然而，根据我的经验，我发现许多初学者被<==的方向搞糊涂了，他们把计算写得好像他们是在==>的方向上。用任何对你有意义的方向。\n\n\n# 最简证明\n\n证明计算是一种构造证明步骤的方法。它通常包含比验证者需要的更多的信息，特别是如果您为了自己的利益，将证明写在小的步骤中。如果你认为一个证明有太多的细节，你可以删除一些不需要的东西。这是否是个好主意——或者，什么时候是个好主意，删除多少内容——主要取决于个人喜好。如果您稍后再回到证明，额外的细节可能会提供有用的文档，说明证明最初是如何构造的。\n\n如果你想减少上面的证明计算中的提示，你可能要做的第一件事是删除作为证明的一部分的两个assert语句，或者至少删除断言c <= x。但是你可以做的更多。\n\n通过前面的计算，我们可以很容易地看到使用了哪些引理，更重要的是，这些引理实例化了哪些值。一旦你知道了这一点，你就可以完全不用计算证明了。整个证明是这样的:\n\nlemma MinimalProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  Monotonicity(c, x);\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 结构化断言\n\n为了说明这一点，不写calc语句的计算证明是有益的。这是它看起来的样子:\n\nlemma AssertProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; Monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  DiagonalIdentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这四组语句中的每一组都对应于[1]节(http://leino.science/papers/krml276.html#sec-calc)计算中的一个步骤。在这个步骤证明的等式或不等式的断言之前，calc语句的提示是什么?验证者然后把四个结论粘在一起来证明引理的后置条件。\n\n\n# 作用域\n\n[1]节(http://leino.science/papers/krml276.html#sec-calc)中的calc语句与[4]节(http://leino.science/papers/krml276.html#sec-linear-asserts)中的拆分的assert语句之间存在差异。不同之处在于，计算中的每一个提示对于证明步骤来说都是局部的。也就是说，提示的作用域就是步骤本身。例如，假设您将1部分中calc语句的所有提示移动到第一个证明步骤。然后，两个证明步骤将不再验证:\n\ncalc {\n  f(a, f(b, c));\n==  { Associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; Monotonicity(c, x);\n      DiagonalIdentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也就是说，在第一步中调用提示中的三个引理所获得的信息不会影响到其他步骤。相反，如果你收集引理主体开始的提示，四个等式和不等式就可以很好地验证:\n\n// hints\nAssociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; Monotonicity(c, x);\nDiagonalIdentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n你可以把calc表述的每一步都看作是一个引理，引理的证明就放在这一步的提示里。这在编写证明时很重要，不仅因为它告诉人类读者某个提示适用于特定的证明步骤，还因为它限制了验证者应用提示的范围。对于复杂的证明，这在实践中会产生很大的不同，因为验证者可能会被太多的信息“弄糊涂”——这表现为验证者的性能差或某些“蝴蝶效应”[2]。\n\n总之，在证明中区分提示是很好的。calc语句在这方面做得很好，但你也可以用assert语句的形式来做。下面我们来看一下。\n\n\n# 断言\n\nassert E;表述了三件事:\n\n 1. 它表明你期望条件E成立\n 2. 它要求验证者证明E 3.它让后面的断言假设E\n\n您可能没有考虑过将断言的这三个方面分开，但是这样做很有用，因为Dafny提供了(1)和(2)的替代方案。\n\n该声明\n\nassert E by { Hint }\n\n\n1\n\n\n改变方面(1)说E是在给定的提示下被证明的，其中hint是一个命题。提示的作用域只是断言本身，所以它在断言的下游不可用。这样，assert by语句等价于:\n\ncalc {\n  E;\n==  { Hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们可以使用assert by重写4部分的证明:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  Associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; Monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这提供了更好的分区，从而更直接地表达了为什么每个断言的条件保持不变。\n\n\n# 原型显性证明\n\n6部分中的证明包含两个断言，它们重申了在前置条件中所写的内容。这些断言背后的思想是明确使用这些先决条件的地方。然而，这有两个缺点。\n\n一个缺点是，必须将断言中的表达式与证明中的其他表达式进行比较，才能意识到断言只是在重申一个以前可用的假设。如果我们可以标记条件，然后引用标签，那就好了。\n\n另一个缺点是，无论是否在断言中重述条件，前提条件都是可用的。如果我们忘记编写断言(可能是因为我们没有意识到我们依赖于这个条件)，或者如果我们意外地编写了错误的前提条件，那么证明仍然有效。也就是说，验证器已经能够使用前置条件，所以它不关心你是重述条件，还是陈述一个不同的(真)条件，或者什么也不陈述。如果我们能更明确地说明这些假设的范围，那就太好了。\n\n还有一种形式的断言by语句。它放松了[6]部分(http://leino.science/papers/krml276.html#sec-assert-by)的aspect(2)。这个表单看起来像这样:\n\nassert Label: E { Hint }\n\n\n1\n\n\n这个有标记的断言语句表示你期望条件E成立，它提供了一个提示语句作为E的证明。在条件前使用标签会抑制“E”作为下游假设的使用。\n\n例如，要证明f(12,12) == 12，需要使用DiagonalIdentity公理。如果你使用带标签的assert by来证明这个事实，那么在带标签的assert之后，被证明的事实仍然不可用:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\n如果你不能用你证明的事实，为什么要用这种说法呢?好吧，我应该说事实在标记的断言之后不是“自动”可用的。但是您可以明确地请求它。你可以用“揭示”声明来做到这一点，在声明中你提到了标签。\n\n下面又是一个例子，但带有“reveal”语句:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nreveal Label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\n你可以在前提条件上使用同样的技巧。也就是说，通常在引理(或方法或函数)中，是一个先决条件\n\nrequires E\n\n\n1\n\n\n在引理的整个正文中都有。但如果你给它贴上标签，你就必须使用“揭示”语句来引出这个假设:\n\nrequires Label: E\n\n\n1\n\n\n在我们看到它的实际应用之前，让我先谈谈标签。Dafny中的标签可以是任何标识符，但它也可以是文本上看起来像数字字面量的东西。以下是五个标签示例:\n\nMyLabel    Label57    L57    57    000_057\n\n\n1\n\n\n这是五个不同的标签——事实上，“57”和“000_057”作为数字字面量表示相同的数字，并不意味着它们是相同的标签。如果它们在印刷页上看起来不一样，它们就是不同的标签。(对于类中的字段名、数据类型的析构函数和其他类型成员也是如此，它们也具有允许看起来像文字的标识符的扩展语法。)\n\n好了，现在我们准备在运行的例子中使用带标签的断言:\n\nlemma DifferentStyleOfProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在这种类型的证明中(在一些逻辑学文本中很常见)，每个断言都通过其相关性显式地证明。如果您认为断言之间的依赖关系构成了一个证明DAG，那么这种证明风格就是对DAG中的祖先进行显式的证明。您可以使用嵌套的assert by语句和标记的断言的层次结构来近似lamport风格的证明[1]。\n\n\n# 总结\n\n校样的写作风格有很多种。最简单的证明是那些自动完成的，不需要进一步证明的证明。其他简单的证明需要一个断言或引理。证明步骤可以使用calc语句和assert by语句组织。通过标记一个“assert By”语句或一个前置条件，这个条件在证明中被抑制了，直到你使用一个“reveal”语句明确地请求它回来。\n\n构造证明是一个好主意，为了可读性和清晰度，以及改善机械证明性能。你可以把一个证明命题想象成有一些输入条件。这些是证明语句上下文中可用的条件和标签。证明语句的输出是calc语句的第一行和最后一行的传递连接，无标记的assert或assert by语句中的条件，以及有标记的断言的标签。\n\n\n# 参考文献\n\n[0]Edsger W. Dijkstra and W. H. J. Feijen. A Method of Programming. Addison-Wesley, July 1988. 🔎\n\n[1]Leslie Lamport. How to write a 21st century proof. Technical report, Microsoft Research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. 🔎\n\n[2]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361–381. Springer, 2016. 🔎\n\n[3]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments — 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170–190. Springer, 2014. 🔎",normalizedContent:"# 不同类型的证明\n\n> k. rustan m. leino manuscript krml 276, 9 march 2020\n\n摘要 就像写作和口语中有不同的句子结构来表达不同的想法一样，也有不同的证明结构来表达证明。这条注释显示了在dafny中可能出现的一些变化。\n\n让我们考虑不同的证明写作风格。作为一个运行的例子，我们将首先定义一个函数及其行为的一些公理。\n\n\n# 一个示例问题\n\n考虑一个带有两个参数的整数函数f:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\n因为我没有为这个函数提供一个函数体，所以dafny将它视为一个未解释的函数。也就是说我们对它一无所知。我们知道它是一个函数，这意味着它的结果值完全由它的输入决定。例如，我们不知道f(7,3)计算的是哪个整数，但是知道如果你用相同的参数再次调用f，你会继续得到相同的值。\n\n为了证明关于f的一些东西，我们想知道更多关于f的性质。下面是三个引理的声明，它们表达了这样的属性:\n\nlemma associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma diagonalidentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n就像函数本身一样，这些引理没有实体。它是引理的主体来证明引理的后置条件。换句话说，主体是证明引理的东西。因为这些引理没有证明，所以它们实际上是“公理”(也就是说，你必须在没有证明的情况下接受它)。\n\n如果你通过dafny 编译器运行这个函数和这些引理，你会收到抱怨，说它们没有实体。但出于本文的目的，我们并不关心从编译器获取正在执行的代码。我们的重点是证明，而dafny 验证者对无实体声明没有异议。就验证者而言，无主体声明只是说没有什么可检查的。\n\n我们将以不同的风格来证明这个性质:\n\n> a,b, c,和x,如果c < = x = = f (a, b),然后f (a、f (b, c)) < = x。\n\n这个性质的证明使用了上面的三个公理。\n\n\n# 证明计算\n\n有时，一个简单的“断言”语句就足以提示dafny验证器完成一个证明。其他时候，您需要调用一个引理。当情况没有这么简单时，在dafny中编写证明的最常见方法是证明计算 [0， 3]。\n\n证明计算是一系列的证明步骤。每一步证明一个等式(例如，a == b)、不等式(例如，a <= b)或逻辑推论(例如，a ==> b)。\n\n一个步骤是垂直书写的，以给一些空间来证明为什么这个步骤是成立的。下面是一个原型步骤:\n\n  a;\n==  // explain why a equals b\n  b;\n\n\n1\n2\n3\n\n\n如本步骤所示，链中的每个公式都以分号结束。\n\n在上面的原型步骤中，我将理由(也称为hint)作为注释编写。这样的注释是有用的文档。如果验证者不能在没有帮助的情况下检查您的步骤，则提示需要不仅仅是注释。然后，用花括号写一段代码，验证者使用从代码中获得的知识来证明这一步。例如,\n\n  a;\n==  { lemmathatjustifiesabequality();  }\n  b;\n\n\n1\n2\n3\n\n\n是时候写证明了。这里是:\n\nlemma calculationalstyleproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; monotonicity(c, x); }\n    f(x, x);\n  ==  { diagonalidentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n让我们来看看这个证明计算。\n\n第一步说，根据结合律，表达式f(a, f(b, c))等于f(f(a, b)， c)注意，这个提示使用特定参数a， b和c调用结合性引理。\n\n第二步说f(f(a, b)， c)和f(x, c)是一样的，因为我们要证明的引理的前提(即先决条件)说x等于f(a, b)。验证者根据我们要证明的引理的前提知道x == f(a, b)这个等式，所以验证者在这个证明步骤中不需要明确的提示。但是，有时候用机器检查的方式来做这样的语句会很好，你可以用“assert”语句来做，就像我在这里展示的那样。\n\n第三步证明f(x, c) <= f(x, x)。这一步的理由是c <= x保持不变(它是在引理前提条件下给出的)，因此可以将引理称为单调性(这需要c <= x作为前提条件)。调用单调性(c, x)引理给了我们\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\n验证者指出，用x为w实例化这个量词给出了我们在这一步中试图证明的不等式。\n\n第四步证明了f(x, x) = x。这个属性直接遵循diagonalidentity公理，用参数x调用。\n\n我们的四个证明步骤证明了以下四个相应的性质:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\n通过==和<=的传递性，这四个性质给了我们\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\n这就是我们要证明的。\n\n\n# 连接和线型计算\n\n一般来说，我发现证明计算是令人信服的，容易阅读。您可以分别检查每一步，并可以看到公式是如何从一行“转换”到一行的。\n\n很多时候(但并非总是如此)，我也发现证明计算对作者来说很简单。在上面的例子中，我们从公式的左边开始计算\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\n我们要证明。然后，我们看一下证明的当前行，找出关于这个表达式我们知道什么性质，以及我们接下来可以应用什么变换。为了在这个过程中获得更多的指导，通常最好从我们试图证明的公式的更复杂的一面开始。举个例子，如果你从\n\ncalc {\n  x;\n\n\n1\n2\n\n\n现在还远不清楚下一步会怎样\n\n==  { diagonalidentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\n我们可以继续这个证明，将上一节的步骤按相反的顺序写下来，并在每一步中反转运算符的方向(例如，将<=更改为>=):\n\n>=  { assert c <= x; monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\n不管我们往哪个方向走，到目前为止，我所展示的计算中的每一行都有类型int。也可以在每一行用一个布尔公式来写证明。这里有一个这样的例子:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { diagonalidentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过==的传递性，证明了公式f(a, f(b, c)) <= x的值为true。\n\n如果您为您的证明计算行选择这样的布尔表达式，那么每一步的操作符通常是逻辑暗示(==>，即“逻辑弱化”)或逻辑“解释”(<==，“逻辑强化”，或“从后”)。当然，你必须选择这两个方向中的一个，而不是同时使用，否则你的证明计算就没有意义了。在这些方向中，<==通常会给你一个更好的起点，因为你会从你要证明的公式开始，最后你会得到true。然而，根据我的经验，我发现许多初学者被<==的方向搞糊涂了，他们把计算写得好像他们是在==>的方向上。用任何对你有意义的方向。\n\n\n# 最简证明\n\n证明计算是一种构造证明步骤的方法。它通常包含比验证者需要的更多的信息，特别是如果您为了自己的利益，将证明写在小的步骤中。如果你认为一个证明有太多的细节，你可以删除一些不需要的东西。这是否是个好主意——或者，什么时候是个好主意，删除多少内容——主要取决于个人喜好。如果您稍后再回到证明，额外的细节可能会提供有用的文档，说明证明最初是如何构造的。\n\n如果你想减少上面的证明计算中的提示，你可能要做的第一件事是删除作为证明的一部分的两个assert语句，或者至少删除断言c <= x。但是你可以做的更多。\n\n通过前面的计算，我们可以很容易地看到使用了哪些引理，更重要的是，这些引理实例化了哪些值。一旦你知道了这一点，你就可以完全不用计算证明了。整个证明是这样的:\n\nlemma minimalproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  monotonicity(c, x);\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 结构化断言\n\n为了说明这一点，不写calc语句的计算证明是有益的。这是它看起来的样子:\n\nlemma assertproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  diagonalidentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这四组语句中的每一组都对应于[1]节(http://leino.science/papers/krml276.html#sec-calc)计算中的一个步骤。在这个步骤证明的等式或不等式的断言之前，calc语句的提示是什么?验证者然后把四个结论粘在一起来证明引理的后置条件。\n\n\n# 作用域\n\n[1]节(http://leino.science/papers/krml276.html#sec-calc)中的calc语句与[4]节(http://leino.science/papers/krml276.html#sec-linear-asserts)中的拆分的assert语句之间存在差异。不同之处在于，计算中的每一个提示对于证明步骤来说都是局部的。也就是说，提示的作用域就是步骤本身。例如，假设您将1部分中calc语句的所有提示移动到第一个证明步骤。然后，两个证明步骤将不再验证:\n\ncalc {\n  f(a, f(b, c));\n==  { associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; monotonicity(c, x);\n      diagonalidentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也就是说，在第一步中调用提示中的三个引理所获得的信息不会影响到其他步骤。相反，如果你收集引理主体开始的提示，四个等式和不等式就可以很好地验证:\n\n// hints\nassociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; monotonicity(c, x);\ndiagonalidentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n你可以把calc表述的每一步都看作是一个引理，引理的证明就放在这一步的提示里。这在编写证明时很重要，不仅因为它告诉人类读者某个提示适用于特定的证明步骤，还因为它限制了验证者应用提示的范围。对于复杂的证明，这在实践中会产生很大的不同，因为验证者可能会被太多的信息“弄糊涂”——这表现为验证者的性能差或某些“蝴蝶效应”[2]。\n\n总之，在证明中区分提示是很好的。calc语句在这方面做得很好，但你也可以用assert语句的形式来做。下面我们来看一下。\n\n\n# 断言\n\nassert e;表述了三件事:\n\n 1. 它表明你期望条件e成立\n 2. 它要求验证者证明e 3.它让后面的断言假设e\n\n您可能没有考虑过将断言的这三个方面分开，但是这样做很有用，因为dafny提供了(1)和(2)的替代方案。\n\n该声明\n\nassert e by { hint }\n\n\n1\n\n\n改变方面(1)说e是在给定的提示下被证明的，其中hint是一个命题。提示的作用域只是断言本身，所以它在断言的下游不可用。这样，assert by语句等价于:\n\ncalc {\n  e;\n==  { hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n我们可以使用assert by重写4部分的证明:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这提供了更好的分区，从而更直接地表达了为什么每个断言的条件保持不变。\n\n\n# 原型显性证明\n\n6部分中的证明包含两个断言，它们重申了在前置条件中所写的内容。这些断言背后的思想是明确使用这些先决条件的地方。然而，这有两个缺点。\n\n一个缺点是，必须将断言中的表达式与证明中的其他表达式进行比较，才能意识到断言只是在重申一个以前可用的假设。如果我们可以标记条件，然后引用标签，那就好了。\n\n另一个缺点是，无论是否在断言中重述条件，前提条件都是可用的。如果我们忘记编写断言(可能是因为我们没有意识到我们依赖于这个条件)，或者如果我们意外地编写了错误的前提条件，那么证明仍然有效。也就是说，验证器已经能够使用前置条件，所以它不关心你是重述条件，还是陈述一个不同的(真)条件，或者什么也不陈述。如果我们能更明确地说明这些假设的范围，那就太好了。\n\n还有一种形式的断言by语句。它放松了[6]部分(http://leino.science/papers/krml276.html#sec-assert-by)的aspect(2)。这个表单看起来像这样:\n\nassert label: e { hint }\n\n\n1\n\n\n这个有标记的断言语句表示你期望条件e成立，它提供了一个提示语句作为e的证明。在条件前使用标签会抑制“e”作为下游假设的使用。\n\n例如，要证明f(12,12) == 12，需要使用diagonalidentity公理。如果你使用带标签的assert by来证明这个事实，那么在带标签的assert之后，被证明的事实仍然不可用:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\n如果你不能用你证明的事实，为什么要用这种说法呢?好吧，我应该说事实在标记的断言之后不是“自动”可用的。但是您可以明确地请求它。你可以用“揭示”声明来做到这一点，在声明中你提到了标签。\n\n下面又是一个例子，但带有“reveal”语句:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nreveal label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\n你可以在前提条件上使用同样的技巧。也就是说，通常在引理(或方法或函数)中，是一个先决条件\n\nrequires e\n\n\n1\n\n\n在引理的整个正文中都有。但如果你给它贴上标签，你就必须使用“揭示”语句来引出这个假设:\n\nrequires label: e\n\n\n1\n\n\n在我们看到它的实际应用之前，让我先谈谈标签。dafny中的标签可以是任何标识符，但它也可以是文本上看起来像数字字面量的东西。以下是五个标签示例:\n\nmylabel    label57    l57    57    000_057\n\n\n1\n\n\n这是五个不同的标签——事实上，“57”和“000_057”作为数字字面量表示相同的数字，并不意味着它们是相同的标签。如果它们在印刷页上看起来不一样，它们就是不同的标签。(对于类中的字段名、数据类型的析构函数和其他类型成员也是如此，它们也具有允许看起来像文字的标识符的扩展语法。)\n\n好了，现在我们准备在运行的例子中使用带标签的断言:\n\nlemma differentstyleofproof(a: int, b: int, c: int, x: int)\n  requires a: c <= x\n  requires b: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal b;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal a; }\n    monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    diagonalidentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在这种类型的证明中(在一些逻辑学文本中很常见)，每个断言都通过其相关性显式地证明。如果您认为断言之间的依赖关系构成了一个证明dag，那么这种证明风格就是对dag中的祖先进行显式的证明。您可以使用嵌套的assert by语句和标记的断言的层次结构来近似lamport风格的证明[1]。\n\n\n# 总结\n\n校样的写作风格有很多种。最简单的证明是那些自动完成的，不需要进一步证明的证明。其他简单的证明需要一个断言或引理。证明步骤可以使用calc语句和assert by语句组织。通过标记一个“assert by”语句或一个前置条件，这个条件在证明中被抑制了，直到你使用一个“reveal”语句明确地请求它回来。\n\n构造证明是一个好主意，为了可读性和清晰度，以及改善机械证明性能。你可以把一个证明命题想象成有一些输入条件。这些是证明语句上下文中可用的条件和标签。证明语句的输出是calc语句的第一行和最后一行的传递连接，无标记的assert或assert by语句中的条件，以及有标记的断言的标签。\n\n\n# 参考文献\n\n[0]edsger w. dijkstra and w. h. j. feijen. a method of programming. addison-wesley, july 1988. 🔎\n\n[1]leslie lamport. how to write a 21st century proof. technical report, microsoft research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. 🔎\n\n[2]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361–381. springer, 2016. 🔎\n\n[3]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments — 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170–190. springer, 2014. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/27, 00:29:25",lastUpdatedTimestamp:1648312165e3},{title:"集合元素上的函数",frontmatter:{title:"集合元素上的函数",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/67167e/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/6.%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%B8%8A%E7%9A%84%E5%87%BD%E6%95%B0.html",relativePath:"40.资源/00.实践探索/6.集合元素上的函数.md",key:"v-523d0d4e",path:"/pages/67167e/",headers:[{level:2,title:"对集合的元素求和",slug:"对集合的元素求和",normalizedTitle:"对集合的元素求和",charIndex:217},{level:2,title:"求和的递归定义",slug:"求和的递归定义",normalizedTitle:"求和的递归定义",charIndex:570},{level:2,title:"不合格证明",slug:"不合格证明",normalizedTitle:"不合格证明",charIndex:937},{level:2,title:"选择其他东西",slug:"选择其他东西",normalizedTitle:"选择其他东西",charIndex:1410},{level:2,title:"内联选择",slug:"内联选择",normalizedTitle:"内联选择",charIndex:2398},{level:2,title:"Let such that",slug:"let-such-that",normalizedTitle:"let such that",charIndex:3362},{level:2,title:"多种选择",slug:"多种选择",normalizedTitle:"多种选择",charIndex:4620},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5353}],headersStr:"对集合的元素求和 求和的递归定义 不合格证明 选择其他东西 内联选择 Let such that 多种选择 总结",content:"# 集合元素上的函数\n\n> K. Rustan M. Leino Manuscript KRML 274, 16 February 2020\n\n摘要 在自然语言中，像“一组数字的和”这样的短语很容易说和理解。在正式设置中定义和使用这些函数需要更多的工作。这个问题与递归定义的函数如何从集合中选取下一个元素有关。本文描述了一个具有代表性的例子，并描述了如何使正式的繁文缛节发挥作用。该解可应用于集合上的任何交换运算和结合运算。\n\n\n# 对集合的元素求和\n\n假设我们有一个函数，它返回集合中所有整数的和:\n\nfunction Sum(s: set<int>): int\n\n\n1\n\n\n如果我们把一个元素y加到一个集合中，我们期望它的和增加y。也就是说，我们希望正确实现以下方法:\n\nmethod AddElement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == Sum(s) && y !in s\n  ensures t == s + {x} && b == Sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事实证明，证明不是自动的。让我们看看细节并填写证明。\n\n\n# 求和的递归定义\n\n函数“Sum”是递归定义的。空集合的和为0。如果集合非空，选择其中一个元素，比如x。然后，在递归计算的剩余元素的和上加上x。\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个定义使用了一个函数Pick，它返回给定集合中的任意元素。以下是它的定义:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\n我待会再讲Pick。此时您需要了解的是，Pick的调用者无法控制返回s中的哪个元素。\n\n\n# 不合格证明\n\n为了证明AddElement，我们需要证明b == Sum(t)在它的最终状态是成立的。回顾作业，这意味着我们需要展示\n\na + y == Sum(s + {y})\n\n\n1\n\n\n在初始状态。由于a是Sum(s)，我们的证明义务可以归结为\n\nSum(s) + y == Sum(s + {y})\n\n\n1\n\n\n我们已知y不在s中。\n\n假设Pick(s + {y})返回y。然后,我们有\n\n  Sum(s + {y});\n==  // def. Sum\n  var x := Pick(s + {y}); x + Sum(s + {y} - {x});\n==  // using the assumption Pick(s + {y}) == y\n  y + Sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + Sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这很简单也很直接。但对于这个证明，我们假设对Pick的相关调用返回了y。如果Pick返回与s不同的元素怎么办?\n\n\n# 选择其他东西\n\n在你意识到“挑选”可以选择一个不同于你所想的元素之前，乌云开始散去。我们需要的是一个引理，它表明选择是无关紧要的。也就是说，引理会让我们把“Sum”看作是，在做递归调用时，我们指定的一个元素。\n\n这就是那个引理。这个证明一开始也有点棘手。归根到底就是让“Pick”选择它所选择的任何元素，然后对“Sum”递归的更小的集合应用归纳假设。\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x := Pick(s);\n  if y == x {\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我说这个引理看起来像Sum的表达式，所以Sum的两个参数是s和s - {y}。或者，我们可以用s + {y}和s来调用Sum来声明该属性。这个选择是上述引理的一个简单推论:\n\nlemma AddToSum(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  SumMyWay(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用引理\n\n有了这个有用的引理，就很容易得到“AddElement”的证明:将其主体更改为\n\nt := s + {y};\nb := a + y;\nAddToSum(s, y);\n\n\n1\n2\n3\n\n\n\n# 内联选择\n\n在上面的开发中，我将‘Pick’定义为一个单独的函数。阅读程序文本中的单词“pick”可能有助于理解“Sum”和“SumMyWay”做什么。但它是一个如此小的函数，所以为什么不直接在使用它的两个地方内联它呢。让我们试一试:\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to Pick\n    x + Sum(s - {x})\n}\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to Pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum        // error: this step might not hold\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n现在我们得到两个错误!\n\n为了解释发生了什么，让我多说一点关于:|以及它的不同寻常之处。\n\n\n# Let such that\n\nDafny中的let-such-that结构有这样一种形式\n\nvar x :| P; E\n\n\n1\n\n\n它的计算结果是E，其中x被绑定到某个满足P的值。例如,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\n计算结果为“14”、“16”或“18”。作为程序员，你无法控制选择x的哪个值。但你会知道两件重要的事。一是x将被选为满足P的值。(如果Dafny验证器不能证明这样的值存在，则会给出一个错误。)另一种方法是，每次使用相同的输入对表达式求值时，都将得到相同的值。换句话说，这个算子是确定性的。\n\n下面是另一个关于决定论的例子:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\n这个表达式选择x为最小的三个素数之一(2、3或5)，然后返回它。您不知道您得到的是这三个值中的哪一个，但您可以保证每次在程序的一次运行中计算这个表达式时，您将得到相同的值。\n\n让我们更准确地理解我所说的“这个表达”。在Dafny中，let-such-that表达式的每一个“文本出现”都可以做出自己的选择。考虑这个问题的一种方法是遍历程序的文本，并用唯一的颜色为每个:|操作符着色。然后，你可以依赖于相同的选项，只有当它们由相同颜色的:|执行时。\n\n这里有一个说明性的例子。\n\nlemma Choices(s: set<int>)\n  requires s != {}\n{\n  var a := Pick(s);\n  var b := Pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n赋给a和b的第一个值来自相同的:|操作符。它们是相同颜色选择的结果。因此，它们被认为是相同的。相反，赋给a和b的下一个值来自不同的:|操作符——不同颜色的操作符。因此，您不能确定‘a’和‘b’是相等的。\n\n实际上，如果你多想一点(或者少想一点)，你就会意识到，我们知道赋给a和b的第一个值是相等的，即使不知道Pick的任何内容。毕竟，Pick是一个函数，如果你对相同的参数调用一个函数两次，它会返回相同的值。数学保证了这一点，Dafny也是如此。那么，对a和b的第二个赋值呢;那些表达式中的:|操作符不也是函数吗?是的，它们是，但它们是不同的功能。它们是不同颜色的函数，以此类推。只要你把程序中出现的每一个:|看作是一个不同的函数，那么所有的数学运算就会如你所期望的那样。\n\n这就是为什么我可以更容易地描述“Sum”的情况，如果我可以使用一个“😐”。为了重用相同的:|，我把它放在一个函数中，我命名为Pick。我建议你做同样的事情如果你在处理涉及到你想要证明属性的选择的幽灵函数。\n\n\n# 多种选择\n\n在理解这些问题之前，如果你试图定义“Sum”并在“AddElement”中使用它，你会感到困惑。现在，您知道单独将:|放入函数中更容易，并且您知道您需要编写一个类似SumMyWay的引理。您可能会好奇，如果没有Pick函数，是否可以做到这一点。也就是说，你可能想知道是否有任何方法可以在Sum中使用一个:|操作符，在SumMyWay中使用另一个:|操作符。是的，这是可能的。我来教你怎么做。\n\n假设我们在函数Sum中内联Pick。也就是说，假设我们像上面4节那样定义“Sum”。在那一节中，我提到，如果你也内联Pick在SumMyWay，你会得到一些错误。这两个错误都是因为“Sum”和“SumMyWay”做出了不同的选择。但我们可以在引理中更具体一些，强制它选择与Sum中选择的元素相同的元素。\n\n你可以这样做，你想让x不只是在s中，而是一个值\n\nSum(s) == x + Sum(s - {x})\n\n\n1\n\n\n没错。只有一个这样的x存在，它是由“Sum”选择的。所以，如果你这样写引理:\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s && Sum(s) == x + Sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n然后验证!知道这一点很好，但是在你的:|周围引入Pick函数似乎更干净。\n\n\n# 总结\n\n注意，程序中出现的每一个:|文本都是一个不同的函数。如果你将它整合到一个你命名的函数中，你将更容易使用:|，因为这样你就减少了因为不同种类(不同“颜色”)的选择而感到困惑的机会。\n\n另外，请注意:|所做的选择可能不是您需要的选择。你可能想要证明一个引理，它说任何选择最后都会得到相同的结果。使用上面的“SumMyWay”引理作为你的证明模板。",normalizedContent:"# 集合元素上的函数\n\n> k. rustan m. leino manuscript krml 274, 16 february 2020\n\n摘要 在自然语言中，像“一组数字的和”这样的短语很容易说和理解。在正式设置中定义和使用这些函数需要更多的工作。这个问题与递归定义的函数如何从集合中选取下一个元素有关。本文描述了一个具有代表性的例子，并描述了如何使正式的繁文缛节发挥作用。该解可应用于集合上的任何交换运算和结合运算。\n\n\n# 对集合的元素求和\n\n假设我们有一个函数，它返回集合中所有整数的和:\n\nfunction sum(s: set<int>): int\n\n\n1\n\n\n如果我们把一个元素y加到一个集合中，我们期望它的和增加y。也就是说，我们希望正确实现以下方法:\n\nmethod addelement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == sum(s) && y !in s\n  ensures t == s + {x} && b == sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事实证明，证明不是自动的。让我们看看细节并填写证明。\n\n\n# 求和的递归定义\n\n函数“sum”是递归定义的。空集合的和为0。如果集合非空，选择其中一个元素，比如x。然后，在递归计算的剩余元素的和上加上x。\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := pick(s);\n    x + sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个定义使用了一个函数pick，它返回给定集合中的任意元素。以下是它的定义:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\n我待会再讲pick。此时您需要了解的是，pick的调用者无法控制返回s中的哪个元素。\n\n\n# 不合格证明\n\n为了证明addelement，我们需要证明b == sum(t)在它的最终状态是成立的。回顾作业，这意味着我们需要展示\n\na + y == sum(s + {y})\n\n\n1\n\n\n在初始状态。由于a是sum(s)，我们的证明义务可以归结为\n\nsum(s) + y == sum(s + {y})\n\n\n1\n\n\n我们已知y不在s中。\n\n假设pick(s + {y})返回y。然后,我们有\n\n  sum(s + {y});\n==  // def. sum\n  var x := pick(s + {y}); x + sum(s + {y} - {x});\n==  // using the assumption pick(s + {y}) == y\n  y + sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这很简单也很直接。但对于这个证明，我们假设对pick的相关调用返回了y。如果pick返回与s不同的元素怎么办?\n\n\n# 选择其他东西\n\n在你意识到“挑选”可以选择一个不同于你所想的元素之前，乌云开始散去。我们需要的是一个引理，它表明选择是无关紧要的。也就是说，引理会让我们把“sum”看作是，在做递归调用时，我们指定的一个元素。\n\n这就是那个引理。这个证明一开始也有点棘手。归根到底就是让“pick”选择它所选择的任何元素，然后对“sum”递归的更小的集合应用归纳假设。\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x := pick(s);\n  if y == x {\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我说这个引理看起来像sum的表达式，所以sum的两个参数是s和s - {y}。或者，我们可以用s + {y}和s来调用sum来声明该属性。这个选择是上述引理的一个简单推论:\n\nlemma addtosum(s: set<int>, y: int)\n  requires y !in s\n  ensures sum(s + {y}) == sum(s) + y\n{\n  summyway(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用引理\n\n有了这个有用的引理，就很容易得到“addelement”的证明:将其主体更改为\n\nt := s + {y};\nb := a + y;\naddtosum(s, y);\n\n\n1\n2\n3\n\n\n\n# 内联选择\n\n在上面的开发中，我将‘pick’定义为一个单独的函数。阅读程序文本中的单词“pick”可能有助于理解“sum”和“summyway”做什么。但它是一个如此小的函数，所以为什么不直接在使用它的两个地方内联它呢。让我们试一试:\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to pick\n    x + sum(s - {x})\n}\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum        // error: this step might not hold\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n现在我们得到两个错误!\n\n为了解释发生了什么，让我多说一点关于:|以及它的不同寻常之处。\n\n\n# let such that\n\ndafny中的let-such-that结构有这样一种形式\n\nvar x :| p; e\n\n\n1\n\n\n它的计算结果是e，其中x被绑定到某个满足p的值。例如,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\n计算结果为“14”、“16”或“18”。作为程序员，你无法控制选择x的哪个值。但你会知道两件重要的事。一是x将被选为满足p的值。(如果dafny验证器不能证明这样的值存在，则会给出一个错误。)另一种方法是，每次使用相同的输入对表达式求值时，都将得到相同的值。换句话说，这个算子是确定性的。\n\n下面是另一个关于决定论的例子:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\n这个表达式选择x为最小的三个素数之一(2、3或5)，然后返回它。您不知道您得到的是这三个值中的哪一个，但您可以保证每次在程序的一次运行中计算这个表达式时，您将得到相同的值。\n\n让我们更准确地理解我所说的“这个表达”。在dafny中，let-such-that表达式的每一个“文本出现”都可以做出自己的选择。考虑这个问题的一种方法是遍历程序的文本，并用唯一的颜色为每个:|操作符着色。然后，你可以依赖于相同的选项，只有当它们由相同颜色的:|执行时。\n\n这里有一个说明性的例子。\n\nlemma choices(s: set<int>)\n  requires s != {}\n{\n  var a := pick(s);\n  var b := pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n赋给a和b的第一个值来自相同的:|操作符。它们是相同颜色选择的结果。因此，它们被认为是相同的。相反，赋给a和b的下一个值来自不同的:|操作符——不同颜色的操作符。因此，您不能确定‘a’和‘b’是相等的。\n\n实际上，如果你多想一点(或者少想一点)，你就会意识到，我们知道赋给a和b的第一个值是相等的，即使不知道pick的任何内容。毕竟，pick是一个函数，如果你对相同的参数调用一个函数两次，它会返回相同的值。数学保证了这一点，dafny也是如此。那么，对a和b的第二个赋值呢;那些表达式中的:|操作符不也是函数吗?是的，它们是，但它们是不同的功能。它们是不同颜色的函数，以此类推。只要你把程序中出现的每一个:|看作是一个不同的函数，那么所有的数学运算就会如你所期望的那样。\n\n这就是为什么我可以更容易地描述“sum”的情况，如果我可以使用一个“😐”。为了重用相同的:|，我把它放在一个函数中，我命名为pick。我建议你做同样的事情如果你在处理涉及到你想要证明属性的选择的幽灵函数。\n\n\n# 多种选择\n\n在理解这些问题之前，如果你试图定义“sum”并在“addelement”中使用它，你会感到困惑。现在，您知道单独将:|放入函数中更容易，并且您知道您需要编写一个类似summyway的引理。您可能会好奇，如果没有pick函数，是否可以做到这一点。也就是说，你可能想知道是否有任何方法可以在sum中使用一个:|操作符，在summyway中使用另一个:|操作符。是的，这是可能的。我来教你怎么做。\n\n假设我们在函数sum中内联pick。也就是说，假设我们像上面4节那样定义“sum”。在那一节中，我提到，如果你也内联pick在summyway，你会得到一些错误。这两个错误都是因为“sum”和“summyway”做出了不同的选择。但我们可以在引理中更具体一些，强制它选择与sum中选择的元素相同的元素。\n\n你可以这样做，你想让x不只是在s中，而是一个值\n\nsum(s) == x + sum(s - {x})\n\n\n1\n\n\n没错。只有一个这样的x存在，它是由“sum”选择的。所以，如果你这样写引理:\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s && sum(s) == x + sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n然后验证!知道这一点很好，但是在你的:|周围引入pick函数似乎更干净。\n\n\n# 总结\n\n注意，程序中出现的每一个:|文本都是一个不同的函数。如果你将它整合到一个你命名的函数中，你将更容易使用:|，因为这样你就减少了因为不同种类(不同“颜色”)的选择而感到困惑的机会。\n\n另外，请注意:|所做的选择可能不是您需要的选择。你可能想要证明一个引理，它说任何选择最后都会得到相同的结果。使用上面的“summyway”引理作为你的证明模板。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"在集合上迭代",frontmatter:{title:"在集合上迭代",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/be298d/",categories:["资源","Dafny实践探索"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/7.%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%8A%E8%BF%AD%E4%BB%A3.html",relativePath:"40.资源/00.实践探索/7.在集合上迭代.md",key:"v-5ca082b2",path:"/pages/be298d/",headers:[{level:2,title:"0. 映射到序列",slug:"_0-映射到序列",normalizedTitle:"0. 映射到序列",charIndex:282},{level:2,title:"1. 虚函数",slug:"_1-虚函数",normalizedTitle:"1. 虚函数",charIndex:1147},{level:2,title:"2. 编译函数",slug:"_2-编译函数",normalizedTitle:"2. 编译函数",charIndex:1500},{level:2,title:"3. 选择最小的整数",slug:"_3-选择最小的整数",normalizedTitle:"3. 选择最小的整数",charIndex:1838},{level:2,title:"4. 证明存在最小值",slug:"_4-证明存在最小值",normalizedTitle:"4. 证明存在最小值",charIndex:2644},{level:2,title:"5. 总命令",slug:"_5-总命令",normalizedTitle:"5. 总命令",charIndex:3799},{level:2,title:"6. 通用集合为序列",slug:"_6-通用集合为序列",normalizedTitle:"6. 通用集合为序列",charIndex:4753},{level:2,title:"7. 总命令有最小值",slug:"_7-总命令有最小值",normalizedTitle:"7. 总命令有最小值",charIndex:5440},{level:2,title:"8. 返回映射到序列",slug:"_8-返回映射到序列",normalizedTitle:"8. 返回映射到序列",charIndex:7315},{level:2,title:"9. 结论",slug:"_9-结论",normalizedTitle:"9. 结论",charIndex:7812},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:7855}],headersStr:"0. 映射到序列 1. 虚函数 2. 编译函数 3. 选择最小的整数 4. 证明存在最小值 5. 总命令 6. 通用集合为序列 7. 总命令有最小值 8. 返回映射到序列 9. 结论 参考文献",content:"# 在集合上迭代\n\n> K. Rustan M. Leino Manuscript KRML 275, 17 February 2020\n\n摘要 以确定的方式处理集合或映射的内容需要一些工作。通过一个典型的例子，本文说明了一种方法。\n\n数学集合类型包括集合、多集、序列和映射。这些对于规范和程序都是必不可少的。在这样的集合的元素上定义函数比人们想象的要困难(或者至少需要更多的劳动)。在本文中，我开发了一个将映射转换为成对序列的示例的程序和证明。该工作的核心部分涉及获得一个可编译函数，该函数以可预测的顺序返回集合的元素。\n\n本文的目标是生成可编译函数。\n\n\n# 0. 映射到序列\n\n映射是键值对的集合，其中没有键重复。我们可以将一个map转换为一个序列，方法是将它的键放入一个序列中，然后通过获取每个键的值来生成对:\n\nfunction method MapToSequence<A,B>(m: map<A,B>): seq<(A,B)> {\n  var keys := SetToSequence(m.Keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于map m，表达式m。“Keys”表示一组钥匙。函数 MapToSequence 将这组键传递给 SetToSequence `以获得这些键的序列。然后，序列构造函数\n\nseq(n, f)\n\n\n1\n\n\n生成一个长度为n的序列，其中索引i的元素被指定为f(i)。在MapToSequence中，序列推导式的第二个参数是由lambda表达式给出的部分函数\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\n对于给定范围内的索引，该函数返回由键keys[i]和对应的值m组成的对。必须在函数的前提条件中给出i的范围，否则表达式keys[i]将导致下标错误。\n\n为了避免表达式m[keys[i]]中的key-is-not-in-map错误，我们需要知道keys[i]是m的一个键。这需要我们知道他们之间的联系。key 和 Keys ，这是在(尚未实现)函数 SetToSequence `的后置条件中声明的。\n\n我们现在需要实现SetToSequence。\n\n\n# 1. 虚函数\n\n让我们从简单的开始。我们将SetToSequence定义为一个虚函数。定义是递归的。当给定的集合非空时，该函数使用choose操作符，也就是let-such-that操作符，并写入:|，从集合中选取一个元素。\n\nfunction SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那不算太坏\n\n\n# 2. 编译函数\n\n为了使我们上面写的SetToSequence可编译，我们将关键字function更改为关键字短语function method。这将生成一个错误消息:\n\n如果要使>可编译，则let-such-that表达式的值必须唯一确定\n\n在Dafny中，表达式和函数(其主体是表达式)必须是确定性的。这意味着\n\nvar x :| x in s;\n\n\n1\n\n\n当给定相同的s时，总是需要为x取相同的值。这将在运行时进行计算，因此Dafny将这个负担交给了程序员(参见[0])。\n\n一种方法是强化条件x in s，让它总是从s中选取最小值。这将唯一地确定let-such-that表达式的值。但是“最小值”是什么意思呢?我们从已知最小值的整数开始，然后求一般情况。\n\n\n# 3. 选择最小的整数\n\n现在，我们只关注整数集。这让我们加强了let-such-that表达式中的条件，从而唯一地讨论集合中的最小元素:\n\nfunction method SetToSequence(s: set<int>): seq<int>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n“唯一确定的”需求现在得到了满足。然而，由于我们新的such-that谓词更加复杂，验证器提出了一个不同的抱怨:\n\n> 不能建立满足该谓词的LHS值的存在性\n\n对我们来说，一个非空集合有一个最小元素似乎很清楚，但我们需要说服验证者。让我们用一个单独的引理来做这个，我们声明如下:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\n我们将在SetToSequence中的let-such表达式之前插入对这个引理的调用。这样，函数体就变成了\n\nif s == {} then [] else\n  ThereIsAMinimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + SetToSequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4. 证明存在最小值\n\n我们的下一个任务是证明“存在最小”引理。下面是一个注释证明:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // The minimum in s might be x, or it might be the minimum\n    // in s - {x}. If we knew the minimum of the latter, then\n    // we could compare the two.\n    // Let`s start by giving a name to the smaller set:\n    var s` := s - {x};\n    // So, s is the union of s` and {x}:\n    assert s == s` + {x};\n    // The following lemma call establishes that there is a\n    // minimum in s`.\n    ThereIsAMinimum(s`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n证明从从s中选取任意元素x开始。如果它是s中唯一的元素，它就是最小值。否则，这个证明引出了s是s + {x} `的事实。对引理的递归调用，通过它的后置条件，告诉我们在s中存在一个最小元素。验证器会自动提供剩余的验证胶，这样我们就完成了。\n\n证明中的断言可能看起来很愚蠢。我们只是定义s为s - {x}。因为x在s中，所以属性s == s + {x} 紧跟其后。是的,确实。验证者可以很容易地确认这一点，但验证者没有足够的创造力来意识到这是一个值得了解的好属性。这是处理集合时的典型情况。例如，如果你正在处理一个序列 q ，你可以单独考虑 q[0] ，并对 q[1..] `进行递归调用。如果是这样，您可能需要手动供应\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\n与set属性一样，验证器很容易证明这个属性，但它自己不会想到它。\n\n这个证明的寓意是，当你将一个集合分割成更小的块，你想要分别进行推理时，断言整个集合等于更小块的组合是一个好主意。\n\n\n# 5. 总命令\n\n上面对整数集的限制很好用，因为整数集的最小值很容易定义，并且给出唯一的元素。要对其他类型应用相同的技巧，我们还需要能够为这些类型定义一个“最小值”。为了定义最小值，你需要一个“总顺序”。让我们回顾一下这是什么意思。\n\n类型A上的关系是一个函数(A, A) -> bool。当满足以下三个条件时，这种关系称为“R”，称为“偏序”:\n\n * R是自反的，也就是说， forall a:: R(a, a) -“R”是反对称的，即 forall a, b:: R(a, b) && R(b, a) ==> a == b -“R”是可传递的，即 的原则,a, b, c:: R (a, b) & & (b, c) = = > R (a, c) `\n\nA total order是另外满足以下条件的部分order:\n\n-“R”是连接(紧密连接)，即: forall a, b:: R(a, b) || R(b, a)\n\n请注意，连接意味着自反性。\n\n下面是一个谓词，它表示一个给定的关系是否是一个完整的顺序:\n\npredicate IsTotalOrder<A(!new)>(R: (A, A) -> bool) {\n  // connexity\n  && (forall a, b :: R(a, b) || R(b, a))\n  // antisymmetry\n  && (forall a, b :: R(a, b) && R(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nDafny不允许我们在谓词中写这些量词，除非它对类型“a”有更多的了解。如果A是一个类类型，那么在Dafny中的forall意味着量化类A的分配实例。这意味着分配另一个“A”实例可能会导致“IsTotalOrder(R)”更改值。为了防止这种情况的发生，Dafny坚持认为，无限制的量化，如“IsTotalOrder”中的那些，应该在不依赖于分配状态的类型上。我们用类型特征 (!new)来表示，它被写成类型参数声明中类型名的后缀。\n\n\n# 6. 通用集合为序列\n\n我们修改了SetToSequence，也取了一个关系R，我们要求它是一个完整的顺序。在此过程中，我们将整数的总顺序<=更改为R，并将R作为参数添加到thereisminimum引理中:\n\nfunction method SetToSequence<A(!new)>(s: set<A>, R: (A, A) -> bool): seq<A>\n  requires IsTotalOrder(R)\n  ensures var q := SetToSequence(s, R);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    ThereIsAMinimum(s, R);\n    var x :| x in s && forall y :: y in s ==> R(x, y);\n    [x] + SetToSequence(s - {x}, R)\n}\n\nlemma ThereIsAMinimum<A(!new)>(s: set<A>, R: (A, A) -> bool)\n  requires s != {} && IsTotalOrder(R)\n  ensures exists x :: x in s && forall y :: y in s ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n修改后的“SetToSequence”引理进行验证。我们剩下的任务是证明这个引理。\n\n\n# 7. 总命令有最小值\n\n我们开始证明泛型的thereisminimum，类似于上面对整数集的证明:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以前“显而易见”的情况这次却给验证者带来了麻烦。让我们帮助它。我们的证明义务是证明s中的某个元素和s中的任何一个元素一样小。如果s是单集{x}，那么我们要寻找的元素只能是x。现在，如果y是s中的元素，我们需要证明R(x, y)因为s是一个单例，所以我们有y == x，然后R(x, y)紧跟着连通性。验证者丢失了这两个事实中的一个。让我们对第一个事实添加一个断言:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\n啊，是的，验证者可以证明这个断言，然后可以进行剩下的证明。\n\n再来看看非单例情况。我们将像上面的整数集证明一样开始:\n\n  } else {\n    var s` := s - {x};\n    assert s == s` + {x};\n    ThereIsAMinimum(s`, R);\n\n\n1\n2\n3\n4\n\n\n验证者抱怨引理的后置条件可能不成立，所以我们将给验证者更多的帮助。\n\n对引理的递归调用(顺便说一下，这个引理被称为“归纳假说”)表明，在s中存在一个最小值。让我们给它一个名字，我们通过引入一个局部变量来约束它的值，以满足引理的后置条件存在量词中的条件:\n\n    var z :| z in s` && forall y :: y in s` ==> R(z, y);\n\n\n1\n\n\n因为s是s + {x} ，所以我们要寻找的最小值要么是 z ，要么是 x `。让我们分别对待这些情况。我们用“if”语句来实现这一点。由于这两种情况是如此对称，我认为使用Dafny的if-case语句看起来很好:\n\n    // by connexity, one of the two cases below applies\n    if\n    case R(z, x) =>\n      // prove z is the minimum not just of s`, but of s\n      // ...\n    case R(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们先来看R(z, x)的情况。最难的部分可能是后置条件中的量词，所以让我们从它开始。要证明一个全称量词，可以使用“forall”语句。\n\n      forall y | y in s\n        ensures R(z, y)\n      {\n\n\n1\n2\n3\n\n\n从y in s，我们知道要么y是x要么y是s。对于前者，证明是基于守卫的R(z, x)。对于后者，证明来自于我们用来引入“z”的这种条件下的量化。不知何故，验证者没有注意到这一点，所以让我们帮助它。我们从这里开始:\n\n        assert x == y || y in s`;\n      }\n\n\n1\n2\n\n\n你瞧!这就是验证者所需要的。\n\n在R(x, z)的情况下，我们将给出类似的forall命题来证明引理的后置条件中的量词:\n\n      forall y | y in s\n        ensures R(x, y)\n      {\n\n\n1\n2\n3\n\n\n如果y是x，则R(x, y)紧跟在连通性后面。另一方面，如果y在s中，那么引入z的那个条件告诉我们R(z, y)所以我们通过传递性得到R(x, y)你可以用不同的方式添加这些提示，使证明更加有效。这里有一种方法:\n\n        assert y in s` ==> R(z, y);\n      }\n\n\n1\n2\n\n\n最后一个评论。当我们证明整数集的最小值时，我认为包含这样的断言通常是有用的:\n\n    assert s == s` + {x};\n\n\n1\n\n\n我也把它包含在通用的“thereisminimum”中。但事实证明，它实际上并不需要(因为我们在两种情况下提供的额外提示中弥补了它)，所以如果你愿意，你可以删除它。\n\n\n# 8. 返回映射到序列\n\n我们做到了!\n\n在我们宣布成功之前，让我们确保我们能使用我们的函数和引理来写MapToSequence函数，我们要写的函数。下面是通用版本，它需要一个给定的总顺序:\n\nfunction method MapToSequence<A(!new),B>(m: map<A,B>, R: (A, A) -> bool): seq<(A,B)>\n  requires IsTotalOrder(R)\n{\n  var keys := SetToSequence(m.Keys, (a,a`) => R(a, a`));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们也可以将它专门化为整数集:\n\nfunction method IntMapToSequence<B>(m: map<int,B>): seq<(int,B)> {\n  MapToSequence(m, (a, a`) => a <= a`)\n}\n\n\n1\n2\n3\n\n\n我们做到了\n\n\n# 9. 结论\n\n我希望这段漫长的旅程向您展示了在Dafny处理藏品的一两件事。\n\n\n# 参考文献\n\n[0]K. Rustan M. Leino. Compiling Hilbert`s epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations, volume 35 of EPiC Series in Computing, pages 106–118. EasyChair, 2015. 🔎",normalizedContent:"# 在集合上迭代\n\n> k. rustan m. leino manuscript krml 275, 17 february 2020\n\n摘要 以确定的方式处理集合或映射的内容需要一些工作。通过一个典型的例子，本文说明了一种方法。\n\n数学集合类型包括集合、多集、序列和映射。这些对于规范和程序都是必不可少的。在这样的集合的元素上定义函数比人们想象的要困难(或者至少需要更多的劳动)。在本文中，我开发了一个将映射转换为成对序列的示例的程序和证明。该工作的核心部分涉及获得一个可编译函数，该函数以可预测的顺序返回集合的元素。\n\n本文的目标是生成可编译函数。\n\n\n# 0. 映射到序列\n\n映射是键值对的集合，其中没有键重复。我们可以将一个map转换为一个序列，方法是将它的键放入一个序列中，然后通过获取每个键的值来生成对:\n\nfunction method maptosequence<a,b>(m: map<a,b>): seq<(a,b)> {\n  var keys := settosequence(m.keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于map m，表达式m。“keys”表示一组钥匙。函数 maptosequence 将这组键传递给 settosequence `以获得这些键的序列。然后，序列构造函数\n\nseq(n, f)\n\n\n1\n\n\n生成一个长度为n的序列，其中索引i的元素被指定为f(i)。在maptosequence中，序列推导式的第二个参数是由lambda表达式给出的部分函数\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\n对于给定范围内的索引，该函数返回由键keys[i]和对应的值m组成的对。必须在函数的前提条件中给出i的范围，否则表达式keys[i]将导致下标错误。\n\n为了避免表达式m[keys[i]]中的key-is-not-in-map错误，我们需要知道keys[i]是m的一个键。这需要我们知道他们之间的联系。key 和 keys ，这是在(尚未实现)函数 settosequence `的后置条件中声明的。\n\n我们现在需要实现settosequence。\n\n\n# 1. 虚函数\n\n让我们从简单的开始。我们将settosequence定义为一个虚函数。定义是递归的。当给定的集合非空时，该函数使用choose操作符，也就是let-such-that操作符，并写入:|，从集合中选取一个元素。\n\nfunction settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n那不算太坏\n\n\n# 2. 编译函数\n\n为了使我们上面写的settosequence可编译，我们将关键字function更改为关键字短语function method。这将生成一个错误消息:\n\n如果要使>可编译，则let-such-that表达式的值必须唯一确定\n\n在dafny中，表达式和函数(其主体是表达式)必须是确定性的。这意味着\n\nvar x :| x in s;\n\n\n1\n\n\n当给定相同的s时，总是需要为x取相同的值。这将在运行时进行计算，因此dafny将这个负担交给了程序员(参见[0])。\n\n一种方法是强化条件x in s，让它总是从s中选取最小值。这将唯一地确定let-such-that表达式的值。但是“最小值”是什么意思呢?我们从已知最小值的整数开始，然后求一般情况。\n\n\n# 3. 选择最小的整数\n\n现在，我们只关注整数集。这让我们加强了let-such-that表达式中的条件，从而唯一地讨论集合中的最小元素:\n\nfunction method settosequence(s: set<int>): seq<int>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n“唯一确定的”需求现在得到了满足。然而，由于我们新的such-that谓词更加复杂，验证器提出了一个不同的抱怨:\n\n> 不能建立满足该谓词的lhs值的存在性\n\n对我们来说，一个非空集合有一个最小元素似乎很清楚，但我们需要说服验证者。让我们用一个单独的引理来做这个，我们声明如下:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\n我们将在settosequence中的let-such表达式之前插入对这个引理的调用。这样，函数体就变成了\n\nif s == {} then [] else\n  thereisaminimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + settosequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4. 证明存在最小值\n\n我们的下一个任务是证明“存在最小”引理。下面是一个注释证明:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // the minimum in s might be x, or it might be the minimum\n    // in s - {x}. if we knew the minimum of the latter, then\n    // we could compare the two.\n    // let`s start by giving a name to the smaller set:\n    var s` := s - {x};\n    // so, s is the union of s` and {x}:\n    assert s == s` + {x};\n    // the following lemma call establishes that there is a\n    // minimum in s`.\n    thereisaminimum(s`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n证明从从s中选取任意元素x开始。如果它是s中唯一的元素，它就是最小值。否则，这个证明引出了s是s + {x} `的事实。对引理的递归调用，通过它的后置条件，告诉我们在s中存在一个最小元素。验证器会自动提供剩余的验证胶，这样我们就完成了。\n\n证明中的断言可能看起来很愚蠢。我们只是定义s为s - {x}。因为x在s中，所以属性s == s + {x} 紧跟其后。是的,确实。验证者可以很容易地确认这一点，但验证者没有足够的创造力来意识到这是一个值得了解的好属性。这是处理集合时的典型情况。例如，如果你正在处理一个序列 q ，你可以单独考虑 q[0] ，并对 q[1..] `进行递归调用。如果是这样，您可能需要手动供应\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\n与set属性一样，验证器很容易证明这个属性，但它自己不会想到它。\n\n这个证明的寓意是，当你将一个集合分割成更小的块，你想要分别进行推理时，断言整个集合等于更小块的组合是一个好主意。\n\n\n# 5. 总命令\n\n上面对整数集的限制很好用，因为整数集的最小值很容易定义，并且给出唯一的元素。要对其他类型应用相同的技巧，我们还需要能够为这些类型定义一个“最小值”。为了定义最小值，你需要一个“总顺序”。让我们回顾一下这是什么意思。\n\n类型a上的关系是一个函数(a, a) -> bool。当满足以下三个条件时，这种关系称为“r”，称为“偏序”:\n\n * r是自反的，也就是说， forall a:: r(a, a) -“r”是反对称的，即 forall a, b:: r(a, b) && r(b, a) ==> a == b -“r”是可传递的，即 的原则,a, b, c:: r (a, b) & & (b, c) = = > r (a, c) `\n\na total order是另外满足以下条件的部分order:\n\n-“r”是连接(紧密连接)，即: forall a, b:: r(a, b) || r(b, a)\n\n请注意，连接意味着自反性。\n\n下面是一个谓词，它表示一个给定的关系是否是一个完整的顺序:\n\npredicate istotalorder<a(!new)>(r: (a, a) -> bool) {\n  // connexity\n  && (forall a, b :: r(a, b) || r(b, a))\n  // antisymmetry\n  && (forall a, b :: r(a, b) && r(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ndafny不允许我们在谓词中写这些量词，除非它对类型“a”有更多的了解。如果a是一个类类型，那么在dafny中的forall意味着量化类a的分配实例。这意味着分配另一个“a”实例可能会导致“istotalorder(r)”更改值。为了防止这种情况的发生，dafny坚持认为，无限制的量化，如“istotalorder”中的那些，应该在不依赖于分配状态的类型上。我们用类型特征 (!new)来表示，它被写成类型参数声明中类型名的后缀。\n\n\n# 6. 通用集合为序列\n\n我们修改了settosequence，也取了一个关系r，我们要求它是一个完整的顺序。在此过程中，我们将整数的总顺序<=更改为r，并将r作为参数添加到thereisminimum引理中:\n\nfunction method settosequence<a(!new)>(s: set<a>, r: (a, a) -> bool): seq<a>\n  requires istotalorder(r)\n  ensures var q := settosequence(s, r);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    thereisaminimum(s, r);\n    var x :| x in s && forall y :: y in s ==> r(x, y);\n    [x] + settosequence(s - {x}, r)\n}\n\nlemma thereisaminimum<a(!new)>(s: set<a>, r: (a, a) -> bool)\n  requires s != {} && istotalorder(r)\n  ensures exists x :: x in s && forall y :: y in s ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n修改后的“settosequence”引理进行验证。我们剩下的任务是证明这个引理。\n\n\n# 7. 总命令有最小值\n\n我们开始证明泛型的thereisminimum，类似于上面对整数集的证明:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以前“显而易见”的情况这次却给验证者带来了麻烦。让我们帮助它。我们的证明义务是证明s中的某个元素和s中的任何一个元素一样小。如果s是单集{x}，那么我们要寻找的元素只能是x。现在，如果y是s中的元素，我们需要证明r(x, y)因为s是一个单例，所以我们有y == x，然后r(x, y)紧跟着连通性。验证者丢失了这两个事实中的一个。让我们对第一个事实添加一个断言:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\n啊，是的，验证者可以证明这个断言，然后可以进行剩下的证明。\n\n再来看看非单例情况。我们将像上面的整数集证明一样开始:\n\n  } else {\n    var s` := s - {x};\n    assert s == s` + {x};\n    thereisaminimum(s`, r);\n\n\n1\n2\n3\n4\n\n\n验证者抱怨引理的后置条件可能不成立，所以我们将给验证者更多的帮助。\n\n对引理的递归调用(顺便说一下，这个引理被称为“归纳假说”)表明，在s中存在一个最小值。让我们给它一个名字，我们通过引入一个局部变量来约束它的值，以满足引理的后置条件存在量词中的条件:\n\n    var z :| z in s` && forall y :: y in s` ==> r(z, y);\n\n\n1\n\n\n因为s是s + {x} ，所以我们要寻找的最小值要么是 z ，要么是 x `。让我们分别对待这些情况。我们用“if”语句来实现这一点。由于这两种情况是如此对称，我认为使用dafny的if-case语句看起来很好:\n\n    // by connexity, one of the two cases below applies\n    if\n    case r(z, x) =>\n      // prove z is the minimum not just of s`, but of s\n      // ...\n    case r(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们先来看r(z, x)的情况。最难的部分可能是后置条件中的量词，所以让我们从它开始。要证明一个全称量词，可以使用“forall”语句。\n\n      forall y | y in s\n        ensures r(z, y)\n      {\n\n\n1\n2\n3\n\n\n从y in s，我们知道要么y是x要么y是s。对于前者，证明是基于守卫的r(z, x)。对于后者，证明来自于我们用来引入“z”的这种条件下的量化。不知何故，验证者没有注意到这一点，所以让我们帮助它。我们从这里开始:\n\n        assert x == y || y in s`;\n      }\n\n\n1\n2\n\n\n你瞧!这就是验证者所需要的。\n\n在r(x, z)的情况下，我们将给出类似的forall命题来证明引理的后置条件中的量词:\n\n      forall y | y in s\n        ensures r(x, y)\n      {\n\n\n1\n2\n3\n\n\n如果y是x，则r(x, y)紧跟在连通性后面。另一方面，如果y在s中，那么引入z的那个条件告诉我们r(z, y)所以我们通过传递性得到r(x, y)你可以用不同的方式添加这些提示，使证明更加有效。这里有一种方法:\n\n        assert y in s` ==> r(z, y);\n      }\n\n\n1\n2\n\n\n最后一个评论。当我们证明整数集的最小值时，我认为包含这样的断言通常是有用的:\n\n    assert s == s` + {x};\n\n\n1\n\n\n我也把它包含在通用的“thereisminimum”中。但事实证明，它实际上并不需要(因为我们在两种情况下提供的额外提示中弥补了它)，所以如果你愿意，你可以删除它。\n\n\n# 8. 返回映射到序列\n\n我们做到了!\n\n在我们宣布成功之前，让我们确保我们能使用我们的函数和引理来写maptosequence函数，我们要写的函数。下面是通用版本，它需要一个给定的总顺序:\n\nfunction method maptosequence<a(!new),b>(m: map<a,b>, r: (a, a) -> bool): seq<(a,b)>\n  requires istotalorder(r)\n{\n  var keys := settosequence(m.keys, (a,a`) => r(a, a`));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们也可以将它专门化为整数集:\n\nfunction method intmaptosequence<b>(m: map<int,b>): seq<(int,b)> {\n  maptosequence(m, (a, a`) => a <= a`)\n}\n\n\n1\n2\n3\n\n\n我们做到了\n\n\n# 9. 结论\n\n我希望这段漫长的旅程向您展示了在dafny处理藏品的一两件事。\n\n\n# 参考文献\n\n[0]k. rustan m. leino. compiling hilbert`s epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning — short presentations, volume 35 of epic series in computing, pages 106–118. easychair, 2015. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Dafny type system",frontmatter:{title:"Dafny type system",date:"2022-03-26T16:59:26.000Z",permalink:"/pages/8065fd/",categories:["资源","常用工具"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/00.Dafny%20type%20system.html",relativePath:"40.资源/10.常用工具/00.Dafny type system.md",key:"v-3c7b36da",path:"/pages/8065fd/",headers:[{level:2,title:"0. 基本类型",slug:"_0-基本类型",normalizedTitle:"0. 基本类型",charIndex:100},{level:3,title:"0.0. Booleans",slug:"_0-0-booleans",normalizedTitle:"0.0. booleans",charIndex:472},{level:3,title:"0.1. 数字类型",slug:"_0-1-数字类型",normalizedTitle:"0.1. 数字类型",charIndex:117},{level:3,title:"0.2. 字符",slug:"_0-2-字符",normalizedTitle:"0.2. 字符",charIndex:127},{level:2,title:"1. 类型参数",slug:"_1-类型参数",normalizedTitle:"1. 类型参数",charIndex:135},{level:2,title:"2. 集合类型",slug:"_2-集合类型",normalizedTitle:"2. 集合类型",charIndex:143},{level:3,title:"2.0. 集合",slug:"_2-0-集合",normalizedTitle:"2.0. 集合",charIndex:151},{level:3,title:"2.1. Multisets",slug:"_2-1-multisets",normalizedTitle:"2.1. multisets",charIndex:6073},{level:3,title:"2.2. 序列",slug:"_2-2-序列",normalizedTitle:"2.2. 序列",charIndex:167},{level:4,title:"2.2.0. 字符串",slug:"_2-2-0-字符串",normalizedTitle:"2.2.0. 字符串",charIndex:175},{level:3,title:"2.3. 有限与无限图",slug:"_2-3-有限与无限图",normalizedTitle:"2.3. 有限与无限图",charIndex:186},{level:2,title:"3. 象征类型",slug:"_3-象征类型",normalizedTitle:"3. 象征类型",charIndex:198},{level:3,title:"3.0. 同义词类型",slug:"_3-0-同义词类型",normalizedTitle:"3.0. 同义词类型",charIndex:206},{level:3,title:"3.1. 不透明类型",slug:"_3-1-不透明类型",normalizedTitle:"3.1. 不透明类型",charIndex:217},{level:2,title:"4. 数据类型",slug:"_4-数据类型",normalizedTitle:"4. 数据类型",charIndex:228},{level:3,title:"4.0. 归纳类型",slug:"_4-0-归纳类型",normalizedTitle:"4.0. 归纳类型",charIndex:12033},{level:3,title:"4.1. 元组类型",slug:"_4-1-元组类型",normalizedTitle:"4.1. 元组类型",charIndex:248},{level:3,title:"4.2. 共同归纳类型",slug:"_4-2-共同归纳类型",normalizedTitle:"4.2. 共同归纳类型",charIndex:258},{level:2,title:"5. 参照类型",slug:"_5-参照类型",normalizedTitle:"5. 参照类型",charIndex:270},{level:3,title:"5.0. 类",slug:"_5-0-类",normalizedTitle:"5.0. 类",charIndex:278},{level:3,title:"5.1. 数组",slug:"_5-1-数组",normalizedTitle:"5.1. 数组",charIndex:285},{level:4,title:"5.1.0. 一维数组",slug:"_5-1-0-一维数组",normalizedTitle:"5.1.0. 一维数组",charIndex:293},{level:4,title:"5.1.1. 多维数组",slug:"_5-1-1-多维数组",normalizedTitle:"5.1.1. 多维数组",charIndex:305},{level:3,title:"5.2. 特征",slug:"_5-2-特征",normalizedTitle:"5.2. 特征",charIndex:317},{level:3,title:"5.3. 类型 object",slug:"_5-3-类型-object",normalizedTitle:"5.3. 类型 object",charIndex:325},{level:3,title:"5.4. 迭代器类型",slug:"_5-4-迭代器类型",normalizedTitle:"5.4. 迭代器类型",charIndex:340},{level:3,title:"5.5. 异步任务类型",slug:"_5-5-异步任务类型",normalizedTitle:"5.5. 异步任务类型",charIndex:351},{level:2,title:"6. 函数类型",slug:"_6-函数类型",normalizedTitle:"6. 函数类型",charIndex:363},{level:3,title:"6.0. Lambda表达式",slug:"_6-0-lambda表达式",normalizedTitle:"6.0. lambda表达式",charIndex:371},{level:2,title:"7. 新类型",slug:"_7-新类型",normalizedTitle:"7. 新类型",charIndex:386},{level:3,title:"7.0. 数字转换操作",slug:"_7-0-数字转换操作",normalizedTitle:"7.0. 数字转换操作",charIndex:26230},{level:2,title:"8. 子集类型",slug:"_8-子集类型",normalizedTitle:"8. 子集类型",charIndex:405},{level:4,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:27631}],headersStr:"0. 基本类型 0.0. Booleans 0.1. 数字类型 0.2. 字符 1. 类型参数 2. 集合类型 2.0. 集合 2.1. Multisets 2.2. 序列 2.2.0. 字符串 2.3. 有限与无限图 3. 象征类型 3.0. 同义词类型 3.1. 不透明类型 4. 数据类型 4.0. 归纳类型 4.1. 元组类型 4.2. 共同归纳类型 5. 参照类型 5.0. 类 5.1. 数组 5.1.0. 一维数组 5.1.1. 多维数组 5.2. 特征 5.3. 类型 object 5.4. 迭代器类型 5.5. 异步任务类型 6. 函数类型 6.0. Lambda表达式 7. 新类型 7.0. 数字转换操作 8. 子集类型 参考资料",content:"# Dafny Type System\n\nDafny语言参考的这一部分描述了Dafny编程语言中的类型。所描述的是Dafny版本1.9.3.20107中实现的内容，异步任务类型尚未进入主分支。\n\n> 0. 基本类型 0.0. 布尔值 0.1. 数字类型 0.2. 字符 1. 类型参数 2. 集合类型 2.0. 集合 2.1. 多集 2.2. 序列 2.2.0. 字符串 2.3. 有限与无限图 3. 象征类型 3.0. 同义词类型 3.1. 不透明类型 4. 数据类型 4.0. 归纳数据类型 4.1. 元组类型 4.2. 共同归纳类型 5. 参照类型 5.0. 类 5.1. 数组 5.1.0. 一维数组 5.1.1. 多维数组 5.2. 特征 5.3. 类型 object 5.4. 迭代器类型 5.5. 异步任务类型 6. 函数类型 6.0. Lambda表达式 7. 新类型 7.0. 数字转化操作 8. 子集类型\n\n\n# 0. 基本类型\n\nDafny提供了三种基本类型，bool表示布尔，int表示整数，real表示实数。\n\n\n# 0.0. Booleans\n\n有两个布尔值，每个值在语言中都有一个对应的文本：false和true。\n\n除了在所有类型上定义的相等（=）和disequality（！=），类型bool还支持以下操作：\n\n       \n操作符    描述\n       \n<==>   当且仅当\n       \n==>    蕴含\n<==    反向蕴含\n       \n&&     连接(且)\n||     析取(或)\n       \n!      否定(非)\n       \n\n否定是一元的；其他的是二进制的。该表显示了一组结合力不断增强的运算符，等式结合比合取和析取强，比否定弱。在每个组中，不同的运算符不关联，因此需要使用括号。例如,\n\nA && B || C    // error\n\n\n1\n\n\n将是不明确的，而必须写为\n\n(A && B) || C\n\n\n1\n\n\n或\n\nA && (B || C)\n\n\n1\n\n\n取决于预期的意思。\n\n表达式A<=>B和A==B给出了相同的值，但请注意，<=>是关联的，=是链接的。所以\n\nA <==> B <==> C\n\n\n1\n\n\n与下式相同\n\nA <==> (B <==> C)\n\n\n1\n\n\n和\n\n(A <==> B) <==> C\n\n\n1\n\n\n鉴于\n\nA == B == C\n\n\n1\n\n\n只是下式的速记\n\nA == B && B == C\n\n\n1\n\n\n合取是关联的，析取也是。这些运算符是短路（从左到右），这意味着只有在第一个操作数的计算不确定表达式的值时，才会计算它们的第二个参数。从逻辑上讲，表达式A&&B是在定义了A并且A的计算结果为false或B时定义的。定义A&&B时，其含义与普通的对称数学连词相同∧. | | |和∨.\n\n含义是“右关联”，从左到右短路。反向蕴涵B<==A与A==>B完全相同，但可以按相反的顺序写入操作数。因此，反向含义是“左关联”，是从“右”到“左”的短路。为了说明关联性规则，以下四行中的每一行都表示了相同的属性，即bool类型的任何A、B和C：\n\nA ==> B ==> C\nA ==> (B ==> C)  // parentheses redundant, since ==> is right associative\nC <== B <== A\n(C <== B) <== A  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\n为了说明短路规则，请注意，表达式a.Length仅在a不为null时才为数组a定义 (见 小节 5), 这意味着以下两个表达式格式正确：\n\na != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n\n\n1\n2\n\n\n这两种表达的反作用是：\n\na.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n\n\n1\n2\n\n\n但这些表达式的格式不好，因为格式好要求左（和右）操作数a.Length<0本身格式良好。\n\n蕴涵A==>B相当于析取！A | | B，但有时（尤其是在规范中）更清晰易读。由于||是从左向右短路，请注意\n\na == null || 0 <= a.Length\n\n\n1\n\n\n结构良好，而\n\n0 <= a.Length || a == null  // not well-formed\n\n\n1\n\n\n结构较差。\n\n此外，布尔语支持逻辑量词（forall和exists），在Dafny语言参考的另一部分中有描述。\n\n\n# 0.1. 数字类型\n\nDafny 支持两种 numeric 类型，integer-based，包括所有整数的基本类型 int，和 real-based，包括所有实数的基本类型 real。 用户定义的基于 int 和 real 的数字类型，称为 newtypes，在第 [7] 节(http://leino.science/papers/krml243.html#sec-newtypes) 中有描述。 此外，代表 int 的非负子范围的 subset type nat 在第 [8] 节（http://leino.science/papers/krml243.html#sec-subset-types）中进行了描述 . 该语言包含每个非负整数的文字，例如“0”、“13”和“1985”。 整数也可以使用前缀“0x”以十六进制书写，如“0x0”、“0xD”和“0x7c1”（始终使用小写“x”，但十六进制数字本身不区分大小写）。 允许使用前导零。 要形成负整数，请使用一元减号运算符。 一些非负实数也有文字。 这些被写成一个小数点，两边都有一个非空的十进制数字序列。 例如，“1.0”、“1609.344”和“0.5772156649”。 对于整数（十进制和十六进制形式）和实数，文字中的任何两位数字都可以用下划线分隔，以提高文字的可读性。 例如：\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 Ångström\n\n\n1\n2\n3\n4\n\n\n除了相等和不相等之外，数值类型还支持以下关系运算：\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\n就像相等和不相等一样，这些运算符是链接的，只要它们链接在“相同的方向”。 那就是说，\n\nA <= B < C == D <= E\n\n\n1\n\n\nis simply a shorthand for\n\nA <= B && B < C && C == D && D <= E\n\n\n1\n\n\n而\n\nA < B > C\n\n\n1\n\n\n不被允许。 每种数字类型也有运算符：\n\n      \n操作符   描述\n      \n+     加\n-     减\n      \n*     乘\n/     除\n%     取模\n      \n-     否定 (一元减)\n      \n\n二元运算符是左结合的，它们在两组中相互关联。 这些组按绑定能力增加的顺序列出，等式绑定比乘法运算符更强，比一元运算符弱。 仅基于整数的数值类型支持模数。 整数除法和模数是欧几里得除法和模数。 这意味着无论两个操作数的符号如何，模数始终返回非负数。 更准确地说，对于任何整数a和非零整数b，\n\na == a / b * b + a % b\n0 <= a % b < B\n\n\n1\n2\n\n\n其中“B”表示“b”的绝对值。 基于实数的数值类型有一个成员 Trunc，它返回实数值的 floor，即不超过实数值的最大整数。 例如，对于任何类型为“real”的“r”和“r”，以下属性成立：\n\n3.14.Trunc == 3\n(-2.5).Trunc == -3\n-2.5.Trunc == -2\nreal(r.Trunc) <= r\nr <= r' ==> r.Trunc <= r'.Trunc\n\n\n1\n2\n3\n4\n5\n\n\n请注意，在第三行中，成员访问（如 .Trunc）的绑定比一元减号更强。 第四行使用从 int 到 real 的转换函数 real，如第 [7.0] 节 (http://leino.science/papers/krml243.html#sec-numeric-conversions) 中所述\n\n\n# 0.2. 字符\n\nDafny 支持 characters 的 char 类型。 字符文字用单引号括起来，如 'D'。 要将单引号写成字符文字，必须使用转义序列。 转义序列也可用于写入其他字符。 支持的转义序列如下：\n\n           \n转义字符       含义\n           \n\\'         字符 '\n\\\"         字符 \"\n\\\\         字符 \\\n\\0         空字符，同 \\u0000\n\\n         换行\n\\r         回车\n\\t         水平制表\n\\u*xxxx*   十六进制编码通用字符 *xxxx*\n           \n\n双引号的转义序列是多余的，因为 '\"' 和 '\"' 表示相同的字符——提供这两种形式是为了支持与字符串文字相同的转义序列（第 [2.2.0] 节（http: //leino.science/papers/krml243.html#sec-string))。 在 \\u*xxxx* 形式中，u 总是小写，但四个十六进制数字不区分大小写。 字符值是有序的，可以使用标准关系运算符进行比较：\n\n      \n操作符   描述\n      \n<     少于\n<=    至多\n>=    至少\n>     大于\n      \n\n字符序列表示字符串，如第 2.2.0 节所述。(http://leino.science/papers/krml243.html#sec-string).\n\n\n# 1. 类型参数\n\nDafny 中的许多类型（以及函数和方法）都可以通过类型进行参数化。 这些类型参数通常在尖括号内声明，可以代表任何类型。 有时需要限制这些类型参数，以便它们只能由某些类型的系列实例化。 因此，Dafny 不仅在幽灵上下文中而且在编译上下文中区分支持相等操作的类型。 为了表明一个类型参数被限制为这种支持平等的类型，类型参数的名称采用后缀“(==)”。[0](http://leino.science/papers/krml243. html#fn-fn-type-mode) 例如，\n\nmethod Compare〈T(==)〉(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\n是一种方法，其类型参数仅限于支持相等的类型。 同样，请注意 all 类型在 ghost 上下文中支持相等； 区别仅适用于非幽灵（即编译）代码。 共归纳数据类型、函数类型以及带有幻像参数的归纳数据类型是不支持等式的类型的示例。 Dafny 有一些推理支持，可以使某些签名不那么混乱（在 Dafny 语言参考的不同部分中进行了描述）。 在某些情况下，这种支持会推断出必须将类型参数限制为支持相等的类型，在这种情况下，Dafny 会自动添加“(==)”。\n\n\n# 2. 集合类型\n\nDafny 提供了几种内置的集合类型。\n\n\n# 2.0. 集合\n\n对于任何类型 T，set〈T〉 类型的每个值都是 T 值的有限集合。 集合成员资格由类型 T 中的相等性确定，因此只有当T 支持相等性时，set〈T〉 才能在非幽灵上下文中使用。 可以使用 set display 表达式形成一个集合，该表达式可能是一个空的、无序的、不区分重复的表达式列表，用花括号括起来。 为了显示，\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\n是设置显示的三个示例。 还有一个 set comprehension 表达式（带有活页夹，就像在逻辑量化中一样），在 Dafny 语言参考的不同部分进行了描述。 除了相等和不相等之外，集合类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真子集\n<=    子集\n>=    超集\n>     真超集\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 集合支持以下二元运算符，按绑定能力递增的顺序列出：\n\n      \n操作符   描述\n      \n!!    不相交\n      \n+     设置联合\n-     设置差异\n      \n*     设置交点\n      \n\n+、- 和 * 的结合性规则类似于同名算术运算符的结合性规则。 表达式A !! B，它的约束力与相等性相同（但它既不与相等性联系也不连锁），说集合A和B没有共同的元素，也就是说，它等价于\n\nA * B == {}\n\n\n1\n\n\n但是，不相交运算符是链式的，所以 A !! B !! C !! D表示：\n\nA * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n\n\n1\n\n\n此外，对于任何set〈T〉类型的集合s和任何T类型的表达式e，集合支持以下操作：\n\n          \n表达式       描述\n          \n|s|       集合基数\ne in s    集合成员\ne !in s   集合非成员\n          \n\n表达式 e !in s 是 !(e in s) 的语法简写。\n\n\n# 2.1. Multisets\n\nmultiset 类似于集合，但跟踪每个元素的多重性，而不仅仅是它的存在或不存在。 对于任何类型 T，multiset〈T〉 类型的每个值都是从 T 值到表示每个元素的多重性的自然数的映射。 Dafny 中的多重集是有限的，也就是说，它们包含有限数量的每个有限元素。 换句话说，多重集仅将有限数量的元素映射到非零（有限）多重性。 与集合一样，多集成员资格由类型“T”中的相等性确定，因此只有当“T”支持相等时，“多集〈T〉”才能在非幽灵上下文中使用。 可以使用 multiset display 表达式来形成多重集，该表达式可能是一个空的、无序列的表达式列表，包含在关键字 multiset 后面的花括号中。 为了显示，\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\n是多组显示的三个示例。 没有多集理解表达式。 除了相等和不相等之外，多重集类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真多集子集\n<=    多集子集\n>=    多集超集\n>     真多集超集\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 多重集支持以下二元运算符，按绑定能力递增的顺序列出：\n\n      \n操作符   描述\n      \n!!    多集不相交\n      \n+     多集联合\n-     多集差异\n      \n*     多集交集\n      \n\n+、- 和 * 的结合性规则类似于同名算术运算符的结合性规则。 表达式'A !! B表示多重集A和B` 没有共同的元素，也就是说，它等价于\n\nA * B == multiset{}\n\n\n1\n\n\n与类似的集合运算符一样，!! 是链式的。 此外，对于任何类型为multiset〈T〉的多重集s、类型为T的表达式e和基于非负整数的数字n，多重集支持以下操作：\n\n            \n表达式         描述\n            \n|s|         多集基数\ne in s      多集成员\ne !in s     多集非成员\ns[e]        e 在 s 中的多样性\ns[e := n]   多集更新 (多样性变化)\n            \n\n当且仅当 s[e] != 0 时，表达式 e in s 才会返回 true。 表达式 e !in s 是 !(e in s) 的语法简写。 表达式 s[e := n] 表示类似于 s 的多重集，但元素 e 的多重性是 n。 请注意，多重集更新 s[e := 0] 会产生类似 s 的多重集，但不会出现任何 e（无论 s 首先是否出现过e）。 作为另一个示例，请注意 s - multiset{e} 等价于：\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2. 序列\n\n对于任何类型“T”，“seq〈T〉”类型的值表示“T”元素的序列，即从连续自然数的有限集合（称为indicies）到“T”的映射 `价值观。 （将其视为一个映射，因此序列是多重集的对偶。）可以使用 sequence display 表达式形成序列，该表达式可能是一个包含在方括号中的空的、有序的表达式列表。 为了阐释，\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\n是顺序显示的三个示例。 没有序列理解表达式。 除了相等和不相等之外，序列类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真前缀\n<=    前缀\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 注意没有>和>=。 序列支持以下二元运算符：\n\n      \n操作符   描述\n      \n+     连接\n      \n\n运算符 + 是关联的，就像同名的算术运算符一样。 此外，对于任何类型为“seq〈T〉”的序列“s”，类型为“T”的表达式“e”，基于整数的数字“i”满足“0 <= i < |s|”，以及整数- 基于数字 lo 和 hi 满足 0 <= lo <= hi <= |s|，序列支持以下操作：\n\n              \n表达式           描述\n              \n|s|           序列长度\ns[i]          序列选择\ns[i := e]     序列更新\ne in s        序列成员\ne !in s       序列非成员\ns[lo..hi]     子序列\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   切片\nmultiset(s)   序列转换为 multiset〈T〉\n              \n\n表达式 s[i := e] 返回一个类似 s 的序列，除了索引 i 处的元素是 e。 表达式 e in s 表示存在一个索引 i 使得 s[i] == e。 仅当元素类型“T”支持相等时，才允许在非幽灵上下文中使用。 表达式 e !in s 是 !(e in s) 的语法简写。\n\n表达式 s[lo..hi] 产生一个序列，该序列通过获取第一个 hi 元素然后删除第一个 lo 元素而形成。 因此，结果序列的长度为“hi - lo”。 请注意，s[0..|s|] 等于 s。 如果省略上限，则默认为 |s|，因此 s[lo..] 会生成通过删除 s 的第一个 lo 元素形成的序列。 如果省略下限，则默认为 0，因此 s[..hi] 产生由 s 的第一个 hi 元素形成的序列。\n\n在序列切片操作中，slices 是一个长度指示符的非空列表，由冒号分隔并可选地终止，并且至少有一个冒号。 每个长度指示符都是一个基于非负整数的数字，其总和不大于|s|。 如果有 k 个冒号，则该操作会从 s 生成 k 个连续子序列，每个长度由相应的长度指示符指示，并将这些作为序列序列返回。1 如果 slices 以冒号结尾，那么最后一个切片的长度会一直延伸到 s 的末尾，即 它的长度是|s|减去给定长度指示符的总和。 例如，对于任何长度至少为 10 的序列 s ，以下等式成立：\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n操作multiset(s)产生序列s的元素的多重集。 仅当元素类型“T”支持相等时，才允许在非幽灵上下文中使用。\n\n# 2.2.0. 字符串\n\n序列类型的一个特例是seq〈char〉，Dafny 提供了一个同义词：string。 字符串与其他序列类似，但为序列显示表达式提供了额外的语法，即字符串文字。 字符串文字有两种语法形式：标准形式和逐字形式。\n\n标准形式的字符串文字用双引号括起来，如 \"Dafny\"。 要在这样的字符串文字中包含双引号，必须使用转义序列。 转义序列也可用于包含其他字符。 支持的转义序列与字符文字相同，请参阅第 [0.2] 节(http://leino.science/papers/krml243.html#sec-char)。 例如，Dafny 表达式 \"say \\\"yes\\\"\" 表示字符串 say \"yes\"。 单引号的转义序列是多余的，因为 \"'\" 和 \"'\" 表示相同的字符串——提供这两种形式是为了支持与字符文字相同的转义序列。\n\n逐字形式的字符串文字用 @\" 和 \" 括起来，如 @\"Dafny\"。 要在这样的字符串文字中包含双引号，必须使用转义序列“”，即两次写入字符。 在逐字形式中，没有其他转义序列。 甚至像换行符这样的字符也可以写在字符串文字中（因此在程序文本中跨越多行）。 例如，以下三个表达式表示相同的字符串：\n\n\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\n由于字符串是序列，因此在它们上定义了关系运算符 < 和 <=。 但是请注意，这些运算符仍然分别表示正确的前缀和前缀，而不是可能需要的某种字母比较，例如，在对字符串进行排序时。\n\n\n# 2.3. 有限与无限图\n\n对于任何类型T和U，map〈T，U〉类型的值表示从T到U的*（有限）映射*。 换句话说，它是一个由T索引的查找表。 地图的 domain 是一组有限的 T 值，它们具有关联的 U 值。 由于域中的键是使用 T 类型中的相等性进行比较的，因此只有当T 支持相等性时，类型map〈T,U〉 才能在非幽灵上下文中使用。\n\n类似地，对于任何类型 T 和 U，imap⟨T,U⟩ 类型的值表示*（可能）无限映射*。 在大多数情况下，imap<T,U> 类似于 map<T,U>，但是 imap<T,U> 类型的映射允许有一个无限域。\n\n可以使用 map display 表达式形成地图，该表达式可能是一个空的、有序的 maplets 列表，每个 maplet 具有 t := u 的形式，其中 t 是 T 类型的表达式，并且 u 是U 类型的表达式，放在关键字map 后面的方括号中。 为了显示，\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\n是地图显示的三个示例。 通过使用关键字 imap 而不是 map，生成的地图将是 imap<T,U> 类型而不是 map<T,U>。 请注意，允许无限映射 (imap) 具有有限域，而不允许有限映射 (map) 具有无限域。 如果同一个键出现多次，则结果映射中只出现最后一次出现。2 还有一个 * 地图理解表达式*，在 Dafny 语言参考的不同部分进行了解释。\n\n对于map<T,U>类型的任何映射fm，map<T,U>或imap<T,U>类型的任何映射m，类型的任何表达式t T，U类型的任何表达式u，以及m域中的任何d（即满足d in m`），映射支持以下操作：\n\n            \n表达式         描述\n            \n|fm|        地图基数\nm[d]        地图选择\nm[t := u]   地图更新\nt in m      映射域成员\nt !in m     映射域非成员\n            \n\n|fm| 表示fm 中的映射个数，即fm 的域的基数。 请注意，无限映射不支持基数运算符。 表达式 m[d] 返回 m 与 d 关联的 U 值。 表达式 m[t := u] 是一个类似于 m 的映射，除了键 t 处的元素是 u。\n\n表达式 t in m 表示 t 在 m 的域中，而 t !in m 是 !(t in m) 的语法简写。 3 这是一个小例子，其中类型为 map<int,real> 的地图 cache 用于缓存 Joule-Thomson 系数的计算值 给定温度下的一些固定气体：\n\nif K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJouleThomsonCoefficient(K);  // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3. 象征类型\n\n有时通过多个名称了解一个类型或抽象地处理一个类型很有用。\n\n\n# 3.0. 同义词类型\n\n类型同义词声明：\n\ntype Y〈T〉 = G\n\n\n1\n\n\n声明 Y〈T〉 是类型 G 的同义词。 这里，T 是一个类型参数的非空列表（每个参数都可选地用后缀“(==)”指定），它可以用作G 中的自由类型变量。 如果同义词没有类型参数，则删除“〈T〉”。 在所有情况下，类型同义词只是同义词。 也就是说，除了可能产生的错误消息之外，Y〈T〉 和 G 之间从来没有区别。\n\n例如，以下类型同义词的名称可能会提高程序的可读性：\n\ntype Replacements〈T〉 = map〈T,T〉\ntype Vertex = int\n\n\n1\n2\n\n\n如第 2.2.0 中所述，string 是seq〈char〉 的内置类型同义词，好像 它将被宣布如下：\n\ntype string = seq〈char〉\n\n\n1\n\n\n\n# 3.1. 不透明类型\n\n类型同义词的一个特例是未指定的。 这样的类型简单地通过以下方式声明：\n\ntype Y〈T〉\n\n\n1\n\n\n它被称为不透明类型。 它的定义可以在精炼模块中显示。 为了表明 Y 表示支持相等的类型，可以在名称“Y”之后紧跟“(==)”。\n\n例如，声明\n\ntype T\nfunction F(t: T): T\n\n\n1\n2\n\n\n可用于在某个任意类型“T”上建模未解释的函数“F”。 作为另一个例子，\n\ntype Monad〈T〉\n\n\n1\n\n\n可以抽象地用于表示任意参数化的 monad。\n\n\n# 4. 数据类型\n\nDafny 提供了两种代数数据类型，一种是归纳定义的，另一种是协归纳定义的。 每个数据类型的显着属性是该类型的每个值唯一标识数据类型的构造函数之一，并且每个构造函数的参数都是单射的。\n\n\n# 4.0. 归纳类型\n\n归纳数据类型的值可以看作是有限树，其中叶子是基本类型、数值类型、引用类型、共归纳数据类型或函数类型的值。 实际上，可以使用 Dafny 有根据的 < 排序来比较归纳数据类型的值。\n\n归纳数据类型声明如下：\n\ndatatype D〈T〉 = Ctors\n\n\n1\n\n\n其中 *Ctors* 是一个非空的 | 分隔的 (datatype) 构造函数 的数据类型列表。 每个构造函数都有以下形式：\n\nC(params)\n\n\n1\n\n\n其中 *params* 是一个逗号分隔的类型列表，前面可选参数名称和冒号，前面可选关键字 ghost。 如果构造函数没有参数，则可以省略构造函数名称后面的括号。 如果没有构造函数接受参数，则该类型通常称为枚举； 例如：\n\ndatatype Friends = Agnes | Agatha | Jermaine | Jack\n\n\n1\n\n\n对于每个构造函数 C，Dafny 定义了一个 discriminator C?，它是一个返回 true 的成员，当且仅当数据类型值是使用 C 构造的。 对于构造函数 C 的每个命名参数 p，Dafny 定义了一个 destructor p，它是从用于构造数据类型值的 C 调用返回 p 参数的成员； 它的使用要求 C? 成立。 例如，对于标准的 List 类型\n\ndatatype List〈T〉 = Nil | Cons(head: T, tail: List〈T〉)\n\n\n1\n\n\n以下成立：\n\nCons(5, Nil).Cons? && Cons(5, Nil).head == 5\n\n\n1\n\n\n注意表达式\n\nCons(5, Nil).tail.head\n\n\n1\n\n\n格式不正确，因为 Cons(5, Nil).tail 不满足 Cons?。\n\n析构函数的名称在数据类型的所有构造函数中必须是唯一的。 构造函数可以与封闭数据类型同名； 这对于通常称为记录类型的单构造函数数据类型特别有用。 例如，黑白像素的记录类型可能表示如下：\n\ndatatype Pixel = Pixel(x: int, y: int, on: bool)\n\n\n1\n\n\n要调用构造函数，通常只需要提及构造函数的名称，但如果这不明确，则始终可以通过数据类型的名称来限定构造函数的名称。 比如上面的Cons(5, Nil)可以写成\n\nList.Cons(5, List.Nil)\n\n\n1\n\n\n作为显式调用数据类型构造函数的替代方法，可以使用 datatype update 表达式将数据类型值构造为一个参数从给定数据类型值的变化。 对于任何类型为数据类型的“d”，该数据类型包括构造函数“C”，该构造函数具有名为“f”的类型为“T”的参数（析构函数），以及任何类型为“T”的表达式“t”，\n\nd[f := t]\n\n\n1\n\n\n构造一个类似于 d 但其 f 参数是 t 的值。 该操作要求 d 满足 C?。 例如，以下等式成立：\n\nCons(4, Nil)[tail := Cons(3, Nil)] == Cons(4, Cons(3, Nil))\n\n\n1\n\n\n\n# 4.1. 元组类型\n\nDafny 构建了对应于元组的记录类型，并为它们提供了一种方便的特殊语法，即括号。 例如，可能已声明为：\n\ndatatype Pair〈T,U〉 = Pair(0: T, 1: U)\n\n\n1\n\n\nDafny 提供了类型 (T, U) 和构造函数 (t, u)，好像数据类型的名称是“”，并且它的类型参数在圆括号中给出，并且好像构造函数名称是“” . 请注意，析构函数名称是“0”和“1”，它们是成员的合法标识符名称。 例如，显示元组析构函数的使用，这里有一个包含 2 元组的属性（即 pairs）：\n\n(5, true).1 == true\n\n\n1\n\n\nDafny 声明 n 元组，其中 n 为 0 或 2 或更高。 没有 1 元组，因为围绕单个类型或单个值的括号没有语义意义。 0 元组类型 () 通常被称为 unit 类型，它的单个值，也写作 ()，被称为 unit。\n\n\n# 4.2. 共同归纳类型\n\n尽管 Dafny 坚持认为有一种方法可以从头开始构造每个归纳数据类型值，但 Dafny 还支持 co-inductive datatypes，其构造函数被延迟评估，因此允许无限结构。 使用关键字“codatatype”声明共归纳数据类型； 除此之外，它像归纳数据类型一样被声明和使用。\n\n例如,\n\ncodatatype IList〈T〉 = Nil | Cons(head: T, tail: IList〈T〉)\ncodatatype Stream〈T〉 = More(head: T, tail: Stream〈T〉)\ncodatatype Tree〈T〉 = Node(left: Tree〈T〉, value: T, right: Tree〈T〉)\n\n\n1\n2\n3\n\n\n分别声明可能无限的列表（即可以是有限或无限的列表）、无限流（即始终无限的列表）和无限二叉树（即每个分支永远存在的树）。\n\n\n# 5. 参照类型\n\nDafny 提供了许多参考类型。 这些代表对程序堆中动态分配的对象的引用。 要访问对象的成员，对对象的引用（即指针 或对象标识）被取消引用。\n\n特殊值 null 是每个引用类型的一部分。4\n\n\n# 5.0. 类\n\nclass C 是一个引用类型，声明如下：\n\nclass C〈T〉 extends J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\n其中类型参数列表T是可选的，“extends J”也是如此，它表示该类扩展了一个特征“J”。 类的成员是 fields、functions 和 methods。 这些是通过取消引用对“C”实例的引用来访问或调用的。 除非函数或方法声明为 static，否则函数或方法会在 C 的 instance 上调用。 机械地，这只是意味着该方法采用隐式 receiver 参数，即用于访问成员的实例。 在实例函数或方法的规范和主体中，接收器参数可以通过关键字 this 显式引用。 但是，在这样的地方，this的成员也可以无条件地被提及。 为了说明，合格的 this.f 和不合格的 f 在以下示例中指的是同一对象的同一字段：\n\nclass C {\n  var f: int;\n  method Example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以方法体总是将 true 分配给输出参数 b。 对同一接收者和成员的合格和不合格访问之间没有语义差异。\n\n一个 C 实例是使用 new 创建的，例如：\n\nc := new C;\n\n\n1\n\n\n请注意，new 只是分配一个 C 对象并返回对它的引用； 其字段的初始值是它们各自类型的任意值。 因此，通常在创建后立即调用称为 initialization method 的方法，例如：\n\nc := new C;\nc.InitFromList(xs, 3);\n\n\n1\n2\n\n\n当初始化方法没有out-parameter并且修改不超过this时，那么上面的两个语句可以合并为一个：\n\nc := new C.InitFromList(xs, 3);\n\n\n1\n\n\n请注意，一个类可以包含多个初始化方法，这些方法可以随时调用，而不仅仅是作为new的一部分，并且new不需要在创建时调用初始化方法。\n\n要编写结构化的面向对象程序，通常依赖于仅以特定方式构造对象。 为此，Dafny 提供了 constructor (method)s，这是一种受限形式的初始化方法。 构造函数是用关键字constructor而不是method声明的。 当一个类包含构造函数时，对该类的每次调用 new 都必须伴随对构造函数之一的调用。 此外，不能在其他时间调用构造函数，只能在对象创建期间调用。 除了这些限制之外，使用普通初始化方法和使用构造函数之间没有语义上的区别。\n\nDafny 设计允许命名构造函数，这促进了使用上面的“InitFromList”之类的名称。 尽管如此，许多类只有一个构造函数或有一个典型的构造函数。 因此，Dafny 允许一个匿名构造函数，即名称本质上是“”的构造函数。 例如：\n\nclass Item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n调用此构造函数时，会删除“.”，如下所示：\n\nm := new Item(45, 29);\n\n\n1\n\n\n请注意，匿名构造函数只是命名构造函数的一种方式； 也可以有其他构造函数。\n\n\n# 5.1. 数组\n\nDafny 支持任何正维度的可变固定长度数组类型。 数组类型是引用类型。\n\n# 5.1.0. 一维数组\n\nn T 元素的一维数组创建如下：\n\na := new T[n];\n\n\n1\n\n\n数组元素的初始值是“T”类型的任意值。 使用不可变的 Length 成员检索数组的长度。 例如上面分配的数组满足：\n\na.Length == n\n\n\n1\n\n\n对于 0 <= i < a.Length 范围内的任何基于整数的数字 i，array selection 表达式 a[i] 检索元素 i（即，前面有 i 数组中的元素）。 可以使用数组更新语句将存储在 i 的元素更改为值 t：\n\na[i] := t;\n\n\n1\n\n\n警告：由new T[n]创建的数组类型是array〈T〉。 一个容易犯的错误是在 new 后面写 array<T> 而不是 T。 例如，考虑以下情况：\n\nvar a := new array〈T〉;\nvar b := new array〈T〉[n];\nvar c := new array〈T〉(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\n第一条语句分配了一个类型为 array〈T〉 的数组，但长度未知。 第二个分配一个长度为“n”的“array〈array〈T〉〉”类型的数组，即一个包含“n”类型的“array〈T〉”值的数组。 第三条语句分配一个类型为array〈T〉的数组，然后尝试调用这个数组的匿名构造函数，传递参数n。 由于array没有构造函数，更不用说匿名构造函数了，这个语句会产生错误。 如果对于需要类型参数的类型省略了类型参数列表，Dafny 将尝试填写这些，因此只要可以推断出array类型参数，就可以省略“〈T〉 ” 在上面的第四个语句中。 但是，与第三条语句一样，array` 没有匿名构造函数，因此会生成错误消息。\n\n一维数组支持将一系列连续元素转换为序列的操作。 对于任何类型为array〈T〉的数组a，基于整数的数字lo和hi满足0 <= lo <= hi <= a.Length，以下操作各自产生一个seq 〈T〉：\n\n            \n表达式         描述\n            \na[lo..hi]   子数组转为序列\na[lo..]     drop\na[..hi]     take\na[..]       数组转换为序列\n            \n\n表达式 a[lo..hi] 获取数组的第一个 hi 元素，然后删除其中的第一个 lo 元素并返回剩余的序列。 因此，结果序列的长度为“hi - lo”。 其他操作是第一个操作的特殊实例。 如果省略 lo，则默认为 0，如果省略 hi，则默认为 a.Length。 在最后一个操作中，lo 和 hi 都被省略了，因此 a[..] 返回由 a 的所有数组元素组成的序列。\n\n子数组操作在规范中特别有用。 例如，使用变量“lo”和“hi”来划分仍然可以找到搜索“key”的子数组的二分搜索算法的循环不变量可以表示如下：\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\n另一个用途是说某个范围的数组元素自方法开始以来没有改变：\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\n或从循环开始：\n\nghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意这个例子中的prevElements的类型是seq<T>，如果a的类型是array<T>。\n\n子数组操作的最后一个示例在于表示数组的元素是方法开头的数组元素的排列，就像在大多数排序算法中所做的那样。 在这里，子数组操作与序列到多集的转换相结合：\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1. 多维数组\n\n2 维或更多维的数组大多类似于一维数组，不同之处在于 new 需要更多长度参数（每个维度一个），并且数组选择表达式和数组更新语句需要更多索引。 例如：\n\nmatrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\n创建一个二维数组，其维度的长度分别为“m”和“n”，然后交换“i,j”和“x,y”处的元素。 matrix 的类型是 array2<T>，对于高维数组（array3<T>、array4<T> 等）也是如此。 但是请注意，没有类型 array0<T>，本来可以是 array1<T> 的东西实际上只是命名为 array<T>。\n\n上面的 new 操作要求 m 和 n 是基于非负整数的数字。 可以使用不可变字段 Length0 和 Length1 检索这些长度。 例如，以下保存了上面创建的数组：\n\nmatrix.Length0 == m && matrix.Length1 == n\n\n\n1\n\n\n高维数组类似（Length0、Length1、Length2、...）。 数组选择表达式和数组更新语句要求索引在范围内。 例如，上面的交换语句只有在以下情况下才是格式正确的：\n\n0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n\n\n1\n2\n\n\n与一维数组相比，没有将元素的延伸从多维数组转换为序列的操作。\n\n\n# 5.2. 特征\n\ntrait 是一个“抽象超类”，或者称它为“接口”或“mixin”。 特征对 Dafny 来说是新的，并且可能会发展一段时间。 一个 trait 的声明很像一个类的声明：\n\ntrait J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\n其中 *members* 可以包含字段、函数和方法，但不能包含构造函数方法。 允许将函数和方法声明为“静态”。\n\n扩展特征“J”的引用类型“C”可以分配给“J”，但不能反过来。 J 的成员可以作为C 的成员使用。 J 中的成员不允许在C 中重新声明，除非该成员是在J 中没有主体的非static 函数或方法。 通过这样做，类型“C”可以为成员提供更强大的规范和主体。\n\nnew 不允许与特征一起使用。 因此，没有分配类型是特征的对象。 但是当然可以有一个类 C 的对象实现了一个特征 J ，并且对这样一个 C 对象的引用可以用作类型 J 的值。\n\n例如，以下特征表示可移动的几何形状：\n\ntrait Shape\n{\n  function method Width(): real\n    reads this\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n成员 Width 和 Move 是 abstract （即无主体），并且可以由扩展 trait 的不同类以不同方式实现。 方法 MoveH 的实现在 trait 中给出，因此被所有扩展 Shape 的类使用。 这里有两个类，每个类都扩展了“Shape”：\n\nclass UnitSquare extends Shape\n{\n  var x: real, y: real;\n  function method Width(): real {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real;\n  function method Width(): real\n    reads this\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n请注意，类可以声明其他成员，它们为特征的抽象成员提供实现，它们重复成员签名，并且它们负责提供自己的成员规范，这些规范既加强了特征中的相应规范，又是 对提供的机构感到满意。 最后，这是一些创建两个类实例并将它们一起用作形状的代码:\n\nvar myShapes: seq〈Shape〉;\nvar A := new UnitSquare;\nmyShapes := [A];\nvar tri := new LowerRightTriangle;\nmyShapes := myShapes + [tri];  // myShapes contains two Shape values, of different classes\nmyShapes[1].MoveH(myShapes[0].Width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3. 类型 object\n\n有一个内置的引用类型object，它就像所有引用类型的超类型。5 type object 是为了启用对动态帧的统一处理。 特别是，保留类型为 set〈object〉 的幽灵字段（通常命名为Repr` 表示“表示”）很有用。\n\n\n# 5.4. 迭代器类型\n\niterator 为编写迭代返回元素的代码提供了编程抽象。 这些 CLU 风格的迭代器是协同例程，因为它们跟踪自己的程序计数器，并且控制可以传入和传出迭代器主体。\n\n迭代器声明如下：\n\niterator Iter〈T〉(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中 T 是类型参数的列表（通常，如果没有类型参数，则省略“〈T〉”）。 这个声明产生了一个同名的引用类型，Iter〈T〉。 在签名中，in-parameters 和 yield-parameters 是迭代器对方法的 in-parameters 和 out-parameters 的模拟。 不同之处在于，方法的输出参数只返回给调用者一次，而迭代器的 yield 参数在迭代器主体执行 yield 时返回。 规范的详细信息在 Dafny 语言参考的不同部分中进行了描述。 主体由语句组成，就像在方法主体中一样，但也可以使用 yield 语句。\n\n从迭代器客户端的角度来看，iterator 声明可以理解为生成具有各种成员的类Iter〈T〉，下面将描述其简化版本。\n\n`Iter〈T〉 类包含一个匿名构造函数，其参数是迭代器的内参数：\n\npredicate Valid()\nconstructor (in-params)\n  modifies this\n  ensures Valid()\n\n\n1\n2\n3\n4\n\n\n使用 new 和这个匿名构造函数创建了一个迭代器。 例如，一个愿意从 start 返回十个连续整数的迭代器可以声明如下：\n\niterator Gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个迭代器的一个实例是使用以下方法创建的：\n\niter := new Gen(30);\n\n\n1\n\n\n谓词“Valid()”表示迭代器何时处于可以尝试计算更多元素的状态。 它是构造函数的后置条件，出现在“MoveNext”成员的规范中：\n\nmethod MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n\n\n1\n2\n3\n4\n\n\n请注意，只要 MoveNext 返回 true，迭代器仍然有效。 一旦 MoveNext 返回 false，就不能再调用 MoveNext 方法。 请注意，客户端没有义务继续调用 MoveNext 直到它返回 false，并且允许迭代器的主体永远保持返回元素。\n\n迭代器的输入参数存储在迭代器类的不可变字段中。 为了根据上面的示例进行说明，迭代器类“Gen”包含以下字段：\n\nvar start: int;\n\n\n1\n\n\n产量参数也导致迭代器的成员 class:\n\nvar x: int;\n\n\n1\n\n\n这些字段由“MoveNext”方法设置。 如果 MoveNext 返回 true，则这些字段中提供了最新的收益率值，客户端可以从那里读取它们。\n\n为了帮助编写规范，迭代器类还包含保留“MoveNext”返回值的历史记录的幽灵成员。 这些幽灵字段的名称跟在 yield 参数的名称之后，并在名称后面附加了一个“s”（表示复数）。 名称检查规则确保这些名称不会引起歧义。 因此，上述“Gen”的迭代器类包含：\n\nghost var xs: seq〈int〉;\n\n\n1\n\n\n这些历史字段由“MoveNext”自动更改，但不能由用户代码分配。\n\n最后，迭代器类包含一些用于规范的特殊字段。 特别是，迭代器规范记录在以下不可变字段中：\n\nghost var _reads: set〈object〉;\nghost var _modifies: set〈object〉;\nghost var _decreases0: T0;\nghost var _decreases1: T1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\n其中，迭代器的 decreases 子句的每个组件都有一个 _decreases*i*: T*i* 字段。 [6](http://leino.science/papers/krml243.html#fn-fn-iterator -field-names) 另外还有一个字段：\n\nghost var _new: set〈object〉;\n\n\n1\n\n\n代表迭代器主体分配的任何对象都将添加到其中。 迭代器主体可以从 _new 集中删除元素，但不能通过赋值给 _new 添加任何元素。\n\n请注意，在迭代器的前提条件中，即坚持构造迭代器，内参数确实是内参数，而不是 this 的字段。\n\n\n# 5.5. 异步任务类型\n\nDafny 中另一个可能会经历一些演变的实验性功能是异步方法。 调用异步方法时，它不会返回 out-parameters 的值，而是返回 *async-task 类型 * 的实例。 在C类中声明的异步方法，具有以下签名：\n\nasync method AM〈T〉(in-params) returns (out-params)\n\n\n1\n\n\n也产生了一个异步任务类型AM〈T〉（在封闭类之外，类型的名称需要限定C.AM〈T〉）。 async-task 类型是一个引用类型，可以理解为一个有各种成员的类，下面介绍它的简化版本。 异步方法的每个类型为X的参数x都会产生一个异步任务类型的不可变幽灵字段：\n\nghost var x: X;\n\n\n1\n\n\n每个Y类型的输出参数y都会产生一个字段\n\nvar y: Y;\n\n\n1\n\n\n这些字段会在异步方法成功等待时自动更改，但不能由用户代码分配。\n\nasync-task 类型还有一些特殊字段，用于跟踪依赖关系、未完成的任务、新分配的对象等。随着异步方法设计的发展，这些字段将被更详细地描述。\n\n\n# 6. 函数类型\n\n函数是 Dafny 中的一等值。 函数类型具有 (T) -> U 的形式，其中 T 是一个以逗号分隔的类型列表，而 U 是一个类型。 T 被称为函数的 domain type(s) 并且 U 是它的 range type。 例如，函数的类型\n\nfunction F(x: int, b: bool): real\n\n\n1\n\n\n是(int, bool) -> real。 参数不允许为ghost。\n\n为了简化函数域由一个类型列表组成的基本情况的外观，在这种情况下可以删除域类型周围的括号，如 T -> U。 在一种类型是元组类型的情况下，这种无害的简化需要额外的解释，因为元组类型也是用括号括起来的。 如果函数接受一个元组参数，则需要额外的一组括号。 例如，函数\n\nfunction G(pair: (int, bool)): real\n\n\n1\n\n\n类型为 ((int, bool)) -> real。 注意必要的双括号。 类似地，不带参数的函数与带 0 元组作为参数的函数不同。 例如，函数\n\nfunction NoArgs(): real\nfunction Z(unit: ()): real\n\n\n1\n2\n\n\n分别有 () -> real 和 (()) -> real 类型。\n\n函数箭头 -> 是右结合的，所以 A -> B -> C 表示 A -> (B -> C)。 另一个关联需要显式括号：(A -> B) -> C。\n\n请注意，命名函数的接收器参数不是类型的一部分。 相反，它在查找函数时使用，然后可以被认为是被捕获到函数定义中。 例如，假设上面的函数“F”在类“C”中声明，而“c”引用了一个“C”类型的对象； 那么，以下是正确的类型：\n\nvar f: (int, bool) -> real := c.F;\n\n\n1\n\n\n而写如下内容是不正确的：\n\nvar f': (C, int, bool) -> real := F;  // not correct\n\n\n1\n\n\n在其类型签名之外，每个函数值都具有三个属性，如下所述。\n\n每个函数都隐含地将堆作为参数。 然而，没有任何函数依赖于整个堆。 函数的一个属性是它在给定输入所依赖的堆位置集上声明的上限。 这让验证者可以确定某些堆修改对某个函数返回的值没有影响。 对于函数f: T -> U和T类型的值t，依赖集表示为f.reads(t)并且具有set〈object〉类型。\n\n函数的第二个属性源于每个函数都可能是部分的。 换句话说，函数的属性是它的前提条件。 对于函数f: T -> U，T类型的参数值t的f的前提条件表示为f.requires(t)并且具有bool类型。\n\n函数的第三个属性更为明显——函数体。 对于函数“f: T -> U”，该函数对“T”类型的输入“t”产生的值表示为“f(t)”，并且具有“U”类型。\n\n请注意，f.reads 和 f.requires 本身就是函数。 假设 f 的类型为 T -> U，而 t 的类型为 T。 那么，f.reads 是 T -> set〈object〉 类型的函数，其 reads 和 requires 属性是：\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires 是 T -> bool 类型的函数，其 reads 和 requires 属性为：\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0. Lambda表达式\n\n除了命名函数之外，Dafny 还支持定义函数的表达式。 这些被称为 lambda (expression)s（一些语言将它们称为 匿名函数）。 lambda 表达式具有以下形式：\n\n(params) specification => body\n\n\n1\n\n\n其中 *params* 是以逗号分隔的参数声明列表，每个参数声明的形式为 x 或 x: T。 参数的类型‘T’在可以推断时可以省略。 如果不需要标识符x，可以用“_”代替。 如果 *params* 包含一个没有明确类型的参数 x（或 _），则可以删除括号； 例如，返回给定整数的后继的函数可以写成以下 lambda 表达式：\n\nx => x + 1\n\n\n1\n\n\n*specification* 是 requires E 或 reads W 的子句列表，其中 E 是布尔表达式， W 是框架表达式。\n\n*body* 是定义函数返回值的表达式。 对于满足前提条件的参数的所有可能值，主体必须格式正确（就像命名函数和方法的主体一样）。 在某些情况下，这意味着有必要编写明确的 requires 和 reads 子句。 例如，lambda 表达式\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\n如果省略 requires 子句，则格式不正确，因为可能会被零除。\n\n在函数不能是部分的并且对读取堆没有限制的设置中，函数 F: T -> U 的 eta 扩展（即，将 F 包装在这样的 lambda 表达式中） lambda 表达式等价于 F) 的方式将写作 x => F(x)。 在 Dafny 中，eta 扩展还必须考虑函数的前提条件和读取集，因此 F 的 eta 扩展如下所示：\n\nx requires F.requires(x) reads F.reads(x) => F(x)\n\n\n1\n\n\n\n# 7. 新类型\n\n可以使用 newtype 声明7 声明新的数字类型\n\nnewtype N = x: M | Q\n\n\n1\n\n\n其中“M”是数字类型，“Q”是布尔表达式，可以将“x”用作自由变量。 如果M是一个基于整数的数值类型，那么N也是； 如果“M”是实数，那么“N”也是如此。 如果可以从 Q 推断出类型 M，则可以省略“:M”。 如果 Q 只是 true，那么声明可以简单地给出：\n\nnewtype N = M\n\n\n1\n\n\n类型“M”被称为“N”的基本类型。\n\nnewtype 是一种数字类型，它支持与其基本类型相同的操作。 newtype 与其他数字类型不同且不兼容； 特别是，如果没有显式转换，它就不能分配给它的基本类型。 对 newtype 的操作与其基类型的操作之间的一个重要区别是 newtype 操作仅在结果满足谓词 Q 时才被定义，对于 newtype 的字面量也是如此。 [8](http:// /leino.science/papers/krml243.html#fn-fn-newtype-design-question）\n\n例如，假设 lo 和 hi 是基于整数的数字，它们满足 0 <= lo <= hi 并考虑以下代码片段：\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\n如果 lo 和 hi 的类型为 int，那么代码片段是合法的； 特别是，它永远不会溢出，因为 int 没有上限。 相反，如果 lo 和 hi 是新类型 int32 的变量，声明如下：\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\n那么代码片段是错误的，因为加法的结果可能无法满足int32定义中的谓词。 代码片段可以重写为\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\n在这种情况下，int 和 int32 都是合法的。\n\n由于 newtype 与其基类型不兼容，并且由于 newtype 操作的所有结果都是 newtype 的成员，因此 Dafny 的编译器可以自由地专门化 newtype 的运行时表示。 例如，通过仔细检查上面 int32 的定义，编译器可能会决定在目标硬件中使用带符号的 32 位整数来存储 int32 值。\n\n请注意，Q 中的绑定变量x 的类型为M，而不是N。 n因此，可能无法就“N”值说明“Q”。 例如，考虑以下类型的 8 位 2 的补码整数：\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\n并考虑一个类型为int8的变量c。 表达式\n\n-128 <= c < 128\n\n\n1\n\n\n定义不明确，因为比较要求每个操作数的类型为“int8”，这意味着文字“128”被检查为“int8”类型，但事实并非如此。 编写此表达式的正确方法是在 c 上使用转换操作，如下所述，将其转换为基本类型：\n\n-128 <= int(c) < 128\n\n\n1\n\n\n有一个限制，即值0必须是每个新类型的一部分。9\n\n\n# 7.0. 数字转换操作\n\n对于每个数字类型N，都有一个同名的转换函数。 它是一个部分恒等函数。 它是在给定值（可以是任何数字类型）是转换为的类型的成员时定义的。 当从基于实数的数值类型转换为基于整数的数值类型时，该操作要求基于实数的参数没有小数部分。 （要将基于实数的数值向下舍入到最接近的整数，请使用 .Trunc 成员，请参阅第 [0.1] 节（http://leino.science/papers/krml243.html#sec-numeric-types）。 )\n\n使用上面的例子来说明，如果 lo 和 hi 的类型是 int32，那么代码片段可以合法地写成如下\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\n其中mid的类型被推断为int。 由于除法的结果值是 int32 类型的成员，因此可以引入另一种转换操作，使 mid 的类型为 int32：\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\n如果编译器确实专门针对int32的运行时表示，那么这些语句的代价是两个或三个运行时转换。\n\n\n# 8. 子集类型\n\n子集类型是对现有类型的限制使用，称为子集类型的基本类型。 子集类型就像基类型和基类型上的谓词的组合使用。\n\n始终允许从子集类型到其基本类型的赋值。 如果分配的值确实满足子集类型的谓词，则允许从基本类型到子集类型的另一个方向的分配。 （注意，相比之下，newtype 和它的基类型之间的赋值是不允许的，即使赋值是目标类型的值。对于这样的赋值，必须使用显式转换，参见第 [7.0]（http: //leino.science/papers/krml243.html#sec-numeric-conversions)。) Dafny 支持一种子集类型，即内置类型 nat，其基本类型为 int。[10](http: //leino.science/papers/krml243.html#fn-fn-more-subset-types）\n\n类型nat指定int的非负子范围。 一个很好地使用子集类型“nat”的简单示例是标准斐波那契函数：\n\nfunction Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\n此函数的等效但笨拙的公式（以调用站点产生的任何错误消息的措辞为模）将使用类型int并在前置条件和后置条件中编写限制谓词：\n\nfunction Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n类型推断永远不会将变量的类型推断为子集类型。 相反，它会将类型推断为子集类型的基本类型。 例如，x 的类型\n\nforall x :: P(x)\n\n\n1\n\n\n将是 int，即使谓词 P 声明其参数的类型为 nat。\n\n# 参考资料\n\n由于 Nadia Polikarpova 和 Paqui Lucio 的评论，本文档得到了改进。\n\n----------------------------------------\n\n 0.  支持平等只是人们可以想象的丰富类型系统中的类型拥有的众多模式之一。 例如，其他模式可能包括具有总订单、可零初始化以及可能无人居住。 如果 Dafny 将来支持更多模式，“( )”后缀语法可能会被扩展。 目前，后缀只能表示支持平等的模式。 ↩\n 1.  现在Dafny支持内置元组，打算把序列切片操作改成返回 不是子序列的序列，而是子序列的元组。 ↩\n 2.  这可能会在未来发生变化，不允许多次出现相同的键。 ↩\n 3.  这在未来可能会改变如下：in和!in 地图将不再支持操作。 相反，对于任何地图 m，m.Domain 将返回其域作为一个集合，而 m.Range 将返回，也作为一个集合，在其域下的 m 的图像。 ↩\n 4.  这将在 Dafny 的未来版本中发生变化，它将同时支持可空和（默认情况下）非 -null 引用类型。 ↩\n 5.  很快，object 将成为一个内置的 trait 而不是内置的特殊 班级。 发生这种情况时，将不再可能执行“新对象”。 object 不能用作类型参数的当前编译器限制也将消失。 ↩\n 6.  将特殊字段_reads和_modifies重命名为相同是有意义的 名称作为相应的关键字，“读取”和“修改”，就像对函数值所做的那样。 此外，各种 _decreases*i* 字段可以组合成一个名为 decreases 的字段，其类型是 n 元组。 ↩\n 7.  是否应该将newtype重命名为numtype？ ↩\n 8.  自动定义“谓词N”有用吗？(m:M){Q} `? ↩\n 9.  限制是由于当前编译器的限制。 这将在未来发生变化，也将为子集类型和非空引用类型开辟可能性。 ↩\n 10. Dafny 的未来版本将支持用户定义的子集类型。 ↩",normalizedContent:"# dafny type system\n\ndafny语言参考的这一部分描述了dafny编程语言中的类型。所描述的是dafny版本1.9.3.20107中实现的内容，异步任务类型尚未进入主分支。\n\n> 0. 基本类型 0.0. 布尔值 0.1. 数字类型 0.2. 字符 1. 类型参数 2. 集合类型 2.0. 集合 2.1. 多集 2.2. 序列 2.2.0. 字符串 2.3. 有限与无限图 3. 象征类型 3.0. 同义词类型 3.1. 不透明类型 4. 数据类型 4.0. 归纳数据类型 4.1. 元组类型 4.2. 共同归纳类型 5. 参照类型 5.0. 类 5.1. 数组 5.1.0. 一维数组 5.1.1. 多维数组 5.2. 特征 5.3. 类型 object 5.4. 迭代器类型 5.5. 异步任务类型 6. 函数类型 6.0. lambda表达式 7. 新类型 7.0. 数字转化操作 8. 子集类型\n\n\n# 0. 基本类型\n\ndafny提供了三种基本类型，bool表示布尔，int表示整数，real表示实数。\n\n\n# 0.0. booleans\n\n有两个布尔值，每个值在语言中都有一个对应的文本：false和true。\n\n除了在所有类型上定义的相等（=）和disequality（！=），类型bool还支持以下操作：\n\n       \n操作符    描述\n       \n<==>   当且仅当\n       \n==>    蕴含\n<==    反向蕴含\n       \n&&     连接(且)\n||     析取(或)\n       \n!      否定(非)\n       \n\n否定是一元的；其他的是二进制的。该表显示了一组结合力不断增强的运算符，等式结合比合取和析取强，比否定弱。在每个组中，不同的运算符不关联，因此需要使用括号。例如,\n\na && b || c    // error\n\n\n1\n\n\n将是不明确的，而必须写为\n\n(a && b) || c\n\n\n1\n\n\n或\n\na && (b || c)\n\n\n1\n\n\n取决于预期的意思。\n\n表达式a<=>b和a==b给出了相同的值，但请注意，<=>是关联的，=是链接的。所以\n\na <==> b <==> c\n\n\n1\n\n\n与下式相同\n\na <==> (b <==> c)\n\n\n1\n\n\n和\n\n(a <==> b) <==> c\n\n\n1\n\n\n鉴于\n\na == b == c\n\n\n1\n\n\n只是下式的速记\n\na == b && b == c\n\n\n1\n\n\n合取是关联的，析取也是。这些运算符是短路（从左到右），这意味着只有在第一个操作数的计算不确定表达式的值时，才会计算它们的第二个参数。从逻辑上讲，表达式a&&b是在定义了a并且a的计算结果为false或b时定义的。定义a&&b时，其含义与普通的对称数学连词相同∧. | | |和∨.\n\n含义是“右关联”，从左到右短路。反向蕴涵b<==a与a==>b完全相同，但可以按相反的顺序写入操作数。因此，反向含义是“左关联”，是从“右”到“左”的短路。为了说明关联性规则，以下四行中的每一行都表示了相同的属性，即bool类型的任何a、b和c：\n\na ==> b ==> c\na ==> (b ==> c)  // parentheses redundant, since ==> is right associative\nc <== b <== a\n(c <== b) <== a  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\n为了说明短路规则，请注意，表达式a.length仅在a不为null时才为数组a定义 (见 小节 5), 这意味着以下两个表达式格式正确：\n\na != null ==> 0 <= a.length\n0 <= a.length <== a != null\n\n\n1\n2\n\n\n这两种表达的反作用是：\n\na.length < 0 ==> a == null  // not well-formed\na == null <== a.length < 0  // not well-formed\n\n\n1\n2\n\n\n但这些表达式的格式不好，因为格式好要求左（和右）操作数a.length<0本身格式良好。\n\n蕴涵a==>b相当于析取！a | | b，但有时（尤其是在规范中）更清晰易读。由于||是从左向右短路，请注意\n\na == null || 0 <= a.length\n\n\n1\n\n\n结构良好，而\n\n0 <= a.length || a == null  // not well-formed\n\n\n1\n\n\n结构较差。\n\n此外，布尔语支持逻辑量词（forall和exists），在dafny语言参考的另一部分中有描述。\n\n\n# 0.1. 数字类型\n\ndafny 支持两种 numeric 类型，integer-based，包括所有整数的基本类型 int，和 real-based，包括所有实数的基本类型 real。 用户定义的基于 int 和 real 的数字类型，称为 newtypes，在第 [7] 节(http://leino.science/papers/krml243.html#sec-newtypes) 中有描述。 此外，代表 int 的非负子范围的 subset type nat 在第 [8] 节（http://leino.science/papers/krml243.html#sec-subset-types）中进行了描述 . 该语言包含每个非负整数的文字，例如“0”、“13”和“1985”。 整数也可以使用前缀“0x”以十六进制书写，如“0x0”、“0xd”和“0x7c1”（始终使用小写“x”，但十六进制数字本身不区分大小写）。 允许使用前导零。 要形成负整数，请使用一元减号运算符。 一些非负实数也有文字。 这些被写成一个小数点，两边都有一个非空的十进制数字序列。 例如，“1.0”、“1609.344”和“0.5772156649”。 对于整数（十进制和十六进制形式）和实数，文字中的任何两位数字都可以用下划线分隔，以提高文字的可读性。 例如：\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 angstrom\n\n\n1\n2\n3\n4\n\n\n除了相等和不相等之外，数值类型还支持以下关系运算：\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\n就像相等和不相等一样，这些运算符是链接的，只要它们链接在“相同的方向”。 那就是说，\n\na <= b < c == d <= e\n\n\n1\n\n\nis simply a shorthand for\n\na <= b && b < c && c == d && d <= e\n\n\n1\n\n\n而\n\na < b > c\n\n\n1\n\n\n不被允许。 每种数字类型也有运算符：\n\n      \n操作符   描述\n      \n+     加\n-     减\n      \n*     乘\n/     除\n%     取模\n      \n-     否定 (一元减)\n      \n\n二元运算符是左结合的，它们在两组中相互关联。 这些组按绑定能力增加的顺序列出，等式绑定比乘法运算符更强，比一元运算符弱。 仅基于整数的数值类型支持模数。 整数除法和模数是欧几里得除法和模数。 这意味着无论两个操作数的符号如何，模数始终返回非负数。 更准确地说，对于任何整数a和非零整数b，\n\na == a / b * b + a % b\n0 <= a % b < b\n\n\n1\n2\n\n\n其中“b”表示“b”的绝对值。 基于实数的数值类型有一个成员 trunc，它返回实数值的 floor，即不超过实数值的最大整数。 例如，对于任何类型为“real”的“r”和“r”，以下属性成立：\n\n3.14.trunc == 3\n(-2.5).trunc == -3\n-2.5.trunc == -2\nreal(r.trunc) <= r\nr <= r' ==> r.trunc <= r'.trunc\n\n\n1\n2\n3\n4\n5\n\n\n请注意，在第三行中，成员访问（如 .trunc）的绑定比一元减号更强。 第四行使用从 int 到 real 的转换函数 real，如第 [7.0] 节 (http://leino.science/papers/krml243.html#sec-numeric-conversions) 中所述\n\n\n# 0.2. 字符\n\ndafny 支持 characters 的 char 类型。 字符文字用单引号括起来，如 'd'。 要将单引号写成字符文字，必须使用转义序列。 转义序列也可用于写入其他字符。 支持的转义序列如下：\n\n           \n转义字符       含义\n           \n\\'         字符 '\n\\\"         字符 \"\n\\\\         字符 \\\n\\0         空字符，同 \\u0000\n\\n         换行\n\\r         回车\n\\t         水平制表\n\\u*xxxx*   十六进制编码通用字符 *xxxx*\n           \n\n双引号的转义序列是多余的，因为 '\"' 和 '\"' 表示相同的字符——提供这两种形式是为了支持与字符串文字相同的转义序列（第 [2.2.0] 节（http: //leino.science/papers/krml243.html#sec-string))。 在 \\u*xxxx* 形式中，u 总是小写，但四个十六进制数字不区分大小写。 字符值是有序的，可以使用标准关系运算符进行比较：\n\n      \n操作符   描述\n      \n<     少于\n<=    至多\n>=    至少\n>     大于\n      \n\n字符序列表示字符串，如第 2.2.0 节所述。(http://leino.science/papers/krml243.html#sec-string).\n\n\n# 1. 类型参数\n\ndafny 中的许多类型（以及函数和方法）都可以通过类型进行参数化。 这些类型参数通常在尖括号内声明，可以代表任何类型。 有时需要限制这些类型参数，以便它们只能由某些类型的系列实例化。 因此，dafny 不仅在幽灵上下文中而且在编译上下文中区分支持相等操作的类型。 为了表明一个类型参数被限制为这种支持平等的类型，类型参数的名称采用后缀“(==)”。[0](http://leino.science/papers/krml243. html#fn-fn-type-mode) 例如，\n\nmethod compare〈t(==)〉(a: t, b: t) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\n是一种方法，其类型参数仅限于支持相等的类型。 同样，请注意 all 类型在 ghost 上下文中支持相等； 区别仅适用于非幽灵（即编译）代码。 共归纳数据类型、函数类型以及带有幻像参数的归纳数据类型是不支持等式的类型的示例。 dafny 有一些推理支持，可以使某些签名不那么混乱（在 dafny 语言参考的不同部分中进行了描述）。 在某些情况下，这种支持会推断出必须将类型参数限制为支持相等的类型，在这种情况下，dafny 会自动添加“(==)”。\n\n\n# 2. 集合类型\n\ndafny 提供了几种内置的集合类型。\n\n\n# 2.0. 集合\n\n对于任何类型 t，set〈t〉 类型的每个值都是 t 值的有限集合。 集合成员资格由类型 t 中的相等性确定，因此只有当t 支持相等性时，set〈t〉 才能在非幽灵上下文中使用。 可以使用 set display 表达式形成一个集合，该表达式可能是一个空的、无序的、不区分重复的表达式列表，用花括号括起来。 为了显示，\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\n是设置显示的三个示例。 还有一个 set comprehension 表达式（带有活页夹，就像在逻辑量化中一样），在 dafny 语言参考的不同部分进行了描述。 除了相等和不相等之外，集合类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真子集\n<=    子集\n>=    超集\n>     真超集\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 集合支持以下二元运算符，按绑定能力递增的顺序列出：\n\n      \n操作符   描述\n      \n!!    不相交\n      \n+     设置联合\n-     设置差异\n      \n*     设置交点\n      \n\n+、- 和 * 的结合性规则类似于同名算术运算符的结合性规则。 表达式a !! b，它的约束力与相等性相同（但它既不与相等性联系也不连锁），说集合a和b没有共同的元素，也就是说，它等价于\n\na * b == {}\n\n\n1\n\n\n但是，不相交运算符是链式的，所以 a !! b !! c !! d表示：\n\na * b == {} && (a + b) * c == {} && (a + b + c) * d == {}\n\n\n1\n\n\n此外，对于任何set〈t〉类型的集合s和任何t类型的表达式e，集合支持以下操作：\n\n          \n表达式       描述\n          \n|s|       集合基数\ne in s    集合成员\ne !in s   集合非成员\n          \n\n表达式 e !in s 是 !(e in s) 的语法简写。\n\n\n# 2.1. multisets\n\nmultiset 类似于集合，但跟踪每个元素的多重性，而不仅仅是它的存在或不存在。 对于任何类型 t，multiset〈t〉 类型的每个值都是从 t 值到表示每个元素的多重性的自然数的映射。 dafny 中的多重集是有限的，也就是说，它们包含有限数量的每个有限元素。 换句话说，多重集仅将有限数量的元素映射到非零（有限）多重性。 与集合一样，多集成员资格由类型“t”中的相等性确定，因此只有当“t”支持相等时，“多集〈t〉”才能在非幽灵上下文中使用。 可以使用 multiset display 表达式来形成多重集，该表达式可能是一个空的、无序列的表达式列表，包含在关键字 multiset 后面的花括号中。 为了显示，\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\n是多组显示的三个示例。 没有多集理解表达式。 除了相等和不相等之外，多重集类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真多集子集\n<=    多集子集\n>=    多集超集\n>     真多集超集\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 多重集支持以下二元运算符，按绑定能力递增的顺序列出：\n\n      \n操作符   描述\n      \n!!    多集不相交\n      \n+     多集联合\n-     多集差异\n      \n*     多集交集\n      \n\n+、- 和 * 的结合性规则类似于同名算术运算符的结合性规则。 表达式'a !! b表示多重集a和b` 没有共同的元素，也就是说，它等价于\n\na * b == multiset{}\n\n\n1\n\n\n与类似的集合运算符一样，!! 是链式的。 此外，对于任何类型为multiset〈t〉的多重集s、类型为t的表达式e和基于非负整数的数字n，多重集支持以下操作：\n\n            \n表达式         描述\n            \n|s|         多集基数\ne in s      多集成员\ne !in s     多集非成员\ns[e]        e 在 s 中的多样性\ns[e := n]   多集更新 (多样性变化)\n            \n\n当且仅当 s[e] != 0 时，表达式 e in s 才会返回 true。 表达式 e !in s 是 !(e in s) 的语法简写。 表达式 s[e := n] 表示类似于 s 的多重集，但元素 e 的多重性是 n。 请注意，多重集更新 s[e := 0] 会产生类似 s 的多重集，但不会出现任何 e（无论 s 首先是否出现过e）。 作为另一个示例，请注意 s - multiset{e} 等价于：\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2. 序列\n\n对于任何类型“t”，“seq〈t〉”类型的值表示“t”元素的序列，即从连续自然数的有限集合（称为indicies）到“t”的映射 `价值观。 （将其视为一个映射，因此序列是多重集的对偶。）可以使用 sequence display 表达式形成序列，该表达式可能是一个包含在方括号中的空的、有序的表达式列表。 为了阐释，\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\n是顺序显示的三个示例。 没有序列理解表达式。 除了相等和不相等之外，序列类型还支持以下关系运算：\n\n      \n操作符   描述\n      \n<     真前缀\n<=    前缀\n      \n\n与算术关系运算符一样，这 些运算符是链接的。 注意没有>和>=。 序列支持以下二元运算符：\n\n      \n操作符   描述\n      \n+     连接\n      \n\n运算符 + 是关联的，就像同名的算术运算符一样。 此外，对于任何类型为“seq〈t〉”的序列“s”，类型为“t”的表达式“e”，基于整数的数字“i”满足“0 <= i < |s|”，以及整数- 基于数字 lo 和 hi 满足 0 <= lo <= hi <= |s|，序列支持以下操作：\n\n              \n表达式           描述\n              \n|s|           序列长度\ns[i]          序列选择\ns[i := e]     序列更新\ne in s        序列成员\ne !in s       序列非成员\ns[lo..hi]     子序列\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   切片\nmultiset(s)   序列转换为 multiset〈t〉\n              \n\n表达式 s[i := e] 返回一个类似 s 的序列，除了索引 i 处的元素是 e。 表达式 e in s 表示存在一个索引 i 使得 s[i] == e。 仅当元素类型“t”支持相等时，才允许在非幽灵上下文中使用。 表达式 e !in s 是 !(e in s) 的语法简写。\n\n表达式 s[lo..hi] 产生一个序列，该序列通过获取第一个 hi 元素然后删除第一个 lo 元素而形成。 因此，结果序列的长度为“hi - lo”。 请注意，s[0..|s|] 等于 s。 如果省略上限，则默认为 |s|，因此 s[lo..] 会生成通过删除 s 的第一个 lo 元素形成的序列。 如果省略下限，则默认为 0，因此 s[..hi] 产生由 s 的第一个 hi 元素形成的序列。\n\n在序列切片操作中，slices 是一个长度指示符的非空列表，由冒号分隔并可选地终止，并且至少有一个冒号。 每个长度指示符都是一个基于非负整数的数字，其总和不大于|s|。 如果有 k 个冒号，则该操作会从 s 生成 k 个连续子序列，每个长度由相应的长度指示符指示，并将这些作为序列序列返回。1 如果 slices 以冒号结尾，那么最后一个切片的长度会一直延伸到 s 的末尾，即 它的长度是|s|减去给定长度指示符的总和。 例如，对于任何长度至少为 10 的序列 s ，以下等式成立：\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n操作multiset(s)产生序列s的元素的多重集。 仅当元素类型“t”支持相等时，才允许在非幽灵上下文中使用。\n\n# 2.2.0. 字符串\n\n序列类型的一个特例是seq〈char〉，dafny 提供了一个同义词：string。 字符串与其他序列类似，但为序列显示表达式提供了额外的语法，即字符串文字。 字符串文字有两种语法形式：标准形式和逐字形式。\n\n标准形式的字符串文字用双引号括起来，如 \"dafny\"。 要在这样的字符串文字中包含双引号，必须使用转义序列。 转义序列也可用于包含其他字符。 支持的转义序列与字符文字相同，请参阅第 [0.2] 节(http://leino.science/papers/krml243.html#sec-char)。 例如，dafny 表达式 \"say \\\"yes\\\"\" 表示字符串 say \"yes\"。 单引号的转义序列是多余的，因为 \"'\" 和 \"'\" 表示相同的字符串——提供这两种形式是为了支持与字符文字相同的转义序列。\n\n逐字形式的字符串文字用 @\" 和 \" 括起来，如 @\"dafny\"。 要在这样的字符串文字中包含双引号，必须使用转义序列“”，即两次写入字符。 在逐字形式中，没有其他转义序列。 甚至像换行符这样的字符也可以写在字符串文字中（因此在程序文本中跨越多行）。 例如，以下三个表达式表示相同的字符串：\n\n\"c:\\\\tmp.txt\"\n@\"c:\\tmp.txt\"\n['c', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\n由于字符串是序列，因此在它们上定义了关系运算符 < 和 <=。 但是请注意，这些运算符仍然分别表示正确的前缀和前缀，而不是可能需要的某种字母比较，例如，在对字符串进行排序时。\n\n\n# 2.3. 有限与无限图\n\n对于任何类型t和u，map〈t，u〉类型的值表示从t到u的*（有限）映射*。 换句话说，它是一个由t索引的查找表。 地图的 domain 是一组有限的 t 值，它们具有关联的 u 值。 由于域中的键是使用 t 类型中的相等性进行比较的，因此只有当t 支持相等性时，类型map〈t,u〉 才能在非幽灵上下文中使用。\n\n类似地，对于任何类型 t 和 u，imap⟨t,u⟩ 类型的值表示*（可能）无限映射*。 在大多数情况下，imap<t,u> 类似于 map<t,u>，但是 imap<t,u> 类型的映射允许有一个无限域。\n\n可以使用 map display 表达式形成地图，该表达式可能是一个空的、有序的 maplets 列表，每个 maplet 具有 t := u 的形式，其中 t 是 t 类型的表达式，并且 u 是u 类型的表达式，放在关键字map 后面的方括号中。 为了显示，\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\n是地图显示的三个示例。 通过使用关键字 imap 而不是 map，生成的地图将是 imap<t,u> 类型而不是 map<t,u>。 请注意，允许无限映射 (imap) 具有有限域，而不允许有限映射 (map) 具有无限域。 如果同一个键出现多次，则结果映射中只出现最后一次出现。2 还有一个 * 地图理解表达式*，在 dafny 语言参考的不同部分进行了解释。\n\n对于map<t,u>类型的任何映射fm，map<t,u>或imap<t,u>类型的任何映射m，类型的任何表达式t t，u类型的任何表达式u，以及m域中的任何d（即满足d in m`），映射支持以下操作：\n\n            \n表达式         描述\n            \n|fm|        地图基数\nm[d]        地图选择\nm[t := u]   地图更新\nt in m      映射域成员\nt !in m     映射域非成员\n            \n\n|fm| 表示fm 中的映射个数，即fm 的域的基数。 请注意，无限映射不支持基数运算符。 表达式 m[d] 返回 m 与 d 关联的 u 值。 表达式 m[t := u] 是一个类似于 m 的映射，除了键 t 处的元素是 u。\n\n表达式 t in m 表示 t 在 m 的域中，而 t !in m 是 !(t in m) 的语法简写。 3 这是一个小例子，其中类型为 map<int,real> 的地图 cache 用于缓存 joule-thomson 系数的计算值 给定温度下的一些固定气体：\n\nif k in cache {  // check if temperature is in domain of cache\n  coeff := cache[k];  // read result in cache\n} else {\n  coeff := computejoulethomsoncoefficient(k);  // do expensive computation\n  cache := cache[k := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3. 象征类型\n\n有时通过多个名称了解一个类型或抽象地处理一个类型很有用。\n\n\n# 3.0. 同义词类型\n\n类型同义词声明：\n\ntype y〈t〉 = g\n\n\n1\n\n\n声明 y〈t〉 是类型 g 的同义词。 这里，t 是一个类型参数的非空列表（每个参数都可选地用后缀“(==)”指定），它可以用作g 中的自由类型变量。 如果同义词没有类型参数，则删除“〈t〉”。 在所有情况下，类型同义词只是同义词。 也就是说，除了可能产生的错误消息之外，y〈t〉 和 g 之间从来没有区别。\n\n例如，以下类型同义词的名称可能会提高程序的可读性：\n\ntype replacements〈t〉 = map〈t,t〉\ntype vertex = int\n\n\n1\n2\n\n\n如第 2.2.0 中所述，string 是seq〈char〉 的内置类型同义词，好像 它将被宣布如下：\n\ntype string = seq〈char〉\n\n\n1\n\n\n\n# 3.1. 不透明类型\n\n类型同义词的一个特例是未指定的。 这样的类型简单地通过以下方式声明：\n\ntype y〈t〉\n\n\n1\n\n\n它被称为不透明类型。 它的定义可以在精炼模块中显示。 为了表明 y 表示支持相等的类型，可以在名称“y”之后紧跟“(==)”。\n\n例如，声明\n\ntype t\nfunction f(t: t): t\n\n\n1\n2\n\n\n可用于在某个任意类型“t”上建模未解释的函数“f”。 作为另一个例子，\n\ntype monad〈t〉\n\n\n1\n\n\n可以抽象地用于表示任意参数化的 monad。\n\n\n# 4. 数据类型\n\ndafny 提供了两种代数数据类型，一种是归纳定义的，另一种是协归纳定义的。 每个数据类型的显着属性是该类型的每个值唯一标识数据类型的构造函数之一，并且每个构造函数的参数都是单射的。\n\n\n# 4.0. 归纳类型\n\n归纳数据类型的值可以看作是有限树，其中叶子是基本类型、数值类型、引用类型、共归纳数据类型或函数类型的值。 实际上，可以使用 dafny 有根据的 < 排序来比较归纳数据类型的值。\n\n归纳数据类型声明如下：\n\ndatatype d〈t〉 = ctors\n\n\n1\n\n\n其中 *ctors* 是一个非空的 | 分隔的 (datatype) 构造函数 的数据类型列表。 每个构造函数都有以下形式：\n\nc(params)\n\n\n1\n\n\n其中 *params* 是一个逗号分隔的类型列表，前面可选参数名称和冒号，前面可选关键字 ghost。 如果构造函数没有参数，则可以省略构造函数名称后面的括号。 如果没有构造函数接受参数，则该类型通常称为枚举； 例如：\n\ndatatype friends = agnes | agatha | jermaine | jack\n\n\n1\n\n\n对于每个构造函数 c，dafny 定义了一个 discriminator c?，它是一个返回 true 的成员，当且仅当数据类型值是使用 c 构造的。 对于构造函数 c 的每个命名参数 p，dafny 定义了一个 destructor p，它是从用于构造数据类型值的 c 调用返回 p 参数的成员； 它的使用要求 c? 成立。 例如，对于标准的 list 类型\n\ndatatype list〈t〉 = nil | cons(head: t, tail: list〈t〉)\n\n\n1\n\n\n以下成立：\n\ncons(5, nil).cons? && cons(5, nil).head == 5\n\n\n1\n\n\n注意表达式\n\ncons(5, nil).tail.head\n\n\n1\n\n\n格式不正确，因为 cons(5, nil).tail 不满足 cons?。\n\n析构函数的名称在数据类型的所有构造函数中必须是唯一的。 构造函数可以与封闭数据类型同名； 这对于通常称为记录类型的单构造函数数据类型特别有用。 例如，黑白像素的记录类型可能表示如下：\n\ndatatype pixel = pixel(x: int, y: int, on: bool)\n\n\n1\n\n\n要调用构造函数，通常只需要提及构造函数的名称，但如果这不明确，则始终可以通过数据类型的名称来限定构造函数的名称。 比如上面的cons(5, nil)可以写成\n\nlist.cons(5, list.nil)\n\n\n1\n\n\n作为显式调用数据类型构造函数的替代方法，可以使用 datatype update 表达式将数据类型值构造为一个参数从给定数据类型值的变化。 对于任何类型为数据类型的“d”，该数据类型包括构造函数“c”，该构造函数具有名为“f”的类型为“t”的参数（析构函数），以及任何类型为“t”的表达式“t”，\n\nd[f := t]\n\n\n1\n\n\n构造一个类似于 d 但其 f 参数是 t 的值。 该操作要求 d 满足 c?。 例如，以下等式成立：\n\ncons(4, nil)[tail := cons(3, nil)] == cons(4, cons(3, nil))\n\n\n1\n\n\n\n# 4.1. 元组类型\n\ndafny 构建了对应于元组的记录类型，并为它们提供了一种方便的特殊语法，即括号。 例如，可能已声明为：\n\ndatatype pair〈t,u〉 = pair(0: t, 1: u)\n\n\n1\n\n\ndafny 提供了类型 (t, u) 和构造函数 (t, u)，好像数据类型的名称是“”，并且它的类型参数在圆括号中给出，并且好像构造函数名称是“” . 请注意，析构函数名称是“0”和“1”，它们是成员的合法标识符名称。 例如，显示元组析构函数的使用，这里有一个包含 2 元组的属性（即 pairs）：\n\n(5, true).1 == true\n\n\n1\n\n\ndafny 声明 n 元组，其中 n 为 0 或 2 或更高。 没有 1 元组，因为围绕单个类型或单个值的括号没有语义意义。 0 元组类型 () 通常被称为 unit 类型，它的单个值，也写作 ()，被称为 unit。\n\n\n# 4.2. 共同归纳类型\n\n尽管 dafny 坚持认为有一种方法可以从头开始构造每个归纳数据类型值，但 dafny 还支持 co-inductive datatypes，其构造函数被延迟评估，因此允许无限结构。 使用关键字“codatatype”声明共归纳数据类型； 除此之外，它像归纳数据类型一样被声明和使用。\n\n例如,\n\ncodatatype ilist〈t〉 = nil | cons(head: t, tail: ilist〈t〉)\ncodatatype stream〈t〉 = more(head: t, tail: stream〈t〉)\ncodatatype tree〈t〉 = node(left: tree〈t〉, value: t, right: tree〈t〉)\n\n\n1\n2\n3\n\n\n分别声明可能无限的列表（即可以是有限或无限的列表）、无限流（即始终无限的列表）和无限二叉树（即每个分支永远存在的树）。\n\n\n# 5. 参照类型\n\ndafny 提供了许多参考类型。 这些代表对程序堆中动态分配的对象的引用。 要访问对象的成员，对对象的引用（即指针 或对象标识）被取消引用。\n\n特殊值 null 是每个引用类型的一部分。4\n\n\n# 5.0. 类\n\nclass c 是一个引用类型，声明如下：\n\nclass c〈t〉 extends j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\n其中类型参数列表t是可选的，“extends j”也是如此，它表示该类扩展了一个特征“j”。 类的成员是 fields、functions 和 methods。 这些是通过取消引用对“c”实例的引用来访问或调用的。 除非函数或方法声明为 static，否则函数或方法会在 c 的 instance 上调用。 机械地，这只是意味着该方法采用隐式 receiver 参数，即用于访问成员的实例。 在实例函数或方法的规范和主体中，接收器参数可以通过关键字 this 显式引用。 但是，在这样的地方，this的成员也可以无条件地被提及。 为了说明，合格的 this.f 和不合格的 f 在以下示例中指的是同一对象的同一字段：\n\nclass c {\n  var f: int;\n  method example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以方法体总是将 true 分配给输出参数 b。 对同一接收者和成员的合格和不合格访问之间没有语义差异。\n\n一个 c 实例是使用 new 创建的，例如：\n\nc := new c;\n\n\n1\n\n\n请注意，new 只是分配一个 c 对象并返回对它的引用； 其字段的初始值是它们各自类型的任意值。 因此，通常在创建后立即调用称为 initialization method 的方法，例如：\n\nc := new c;\nc.initfromlist(xs, 3);\n\n\n1\n2\n\n\n当初始化方法没有out-parameter并且修改不超过this时，那么上面的两个语句可以合并为一个：\n\nc := new c.initfromlist(xs, 3);\n\n\n1\n\n\n请注意，一个类可以包含多个初始化方法，这些方法可以随时调用，而不仅仅是作为new的一部分，并且new不需要在创建时调用初始化方法。\n\n要编写结构化的面向对象程序，通常依赖于仅以特定方式构造对象。 为此，dafny 提供了 constructor (method)s，这是一种受限形式的初始化方法。 构造函数是用关键字constructor而不是method声明的。 当一个类包含构造函数时，对该类的每次调用 new 都必须伴随对构造函数之一的调用。 此外，不能在其他时间调用构造函数，只能在对象创建期间调用。 除了这些限制之外，使用普通初始化方法和使用构造函数之间没有语义上的区别。\n\ndafny 设计允许命名构造函数，这促进了使用上面的“initfromlist”之类的名称。 尽管如此，许多类只有一个构造函数或有一个典型的构造函数。 因此，dafny 允许一个匿名构造函数，即名称本质上是“”的构造函数。 例如：\n\nclass item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n调用此构造函数时，会删除“.”，如下所示：\n\nm := new item(45, 29);\n\n\n1\n\n\n请注意，匿名构造函数只是命名构造函数的一种方式； 也可以有其他构造函数。\n\n\n# 5.1. 数组\n\ndafny 支持任何正维度的可变固定长度数组类型。 数组类型是引用类型。\n\n# 5.1.0. 一维数组\n\nn t 元素的一维数组创建如下：\n\na := new t[n];\n\n\n1\n\n\n数组元素的初始值是“t”类型的任意值。 使用不可变的 length 成员检索数组的长度。 例如上面分配的数组满足：\n\na.length == n\n\n\n1\n\n\n对于 0 <= i < a.length 范围内的任何基于整数的数字 i，array selection 表达式 a[i] 检索元素 i（即，前面有 i 数组中的元素）。 可以使用数组更新语句将存储在 i 的元素更改为值 t：\n\na[i] := t;\n\n\n1\n\n\n警告：由new t[n]创建的数组类型是array〈t〉。 一个容易犯的错误是在 new 后面写 array<t> 而不是 t。 例如，考虑以下情况：\n\nvar a := new array〈t〉;\nvar b := new array〈t〉[n];\nvar c := new array〈t〉(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\n第一条语句分配了一个类型为 array〈t〉 的数组，但长度未知。 第二个分配一个长度为“n”的“array〈array〈t〉〉”类型的数组，即一个包含“n”类型的“array〈t〉”值的数组。 第三条语句分配一个类型为array〈t〉的数组，然后尝试调用这个数组的匿名构造函数，传递参数n。 由于array没有构造函数，更不用说匿名构造函数了，这个语句会产生错误。 如果对于需要类型参数的类型省略了类型参数列表，dafny 将尝试填写这些，因此只要可以推断出array类型参数，就可以省略“〈t〉 ” 在上面的第四个语句中。 但是，与第三条语句一样，array` 没有匿名构造函数，因此会生成错误消息。\n\n一维数组支持将一系列连续元素转换为序列的操作。 对于任何类型为array〈t〉的数组a，基于整数的数字lo和hi满足0 <= lo <= hi <= a.length，以下操作各自产生一个seq 〈t〉：\n\n            \n表达式         描述\n            \na[lo..hi]   子数组转为序列\na[lo..]     drop\na[..hi]     take\na[..]       数组转换为序列\n            \n\n表达式 a[lo..hi] 获取数组的第一个 hi 元素，然后删除其中的第一个 lo 元素并返回剩余的序列。 因此，结果序列的长度为“hi - lo”。 其他操作是第一个操作的特殊实例。 如果省略 lo，则默认为 0，如果省略 hi，则默认为 a.length。 在最后一个操作中，lo 和 hi 都被省略了，因此 a[..] 返回由 a 的所有数组元素组成的序列。\n\n子数组操作在规范中特别有用。 例如，使用变量“lo”和“hi”来划分仍然可以找到搜索“key”的子数组的二分搜索算法的循环不变量可以表示如下：\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\n另一个用途是说某个范围的数组元素自方法开始以来没有改变：\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\n或从循环开始：\n\nghost var prevelements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevelements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意这个例子中的prevelements的类型是seq<t>，如果a的类型是array<t>。\n\n子数组操作的最后一个示例在于表示数组的元素是方法开头的数组元素的排列，就像在大多数排序算法中所做的那样。 在这里，子数组操作与序列到多集的转换相结合：\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1. 多维数组\n\n2 维或更多维的数组大多类似于一维数组，不同之处在于 new 需要更多长度参数（每个维度一个），并且数组选择表达式和数组更新语句需要更多索引。 例如：\n\nmatrix := new t[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\n创建一个二维数组，其维度的长度分别为“m”和“n”，然后交换“i,j”和“x,y”处的元素。 matrix 的类型是 array2<t>，对于高维数组（array3<t>、array4<t> 等）也是如此。 但是请注意，没有类型 array0<t>，本来可以是 array1<t> 的东西实际上只是命名为 array<t>。\n\n上面的 new 操作要求 m 和 n 是基于非负整数的数字。 可以使用不可变字段 length0 和 length1 检索这些长度。 例如，以下保存了上面创建的数组：\n\nmatrix.length0 == m && matrix.length1 == n\n\n\n1\n\n\n高维数组类似（length0、length1、length2、...）。 数组选择表达式和数组更新语句要求索引在范围内。 例如，上面的交换语句只有在以下情况下才是格式正确的：\n\n0 <= i < matrix.length0 && 0 <= j < matrix.length1 &&\n0 <= x < matrix.length0 && 0 <= y < matrix.length1\n\n\n1\n2\n\n\n与一维数组相比，没有将元素的延伸从多维数组转换为序列的操作。\n\n\n# 5.2. 特征\n\ntrait 是一个“抽象超类”，或者称它为“接口”或“mixin”。 特征对 dafny 来说是新的，并且可能会发展一段时间。 一个 trait 的声明很像一个类的声明：\n\ntrait j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\n其中 *members* 可以包含字段、函数和方法，但不能包含构造函数方法。 允许将函数和方法声明为“静态”。\n\n扩展特征“j”的引用类型“c”可以分配给“j”，但不能反过来。 j 的成员可以作为c 的成员使用。 j 中的成员不允许在c 中重新声明，除非该成员是在j 中没有主体的非static 函数或方法。 通过这样做，类型“c”可以为成员提供更强大的规范和主体。\n\nnew 不允许与特征一起使用。 因此，没有分配类型是特征的对象。 但是当然可以有一个类 c 的对象实现了一个特征 j ，并且对这样一个 c 对象的引用可以用作类型 j 的值。\n\n例如，以下特征表示可移动的几何形状：\n\ntrait shape\n{\n  function method width(): real\n    reads this\n  method move(dx: real, dy: real)\n    modifies this\n  method moveh(dx: real)\n    modifies this\n  {\n    move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n成员 width 和 move 是 abstract （即无主体），并且可以由扩展 trait 的不同类以不同方式实现。 方法 moveh 的实现在 trait 中给出，因此被所有扩展 shape 的类使用。 这里有两个类，每个类都扩展了“shape”：\n\nclass unitsquare extends shape\n{\n  var x: real, y: real;\n  function method width(): real {  // note the empty reads clause\n    1.0\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass lowerrighttriangle extends shape\n{\n  var xnw: real, ynw: real, xse: real, yse: real;\n  function method width(): real\n    reads this\n  {\n    xse - xnw\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    xnw, ynw, xse, yse := xnw + dx, ynw + dy, xse + dx, yse + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n请注意，类可以声明其他成员，它们为特征的抽象成员提供实现，它们重复成员签名，并且它们负责提供自己的成员规范，这些规范既加强了特征中的相应规范，又是 对提供的机构感到满意。 最后，这是一些创建两个类实例并将它们一起用作形状的代码:\n\nvar myshapes: seq〈shape〉;\nvar a := new unitsquare;\nmyshapes := [a];\nvar tri := new lowerrighttriangle;\nmyshapes := myshapes + [tri];  // myshapes contains two shape values, of different classes\nmyshapes[1].moveh(myshapes[0].width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3. 类型 object\n\n有一个内置的引用类型object，它就像所有引用类型的超类型。5 type object 是为了启用对动态帧的统一处理。 特别是，保留类型为 set〈object〉 的幽灵字段（通常命名为repr` 表示“表示”）很有用。\n\n\n# 5.4. 迭代器类型\n\niterator 为编写迭代返回元素的代码提供了编程抽象。 这些 clu 风格的迭代器是协同例程，因为它们跟踪自己的程序计数器，并且控制可以传入和传出迭代器主体。\n\n迭代器声明如下：\n\niterator iter〈t〉(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中 t 是类型参数的列表（通常，如果没有类型参数，则省略“〈t〉”）。 这个声明产生了一个同名的引用类型，iter〈t〉。 在签名中，in-parameters 和 yield-parameters 是迭代器对方法的 in-parameters 和 out-parameters 的模拟。 不同之处在于，方法的输出参数只返回给调用者一次，而迭代器的 yield 参数在迭代器主体执行 yield 时返回。 规范的详细信息在 dafny 语言参考的不同部分中进行了描述。 主体由语句组成，就像在方法主体中一样，但也可以使用 yield 语句。\n\n从迭代器客户端的角度来看，iterator 声明可以理解为生成具有各种成员的类iter〈t〉，下面将描述其简化版本。\n\n`iter〈t〉 类包含一个匿名构造函数，其参数是迭代器的内参数：\n\npredicate valid()\nconstructor (in-params)\n  modifies this\n  ensures valid()\n\n\n1\n2\n3\n4\n\n\n使用 new 和这个匿名构造函数创建了一个迭代器。 例如，一个愿意从 start 返回十个连续整数的迭代器可以声明如下：\n\niterator gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个迭代器的一个实例是使用以下方法创建的：\n\niter := new gen(30);\n\n\n1\n\n\n谓词“valid()”表示迭代器何时处于可以尝试计算更多元素的状态。 它是构造函数的后置条件，出现在“movenext”成员的规范中：\n\nmethod movenext() returns (more: bool)\n  requires valid()\n  modifies this\n  ensures more ==> valid()\n\n\n1\n2\n3\n4\n\n\n请注意，只要 movenext 返回 true，迭代器仍然有效。 一旦 movenext 返回 false，就不能再调用 movenext 方法。 请注意，客户端没有义务继续调用 movenext 直到它返回 false，并且允许迭代器的主体永远保持返回元素。\n\n迭代器的输入参数存储在迭代器类的不可变字段中。 为了根据上面的示例进行说明，迭代器类“gen”包含以下字段：\n\nvar start: int;\n\n\n1\n\n\n产量参数也导致迭代器的成员 class:\n\nvar x: int;\n\n\n1\n\n\n这些字段由“movenext”方法设置。 如果 movenext 返回 true，则这些字段中提供了最新的收益率值，客户端可以从那里读取它们。\n\n为了帮助编写规范，迭代器类还包含保留“movenext”返回值的历史记录的幽灵成员。 这些幽灵字段的名称跟在 yield 参数的名称之后，并在名称后面附加了一个“s”（表示复数）。 名称检查规则确保这些名称不会引起歧义。 因此，上述“gen”的迭代器类包含：\n\nghost var xs: seq〈int〉;\n\n\n1\n\n\n这些历史字段由“movenext”自动更改，但不能由用户代码分配。\n\n最后，迭代器类包含一些用于规范的特殊字段。 特别是，迭代器规范记录在以下不可变字段中：\n\nghost var _reads: set〈object〉;\nghost var _modifies: set〈object〉;\nghost var _decreases0: t0;\nghost var _decreases1: t1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\n其中，迭代器的 decreases 子句的每个组件都有一个 _decreases*i*: t*i* 字段。 [6](http://leino.science/papers/krml243.html#fn-fn-iterator -field-names) 另外还有一个字段：\n\nghost var _new: set〈object〉;\n\n\n1\n\n\n代表迭代器主体分配的任何对象都将添加到其中。 迭代器主体可以从 _new 集中删除元素，但不能通过赋值给 _new 添加任何元素。\n\n请注意，在迭代器的前提条件中，即坚持构造迭代器，内参数确实是内参数，而不是 this 的字段。\n\n\n# 5.5. 异步任务类型\n\ndafny 中另一个可能会经历一些演变的实验性功能是异步方法。 调用异步方法时，它不会返回 out-parameters 的值，而是返回 *async-task 类型 * 的实例。 在c类中声明的异步方法，具有以下签名：\n\nasync method am〈t〉(in-params) returns (out-params)\n\n\n1\n\n\n也产生了一个异步任务类型am〈t〉（在封闭类之外，类型的名称需要限定c.am〈t〉）。 async-task 类型是一个引用类型，可以理解为一个有各种成员的类，下面介绍它的简化版本。 异步方法的每个类型为x的参数x都会产生一个异步任务类型的不可变幽灵字段：\n\nghost var x: x;\n\n\n1\n\n\n每个y类型的输出参数y都会产生一个字段\n\nvar y: y;\n\n\n1\n\n\n这些字段会在异步方法成功等待时自动更改，但不能由用户代码分配。\n\nasync-task 类型还有一些特殊字段，用于跟踪依赖关系、未完成的任务、新分配的对象等。随着异步方法设计的发展，这些字段将被更详细地描述。\n\n\n# 6. 函数类型\n\n函数是 dafny 中的一等值。 函数类型具有 (t) -> u 的形式，其中 t 是一个以逗号分隔的类型列表，而 u 是一个类型。 t 被称为函数的 domain type(s) 并且 u 是它的 range type。 例如，函数的类型\n\nfunction f(x: int, b: bool): real\n\n\n1\n\n\n是(int, bool) -> real。 参数不允许为ghost。\n\n为了简化函数域由一个类型列表组成的基本情况的外观，在这种情况下可以删除域类型周围的括号，如 t -> u。 在一种类型是元组类型的情况下，这种无害的简化需要额外的解释，因为元组类型也是用括号括起来的。 如果函数接受一个元组参数，则需要额外的一组括号。 例如，函数\n\nfunction g(pair: (int, bool)): real\n\n\n1\n\n\n类型为 ((int, bool)) -> real。 注意必要的双括号。 类似地，不带参数的函数与带 0 元组作为参数的函数不同。 例如，函数\n\nfunction noargs(): real\nfunction z(unit: ()): real\n\n\n1\n2\n\n\n分别有 () -> real 和 (()) -> real 类型。\n\n函数箭头 -> 是右结合的，所以 a -> b -> c 表示 a -> (b -> c)。 另一个关联需要显式括号：(a -> b) -> c。\n\n请注意，命名函数的接收器参数不是类型的一部分。 相反，它在查找函数时使用，然后可以被认为是被捕获到函数定义中。 例如，假设上面的函数“f”在类“c”中声明，而“c”引用了一个“c”类型的对象； 那么，以下是正确的类型：\n\nvar f: (int, bool) -> real := c.f;\n\n\n1\n\n\n而写如下内容是不正确的：\n\nvar f': (c, int, bool) -> real := f;  // not correct\n\n\n1\n\n\n在其类型签名之外，每个函数值都具有三个属性，如下所述。\n\n每个函数都隐含地将堆作为参数。 然而，没有任何函数依赖于整个堆。 函数的一个属性是它在给定输入所依赖的堆位置集上声明的上限。 这让验证者可以确定某些堆修改对某个函数返回的值没有影响。 对于函数f: t -> u和t类型的值t，依赖集表示为f.reads(t)并且具有set〈object〉类型。\n\n函数的第二个属性源于每个函数都可能是部分的。 换句话说，函数的属性是它的前提条件。 对于函数f: t -> u，t类型的参数值t的f的前提条件表示为f.requires(t)并且具有bool类型。\n\n函数的第三个属性更为明显——函数体。 对于函数“f: t -> u”，该函数对“t”类型的输入“t”产生的值表示为“f(t)”，并且具有“u”类型。\n\n请注意，f.reads 和 f.requires 本身就是函数。 假设 f 的类型为 t -> u，而 t 的类型为 t。 那么，f.reads 是 t -> set〈object〉 类型的函数，其 reads 和 requires 属性是：\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires 是 t -> bool 类型的函数，其 reads 和 requires 属性为：\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0. lambda表达式\n\n除了命名函数之外，dafny 还支持定义函数的表达式。 这些被称为 lambda (expression)s（一些语言将它们称为 匿名函数）。 lambda 表达式具有以下形式：\n\n(params) specification => body\n\n\n1\n\n\n其中 *params* 是以逗号分隔的参数声明列表，每个参数声明的形式为 x 或 x: t。 参数的类型‘t’在可以推断时可以省略。 如果不需要标识符x，可以用“_”代替。 如果 *params* 包含一个没有明确类型的参数 x（或 _），则可以删除括号； 例如，返回给定整数的后继的函数可以写成以下 lambda 表达式：\n\nx => x + 1\n\n\n1\n\n\n*specification* 是 requires e 或 reads w 的子句列表，其中 e 是布尔表达式， w 是框架表达式。\n\n*body* 是定义函数返回值的表达式。 对于满足前提条件的参数的所有可能值，主体必须格式正确（就像命名函数和方法的主体一样）。 在某些情况下，这意味着有必要编写明确的 requires 和 reads 子句。 例如，lambda 表达式\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\n如果省略 requires 子句，则格式不正确，因为可能会被零除。\n\n在函数不能是部分的并且对读取堆没有限制的设置中，函数 f: t -> u 的 eta 扩展（即，将 f 包装在这样的 lambda 表达式中） lambda 表达式等价于 f) 的方式将写作 x => f(x)。 在 dafny 中，eta 扩展还必须考虑函数的前提条件和读取集，因此 f 的 eta 扩展如下所示：\n\nx requires f.requires(x) reads f.reads(x) => f(x)\n\n\n1\n\n\n\n# 7. 新类型\n\n可以使用 newtype 声明7 声明新的数字类型\n\nnewtype n = x: m | q\n\n\n1\n\n\n其中“m”是数字类型，“q”是布尔表达式，可以将“x”用作自由变量。 如果m是一个基于整数的数值类型，那么n也是； 如果“m”是实数，那么“n”也是如此。 如果可以从 q 推断出类型 m，则可以省略“:m”。 如果 q 只是 true，那么声明可以简单地给出：\n\nnewtype n = m\n\n\n1\n\n\n类型“m”被称为“n”的基本类型。\n\nnewtype 是一种数字类型，它支持与其基本类型相同的操作。 newtype 与其他数字类型不同且不兼容； 特别是，如果没有显式转换，它就不能分配给它的基本类型。 对 newtype 的操作与其基类型的操作之间的一个重要区别是 newtype 操作仅在结果满足谓词 q 时才被定义，对于 newtype 的字面量也是如此。 [8](http:// /leino.science/papers/krml243.html#fn-fn-newtype-design-question）\n\n例如，假设 lo 和 hi 是基于整数的数字，它们满足 0 <= lo <= hi 并考虑以下代码片段：\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\n如果 lo 和 hi 的类型为 int，那么代码片段是合法的； 特别是，它永远不会溢出，因为 int 没有上限。 相反，如果 lo 和 hi 是新类型 int32 的变量，声明如下：\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\n那么代码片段是错误的，因为加法的结果可能无法满足int32定义中的谓词。 代码片段可以重写为\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\n在这种情况下，int 和 int32 都是合法的。\n\n由于 newtype 与其基类型不兼容，并且由于 newtype 操作的所有结果都是 newtype 的成员，因此 dafny 的编译器可以自由地专门化 newtype 的运行时表示。 例如，通过仔细检查上面 int32 的定义，编译器可能会决定在目标硬件中使用带符号的 32 位整数来存储 int32 值。\n\n请注意，q 中的绑定变量x 的类型为m，而不是n。 n因此，可能无法就“n”值说明“q”。 例如，考虑以下类型的 8 位 2 的补码整数：\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\n并考虑一个类型为int8的变量c。 表达式\n\n-128 <= c < 128\n\n\n1\n\n\n定义不明确，因为比较要求每个操作数的类型为“int8”，这意味着文字“128”被检查为“int8”类型，但事实并非如此。 编写此表达式的正确方法是在 c 上使用转换操作，如下所述，将其转换为基本类型：\n\n-128 <= int(c) < 128\n\n\n1\n\n\n有一个限制，即值0必须是每个新类型的一部分。9\n\n\n# 7.0. 数字转换操作\n\n对于每个数字类型n，都有一个同名的转换函数。 它是一个部分恒等函数。 它是在给定值（可以是任何数字类型）是转换为的类型的成员时定义的。 当从基于实数的数值类型转换为基于整数的数值类型时，该操作要求基于实数的参数没有小数部分。 （要将基于实数的数值向下舍入到最接近的整数，请使用 .trunc 成员，请参阅第 [0.1] 节（http://leino.science/papers/krml243.html#sec-numeric-types）。 )\n\n使用上面的例子来说明，如果 lo 和 hi 的类型是 int32，那么代码片段可以合法地写成如下\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\n其中mid的类型被推断为int。 由于除法的结果值是 int32 类型的成员，因此可以引入另一种转换操作，使 mid 的类型为 int32：\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\n如果编译器确实专门针对int32的运行时表示，那么这些语句的代价是两个或三个运行时转换。\n\n\n# 8. 子集类型\n\n子集类型是对现有类型的限制使用，称为子集类型的基本类型。 子集类型就像基类型和基类型上的谓词的组合使用。\n\n始终允许从子集类型到其基本类型的赋值。 如果分配的值确实满足子集类型的谓词，则允许从基本类型到子集类型的另一个方向的分配。 （注意，相比之下，newtype 和它的基类型之间的赋值是不允许的，即使赋值是目标类型的值。对于这样的赋值，必须使用显式转换，参见第 [7.0]（http: //leino.science/papers/krml243.html#sec-numeric-conversions)。) dafny 支持一种子集类型，即内置类型 nat，其基本类型为 int。[10](http: //leino.science/papers/krml243.html#fn-fn-more-subset-types）\n\n类型nat指定int的非负子范围。 一个很好地使用子集类型“nat”的简单示例是标准斐波那契函数：\n\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\n此函数的等效但笨拙的公式（以调用站点产生的任何错误消息的措辞为模）将使用类型int并在前置条件和后置条件中编写限制谓词：\n\nfunction fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n类型推断永远不会将变量的类型推断为子集类型。 相反，它会将类型推断为子集类型的基本类型。 例如，x 的类型\n\nforall x :: p(x)\n\n\n1\n\n\n将是 int，即使谓词 p 声明其参数的类型为 nat。\n\n# 参考资料\n\n由于 nadia polikarpova 和 paqui lucio 的评论，本文档得到了改进。\n\n----------------------------------------\n\n 0.  支持平等只是人们可以想象的丰富类型系统中的类型拥有的众多模式之一。 例如，其他模式可能包括具有总订单、可零初始化以及可能无人居住。 如果 dafny 将来支持更多模式，“( )”后缀语法可能会被扩展。 目前，后缀只能表示支持平等的模式。 ↩\n 1.  现在dafny支持内置元组，打算把序列切片操作改成返回 不是子序列的序列，而是子序列的元组。 ↩\n 2.  这可能会在未来发生变化，不允许多次出现相同的键。 ↩\n 3.  这在未来可能会改变如下：in和!in 地图将不再支持操作。 相反，对于任何地图 m，m.domain 将返回其域作为一个集合，而 m.range 将返回，也作为一个集合，在其域下的 m 的图像。 ↩\n 4.  这将在 dafny 的未来版本中发生变化，它将同时支持可空和（默认情况下）非 -null 引用类型。 ↩\n 5.  很快，object 将成为一个内置的 trait 而不是内置的特殊 班级。 发生这种情况时，将不再可能执行“新对象”。 object 不能用作类型参数的当前编译器限制也将消失。 ↩\n 6.  将特殊字段_reads和_modifies重命名为相同是有意义的 名称作为相应的关键字，“读取”和“修改”，就像对函数值所做的那样。 此外，各种 _decreases*i* 字段可以组合成一个名为 decreases 的字段，其类型是 n 元组。 ↩\n 7.  是否应该将newtype重命名为numtype？ ↩\n 8.  自动定义“谓词n”有用吗？(m:m){q} `? ↩\n 9.  限制是由于当前编译器的限制。 这将在未来发生变化，也将为子集类型和非空引用类型开辟可能性。 ↩\n 10. dafny 的未来版本将支持用户定义的子集类型。 ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"Style Guide for Dafny programs",frontmatter:{title:"Style Guide for Dafny programs",date:"2022-03-26T17:01:15.000Z",permalink:"/pages/0f17ab/",categories:["资源","常用工具"],tags:"111 -",readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/05.Style%20Guide%20for%20Dafny%20programs.html",relativePath:"40.资源/10.常用工具/05.Style Guide for Dafny programs.md",key:"v-03378743",path:"/pages/0f17ab/",headers:[{level:2,title:"命名约定",slug:"命名约定",normalizedTitle:"命名约定",charIndex:50},{level:2,title:"前缀方法",slug:"前缀方法",normalizedTitle:"前缀方法",charIndex:582},{level:3,title:"代码布局",slug:"代码布局",normalizedTitle:"代码布局",charIndex:68},{level:3,title:"Braces",slug:"braces",normalizedTitle:"braces",charIndex:78},{level:3,title:"Imports",slug:"imports",normalizedTitle:"imports",charIndex:90},{level:2,title:"缩进和换行",slug:"缩进和换行",normalizedTitle:"缩进和换行",charIndex:101},{level:3,title:"制表符还是空格?",slug:"制表符还是空格",normalizedTitle:"制表符还是空格?",charIndex:2136},{level:3,title:"最大字符限制",slug:"最大字符限制",normalizedTitle:"最大字符限制",charIndex:126},{level:3,title:"换行符",slug:"换行符",normalizedTitle:"换行符",charIndex:138},{level:3,title:"函数、方法、谓词和引理",slug:"函数、方法、谓词和引理",normalizedTitle:"函数、方法、谓词和引理",charIndex:147},{level:2,title:"需要避免的事情",slug:"需要避免的事情",normalizedTitle:"需要避免的事情",charIndex:162},{level:3,title:"括号",slug:"括号",normalizedTitle:"括号",charIndex:175},{level:3,title:"空格",slug:"空格",normalizedTitle:"空格",charIndex:117},{level:4,title:"类型声明",slug:"类型声明",normalizedTitle:"类型声明",charIndex:193},{level:4,title:"函数、方法、谓词和引理声明",slug:"函数、方法、谓词和引理声明",normalizedTitle:"函数、方法、谓词和引理声明",charIndex:205},{level:2,title:"建议",slug:"建议",normalizedTitle:"建议",charIndex:222},{level:3,title:"Externs",slug:"externs",normalizedTitle:"externs",charIndex:230},{level:3,title:"需要考虑的事项",slug:"需要考虑的事项",normalizedTitle:"需要考虑的事项",charIndex:243}],headersStr:"命名约定 前缀方法 代码布局 Braces Imports 缩进和换行 制表符还是空格? 最大字符限制 换行符 函数、方法、谓词和引理 需要避免的事情 括号 空格 类型声明 函数、方法、谓词和引理声明 建议 Externs 需要考虑的事项",content:'# Style Guide for Dafny Programmers\n\nDafny 文档\n\n * 命名约定\n   * 方法前缀\n * 代码布局\n   * Braces\n   * Imports\n * 缩进和换行\n   * 制表符还是空格？\n   * 最大字符限制\n   * 换行符\n   * 函数、方法、谓词和引理\n * 需要避免的事情\n   * 括号\n   * 空格\n     * 类型声明\n     * 函数、方法、谓词和引理声明\n * 建议\n   * Externs\n   * 需要考虑的事项\n\n本样式指南提供了 Dafny 代码的编码约定。\n\n此文档仍在进行中。 请随时添加更多建议。\n\n\n# 命名约定\n\n任何变量都以camelCase命名。\n\nvar minValue := 1;\nvar cipherMessage := "Hello World";\n\n\n1\n2\n\n\n任何引理、谓词、函数、方法、类、模块、数据类型和新类型都以PascalCase命名。\n\nmethod FindIndex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\n任何静态或全局 常量 都以 UPPERCASE_WITH_UNDERSCORES 命名。\n\nstatic const MONTHS_IN_A_YEAR := 12\n\n\n1\n\n\n\n# 前缀方法\n\n当变量或方法位于类/模块中时，避免使用冗余名称。\n\nclass Integer {\n\n    // The following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to ToString()\n    // so that the method call is Integer.ToString(i)\n    // instead of Integer.IntegerToString(i).\n\n    // YES\n    method ToString(i: int) returns (s: string)\n        ...\n\n    // NO\n    method IntegerToString(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 代码布局\n\n\n# Braces\n\n默认情况下，左大括号在同一行。\n\nmodule M {\n    ...\n    method Met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果方法（或函数、引理等）签名太长而不能放在一行中，或者如果签名至少有一个规范子句，则左大括号将换行。\n\nmodule M {\n    ...\n    method Met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这适用于每个范围：module、class、predicate、if、while 等等。\n\n\n# Imports\n\n默认情况下，导入模块而不打开它们。\n\nimport Coffee\n...\n\n\n1\n2\n\n\n但是，如果某个模块的某些成员非常频繁地使用，请使用 opened 导入它：\n\nimport opened Donut\n...\n\n\n1\n2\n\n\n当一个文件使用两个模块并且它们都定义同名的方法时，不要将它们导入 opened。\n\nimport MyModule\nimport YourModule\n...\nmethod MyMethod() {\n    MyModule.foo();\n    YourModule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在这种情况下，如果要缩短模块名称，请使用简写名称导入。\n\nimport M = MyModuleWithACumbersomeName\nimport Y = YourModuleWithACumbersomeName\n...\nmethod MyMethod() {\n    M.foo();\n    Y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常见的导入，例如 StandardLibrary 和 Native，应该组合在一起，然后是自定义模块导入，中间有一个空行。\n\nimport opened StandardLibrary\nimport opened Native\n\nimport opened Donut\nimport Coffee\n\n\n1\n2\n3\n4\n5\n\n\n虽然不是必需的，但建议保持 imports 和 includes 的字母顺序，除非将它们按逻辑分组更有意义。\n\n\n# 缩进和换行\n\n\n# 制表符还是空格?\n\n空格优于制表符。 选项卡只能用于与包含选项卡的现有代码保持一致。\n\n每个缩进使用 2 个空格。\n\n\n# 最大字符限制\n\n虽然没有特别的严格要求，但一般建议每行最多 120 个字符。\n\n\n# 换行符\n\n在连续的函数、方法、谓词和引理之间使用换行符，提高代码可读性。\n\n以换行符结束每个文件。\n\n\n# 函数、方法、谓词和引理\n\n每个 Dafny 方法都有以下签名。\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type) returns (ret: Type)\n    requires P()\n    modifies param2\n    ensures Q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\n如果可能，将 MethodName 和 returns 语句放在同一行，因为关键字 returns 与其他方法规范子句不同，例如 requires、modifies、ensures 和 decreases ，应该按这个顺序出现。 每个方法规范子句应该在单独的行上，缩进。\n\n如果 Method 签名太长，我们可以将其分解。\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type,\n        param3: Type, param4: Type, param5: Type)\n    returns (ret1: Type, ret2: Type, ret3: Type, ret4: Type,\n        ret5: Type)\n    requires P1()\n    requires P2()\n    requires P3()\n    modifies param2\n    modifies param3\n    ensures Q1()\n    ensures Q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n多个 requires 或 ensures 可以合并为一个：\n\nrequires\n    && P1()\n    && P2()\n    && P3()\n\n\n1\n2\n3\n4\n\n\n相同的规则适用于 function、predicate 和 lemma 定义。\n\n\n# 需要避免的事情\n\n\n# 括号\n\n在许多情况下，Dafny 不需要在表达式周围加上括号。 这里有些例子。\n\n * If-Else-While 语句\n\n// YES\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// NO\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 带有表达式参数的语句\n\n// YES\nassert x < 100;\nprint x;\n\n// NO\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 简单的布尔/算术表达式\n\n// YES\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// NO\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 空格\n\n避免表达式中不必要的空格。\n\n# 类型声明\n\n类型声明应该具有variableName: variableType的形式。\n\n// YES\nconst one: int := 1\nclass {:extern} Util {\n    var {:extern} Exception: System.String\n}\n\n// NO\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} Util {\n    var {:extern} Exception : System.String // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果 Dafny 可以推断出该类型，请将其省略，除非您认为它在程序中提供了有用的文档。 所以，上面的常量 one 最好声明为\n\nconst one := 1\n\n\n1\n\n\n# 函数、方法、谓词和引理声明\n\nfunction、method、predicate 和 lemma 定义应该具有 FunctionName(parameterName: parameterType, ...) 的形式。\n\n// YES\nfunction method Foo<int>(i: int): int\n\n// NO\nfunction method Foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\nAvoid too little or too much whitespace that reduces the overall readability.\n\n// YES\nlemma MyLemma<A, B>(x: seq<seq<A>>, y: B) {\n    ...\n}\n\n// NO\nlemma MyLemma <A,B> ( x : seq<seq<A>> , y :B){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 建议\n\n本节描述了一些建议，这些建议可以帮助使代码更具可读性和易于遵循，尽管没有严格执行。\n\n\n# Externs\n\n尽可能在 Dafny 和目标语言（例如 C#、Java 等）中将它们命名为相同的名称，这样在 Dafny 中我们只需编写 {:extern}，而不是 {:extern "<name>"}。\n\n\n# 需要考虑的事项\n\n在 Dafny 中设计/实施程序之前思考这些问题。\n\n * 这个变量名/函数名X是个好名字吗？\n * 这个方法M在模块X中有意义吗？ 它不应该在模块 Y 中吗？\n * 定义X是否属于文件Y.dfy？\n * X.dfy 是一个好的文件名吗？',normalizedContent:'# style guide for dafny programmers\n\ndafny 文档\n\n * 命名约定\n   * 方法前缀\n * 代码布局\n   * braces\n   * imports\n * 缩进和换行\n   * 制表符还是空格？\n   * 最大字符限制\n   * 换行符\n   * 函数、方法、谓词和引理\n * 需要避免的事情\n   * 括号\n   * 空格\n     * 类型声明\n     * 函数、方法、谓词和引理声明\n * 建议\n   * externs\n   * 需要考虑的事项\n\n本样式指南提供了 dafny 代码的编码约定。\n\n此文档仍在进行中。 请随时添加更多建议。\n\n\n# 命名约定\n\n任何变量都以camelcase命名。\n\nvar minvalue := 1;\nvar ciphermessage := "hello world";\n\n\n1\n2\n\n\n任何引理、谓词、函数、方法、类、模块、数据类型和新类型都以pascalcase命名。\n\nmethod findindex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\n任何静态或全局 常量 都以 uppercase_with_underscores 命名。\n\nstatic const months_in_a_year := 12\n\n\n1\n\n\n\n# 前缀方法\n\n当变量或方法位于类/模块中时，避免使用冗余名称。\n\nclass integer {\n\n    // the following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to tostring()\n    // so that the method call is integer.tostring(i)\n    // instead of integer.integertostring(i).\n\n    // yes\n    method tostring(i: int) returns (s: string)\n        ...\n\n    // no\n    method integertostring(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 代码布局\n\n\n# braces\n\n默认情况下，左大括号在同一行。\n\nmodule m {\n    ...\n    method met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果方法（或函数、引理等）签名太长而不能放在一行中，或者如果签名至少有一个规范子句，则左大括号将换行。\n\nmodule m {\n    ...\n    method met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这适用于每个范围：module、class、predicate、if、while 等等。\n\n\n# imports\n\n默认情况下，导入模块而不打开它们。\n\nimport coffee\n...\n\n\n1\n2\n\n\n但是，如果某个模块的某些成员非常频繁地使用，请使用 opened 导入它：\n\nimport opened donut\n...\n\n\n1\n2\n\n\n当一个文件使用两个模块并且它们都定义同名的方法时，不要将它们导入 opened。\n\nimport mymodule\nimport yourmodule\n...\nmethod mymethod() {\n    mymodule.foo();\n    yourmodule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在这种情况下，如果要缩短模块名称，请使用简写名称导入。\n\nimport m = mymodulewithacumbersomename\nimport y = yourmodulewithacumbersomename\n...\nmethod mymethod() {\n    m.foo();\n    y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常见的导入，例如 standardlibrary 和 native，应该组合在一起，然后是自定义模块导入，中间有一个空行。\n\nimport opened standardlibrary\nimport opened native\n\nimport opened donut\nimport coffee\n\n\n1\n2\n3\n4\n5\n\n\n虽然不是必需的，但建议保持 imports 和 includes 的字母顺序，除非将它们按逻辑分组更有意义。\n\n\n# 缩进和换行\n\n\n# 制表符还是空格?\n\n空格优于制表符。 选项卡只能用于与包含选项卡的现有代码保持一致。\n\n每个缩进使用 2 个空格。\n\n\n# 最大字符限制\n\n虽然没有特别的严格要求，但一般建议每行最多 120 个字符。\n\n\n# 换行符\n\n在连续的函数、方法、谓词和引理之间使用换行符，提高代码可读性。\n\n以换行符结束每个文件。\n\n\n# 函数、方法、谓词和引理\n\n每个 dafny 方法都有以下签名。\n\nmethod {:<attributes>} methodname(param1: type, param2: type) returns (ret: type)\n    requires p()\n    modifies param2\n    ensures q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\n如果可能，将 methodname 和 returns 语句放在同一行，因为关键字 returns 与其他方法规范子句不同，例如 requires、modifies、ensures 和 decreases ，应该按这个顺序出现。 每个方法规范子句应该在单独的行上，缩进。\n\n如果 method 签名太长，我们可以将其分解。\n\nmethod {:<attributes>} methodname(param1: type, param2: type,\n        param3: type, param4: type, param5: type)\n    returns (ret1: type, ret2: type, ret3: type, ret4: type,\n        ret5: type)\n    requires p1()\n    requires p2()\n    requires p3()\n    modifies param2\n    modifies param3\n    ensures q1()\n    ensures q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n多个 requires 或 ensures 可以合并为一个：\n\nrequires\n    && p1()\n    && p2()\n    && p3()\n\n\n1\n2\n3\n4\n\n\n相同的规则适用于 function、predicate 和 lemma 定义。\n\n\n# 需要避免的事情\n\n\n# 括号\n\n在许多情况下，dafny 不需要在表达式周围加上括号。 这里有些例子。\n\n * if-else-while 语句\n\n// yes\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// no\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 带有表达式参数的语句\n\n// yes\nassert x < 100;\nprint x;\n\n// no\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 简单的布尔/算术表达式\n\n// yes\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// no\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 空格\n\n避免表达式中不必要的空格。\n\n# 类型声明\n\n类型声明应该具有variablename: variabletype的形式。\n\n// yes\nconst one: int := 1\nclass {:extern} util {\n    var {:extern} exception: system.string\n}\n\n// no\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} util {\n    var {:extern} exception : system.string // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果 dafny 可以推断出该类型，请将其省略，除非您认为它在程序中提供了有用的文档。 所以，上面的常量 one 最好声明为\n\nconst one := 1\n\n\n1\n\n\n# 函数、方法、谓词和引理声明\n\nfunction、method、predicate 和 lemma 定义应该具有 functionname(parametername: parametertype, ...) 的形式。\n\n// yes\nfunction method foo<int>(i: int): int\n\n// no\nfunction method foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\navoid too little or too much whitespace that reduces the overall readability.\n\n// yes\nlemma mylemma<a, b>(x: seq<seq<a>>, y: b) {\n    ...\n}\n\n// no\nlemma mylemma <a,b> ( x : seq<seq<a>> , y :b){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 建议\n\n本节描述了一些建议，这些建议可以帮助使代码更具可读性和易于遵循，尽管没有严格执行。\n\n\n# externs\n\n尽可能在 dafny 和目标语言（例如 c#、java 等）中将它们命名为相同的名称，这样在 dafny 中我们只需编写 {:extern}，而不是 {:extern "<name>"}。\n\n\n# 需要考虑的事项\n\n在 dafny 中设计/实施程序之前思考这些问题。\n\n * 这个变量名/函数名x是个好名字吗？\n * 这个方法m在模块x中有意义吗？ 它不应该在模块 y 中吗？\n * 定义x是否属于文件y.dfy？\n * x.dfy 是一个好的文件名吗？',charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"Cheet Sheet",frontmatter:{title:"Cheet Sheet",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/a65c3f/",categories:["资源","常用工具"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Cheet%20Sheet.html",relativePath:"40.资源/10.常用工具/10.Cheet Sheet.md",key:"v-7bba5a2e",path:"/pages/a65c3f/",headers:[{level:2,title:"Specification",slug:"specification",normalizedTitle:"specification",charIndex:1855}],headersStr:"Specification",content:"KEYWORD(S)       WHAT IT DOES             SNIPPET\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { Foo(i);\n                                          }\nmethod returns   subroutines              /* Without a return value*/ method Hello() { print “Hello\n                                          Dafny”; } /*With a return value */ method Norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* Multiple return values */\n                                          method Prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class Point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method Dist2(that: Point) returns\n                                          (z: real) requires that != null { z := Norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          Find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# Specification\n\nKEYWORD(S)             WHAT IT DOES              SNIPPET\nrequires               precondition              method Rot90(p: Point) returns (q: Point) requires p !=\n                                                 null{ q := new Point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.Length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.Length }\nmodifies               framing (for methods)     method Reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to “a” otherwise */\nreads                  framing (for functions)   predicate Sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to “a[_]” otherwise */\ninvariant              loop invariants           i := 0;while i < a.Length invariant 0 <= i <= a.Length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.Length ==> a[k] ==\n                                                 0;",normalizedContent:"keyword(s)       what it does             snippet\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { foo(i);\n                                          }\nmethod returns   subroutines              /* without a return value*/ method hello() { print “hello\n                                          dafny”; } /*with a return value */ method norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* multiple return values */\n                                          method prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method dist2(that: point) returns\n                                          (z: real) requires that != null { z := norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# specification\n\nkeyword(s)             what it does              snippet\nrequires               precondition              method rot90(p: point) returns (q: point) requires p !=\n                                                 null{ q := new point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.length }\nmodifies               framing (for methods)     method reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to “a” otherwise */\nreads                  framing (for functions)   predicate sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to “a[_]” otherwise */\ninvariant              loop invariants           i := 0;while i < a.length invariant 0 <= i <= a.length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.length ==> a[k] ==\n                                                 0;",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"收藏站",frontmatter:{title:"收藏站",date:"2022-03-25T11:48:45.000Z",permalink:"/pages/1b94a4/",categories:["收藏"],tags:[null],readingShow:"top"},regularPath:"/50.%E6%94%B6%E8%97%8F/01.%E6%94%B6%E8%97%8F%E7%AB%99.html",relativePath:"50.收藏/01.收藏站.md",key:"v-99fc7970",path:"/pages/1b94a4/",headers:[{level:2,title:"官方网站",slug:"官方网站",normalizedTitle:"官方网站",charIndex:99},{level:2,title:"文章收藏",slug:"文章收藏",normalizedTitle:"文章收藏",charIndex:111},{level:2,title:"相关社群",slug:"相关社群",normalizedTitle:"相关社群",charIndex:120}],headersStr:"官方网站 文章收藏 相关社群",content:"# Dafny宝藏大全\n\n> 本站点收藏并统计整理了绝大部分Dafny学习资源，各位看官可根据需要自行访问学习。\n\n提示\n\n若有推荐网站或者链接失效的卡片，可以联系站长或在页底评论区留言。\n\n\n# 官方网站\n\n·\n\n\n# 文章收藏\n\n\n# 相关社群",normalizedContent:"# dafny宝藏大全\n\n> 本站点收藏并统计整理了绝大部分dafny学习资源，各位看官可根据需要自行访问学习。\n\n提示\n\n若有推荐网站或者链接失效的卡片，可以联系站长或在页底评论区留言。\n\n\n# 官方网站\n\n·\n\n\n# 文章收藏\n\n\n# 相关社群",charsets:{cjk:!0},lastUpdated:"2022/03/25, 15:04:11",lastUpdatedTimestamp:1648191851e3},{title:"本站 - 导航站模块",frontmatter:{title:"本站 - 导航站模块",date:"2022-01-11T14:03:46.000Z",categories:[null],tags:[null],permalink:"/pages/30bf81/",readingShow:"top"},regularPath:"/60.%E6%94%AF%E6%8C%81/01.%E5%AF%BC%E8%88%AA%E7%AB%99.html",relativePath:"60.支持/01.导航站.md",key:"v-18848ef1",path:"/pages/30bf81/",headers:[{level:2,title:"搜索引擎",slug:"搜索引擎",normalizedTitle:"搜索引擎",charIndex:2},{level:2,title:"前端开发",slug:"前端开发",normalizedTitle:"前端开发",charIndex:11}],headersStr:"搜索引擎 前端开发",content:"# 搜索引擎\n\n\n# 前端开发",normalizedContent:"# 搜索引擎\n\n\n# 前端开发",charsets:{cjk:!0},lastUpdated:"2022/03/25, 01:03:52",lastUpdatedTimestamp:1648141432e3},{title:"Dafny Quick Reference",frontmatter:{title:"Dafny Quick Reference",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8fb957/",categories:["语言","dafny-quick-start"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/00.Dafny%20Quick%20Reference.html",relativePath:"80.语言/00.dafny-quick-start/00.Dafny Quick Reference.md",key:"v-77d4d05b",path:"/pages/8fb957/",headers:[{level:2,title:"基本定义",slug:"基本定义",normalizedTitle:"基本定义",charIndex:439},{level:2,title:"方法 methods",slug:"方法-methods",normalizedTitle:"方法 methods",charIndex:797},{level:3,title:"框架Frame",slug:"框架frame",normalizedTitle:"框架frame",charIndex:1498},{level:3,title:"变体函数 variant function",slug:"变体函数-variant-function",normalizedTitle:"变体函数 variant function",charIndex:1737},{level:3,title:"ghost 关键字",slug:"ghost-关键字",normalizedTitle:"ghost 关键字",charIndex:1883},{level:3,title:"this 关键字",slug:"this-关键字",normalizedTitle:"this 关键字",charIndex:1946},{level:3,title:"构造函数/构造体 constructor",slug:"构造函数-构造体-constructor",normalizedTitle:"构造函数/构造体 constructor",charIndex:2050},{level:3,title:"lemma 关键字",slug:"lemma-关键字",normalizedTitle:"lemma 关键字",charIndex:2356},{level:2,title:"函数 function",slug:"函数-function",normalizedTitle:"函数 function",charIndex:2720},{level:3,title:"类 class",slug:"类-class",normalizedTitle:"类 class",charIndex:3632},{level:3,title:"数据类型 datatypes",slug:"数据类型-datatypes",normalizedTitle:"数据类型 datatypes",charIndex:3732},{level:3,title:"泛型 Generics",slug:"泛型-generics",normalizedTitle:"泛型 generics",charIndex:4387},{level:3,title:"声明 Statement",slug:"声明-statement",normalizedTitle:"声明 statement",charIndex:4691},{level:4,title:"函数/方法的返回值赋值给变量",slug:"函数-方法的返回值赋值给变量",normalizedTitle:"函数/方法的返回值赋值给变量",charIndex:5054},{level:4,title:"assert 声明",slug:"assert-声明",normalizedTitle:"assert 声明",charIndex:5492},{level:4,title:"print 打印语句",slug:"print-打印语句",normalizedTitle:"print 打印语句",charIndex:5539},{level:4,title:"if 选择语句",slug:"if-选择语句",normalizedTitle:"if 选择语句",charIndex:5622},{level:4,title:"while 循环语句",slug:"while-循环语句",normalizedTitle:"while 循环语句",charIndex:5692},{level:4,title:"match语句(阿巴阿巴)",slug:"match语句-阿巴阿巴",normalizedTitle:"match语句(阿巴阿巴)",charIndex:5962},{level:4,title:"break语句",slug:"break语句",normalizedTitle:"break语句",charIndex:6102},{level:2,title:"表达式 Expressions",slug:"表达式-expressions",normalizedTitle:"表达式 expressions",charIndex:6151},{level:3,title:"基本运算符",slug:"基本运算符",normalizedTitle:"基本运算符",charIndex:6217},{level:4,title:"整数运算",slug:"整数运算",normalizedTitle:"整数运算",charIndex:6676},{level:4,title:"离 散 数 学",slug:"离-散-数-学",normalizedTitle:"离 散 数 学",charIndex:6843},{level:4,title:"集合运算",slug:"集合运算",normalizedTitle:"集合运算",charIndex:6964},{level:4,title:"序列运算",slug:"序列运算",normalizedTitle:"序列运算",charIndex:7185},{level:4,title:"if-then-else判断语句",slug:"if-then-else判断语句",normalizedTitle:"if-then-else判断语句",charIndex:7731},{level:4,title:"match匹配表达式",slug:"match匹配表达式",normalizedTitle:"match匹配表达式",charIndex:7894}],headersStr:"基本定义 方法 methods 框架Frame 变体函数 variant function ghost 关键字 this 关键字 构造函数/构造体 constructor lemma 关键字 函数 function 类 class 数据类型 datatypes 泛型 Generics 声明 Statement 函数/方法的返回值赋值给变量 assert 声明 print 打印语句 if 选择语句 while 循环语句 match语句(阿巴阿巴) break语句 表达式 Expressions 基本运算符 整数运算 离 散 数 学 集合运算 序列运算 if-then-else判断语句 match匹配表达式",content:"# 基础学习\n\n此页面说明了 Dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 Dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\nDafny程序长这样：xxxxx.dfy，Dafny文件是以dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main不是必须的。\n\n注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)T：\n\nvar x: T\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\nDafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<'T>：不可变的无序集合\n * seq<'T>：不可变的有序集合\n * array<'T>、array2<'T>、array3<'T>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。\n\naaaaaaaaaaaa\n\n\n# 方法 methods\n\n方法的声明如下：\n\nsssssss\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y) //输入输出参数\n\nrequires Pre //前置条件\n\nmodifies Frame //框架\n\nensures Post //后置条件\n\ndecreases TerminationMetric //变体函数\n\n{\n\n`sssssss`\n\n`method M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //输入输出参数`\n\n `requires Pre\t//前置条件`   \n\n `modifies Frame  //框架`\n\n `ensures Post\t//后置条件`\n\n `decreases TerminationMetric //变体函数`\n\n`{`\n\n\n}\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * Pre: 表示方法 前提条件 的 布尔表达式\n * Frame: 表示类对象的集合，可以被方法更新(Frame denotes a set of objects whose fields may be updated by the method)\n * Post: 是方法 后置条件 的 布尔表达式\n * TerminationMetric: 是方法的变体函数(TerminationMetric is the method’s variant function)\n * Body: 是实现方法的语句。\n\n\n# 框架Frame\n\n框架Frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架Frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类C的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的“top”元素。\n\n如果省略没写的话，Dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\nDafny IDE 将在工具提示中显示猜测。\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 C 中的静态方法 M 可以由 C.M(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器\n\nmodifies this //框架内对象的构造体 this就是this.frame？\n\n{\n\nBody\n\n}\n\n\n# lemma 关键字\n\n有时，方法(method)关键字会被引理(lemmas)取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\n\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件\n\n{\n\nx, y, z := a, b, c;\n\nif z < y {\n\ny, z := z, y;\n\n}\n\nif y < x {\n\nx, y := y, x;\n\n}\n\nif z < y {\n\ny, z := z, y;\n\n}\n\n}\n\n\n# 函数 function\n\n函数具有以下形式：\n\nfunction F(a: A, b: B, c: C): T\n\nrequires Pre //前置条件pre\n\nreads Frame //框架frame\n\nensures Post //后置条件post\n\ndecreases TerminationMetric //变体函数\n\n{\n\nBody //函数体\n\n}\n\n * a, b, c : 输入的形参，\n * T : 返回结果的类型，\n * Pre: 表示函数前提条件的布尔表达式，\n * Frame: 函数体body需要的对象列表\n * Post: 函数的后置条件布尔表达式\n * TerminationMetric: 变体函数\n * Body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 Dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如Factorial这个函数所有数字都≥1）\n\nfunction Factorial(n: int): int\n\nrequires 0 <= n //前置条件pre\n\nensures 1 <= Factorial(n) //后置条件post\n\n{\n\nif n == 0 then 1 else Factorial(n-1) * n //函数体body\n\n}\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字 static 来删除此参数。\n\n类 C 中的静态函数 F 可以被 C.F(...) 调用。\n\n\n# 类 class\n\n一个类定义如下：\n\nclass C {\n\n// member declarations go here\n\n}\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。\n\n\n# 数据类型 datatypes\n\n归纳数据类型（inductive datatype）是一种类型，其值是用一组固定的构造函数创建的。\n\n数据类型 为Tree带有构造函数 Leaf 和 Node 的函数声明如下：\n\ndatatype Tree = Leaf | Node(Tree, int, Tree)//Leaf为无参构造函数 Node为有参\n\n构造函数由竖线分隔。 无参数构造函数不需要使用括号，如 Leaf 所示。\n\n对于每个构造函数 Ct，数据类型隐式声明了一个布尔成员 Ct?，对于已经使用 Ct 构造函数赋的值的成员，它返回 true。 例如，在代码片段之后：\n\nvar t0 := Leaf;\n\nvar t1 := Node(t0, 5, t0);\n\n表达式 t1.Node结果为 true, t0.Node结果为false。\n\n如果两个数据类型值是使用相同的构造函数和该构造函数的相同参数创建的，则它们是相等的。因此，对于像 Leaf、t.Leaf 这样的无参数构造函数，Dafny会给出与 t == Leaf 相同的结果。(没看懂，不管了)\n\n构造函数可以选择为其任何参数声明析构函数，这是通过为参数引入名称来完成的。 例如，如果 Tree 被声明为：\n\ndatatype Tree = Leaf | Node(left: Tree, data: int, right: Tree)\n\n那么t1.data == 5和t1.left == t0在上面的代码片段之后保持不变。(还是没懂)\n\n\n# 泛型 Generics\n\nDafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型T\n\nclass MyMultiset<T> {\n\n/*...*/\n\n} //类泛型\n\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //自定义数据泛型\n\nmethod Find<T>(key: T, collection: Tree<T>) { //方法泛型\n\n/*...*/\n\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T { //函数泛型\n\n/*...*/\n\n}\n\n\n# 声明 Statement\n\n以下是 Dafny 中最常见语句:\n\nvar LocalVariables := ExprList;\n\nLvalues := ExprList;\n\nassert BoolExpr;\n\nprint ExprList;\n\nif BoolExpr0 {\n\nStmts0\n\n} else if BoolExpr1 {\n\nStmts1\n\n} else {\n\nStmts2\n\n}\n\nwhile BoolExpr\n\ninvariant Inv\n\nmodifies Frame\n\ndecreases Rank\n\n{\n\nStmts\n\n}\n\nmatch Expr {\n\ncase Empty => Stmts0\n\ncase Node(l, d, r) => Stmts1\n\n}\n\nbreak;\n\nreturn;\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个 局部变量 而已）\n\nvar LocalVariables := ExprList;\n\nvar 语句引入了局部变量。\n\nLvalues := ExprList;\n\n赋值语句将 ExprList变量赋给Lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 L 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\n第一种形式分配一个类型为 T 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了T是一维和二维数组对象的匿名构造方法\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies语句限制了循环的框架\n * reduction语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。(真没看懂）\n\nwhile BoolExpr //布尔表达式-循环条件\n\ninvariant Inv\n\nmodifies Frame\n\ndecreases Rank\n\n{\n\nStatements\n\n}\n\n# match语句(阿巴阿巴)\n\nmatch 语句计算源 Expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。\n\n\n# 表达式 Expressions\n\nDafny 中的表达式与类 Java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），Dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==> 低的绑定力，而后者又比 && 和 || 具有更低的绑定力。\n\nDafny 比较表达式可以是链式的，这意味着“相同方向”的比较可以串在一起。例如，0 <= i < j <= a.Length == N\n\n含义相同： 0 <= i && i < j && j <= a.Length && a.Length == N\n\n请注意，布尔相等可以使用 == 和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和 %（整数模）遵循欧几里德定义，这意味着 % 总是导致非负数。 （因此，当 / 或 % 的第一个参数为负数时，结果与您在 C、Java 或 C# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/Modulo_operation。）\n\n# 离 散 数 学\n\nDafny 表达式包括全称量词和存在量词，其形式为：forall x :: Expr 和exists x :: Expr，其中x 是绑定变量（可以使用显式类型声明，如x: T 中所示），而Expr 是一个布尔表达式。\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 S 中的表达式 x 表示 x 是集合 S 的成员，而 x !in S 是一个方便的写法 !(x in S)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in S 和 x !in S。序列 S 的长度表示为 |S|，并且此类序列的元素具有从 0 到小于 |S| 的索引。表达式 S[j] 表示序列 S 的索引 j 处的元素。表达式 S[m..n]，其中 0 <= m <= n <= |S|，返回一个序列，其元素是S 从索引 m 开始（即，从 S[m]、S[m+1]、……直到但不包括 S[n]）。表达式 S[m..]; （通常称为“drop m”）与 S[m..|S|] 相同；也就是说，它返回除 S 的前 m 个元素之外的所有元素的序列。表达式 S[..n] ; （通常称为“take n”）与 S[0..n] 相同，即它返回由 S 的前 n 个元素组成的序列。\n\n如果 j 是序列 S 的有效索引，则表达式 S[j := x];是类似于 S 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得 [x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if BoolExpr then Expr0 else Expr1\n\n其中 Expr0 和 Expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",normalizedContent:"# 基础学习\n\n此页面说明了 dafny 中许多最常见的语言功能。 为了让您更快上手，这里的描述被简化了——这个页面不是语言参考。例如，此页面不会涉及模块、迭代器或细化，除非您在 dafny 中编写更大或更高级的程序，否则您将不需要这些。\n\ndafny程序长这样：xxxxx.dfy，dafny文件是以dfy结尾的。\n\n程序主要包含以下几部分：\n\n 1. 类型(types)\n\n 2. 方法(methods)\n\n 3. 函数(functions)\n\n 4. 用户自定义的类型包括类（class）和归纳数据类型(inductive class)\n\n 5. 类class本身也包含一组声明(declarations)、介绍字段（introducing fields）、方法(methods)和函数(functions)。\n    \n    如果有main方法那就从main开始验证程序，没有也没关系，main不是必须的。\n\n注释：// 双斜杠 或者 /* xxxxx */\n\n\n# 基本定义\n\n在类中，定义字段x为数据类型(types)t：\n\nvar x: t\n\n注意事项：\n\n * 数据类型必需手动申明的，不会被自动推断。\n\n * 通过在声明前加上关键 ghost 可以将该字段声明为幽灵（即用于规范而不是执行）字段。\n\ndafny 的9种数据类型包括：\n\n * bool：布尔值\n * int：无界整数\n * string: 字符串\n * class/inductive class: 用户自定义的类和归纳类、\n * set<'t>：不可变的无序集合\n * seq<'t>：不可变的有序集合\n * array<'t>、array2<'t>、array3<'t>: 多维数组类型\n * object：所有类型的超类\n * nat：范围是int一半，非负整数。\n\naaaaaaaaaaaa\n\n\n# 方法 methods\n\n方法的声明如下：\n\nsssssss\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y) //输入输出参数\n\nrequires pre //前置条件\n\nmodifies frame //框架\n\nensures post //后置条件\n\ndecreases terminationmetric //变体函数\n\n{\n\n`sssssss`\n\n`method m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //输入输出参数`\n\n `requires pre\t//前置条件`   \n\n `modifies frame  //框架`\n\n `ensures post\t//后置条件`\n\n `decreases terminationmetric //变体函数`\n\n`{`\n\n\n}\n\n其中：\n\n * a, b, c : 输入参数\n * x, y, z : 输出参数\n * pre: 表示方法 前提条件 的 布尔表达式\n * frame: 表示类对象的集合，可以被方法更新(frame denotes a set of objects whose fields may be updated by the method)\n * post: 是方法 后置条件 的 布尔表达式\n * terminationmetric: 是方法的变体函数(terminationmetric is the method’s variant function)\n * body: 是实现方法的语句。\n\n\n# 框架frame\n\n框架frame 是单个或多个对象组成的表达式的集合。(见下面例子)\n\n框架frame是由类内对象和类外方法内对象两部分组成。(反正就是一堆类对象的集合）\n\n例如，如果 c 和 d 是类c的对象，那么以下每行意思是一样的。\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\n如果方法内啥都没写，那么前置和后置条件默认为真，框架默认为空集。\n\n\n# 变体函数 variant function\n\n变体函数是一个表达式组成的列表，表示由给定表达式组成的字典元组，后跟隐含的“top”元素。\n\n如果省略没写的话，dafny 将猜测该方法的变体函数，通常是以该方法的参数列表开头的字典元组。\n\ndafny ide 将在工具提示中显示猜测。\n\n\n# ghost 关键字\n\n通过在声明之前加上关键字 ghost 可以将方法声明为 ghost方法（仅规范而不用于执行）。\n\n\n# this 关键字\n\n默认情况下，类中的方法都具有隐式接收器参数 this。可以通过在方法声明之前使用关键字 static 来删除此参数。\n\n类 c 中的静态方法 m 可以由 c.m(...) 调用。\n\n\n# 构造函数/构造体 constructor\n\n在类中，一个方法可以通过将method关键字替换为constructor，申明一个构造方法。\n\n构造函数(构造方法)只能在分配对象时调用（参见示例）\n\n对于包含一个或多个构造函数的类，对象创建必须与对构造函数的调用一起完成。\n\n通常，一个方法当然得有一个名字，但是一个类可以有一个没有名字的构造函数，也就是匿名构造函数 constructor (n:int )\n\nconstructor (n: int) //constructor 匿名构造器\n\nmodifies this //框架内对象的构造体 this就是this.frame？\n\n{\n\nbody\n\n}\n\n\n# lemma 关键字\n\n有时，方法(method)关键字会被引理(lemmas)取代。\n\n通过使用lemma关键字而不是method来声明方法，会让程序更清楚明白\n\n示例：输入三个整数，返回排序后的三个整数\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\n\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //后置条件\n\n{\n\nx, y, z := a, b, c;\n\nif z < y {\n\ny, z := z, y;\n\n}\n\nif y < x {\n\nx, y := y, x;\n\n}\n\nif z < y {\n\ny, z := z, y;\n\n}\n\n}\n\n\n# 函数 function\n\n函数具有以下形式：\n\nfunction f(a: a, b: b, c: c): t\n\nrequires pre //前置条件pre\n\nreads frame //框架frame\n\nensures post //后置条件post\n\ndecreases terminationmetric //变体函数\n\n{\n\nbody //函数体\n\n}\n\n * a, b, c : 输入的形参，\n * t : 返回结果的类型，\n * pre: 表示函数前提条件的布尔表达式，\n * frame: 函数体body需要的对象列表\n * post: 函数的后置条件布尔表达式\n * terminationmetric: 变体函数\n * body: 定义函数的表达式。\n\n前置条件允许函数是部分的(只用前置就行不用写后置），即前置条件表示函数何时定义，并且 dafny 会验证函数的每次使用都满足前置条件。\n\n通常不需要后置条件，因为函数在函数体内已经给出了完整的定义。\n\n例如：\n\n（写个后置加个保险也行，一般后置就是声明该函数的基本属性，比如factorial这个函数所有数字都≥1）\n\nfunction factorial(n: int): int\n\nrequires 0 <= n //前置条件pre\n\nensures 1 <= factorial(n) //后置条件post\n\n{\n\nif n == 0 then 1 else factorial(n-1) * n //函数体body\n\n}\n\n要在后置条件中引用函数的结果，请使用函数本身的名称，如示例中所示。\n\n默认情况下，函数是ghost，不能从可执行（非ghost）代码中调用。\n\n为了使它从ghost变成非ghost，用关键字function method替换 function.\n\n一个返回布尔值的函数可以用关键字声明，然后省略冒号和返回类型。\n\n如果函数或方法被声明为类class成员，则它具有隐式接收器参数 this。可以通过在声明之前加上关键字 static 来删除此参数。\n\n类 c 中的静态函数 f 可以被 c.f(...) 调用。\n\n\n# 类 class\n\n一个类定义如下：\n\nclass c {\n\n// member declarations go here\n\n}\n\n其中类的成员（字段、方法和函数）在花括号内定义（如上所述）。\n\n\n# 数据类型 datatypes\n\n归纳数据类型（inductive datatype）是一种类型，其值是用一组固定的构造函数创建的。\n\n数据类型 为tree带有构造函数 leaf 和 node 的函数声明如下：\n\ndatatype tree = leaf | node(tree, int, tree)//leaf为无参构造函数 node为有参\n\n构造函数由竖线分隔。 无参数构造函数不需要使用括号，如 leaf 所示。\n\n对于每个构造函数 ct，数据类型隐式声明了一个布尔成员 ct?，对于已经使用 ct 构造函数赋的值的成员，它返回 true。 例如，在代码片段之后：\n\nvar t0 := leaf;\n\nvar t1 := node(t0, 5, t0);\n\n表达式 t1.node结果为 true, t0.node结果为false。\n\n如果两个数据类型值是使用相同的构造函数和该构造函数的相同参数创建的，则它们是相等的。因此，对于像 leaf、t.leaf 这样的无参数构造函数，dafny会给出与 t == leaf 相同的结果。(没看懂，不管了)\n\n构造函数可以选择为其任何参数声明析构函数，这是通过为参数引入名称来完成的。 例如，如果 tree 被声明为：\n\ndatatype tree = leaf | node(left: tree, data: int, right: tree)\n\n那么t1.data == 5和t1.left == t0在上面的代码片段之后保持不变。(还是没懂)\n\n\n# 泛型 generics\n\ndafny同其他语言一样都有泛型，任何类、方法、函数都可以有类型参数，在<>中申明该数据类型t\n\nclass mymultiset<t> {\n\n/*...*/\n\n} //类泛型\n\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //自定义数据泛型\n\nmethod find<t>(key: t, collection: tree<t>) { //方法泛型\n\n/*...*/\n\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t { //函数泛型\n\n/*...*/\n\n}\n\n\n# 声明 statement\n\n以下是 dafny 中最常见语句:\n\nvar localvariables := exprlist;\n\nlvalues := exprlist;\n\nassert boolexpr;\n\nprint exprlist;\n\nif boolexpr0 {\n\nstmts0\n\n} else if boolexpr1 {\n\nstmts1\n\n} else {\n\nstmts2\n\n}\n\nwhile boolexpr\n\ninvariant inv\n\nmodifies frame\n\ndecreases rank\n\n{\n\nstmts\n\n}\n\nmatch expr {\n\ncase empty => stmts0\n\ncase node(l, d, r) => stmts1\n\n}\n\nbreak;\n\nreturn;\n\n# 函数/方法的返回值赋值给变量\n\n(就是将函数/方法返回的值或对象 赋给 一个 局部变量 而已）\n\nvar localvariables := exprlist;\n\nvar 语句引入了局部变量。\n\nlvalues := exprlist;\n\n赋值语句将 exprlist变量赋给lvalues。 这些分配是并行执行的（更重要的是，所有必要的读取都发生在写入之前），因此左侧必须表示不同的 l 值。 每个右侧都可以是以下形式之一的表达式或对象创建：\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\n第一种形式分配一个类型为 t 的对象。\n\n第二种形式另外在新分配的对象上调用初始化方法或构造函数。\n\n第三种形式是当调用匿名构造函数时的语法。\n\n其他形式分别了t是一维和二维数组对象的匿名构造方法\n\n# assert 声明\n\nassert 语句判断后面的表达式结果是否为真（由验证器验证）。\n\n# print 打印语句\n\n打印语句将给定打印表达式的值输出到标准输出。字符串中的字符可以转义；例如，对 print 语句感兴趣的是 \\n 表示字符串中的换行符。\n\n# if 选择语句\n\nif 语句是通常的语句。该示例显示了使用 else if 将备选方案串在一起。像往常一样，else 分支是可选的。\n\n# while 循环语句\n\n * while 语句是通常的循环，其中\n * invariant 声明给出了一个循环变量\n * modifies语句限制了循环的框架\n * reduction语句从循环中引入了一个变体函数。\n\n默认情况下，循环不变式为真，修改框与封闭上下文中的相同（通常是封闭方法的修改子句），并从循环保护中猜测变体函数。(真没看懂）\n\nwhile boolexpr //布尔表达式-循环条件\n\ninvariant inv\n\nmodifies frame\n\ndecreases rank\n\n{\n\nstatements\n\n}\n\n# match语句(阿巴阿巴)\n\nmatch 语句计算源 expr（一个类型为归纳数据类型的表达式），然后执行与用于创建源数据类型值的构造函数相对应的 case，将构造函数参数绑定到给定的名称。如果不需要它们来标记 match 语句的结尾，则可以省略包围 case 的花括号。\n\n# break语句\n\nbreak 语句可用于退出循环，而 return 语句可用于退出方法。\n\n\n# 表达式 expressions\n\ndafny 中的表达式与类 java 语言中的表达式非常相似。以下是一些值得注意的差异。\n\n\n# 基本运算符\n\n除了短路布尔运算符 && (and) 和 || （或），dafny 有一个短路蕴涵运算符 ==> 和一个 if-and-only-if 运算符 <==>。\n\n正如它们的宽度所暗示的那样，<==> 具有比 ==> 低的绑定力，而后者又比 && 和 || 具有更低的绑定力。\n\ndafny 比较表达式可以是链式的，这意味着“相同方向”的比较可以串在一起。例如，0 <= i < j <= a.length == n\n\n含义相同： 0 <= i && i < j && j <= a.length && a.length == n\n\n请注意，布尔相等可以使用 == 和 <==> 来表示。这些之间有两个区别。首先，== 比 <==> 具有更高的约束力。其次，== 是链接，而 <==> 是关联的。也就是说，a == b == c 与 a == b && b == c 相同，而 a <==> b <==> c 与 a <==> (b <== > c)，这也与 (a <==> b) <==> c 相同。\n\n# 整数运算\n\n对整数的运算是常用的运算，除了 /（整数除法）和 %（整数模）遵循欧几里德定义，这意味着 % 总是导致非负数。 （因此，当 / 或 % 的第一个参数为负数时，结果与您在 c、java 或 c# 中得到的结果不同，请参阅 http://en.wikipedia.org/wiki/modulo_operation。）\n\n# 离 散 数 学\n\ndafny 表达式包括全称量词和存在量词，其形式为：forall x :: expr 和exists x :: expr，其中x 是绑定变量（可以使用显式类型声明，如x: t 中所示），而expr 是一个布尔表达式。\n\n# 集合运算\n\n集合上的操作包括+（并）、*（交）和-（集合差）、集合比较运算符<（真子集）、<=（子集）、它们的对偶> 和>=，以及!! （脱节）。 s 中的表达式 x 表示 x 是集合 s 的成员，而 x !in s 是一个方便的写法 !(x in s)。\n\n要从某些元素创建一个集合，请将它们括在花括号中。例如，{x,y} 是由 x 和 y 组成的集合（如果 x == y，则为单例集），{x} 是包含 x 的单例集，{} 是空集。\n\n# 序列运算\n\n对序列的操作包括 +（连接）和比较运算符 <（适当的前缀）和 <=（前缀）。成员资格可以像集合一样检查：x in s 和 x !in s。序列 s 的长度表示为 |s|，并且此类序列的元素具有从 0 到小于 |s| 的索引。表达式 s[j] 表示序列 s 的索引 j 处的元素。表达式 s[m..n]，其中 0 <= m <= n <= |s|，返回一个序列，其元素是s 从索引 m 开始（即，从 s[m]、s[m+1]、……直到但不包括 s[n]）。表达式 s[m..]; （通常称为“drop m”）与 s[m..|s|] 相同；也就是说，它返回除 s 的前 m 个元素之外的所有元素的序列。表达式 s[..n] ; （通常称为“take n”）与 s[0..n] 相同，即它返回由 s 的前 n 个元素组成的序列。\n\n如果 j 是序列 s 的有效索引，则表达式 s[j := x];是类似于 s 的序列，只是它在索引 j 处有 x。\n\n最后，要从一些元素组成一个序列，请将它们括在方括号中。例如，[x,y] 是由两个元素 x 和 y 组成的序列，使得 [x,y][0] == x 和 [x,y][1] == y，[x] 是唯一元素是 x 的单例序列，[] 是空序列。\n\n# if-then-else判断语句\n\nif-then-else 表达式的形式为：if boolexpr then expr0 else expr1\n\n其中 expr0 和 expr1 是相同类型的任何表达式。与 if 语句不同，if-then-else 表达式使用 then 关键字，并且必须包含显式的 else 分支。\n\n# match匹配表达式\n\nmatch 表达式类似于 match 语句并具有以下形式：\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\n大括号可用于标记匹配表达式的结束，但最常见的是不需要这样做，然后可以省略大括号。",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Getting Started with Dafny A Guide",frontmatter:{title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8766fd/",categories:["语言","dafny-quick-start"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/10.Getting%20Started%20with%20Dafny%20A%20Guide.html",relativePath:"80.语言/00.dafny-quick-start/10.Getting Started with Dafny A Guide.md",key:"v-618eaefe",path:"/pages/8766fd/",headers:[{level:2,title:"Getting Started with Dafny: A Guide",slug:"getting-started-with-dafny-a-guide",normalizedTitle:"getting started with dafny: a guide",charIndex:28},{level:3,title:"Introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:242},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:1945},{level:3,title:"Pre- and Postconditions",slug:"pre-and-postconditions",normalizedTitle:"pre- and postconditions",charIndex:5156},{level:3,title:"Assertions",slug:"assertions",normalizedTitle:"assertions",charIndex:12244},{level:3,title:"Functions",slug:"functions",normalizedTitle:"functions",charIndex:22875},{level:3,title:"Loop Invariants",slug:"loop-invariants",normalizedTitle:"loop invariants",charIndex:28455},{level:3,title:"Termination",slug:"termination",normalizedTitle:"termination",charIndex:39962},{level:3,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:43929},{level:3,title:"Quantifiers",slug:"quantifiers",normalizedTitle:"quantifiers",charIndex:46819},{level:3,title:"Predicates",slug:"predicates",normalizedTitle:"predicates",charIndex:53780},{level:3,title:"Framing",slug:"framing",normalizedTitle:"framing",charIndex:55371},{level:3,title:"Binary Search",slug:"binary-search",normalizedTitle:"binary search",charIndex:59349},{level:3,title:"Conclusion",slug:"conclusion",normalizedTitle:"conclusion",charIndex:64781}],headersStr:"Getting Started with Dafny: A Guide Introduction Methods Pre- and Postconditions Assertions Functions Loop Invariants Termination Arrays Quantifiers Predicates Framing Binary Search Conclusion",content:'Dafny Documentation\n\n\n#\n\n\n# Getting Started with Dafny: A Guide\n\nBe sure to follow along with the code examples by clicking the “load in editor” link in the corner. See what the tool says, try to fix programs on your own, and experiment!\n\n\n# Introduction\n\nDafny is a language that is designed to make it easy to write correct code. This means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. To accomplish this, Dafny relies on high-level annotations to reason about and prove correctness of code. The effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. Dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). Dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. This is often easier than writing the code, because annotations are shorter and more direct. For example, the following fragment of annotation in Dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nThis says that for all integers k that are indices into the array, the value at that index is greater than zero. By writing these annotations, one is confident that the code is correct. Further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nIn addition to proving a correspondence to user supplied annotations, Dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. This guarantee is a powerful one, and is a strong case in and of itself for the use of Dafny and tools like it. Dafny also proves the termination of code, except in specially designated loops.\n\nLet’s get started writing some Dafny programs.\n\n\n# Methods\n\nDafny resembles a typical imperative programming language in many ways. There are methods, variables, types, loops, if statements, arrays, integers, and more. One of the basic units of any Dafny program is the method. A method is a piece of imperative, executable code. In other languages, they might be called procedures, or functions, but in Dafny the term “function” is reserved for a different concept that we will cover later. A method is declared in the following way:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a method called “Abs” which takes a single integer parameter, called “x”, and returns a single integer, called “y”. Note that the types are required for each parameter and return value, and follow each name after a colon (:). Also, the return values are named, and there can be multiple return values, as in below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThe method body is the code contained within the braces, which until now has been cleverly represented as “...” (which is not Dafny syntax). The body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. For example, the MultipleReturns method may be implemented as:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nAssignments do not use “=”, but rather “:=”. (In fact, as Dafny uses “==” for equality, there is no use of a single equals sign in Dafny expressions.) Simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. To return a value from a method, the value is assigned to one of the named return values sometime before a return statement. In fact, the return values act very much like local variables, and can be assigned to more than once. The input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. Return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. There are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). Here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (Other comparison operators are <=, >, >=, != and ==, with the expected meaning. See the reference for more on operators.)\n\n\n# Pre- and Postconditions\n\nNone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). The real power of Dafny comes from the ability to annotate these methods to specify their behavior. For example, one property that we observe with the Abs method is that the result is always greater than or equal to zero, regardless of the input. We could put this observation in a comment, but then we would have no way to know whether the method actually had this property. Further, if someone came along and changed the method, we wouldn’t be guaranteed that the comment was changed to match. With annotations, we can have Dafny prove that the property we claim of the method is true. There are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nThis property of the Abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. Postconditions, declared with the ensures keyword, are given as part of the method’s declaration, after the return values (if present) and before the method body. The keyword is followed by the boolean expression. Like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. In the case of the Abs method, a reasonable postcondition is the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nYou can see here why return values are given names. This makes them easy to refer to in the postcondition of a method. When the expression is true, we say that the postcondition holds. The postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). In this case, the only property we are expressing is that the return value is always at least zero.\n\nSometimes there are multiple properties that we would like to establish about our code. In this case, we have two options. We can either join the two conditions together with the boolean “and” operator (&&), or we can write multiple ensures specifications. The latter is basically the same as the former, but it seperates distinct properties. For example, the return value names from the MultipleReturns method might lead one to guess the following postconditions:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition can also be written:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in Dafny. (In general, most of the comparison operators can be chained, but only “in one direction”, i.e. not mixing “greater than” and “less than”. See the reference for details.)\n\nThe first way of expressing the postconditions separates the “less” part from the “more” part, which may be desirable. Another thing to note is that we have included one of the input parameters in the postcondition. This is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\nDafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). This means that Dafny wasn’t able to prove that this annotation holds every time the method returns. In general, there are two main causes for Dafny verification errors: specifications that are inconsistent with the code, and situations where it is not “clever” enough to prove the required properties. Differentiating between these two possibilities can be a difficult task, but fortunately, Dafny and the Boogie/Z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nIn this situation, Dafny is correct in saying there is an error with the code. The key to the problem is that y is an integer, so it can be negative. If y is negative (or zero), then more can actually be smaller than or equal to x. Our method will not work as intended unless y is strictly larger than zero. This is precisely the idea of a precondition. A precondition is similar to a postcondition, except that it is something that must be true before a method is called. When you call a method, it is your job to establish (make true) the preconditions, something Dafny will enforce using a proof. Likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. The caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. We can give the necessary precondition to MultipleReturns as below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nLike postconditions, multiple preconditions can be written either with the boolean “and” operator (&&), or by multiple requires keywords. Traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). With the addition of this condition, Dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nExercise 0. Write a method Max that takes two integer parameters and returns their maximum. Add appropriate annotations and make sure your code verifies.\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNot all methods necessarily have preconditions. For example, the Abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). Even though it has no need of preconditions, the Abs function as it stands now is not very useful. To investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# Assertions\n\nUnlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. Like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. An assertion says that a particular expression always holds when control reaches that part of the code. For example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try "asserting" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny proves this method correct, as 2 is always less than 3. Asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. You can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. Assertions are a powerful tool for debugging annotations, by checking what Dafny is able to prove about your code. For example, we can use it to investigate what Dafny knows about the Abs function.\n\nTo do this, we need one more concept: local variables. Local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (See the reference for details.) Local variables are declared with the var keyword, and can optionally have type declarations. Unlike method parameters, where types are required, Dafny can infer the types of local variables in almost all situations. This is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nThe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nMultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nExplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. We needed variables because we want to talk about the return value of the Abs method. We cannot put Abs inside a specification directly, as the method could change memory state, among other problems. So we capture the return value of a call to Abs as follows:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is an example of a situation where we can ask Dafny what it knows about the values in the code, in this case v. We do this by adding assertions, like the one above. Every time Dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. In this example, there is only one control path through the method, and Dafny is able to prove the annotation easily because it is exactly the postcondition of the Abs method. Abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to Abs.\n\nExercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nBut we know something stronger about the Abs method. In particular, for non-negative x, Abs(x) == x. Specifically, in the above program, the value of v is 3. If we try adding an assertion (or changing the existing one) to say:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that Dafny cannot prove our assertion, and gives an error. The reason this happens is that Dafny “forgets” about the body of every method except the one it is currently working on. This simplifies Dafny’s job tremendously, and is one of the reasons it is able to operate at reasonable speeds. It also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). We don’t care at all what happens inside each method when we call it, as long as it satisfies its annotations. This works because Dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nFor the Abs method, this means that the only thing Dafny knows in the Testing method about the value returned from Abs is what the postconditions say about it, and nothing more. This means that Dafny won’t know the nice property about Abs and non-negative integers unless we tell it by putting this in the postcondition of the Abs method. Another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. Everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. In the Abs case, we might have written:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nThis method satisfies the postconditions, but clearly the program fragment:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. Dafny is considering, in an abstract way, all methods with those annotations. The mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. We need stronger postconditions to eliminate these other possibilities, and “fix” the method down to exactly the one we want. We can partially do this with the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. The second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean “and” and comparisons, so the above says 0 <= x implies y == x). The left and right sides must both be boolean expressions.\n\nThe postcondition says that after Abs is called, if the value of x was non-negative, then y is equal to x. One caveat of the implication is that it is still true if the left part (the antecedent) is false. So the second postcondition is trivially true when x is negative. In fact, the only thing that the annotations say when x is negative is that the result, y, is positive. But this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nThese annotations are enough to require that our method actually computes the absolute value of x. These postconditions are not the only way to express this property. For example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIn general, there can be many ways to write down a given property. Most of the time it doesn’t matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nBut we still have an issue: there seems to be a lot of duplication. The body of the method is reflected very closely in the annotations. While this is correct code, we want to eliminate this redundancy. As you might guess, Dafny provides a means of doing this: functions.\n\nExercise 2. Using a precondition, change Abs to say it can only be called on negative values. Simplify the body of Abs into just one return statement and make sure the method still verifies.\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 3. Keeping the postconditions of Abs the same as above, change the body of Abs to just y := x + 2. What precondition do you need to annotate the method with in order for the verification to go through? What precondition do you need if the body is y := x + 1? What does that precondition say about when you can call the method?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a function called abs which takes a single integer, and returns an integer (the second int). Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. Here our body must be an integer expression. In order to implement the absolute value function, we need to use an if expression. An if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nObviously, the condition must be a boolean expression, and the two branches must have the same type. You might wonder why anyone would bother with functions, if they are so limited compared to methods. The power of functions comes from the fact that they can be used directly in specifications. So we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nIn fact, not only can we write this statement directly without capturing to a local variable, we didn’t even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). The limitations of functions are precisely what let Dafny do this. Unlike methods, Dafny does not forget the body of a function when considering other functions. So it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nExercise 4. Write a function max that returns the larger of two given integer parameters. Write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat of functions is that not only can they appear in annotations, they can only appear in annotations. One cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. Functions are never part of the final compiled program, they are just tools to help us verify our code. Sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. Note that there are restrictions on what functions can be function methods (See the reference for details).\n\nExercise 5. Change your test method from Exercise 4 to capture the value of max to a variable, and then do the checks from Exercise 4 using the variable. Dafny will reject this program because you are calling max from real code. Fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nExercise 6. Now that we have an abs function, change the postcondition of method Abs to make use of abs. After confirming the method still verifies, change the body of Abs to also use abs. (After doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nUnlike methods, functions can appear in expressions. Thus we can do something like implement the mathematical Fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nHere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. It turns out that we could make this function a function method if we wanted to. But this would be extremely slow, as this version of calculating the Fibonacci numbers has exponential complexity. There are much better ways to calculate the Fibonacci function. But this function is still useful, as we can have Dafny prove that a fast version really matches the mathematical definition. We can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nWe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWe haven’t written the body yet, so Dafny will complain that our postcondition doesn’t hold. We need an algorithm to calculate the nth Fibonacci number. The basic idea is to keep a counter, and repeatedly calculate adjacent pairs of Fibonacci numbers until the desired number is reached. To do this, we need a loop. In Dafny, this is done via a while loop. A while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nThis is a trivial loop that just increments i until it reaches n. This will form the core of our loop to calculate Fibonacci numbers.\n\n\n# Loop Invariants\n\nwhile loops present a problem for Dafny. There is no way for Dafny to know in advance how many times the code will go around the loop. But Dafny needs to consider all paths through a program, which could include going around the loop any number of times. To make it possible for Dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\nA loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. It captures something that is invariant, i.e. does not change, about every step of the loop. Now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldn’t need the loop. Like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. For example, we see in the above loop that if i starts off positive, then it stays positive. So we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWhen you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. By preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. Dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). Just as Dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nIn our example, the point of the loop is to build up the Fibonacci numbers one (well, two) at a time until we reach the desired number. After we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. We can use our assertion trick to check to see if Dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nWe find that this assertion fails. As far as Dafny knows, it is possible that i somehow became much larger than n at some point during the loop. All it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. In this case, this amounts to n <= i and 0 <= i. But this is not enough to guarantee that i == n, just that n <= i. Somehow we need to eliminate the possibility of i exceeding n. One first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThis does not verify, as Dafny complains that the invariant is not preserved (also known as not maintained) by the loop. We want to be able to say that after the loop exits, then all the invariants hold. Our invariant holds for every execution of the loop except for the very last one. Because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. Thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nNow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows Dafny to prove the assertion i == n. The challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nExercise 7. Change the loop invariant to 0 <= i <= n+2. Does the loop still verify? Does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExercise 8. With the original loop invariant, change the loop guard from i < n to i != n. Do the loop and the assertion after the loop still verify? Why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIn addition to the counter, our algorithm called for a pair of numbers which represent adjacent Fibonacci numbers in the sequence. Unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. To find these invariants, we employ a common Dafny trick: working backwards from the postconditions.\n\nOur postcondition for the Fibonacci method is that the return value b is equal to fib(n). But after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. This might make a good invariant, as it relates something to the loop counter. This observation is surprisingly common throughout Dafny programs. Often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. So we have that the variable b, which is conveniently our out parameter, will be the current Fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nWe also note that in our algorithm, we can compute any Fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. So we want a way of tracking the previous Fibonacci number, which we will call a. Another invariant will express that number’s relation to the loop counter. The invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nAt each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. Using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nHere a is the trailing number, and b is the leading number. The parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. Thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nWe also have made a change to the loop counter i. Because we also want to track the trailing number, we can’t start the counter at zero, as otherwise we would have to calculate a negative Fibonacci number. The problem with doing this is that the loop counter invariant may not hold when we enter the loop. The only problem is when n is zero. This can be eliminated as a special case, by testing for this condition at the beginning of the loop. The completed Fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. Dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nExercise 9. The ComputeFib method above is more complicated than necessary. Write a simpler program by not introducing a as the Fibonacci number that precedes b, but instead introducing a variable c that succeeds b. Verify your program is correct according to the mathematical definition of Fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nExercise 10. Starting with the completed ComputeFib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. Verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nOne of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. For example, we could have omitted the entire body of the loop in the previous program. The invariants would be correct, because they are still true upon entering the loop, and since the loop doesn’t change anything, they would be preserved by the loop. We know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. Thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# Termination\n\nDafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. For many things, Dafny is able to guess the right annotations, but sometimes it needs to be made explicit. In fact, for all of the code we have seen so far, Dafny has been able to do this proof on its own, which is why we haven’t seen the decreases annotation explicitly yet. There are two places Dafny proves termination: loops and recursion. Both of these situations require either an explicit annotation or a correct guess by Dafny.\n\nA decreases annotation, as its name suggests, gives Dafny an expression that decreases with every loop iteration or recursive call. There are two conditions that Dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. Many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (See the reference for details.) In the case of integers, the bound is assumed to be zero. For example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nHere Dafny has all the ingredients it needs to prove termination. The variable i gets smaller each loop iteration, and is bounded below by zero. This is fine, except the loop is backwards from most loops, which tend to count up instead of down. In this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. A simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis is actually Dafny’s guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. The upper bound of the loop invariant implies that 0 <= n – i, and gives Dafny a lower bound on the quantity. This also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nExercise 11. In the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. Note that if the loop guard were instead written as i != n (as in Exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. Change the loop guard to i != n and delete the invariant annotation. Does the program verify? What happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe other situation that requires a termination proof is when methods or functions are recursive. Similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. When Dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nAs before, Dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where Dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# Arrays\n\nAll that we have considered is fine for toy functions and little mathematical exercises, but it really isn’t helpful for real programs. So far we have only considered a handful of values at a time in local variables. Now we turn our attention to arrays of data. Arrays are a built-in part of the language, with their own type, array<T>, where T is another type. For now we only consider arrays of integers, array<int>. Arrays can be null, and have a built-in length field, a.Length. Element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. All array accesses must be proven to be within bounds, which is part of Dafny’s no-runtime-errors safety guarantee. Because bounds checks are proven at verification time, no runtime checks need to be made. To create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (See the tutorial on memory for more on allocation.)\n\nOne of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. We have two outcomes for a search, with a different correctness condition for each. If the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. This might be expressed as follows:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe array index here is safe because the implication operator is short circuiting. Short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. Using the short circuiting property of the implication operator, along with the boolean “and” (&&), which is also short circuiting, is a common Dafny practice. The condition index < a.Length is necessary because otherwise the method could return a large integer which is not an index into the array. Together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nIf the key is not in the array, then we would like the method to return a negative number. In this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. To express this property, we turn to another common Dafny tool: quantifiers.\n\n\n# Quantifiers\n\nA quantifier in Dafny most often takes the form of a forall expression, also called a universal quantifier. As its name suggests, this expression is true if some property holds for all elements of some set. For now, we will consider the set of integers. An example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\nA quantifier introduces a temporary name for each element of the set it is considering. This is called the bound variable, in this case k. The bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (In general, one can have any number of bound variables, a topic we will return to later.) A pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). In this case, the property is that adding one to any integer makes a strictly larger integer. Dafny is able to prove this simple property automatically. Generally it is not very useful to quantify over infinite sets, such as all the integers. Instead, quantifiers are typically used to quantify over all elements in an array or data structure. We do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\nThis says that some property holds for each element of the array. The implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. Dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nWith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\nThus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nAs you can see, we have omitted the loop invariants on the while loop, so Dafny gives us a verification error on one of the postconditions. The reason we get an error is that Dafny does not know that the loop actually covers all the elements. In order to convince Dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). Just like the postcondition, we can use a quantifier to express this property:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThis says that everything before, but excluding, the current index is not the key. Notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. This common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. This means that it is true when entering the loop. We test the value of the array before we extend the non-key part of the array, so Dafny can prove that this invariant is preserved. One problem arises when we try to add this invariant: Dafny complains about the index being out of range for the array access within the invariant.\n\nThis code does not verify because there is no invariant on index, so it could be greater than the length of the array. Then the bound variable, k, could exceed the length of the array. To fix this, we put the standard bounds on index, 0 <= index <= a.Length. Note that because we say k < index, the array access is still protected from error even when index == a.Length. The use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. The complete method is given below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 12. Write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the array’s elements. Annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nA linear search is not very efficient, especially when many queries are made of the same data. If the array is sorted, then we can use the very efficient binary search procedure to find the key. But in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. We could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# Predicates\n\nA predicate is a function which returns a boolean. It is a simple but powerful idea that occurs throughout Dafny programs. For example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. The use of predicates makes our code shorter, as we do not need to write out a long property over and over. It can also make our code easier to read by giving a common property a name.\n\nThere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. We can write a quantifier that expresses the property, “if x is before y in the array, then x <= y,” as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\nHere we have two bound variables, j and k, which are both integers. The comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. Then the second part says that they are ordered properly with respect to one another. Quantifiers are just a type of boolean valued expression in Dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nNote that there is no return type, because predicates always return a boolean.\n\nDafny rejects this code as given, claiming that the predicate cannot read a. Fixing this issue requires another annotation, the reads annotation.\n\n\n# Framing\n\nThe sorted predicate is not able to access the array because the array was not included in the function’s reading frame. The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. The reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. For example, we might have two arrays, one of which we know is sorted. If we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. While we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. In this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nA reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. Instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. The name of an array, like a in the above example, stands for all the elements of that array. One can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. Dafny will check that you do not read any memory location that is not stated in the reading frame. This means that function calls within a function must have reading frames that are a subset of the calling function’s reading frame. One thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nFrames also affect methods. As you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. Methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. They are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. In combination with reads, modification restrictions allow Dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow Dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that Dafny can reason about.\n\nNote that framing only applies to the heap, or memory accessed through references. Local variables are not stored on the heap, so they cannot be mentioned in reads annotations. Note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. Arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nExercise 13. Modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nExercise 14. What happens if you remove the precondition a != null? Change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Binary Search\n\nPredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nWe have the same postconditions that we did for the linear search, as the goal is the same. The difference is that now we know the array is sorted. Because Dafny can unwrap functions, inside the body of the method it knows this too. We can then use that property to prove the correctness of the search. The method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nThis is a fairly standard binary search implementation. First we declare our range to search over. This can be thought of as the remaining space where the key could possibly be. The range is inclusive-exclusive, meaning it encompasses indices [low, high). The first invariant expresses the fact that this range is within the array. The second says that the key is not anywhere outside of this range. In the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. We need the addition of one when moving the lower end of the range because it is inclusive on the low side. If we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. We could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. In the above formulation, this is unnecessary because when low == high, the loop exits. But this means that no elements are left in the search range, so the key was not found. This can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nWhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). Thus the invariant says that all elements in the array are not the key, and the second postcondition holds. As you can see, it is easy to introduce subtle off by one errors in this code. With the invariants, not only can Dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nExercise 15. Change the assignments in the body of BinarySearch to set low to mid or to set high to mid - 1. In each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Conclusion\n\nWe’ve seen a whirlwind tour of the major features of Dafny, and used it for some interesting, if a little on the small side, examples of what Dafny can do. But to really take advantage of the power Dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. Now that you are familiar with the basics of Dafny, you can peruse the tutorials on each of these topics at your leisure. Each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. The examples are also a good place to look for model Dafny programs. Finally, the reference contains the gritty details of Dafny syntax and semantics, for when you just need to know what the disjoint set operator is (it’s !!, for those interested).\n\nEven if you do not use Dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. Invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. When modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. They also ensure that APIs are used correctly, by formalizing behavior and requirements and enforcing correct usage. Reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',normalizedContent:'dafny documentation\n\n\n#\n\n\n# getting started with dafny: a guide\n\nbe sure to follow along with the code examples by clicking the “load in editor” link in the corner. see what the tool says, try to fix programs on your own, and experiment!\n\n\n# introduction\n\ndafny is a language that is designed to make it easy to write correct code. this means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. to accomplish this, dafny relies on high-level annotations to reason about and prove correctness of code. the effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. this is often easier than writing the code, because annotations are shorter and more direct. for example, the following fragment of annotation in dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nthis says that for all integers k that are indices into the array, the value at that index is greater than zero. by writing these annotations, one is confident that the code is correct. further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nin addition to proving a correspondence to user supplied annotations, dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. this guarantee is a powerful one, and is a strong case in and of itself for the use of dafny and tools like it. dafny also proves the termination of code, except in specially designated loops.\n\nlet’s get started writing some dafny programs.\n\n\n# methods\n\ndafny resembles a typical imperative programming language in many ways. there are methods, variables, types, loops, if statements, arrays, integers, and more. one of the basic units of any dafny program is the method. a method is a piece of imperative, executable code. in other languages, they might be called procedures, or functions, but in dafny the term “function” is reserved for a different concept that we will cover later. a method is declared in the following way:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a method called “abs” which takes a single integer parameter, called “x”, and returns a single integer, called “y”. note that the types are required for each parameter and return value, and follow each name after a colon (:). also, the return values are named, and there can be multiple return values, as in below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthe method body is the code contained within the braces, which until now has been cleverly represented as “...” (which is not dafny syntax). the body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. for example, the multiplereturns method may be implemented as:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nassignments do not use “=”, but rather “:=”. (in fact, as dafny uses “==” for equality, there is no use of a single equals sign in dafny expressions.) simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. to return a value from a method, the value is assigned to one of the named return values sometime before a return statement. in fact, the return values act very much like local variables, and can be assigned to more than once. the input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. there are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (other comparison operators are <=, >, >=, != and ==, with the expected meaning. see the reference for more on operators.)\n\n\n# pre- and postconditions\n\nnone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). the real power of dafny comes from the ability to annotate these methods to specify their behavior. for example, one property that we observe with the abs method is that the result is always greater than or equal to zero, regardless of the input. we could put this observation in a comment, but then we would have no way to know whether the method actually had this property. further, if someone came along and changed the method, we wouldn’t be guaranteed that the comment was changed to match. with annotations, we can have dafny prove that the property we claim of the method is true. there are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nthis property of the abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. postconditions, declared with the ensures keyword, are given as part of the method’s declaration, after the return values (if present) and before the method body. the keyword is followed by the boolean expression. like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. in the case of the abs method, a reasonable postcondition is the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nyou can see here why return values are given names. this makes them easy to refer to in the postcondition of a method. when the expression is true, we say that the postcondition holds. the postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). in this case, the only property we are expressing is that the return value is always at least zero.\n\nsometimes there are multiple properties that we would like to establish about our code. in this case, we have two options. we can either join the two conditions together with the boolean “and” operator (&&), or we can write multiple ensures specifications. the latter is basically the same as the former, but it seperates distinct properties. for example, the return value names from the multiplereturns method might lead one to guess the following postconditions:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition can also be written:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in dafny. (in general, most of the comparison operators can be chained, but only “in one direction”, i.e. not mixing “greater than” and “less than”. see the reference for details.)\n\nthe first way of expressing the postconditions separates the “less” part from the “more” part, which may be desirable. another thing to note is that we have included one of the input parameters in the postcondition. this is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\ndafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). this means that dafny wasn’t able to prove that this annotation holds every time the method returns. in general, there are two main causes for dafny verification errors: specifications that are inconsistent with the code, and situations where it is not “clever” enough to prove the required properties. differentiating between these two possibilities can be a difficult task, but fortunately, dafny and the boogie/z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nin this situation, dafny is correct in saying there is an error with the code. the key to the problem is that y is an integer, so it can be negative. if y is negative (or zero), then more can actually be smaller than or equal to x. our method will not work as intended unless y is strictly larger than zero. this is precisely the idea of a precondition. a precondition is similar to a postcondition, except that it is something that must be true before a method is called. when you call a method, it is your job to establish (make true) the preconditions, something dafny will enforce using a proof. likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. the caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. we can give the necessary precondition to multiplereturns as below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlike postconditions, multiple preconditions can be written either with the boolean “and” operator (&&), or by multiple requires keywords. traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). with the addition of this condition, dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nexercise 0. write a method max that takes two integer parameters and returns their maximum. add appropriate annotations and make sure your code verifies.\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnot all methods necessarily have preconditions. for example, the abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). even though it has no need of preconditions, the abs function as it stands now is not very useful. to investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# assertions\n\nunlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. an assertion says that a particular expression always holds when control reaches that part of the code. for example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try "asserting" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny proves this method correct, as 2 is always less than 3. asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. you can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. assertions are a powerful tool for debugging annotations, by checking what dafny is able to prove about your code. for example, we can use it to investigate what dafny knows about the abs function.\n\nto do this, we need one more concept: local variables. local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (see the reference for details.) local variables are declared with the var keyword, and can optionally have type declarations. unlike method parameters, where types are required, dafny can infer the types of local variables in almost all situations. this is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nthe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nmultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nexplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. we needed variables because we want to talk about the return value of the abs method. we cannot put abs inside a specification directly, as the method could change memory state, among other problems. so we capture the return value of a call to abs as follows:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is an example of a situation where we can ask dafny what it knows about the values in the code, in this case v. we do this by adding assertions, like the one above. every time dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. in this example, there is only one control path through the method, and dafny is able to prove the annotation easily because it is exactly the postcondition of the abs method. abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to abs.\n\nexercise 1. write a test method that calls your max method from exercise 0 and then asserts something about the result.\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbut we know something stronger about the abs method. in particular, for non-negative x, abs(x) == x. specifically, in the above program, the value of v is 3. if we try adding an assertion (or changing the existing one) to say:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that dafny cannot prove our assertion, and gives an error. the reason this happens is that dafny “forgets” about the body of every method except the one it is currently working on. this simplifies dafny’s job tremendously, and is one of the reasons it is able to operate at reasonable speeds. it also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). we don’t care at all what happens inside each method when we call it, as long as it satisfies its annotations. this works because dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nfor the abs method, this means that the only thing dafny knows in the testing method about the value returned from abs is what the postconditions say about it, and nothing more. this means that dafny won’t know the nice property about abs and non-negative integers unless we tell it by putting this in the postcondition of the abs method. another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. in the abs case, we might have written:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nthis method satisfies the postconditions, but clearly the program fragment:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. dafny is considering, in an abstract way, all methods with those annotations. the mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. we need stronger postconditions to eliminate these other possibilities, and “fix” the method down to exactly the one we want. we can partially do this with the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. the second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean “and” and comparisons, so the above says 0 <= x implies y == x). the left and right sides must both be boolean expressions.\n\nthe postcondition says that after abs is called, if the value of x was non-negative, then y is equal to x. one caveat of the implication is that it is still true if the left part (the antecedent) is false. so the second postcondition is trivially true when x is negative. in fact, the only thing that the annotations say when x is negative is that the result, y, is positive. but this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nthese annotations are enough to require that our method actually computes the absolute value of x. these postconditions are not the only way to express this property. for example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nin general, there can be many ways to write down a given property. most of the time it doesn’t matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nbut we still have an issue: there seems to be a lot of duplication. the body of the method is reflected very closely in the annotations. while this is correct code, we want to eliminate this redundancy. as you might guess, dafny provides a means of doing this: functions.\n\nexercise 2. using a precondition, change abs to say it can only be called on negative values. simplify the body of abs into just one return statement and make sure the method still verifies.\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 3. keeping the postconditions of abs the same as above, change the body of abs to just y := x + 2. what precondition do you need to annotate the method with in order for the verification to go through? what precondition do you need if the body is y := x + 1? what does that precondition say about when you can call the method?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a function called abs which takes a single integer, and returns an integer (the second int). unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. here our body must be an integer expression. in order to implement the absolute value function, we need to use an if expression. an if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nobviously, the condition must be a boolean expression, and the two branches must have the same type. you might wonder why anyone would bother with functions, if they are so limited compared to methods. the power of functions comes from the fact that they can be used directly in specifications. so we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nin fact, not only can we write this statement directly without capturing to a local variable, we didn’t even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). the limitations of functions are precisely what let dafny do this. unlike methods, dafny does not forget the body of a function when considering other functions. so it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nexercise 4. write a function max that returns the larger of two given integer parameters. write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat of functions is that not only can they appear in annotations, they can only appear in annotations. one cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. functions are never part of the final compiled program, they are just tools to help us verify our code. sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. note that there are restrictions on what functions can be function methods (see the reference for details).\n\nexercise 5. change your test method from exercise 4 to capture the value of max to a variable, and then do the checks from exercise 4 using the variable. dafny will reject this program because you are calling max from real code. fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexercise 6. now that we have an abs function, change the postcondition of method abs to make use of abs. after confirming the method still verifies, change the body of abs to also use abs. (after doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nunlike methods, functions can appear in expressions. thus we can do something like implement the mathematical fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nhere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. it turns out that we could make this function a function method if we wanted to. but this would be extremely slow, as this version of calculating the fibonacci numbers has exponential complexity. there are much better ways to calculate the fibonacci function. but this function is still useful, as we can have dafny prove that a fast version really matches the mathematical definition. we can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nwe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwe haven’t written the body yet, so dafny will complain that our postcondition doesn’t hold. we need an algorithm to calculate the nth fibonacci number. the basic idea is to keep a counter, and repeatedly calculate adjacent pairs of fibonacci numbers until the desired number is reached. to do this, we need a loop. in dafny, this is done via a while loop. a while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nthis is a trivial loop that just increments i until it reaches n. this will form the core of our loop to calculate fibonacci numbers.\n\n\n# loop invariants\n\nwhile loops present a problem for dafny. there is no way for dafny to know in advance how many times the code will go around the loop. but dafny needs to consider all paths through a program, which could include going around the loop any number of times. to make it possible for dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\na loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. it captures something that is invariant, i.e. does not change, about every step of the loop. now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldn’t need the loop. like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. for example, we see in the above loop that if i starts off positive, then it stays positive. so we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwhen you specify an invariant, dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. by preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). just as dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nin our example, the point of the loop is to build up the fibonacci numbers one (well, two) at a time until we reach the desired number. after we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. we can use our assertion trick to check to see if dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nwe find that this assertion fails. as far as dafny knows, it is possible that i somehow became much larger than n at some point during the loop. all it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. in this case, this amounts to n <= i and 0 <= i. but this is not enough to guarantee that i == n, just that n <= i. somehow we need to eliminate the possibility of i exceeding n. one first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthis does not verify, as dafny complains that the invariant is not preserved (also known as not maintained) by the loop. we want to be able to say that after the loop exits, then all the invariants hold. our invariant holds for every execution of the loop except for the very last one. because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nnow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows dafny to prove the assertion i == n. the challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nexercise 7. change the loop invariant to 0 <= i <= n+2. does the loop still verify? does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexercise 8. with the original loop invariant, change the loop guard from i < n to i != n. do the loop and the assertion after the loop still verify? why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nin addition to the counter, our algorithm called for a pair of numbers which represent adjacent fibonacci numbers in the sequence. unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. to find these invariants, we employ a common dafny trick: working backwards from the postconditions.\n\nour postcondition for the fibonacci method is that the return value b is equal to fib(n). but after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. this might make a good invariant, as it relates something to the loop counter. this observation is surprisingly common throughout dafny programs. often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. so we have that the variable b, which is conveniently our out parameter, will be the current fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nwe also note that in our algorithm, we can compute any fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. so we want a way of tracking the previous fibonacci number, which we will call a. another invariant will express that number’s relation to the loop counter. the invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nat each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nhere a is the trailing number, and b is the leading number. the parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nwe also have made a change to the loop counter i. because we also want to track the trailing number, we can’t start the counter at zero, as otherwise we would have to calculate a negative fibonacci number. the problem with doing this is that the loop counter invariant may not hold when we enter the loop. the only problem is when n is zero. this can be eliminated as a special case, by testing for this condition at the beginning of the loop. the completed fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nexercise 9. the computefib method above is more complicated than necessary. write a simpler program by not introducing a as the fibonacci number that precedes b, but instead introducing a variable c that succeeds b. verify your program is correct according to the mathematical definition of fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nexercise 10. starting with the completed computefib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\none of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. for example, we could have omitted the entire body of the loop in the previous program. the invariants would be correct, because they are still true upon entering the loop, and since the loop doesn’t change anything, they would be preserved by the loop. we know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# termination\n\ndafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. for many things, dafny is able to guess the right annotations, but sometimes it needs to be made explicit. in fact, for all of the code we have seen so far, dafny has been able to do this proof on its own, which is why we haven’t seen the decreases annotation explicitly yet. there are two places dafny proves termination: loops and recursion. both of these situations require either an explicit annotation or a correct guess by dafny.\n\na decreases annotation, as its name suggests, gives dafny an expression that decreases with every loop iteration or recursive call. there are two conditions that dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (see the reference for details.) in the case of integers, the bound is assumed to be zero. for example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nhere dafny has all the ingredients it needs to prove termination. the variable i gets smaller each loop iteration, and is bounded below by zero. this is fine, except the loop is backwards from most loops, which tend to count up instead of down. in this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. a simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis is actually dafny’s guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. the upper bound of the loop invariant implies that 0 <= n – i, and gives dafny a lower bound on the quantity. this also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nexercise 11. in the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. note that if the loop guard were instead written as i != n (as in exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. change the loop guard to i != n and delete the invariant annotation. does the program verify? what happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe other situation that requires a termination proof is when methods or functions are recursive. similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. when dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nas before, dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# arrays\n\nall that we have considered is fine for toy functions and little mathematical exercises, but it really isn’t helpful for real programs. so far we have only considered a handful of values at a time in local variables. now we turn our attention to arrays of data. arrays are a built-in part of the language, with their own type, array<t>, where t is another type. for now we only consider arrays of integers, array<int>. arrays can be null, and have a built-in length field, a.length. element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. all array accesses must be proven to be within bounds, which is part of dafny’s no-runtime-errors safety guarantee. because bounds checks are proven at verification time, no runtime checks need to be made. to create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (see the tutorial on memory for more on allocation.)\n\none of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. we have two outcomes for a search, with a different correctness condition for each. if the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. this might be expressed as follows:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe array index here is safe because the implication operator is short circuiting. short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. using the short circuiting property of the implication operator, along with the boolean “and” (&&), which is also short circuiting, is a common dafny practice. the condition index < a.length is necessary because otherwise the method could return a large integer which is not an index into the array. together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nif the key is not in the array, then we would like the method to return a negative number. in this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. to express this property, we turn to another common dafny tool: quantifiers.\n\n\n# quantifiers\n\na quantifier in dafny most often takes the form of a forall expression, also called a universal quantifier. as its name suggests, this expression is true if some property holds for all elements of some set. for now, we will consider the set of integers. an example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\na quantifier introduces a temporary name for each element of the set it is considering. this is called the bound variable, in this case k. the bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (in general, one can have any number of bound variables, a topic we will return to later.) a pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). in this case, the property is that adding one to any integer makes a strictly larger integer. dafny is able to prove this simple property automatically. generally it is not very useful to quantify over infinite sets, such as all the integers. instead, quantifiers are typically used to quantify over all elements in an array or data structure. we do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\nthis says that some property holds for each element of the array. the implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nwith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\nthus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nas you can see, we have omitted the loop invariants on the while loop, so dafny gives us a verification error on one of the postconditions. the reason we get an error is that dafny does not know that the loop actually covers all the elements. in order to convince dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). just like the postcondition, we can use a quantifier to express this property:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthis says that everything before, but excluding, the current index is not the key. notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. this common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. this means that it is true when entering the loop. we test the value of the array before we extend the non-key part of the array, so dafny can prove that this invariant is preserved. one problem arises when we try to add this invariant: dafny complains about the index being out of range for the array access within the invariant.\n\nthis code does not verify because there is no invariant on index, so it could be greater than the length of the array. then the bound variable, k, could exceed the length of the array. to fix this, we put the standard bounds on index, 0 <= index <= a.length. note that because we say k < index, the array access is still protected from error even when index == a.length. the use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. the complete method is given below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 12. write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the array’s elements. annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\na linear search is not very efficient, especially when many queries are made of the same data. if the array is sorted, then we can use the very efficient binary search procedure to find the key. but in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. we could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# predicates\n\na predicate is a function which returns a boolean. it is a simple but powerful idea that occurs throughout dafny programs. for example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. the use of predicates makes our code shorter, as we do not need to write out a long property over and over. it can also make our code easier to read by giving a common property a name.\n\nthere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. we can write a quantifier that expresses the property, “if x is before y in the array, then x <= y,” as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\nhere we have two bound variables, j and k, which are both integers. the comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. then the second part says that they are ordered properly with respect to one another. quantifiers are just a type of boolean valued expression in dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nnote that there is no return type, because predicates always return a boolean.\n\ndafny rejects this code as given, claiming that the predicate cannot read a. fixing this issue requires another annotation, the reads annotation.\n\n\n# framing\n\nthe sorted predicate is not able to access the array because the array was not included in the function’s reading frame. the reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. the reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. for example, we might have two arrays, one of which we know is sorted. if we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. while we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. in this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. the name of an array, like a in the above example, stands for all the elements of that array. one can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. dafny will check that you do not read any memory location that is not stated in the reading frame. this means that function calls within a function must have reading frames that are a subset of the calling function’s reading frame. one thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nframes also affect methods. as you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. they are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. in combination with reads, modification restrictions allow dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that dafny can reason about.\n\nnote that framing only applies to the heap, or memory accessed through references. local variables are not stored on the heap, so they cannot be mentioned in reads annotations. note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nexercise 13. modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexercise 14. what happens if you remove the precondition a != null? change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# binary search\n\npredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nwe have the same postconditions that we did for the linear search, as the goal is the same. the difference is that now we know the array is sorted. because dafny can unwrap functions, inside the body of the method it knows this too. we can then use that property to prove the correctness of the search. the method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nthis is a fairly standard binary search implementation. first we declare our range to search over. this can be thought of as the remaining space where the key could possibly be. the range is inclusive-exclusive, meaning it encompasses indices [low, high). the first invariant expresses the fact that this range is within the array. the second says that the key is not anywhere outside of this range. in the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. we need the addition of one when moving the lower end of the range because it is inclusive on the low side. if we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. we could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. in the above formulation, this is unnecessary because when low == high, the loop exits. but this means that no elements are left in the search range, so the key was not found. this can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nwhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). thus the invariant says that all elements in the array are not the key, and the second postcondition holds. as you can see, it is easy to introduce subtle off by one errors in this code. with the invariants, not only can dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nexercise 15. change the assignments in the body of binarysearch to set low to mid or to set high to mid - 1. in each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# conclusion\n\nwe’ve seen a whirlwind tour of the major features of dafny, and used it for some interesting, if a little on the small side, examples of what dafny can do. but to really take advantage of the power dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. now that you are familiar with the basics of dafny, you can peruse the tutorials on each of these topics at your leisure. each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. the examples are also a good place to look for model dafny programs. finally, the reference contains the gritty details of dafny syntax and semantics, for when you just need to know what the disjoint set operator is (it’s !!, for those interested).\n\neven if you do not use dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. when modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. they also ensure that apis are used correctly, by formalizing behavior and requirements and enforcing correct usage. reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"cheet",frontmatter:{title:"cheet",date:"2022-03-26T11:02:27.000Z",categories:["语言","dafny-quick-start"],tags:[null],permalink:"/pages/fe5721/",readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/20.cheet.html",relativePath:"80.语言/00.dafny-quick-start/20.cheet.md",key:"v-e10e4096",path:"/pages/fe5721/",headers:[{level:2,title:"Specification",slug:"specification",normalizedTitle:"specification",charIndex:1855}],headersStr:"Specification",content:"KEYWORD(S)       WHAT IT DOES             SNIPPET\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { Foo(i);\n                                          }\nmethod returns   subroutines              /* Without a return value*/ method Hello() { print “Hello\n                                          Dafny”; } /*With a return value */ method Norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* Multiple return values */\n                                          method Prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class Point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method Dist2(that: Point) returns\n                                          (z: real) requires that != null { z := Norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          Find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# Specification\n\nKEYWORD(S)             WHAT IT DOES              SNIPPET\nrequires               precondition              method Rot90(p: Point) returns (q: Point) requires p !=\n                                                 null{ q := new Point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.Length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.Length }\nmodifies               framing (for methods)     method Reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to “a” otherwise */\nreads                  framing (for functions)   predicate Sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to “a[_]” otherwise */\ninvariant              loop invariants           i := 0;while i < a.Length invariant 0 <= i <= a.Length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.Length ==> a[k] ==\n                                                 0;",normalizedContent:"keyword(s)       what it does             snippet\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { foo(i);\n                                          }\nmethod returns   subroutines              /* without a return value*/ method hello() { print “hello\n                                          dafny”; } /*with a return value */ method norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* multiple return values */\n                                          method prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method dist2(that: point) returns\n                                          (z: real) requires that != null { z := norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# specification\n\nkeyword(s)             what it does              snippet\nrequires               precondition              method rot90(p: point) returns (q: point) requires p !=\n                                                 null{ q := new point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.length }\nmodifies               framing (for methods)     method reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to “a” otherwise */\nreads                  framing (for functions)   predicate sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to “a[_]” otherwise */\ninvariant              loop invariants           i := 0;while i < a.length invariant 0 <= i <= a.length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.length ==> a[k] ==\n                                                 0;",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"Getting Started with Dafny A Guide",frontmatter:{title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:03:41.000Z",permalink:"/pages/c80a4c/",categories:["语言","dafny-tutorials"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/10.dafny-tutorials/00.Getting%20Started%20with%20Dafny%20A%20Guide.html",relativePath:"80.语言/10.dafny-tutorials/00.Getting Started with Dafny A Guide.md",key:"v-6f2fc85c",path:"/pages/c80a4c/",headers:[{level:2,title:"Getting Started with Dafny: A Guide",slug:"getting-started-with-dafny-a-guide",normalizedTitle:"getting started with dafny: a guide",charIndex:28},{level:3,title:"Introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:242},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:1945},{level:3,title:"Pre- and Postconditions",slug:"pre-and-postconditions",normalizedTitle:"pre- and postconditions",charIndex:5156},{level:3,title:"Assertions",slug:"assertions",normalizedTitle:"assertions",charIndex:12244},{level:3,title:"Functions",slug:"functions",normalizedTitle:"functions",charIndex:22875},{level:3,title:"Loop Invariants",slug:"loop-invariants",normalizedTitle:"loop invariants",charIndex:28455},{level:3,title:"Termination",slug:"termination",normalizedTitle:"termination",charIndex:39962},{level:3,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:43929},{level:3,title:"Quantifiers",slug:"quantifiers",normalizedTitle:"quantifiers",charIndex:46819},{level:3,title:"Predicates",slug:"predicates",normalizedTitle:"predicates",charIndex:53780},{level:3,title:"Framing",slug:"framing",normalizedTitle:"framing",charIndex:55371},{level:3,title:"Binary Search",slug:"binary-search",normalizedTitle:"binary search",charIndex:59349},{level:3,title:"Conclusion",slug:"conclusion",normalizedTitle:"conclusion",charIndex:64781}],headersStr:"Getting Started with Dafny: A Guide Introduction Methods Pre- and Postconditions Assertions Functions Loop Invariants Termination Arrays Quantifiers Predicates Framing Binary Search Conclusion",content:'Dafny Documentation\n\n\n#\n\n\n# Getting Started with Dafny: A Guide\n\nBe sure to follow along with the code examples by clicking the “load in editor” link in the corner. See what the tool says, try to fix programs on your own, and experiment!\n\n\n# Introduction\n\nDafny is a language that is designed to make it easy to write correct code. This means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. To accomplish this, Dafny relies on high-level annotations to reason about and prove correctness of code. The effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. Dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). Dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. This is often easier than writing the code, because annotations are shorter and more direct. For example, the following fragment of annotation in Dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nThis says that for all integers k that are indices into the array, the value at that index is greater than zero. By writing these annotations, one is confident that the code is correct. Further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nIn addition to proving a correspondence to user supplied annotations, Dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. This guarantee is a powerful one, and is a strong case in and of itself for the use of Dafny and tools like it. Dafny also proves the termination of code, except in specially designated loops.\n\nLet’s get started writing some Dafny programs.\n\n\n# Methods\n\nDafny resembles a typical imperative programming language in many ways. There are methods, variables, types, loops, if statements, arrays, integers, and more. One of the basic units of any Dafny program is the method. A method is a piece of imperative, executable code. In other languages, they might be called procedures, or functions, but in Dafny the term “function” is reserved for a different concept that we will cover later. A method is declared in the following way:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a method called “Abs” which takes a single integer parameter, called “x”, and returns a single integer, called “y”. Note that the types are required for each parameter and return value, and follow each name after a colon (:). Also, the return values are named, and there can be multiple return values, as in below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThe method body is the code contained within the braces, which until now has been cleverly represented as “...” (which is not Dafny syntax). The body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. For example, the MultipleReturns method may be implemented as:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nAssignments do not use “=”, but rather “:=”. (In fact, as Dafny uses “==” for equality, there is no use of a single equals sign in Dafny expressions.) Simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. To return a value from a method, the value is assigned to one of the named return values sometime before a return statement. In fact, the return values act very much like local variables, and can be assigned to more than once. The input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. Return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. There are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). Here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (Other comparison operators are <=, >, >=, != and ==, with the expected meaning. See the reference for more on operators.)\n\n\n# Pre- and Postconditions\n\nNone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). The real power of Dafny comes from the ability to annotate these methods to specify their behavior. For example, one property that we observe with the Abs method is that the result is always greater than or equal to zero, regardless of the input. We could put this observation in a comment, but then we would have no way to know whether the method actually had this property. Further, if someone came along and changed the method, we wouldn’t be guaranteed that the comment was changed to match. With annotations, we can have Dafny prove that the property we claim of the method is true. There are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nThis property of the Abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. Postconditions, declared with the ensures keyword, are given as part of the method’s declaration, after the return values (if present) and before the method body. The keyword is followed by the boolean expression. Like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. In the case of the Abs method, a reasonable postcondition is the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nYou can see here why return values are given names. This makes them easy to refer to in the postcondition of a method. When the expression is true, we say that the postcondition holds. The postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). In this case, the only property we are expressing is that the return value is always at least zero.\n\nSometimes there are multiple properties that we would like to establish about our code. In this case, we have two options. We can either join the two conditions together with the boolean “and” operator (&&), or we can write multiple ensures specifications. The latter is basically the same as the former, but it seperates distinct properties. For example, the return value names from the MultipleReturns method might lead one to guess the following postconditions:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition can also be written:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in Dafny. (In general, most of the comparison operators can be chained, but only “in one direction”, i.e. not mixing “greater than” and “less than”. See the reference for details.)\n\nThe first way of expressing the postconditions separates the “less” part from the “more” part, which may be desirable. Another thing to note is that we have included one of the input parameters in the postcondition. This is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\nDafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). This means that Dafny wasn’t able to prove that this annotation holds every time the method returns. In general, there are two main causes for Dafny verification errors: specifications that are inconsistent with the code, and situations where it is not “clever” enough to prove the required properties. Differentiating between these two possibilities can be a difficult task, but fortunately, Dafny and the Boogie/Z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nIn this situation, Dafny is correct in saying there is an error with the code. The key to the problem is that y is an integer, so it can be negative. If y is negative (or zero), then more can actually be smaller than or equal to x. Our method will not work as intended unless y is strictly larger than zero. This is precisely the idea of a precondition. A precondition is similar to a postcondition, except that it is something that must be true before a method is called. When you call a method, it is your job to establish (make true) the preconditions, something Dafny will enforce using a proof. Likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. The caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. We can give the necessary precondition to MultipleReturns as below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nLike postconditions, multiple preconditions can be written either with the boolean “and” operator (&&), or by multiple requires keywords. Traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). With the addition of this condition, Dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nExercise 0. Write a method Max that takes two integer parameters and returns their maximum. Add appropriate annotations and make sure your code verifies.\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNot all methods necessarily have preconditions. For example, the Abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). Even though it has no need of preconditions, the Abs function as it stands now is not very useful. To investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# Assertions\n\nUnlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. Like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. An assertion says that a particular expression always holds when control reaches that part of the code. For example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try "asserting" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny proves this method correct, as 2 is always less than 3. Asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. You can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. Assertions are a powerful tool for debugging annotations, by checking what Dafny is able to prove about your code. For example, we can use it to investigate what Dafny knows about the Abs function.\n\nTo do this, we need one more concept: local variables. Local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (See the reference for details.) Local variables are declared with the var keyword, and can optionally have type declarations. Unlike method parameters, where types are required, Dafny can infer the types of local variables in almost all situations. This is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nThe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nMultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nExplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. We needed variables because we want to talk about the return value of the Abs method. We cannot put Abs inside a specification directly, as the method could change memory state, among other problems. So we capture the return value of a call to Abs as follows:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is an example of a situation where we can ask Dafny what it knows about the values in the code, in this case v. We do this by adding assertions, like the one above. Every time Dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. In this example, there is only one control path through the method, and Dafny is able to prove the annotation easily because it is exactly the postcondition of the Abs method. Abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to Abs.\n\nExercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nBut we know something stronger about the Abs method. In particular, for non-negative x, Abs(x) == x. Specifically, in the above program, the value of v is 3. If we try adding an assertion (or changing the existing one) to say:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that Dafny cannot prove our assertion, and gives an error. The reason this happens is that Dafny “forgets” about the body of every method except the one it is currently working on. This simplifies Dafny’s job tremendously, and is one of the reasons it is able to operate at reasonable speeds. It also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). We don’t care at all what happens inside each method when we call it, as long as it satisfies its annotations. This works because Dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nFor the Abs method, this means that the only thing Dafny knows in the Testing method about the value returned from Abs is what the postconditions say about it, and nothing more. This means that Dafny won’t know the nice property about Abs and non-negative integers unless we tell it by putting this in the postcondition of the Abs method. Another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. Everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. In the Abs case, we might have written:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nThis method satisfies the postconditions, but clearly the program fragment:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. Dafny is considering, in an abstract way, all methods with those annotations. The mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. We need stronger postconditions to eliminate these other possibilities, and “fix” the method down to exactly the one we want. We can partially do this with the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. The second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean “and” and comparisons, so the above says 0 <= x implies y == x). The left and right sides must both be boolean expressions.\n\nThe postcondition says that after Abs is called, if the value of x was non-negative, then y is equal to x. One caveat of the implication is that it is still true if the left part (the antecedent) is false. So the second postcondition is trivially true when x is negative. In fact, the only thing that the annotations say when x is negative is that the result, y, is positive. But this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nThese annotations are enough to require that our method actually computes the absolute value of x. These postconditions are not the only way to express this property. For example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIn general, there can be many ways to write down a given property. Most of the time it doesn’t matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nBut we still have an issue: there seems to be a lot of duplication. The body of the method is reflected very closely in the annotations. While this is correct code, we want to eliminate this redundancy. As you might guess, Dafny provides a means of doing this: functions.\n\nExercise 2. Using a precondition, change Abs to say it can only be called on negative values. Simplify the body of Abs into just one return statement and make sure the method still verifies.\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 3. Keeping the postconditions of Abs the same as above, change the body of Abs to just y := x + 2. What precondition do you need to annotate the method with in order for the verification to go through? What precondition do you need if the body is y := x + 1? What does that precondition say about when you can call the method?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a function called abs which takes a single integer, and returns an integer (the second int). Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. Here our body must be an integer expression. In order to implement the absolute value function, we need to use an if expression. An if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nObviously, the condition must be a boolean expression, and the two branches must have the same type. You might wonder why anyone would bother with functions, if they are so limited compared to methods. The power of functions comes from the fact that they can be used directly in specifications. So we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nIn fact, not only can we write this statement directly without capturing to a local variable, we didn’t even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). The limitations of functions are precisely what let Dafny do this. Unlike methods, Dafny does not forget the body of a function when considering other functions. So it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nExercise 4. Write a function max that returns the larger of two given integer parameters. Write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat of functions is that not only can they appear in annotations, they can only appear in annotations. One cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. Functions are never part of the final compiled program, they are just tools to help us verify our code. Sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. Note that there are restrictions on what functions can be function methods (See the reference for details).\n\nExercise 5. Change your test method from Exercise 4 to capture the value of max to a variable, and then do the checks from Exercise 4 using the variable. Dafny will reject this program because you are calling max from real code. Fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nExercise 6. Now that we have an abs function, change the postcondition of method Abs to make use of abs. After confirming the method still verifies, change the body of Abs to also use abs. (After doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nUnlike methods, functions can appear in expressions. Thus we can do something like implement the mathematical Fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nHere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. It turns out that we could make this function a function method if we wanted to. But this would be extremely slow, as this version of calculating the Fibonacci numbers has exponential complexity. There are much better ways to calculate the Fibonacci function. But this function is still useful, as we can have Dafny prove that a fast version really matches the mathematical definition. We can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nWe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWe haven’t written the body yet, so Dafny will complain that our postcondition doesn’t hold. We need an algorithm to calculate the nth Fibonacci number. The basic idea is to keep a counter, and repeatedly calculate adjacent pairs of Fibonacci numbers until the desired number is reached. To do this, we need a loop. In Dafny, this is done via a while loop. A while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nThis is a trivial loop that just increments i until it reaches n. This will form the core of our loop to calculate Fibonacci numbers.\n\n\n# Loop Invariants\n\nwhile loops present a problem for Dafny. There is no way for Dafny to know in advance how many times the code will go around the loop. But Dafny needs to consider all paths through a program, which could include going around the loop any number of times. To make it possible for Dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\nA loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. It captures something that is invariant, i.e. does not change, about every step of the loop. Now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldn’t need the loop. Like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. For example, we see in the above loop that if i starts off positive, then it stays positive. So we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWhen you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. By preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. Dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). Just as Dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nIn our example, the point of the loop is to build up the Fibonacci numbers one (well, two) at a time until we reach the desired number. After we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. We can use our assertion trick to check to see if Dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nWe find that this assertion fails. As far as Dafny knows, it is possible that i somehow became much larger than n at some point during the loop. All it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. In this case, this amounts to n <= i and 0 <= i. But this is not enough to guarantee that i == n, just that n <= i. Somehow we need to eliminate the possibility of i exceeding n. One first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThis does not verify, as Dafny complains that the invariant is not preserved (also known as not maintained) by the loop. We want to be able to say that after the loop exits, then all the invariants hold. Our invariant holds for every execution of the loop except for the very last one. Because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. Thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nNow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows Dafny to prove the assertion i == n. The challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nExercise 7. Change the loop invariant to 0 <= i <= n+2. Does the loop still verify? Does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExercise 8. With the original loop invariant, change the loop guard from i < n to i != n. Do the loop and the assertion after the loop still verify? Why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIn addition to the counter, our algorithm called for a pair of numbers which represent adjacent Fibonacci numbers in the sequence. Unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. To find these invariants, we employ a common Dafny trick: working backwards from the postconditions.\n\nOur postcondition for the Fibonacci method is that the return value b is equal to fib(n). But after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. This might make a good invariant, as it relates something to the loop counter. This observation is surprisingly common throughout Dafny programs. Often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. So we have that the variable b, which is conveniently our out parameter, will be the current Fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nWe also note that in our algorithm, we can compute any Fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. So we want a way of tracking the previous Fibonacci number, which we will call a. Another invariant will express that number’s relation to the loop counter. The invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nAt each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. Using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nHere a is the trailing number, and b is the leading number. The parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. Thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nWe also have made a change to the loop counter i. Because we also want to track the trailing number, we can’t start the counter at zero, as otherwise we would have to calculate a negative Fibonacci number. The problem with doing this is that the loop counter invariant may not hold when we enter the loop. The only problem is when n is zero. This can be eliminated as a special case, by testing for this condition at the beginning of the loop. The completed Fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. Dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nExercise 9. The ComputeFib method above is more complicated than necessary. Write a simpler program by not introducing a as the Fibonacci number that precedes b, but instead introducing a variable c that succeeds b. Verify your program is correct according to the mathematical definition of Fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nExercise 10. Starting with the completed ComputeFib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. Verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nOne of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. For example, we could have omitted the entire body of the loop in the previous program. The invariants would be correct, because they are still true upon entering the loop, and since the loop doesn’t change anything, they would be preserved by the loop. We know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. Thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# Termination\n\nDafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. For many things, Dafny is able to guess the right annotations, but sometimes it needs to be made explicit. In fact, for all of the code we have seen so far, Dafny has been able to do this proof on its own, which is why we haven’t seen the decreases annotation explicitly yet. There are two places Dafny proves termination: loops and recursion. Both of these situations require either an explicit annotation or a correct guess by Dafny.\n\nA decreases annotation, as its name suggests, gives Dafny an expression that decreases with every loop iteration or recursive call. There are two conditions that Dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. Many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (See the reference for details.) In the case of integers, the bound is assumed to be zero. For example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nHere Dafny has all the ingredients it needs to prove termination. The variable i gets smaller each loop iteration, and is bounded below by zero. This is fine, except the loop is backwards from most loops, which tend to count up instead of down. In this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. A simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis is actually Dafny’s guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. The upper bound of the loop invariant implies that 0 <= n – i, and gives Dafny a lower bound on the quantity. This also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nExercise 11. In the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. Note that if the loop guard were instead written as i != n (as in Exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. Change the loop guard to i != n and delete the invariant annotation. Does the program verify? What happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe other situation that requires a termination proof is when methods or functions are recursive. Similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. When Dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nAs before, Dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where Dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# Arrays\n\nAll that we have considered is fine for toy functions and little mathematical exercises, but it really isn’t helpful for real programs. So far we have only considered a handful of values at a time in local variables. Now we turn our attention to arrays of data. Arrays are a built-in part of the language, with their own type, array<T>, where T is another type. For now we only consider arrays of integers, array<int>. Arrays can be null, and have a built-in length field, a.Length. Element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. All array accesses must be proven to be within bounds, which is part of Dafny’s no-runtime-errors safety guarantee. Because bounds checks are proven at verification time, no runtime checks need to be made. To create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (See the tutorial on memory for more on allocation.)\n\nOne of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. We have two outcomes for a search, with a different correctness condition for each. If the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. This might be expressed as follows:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe array index here is safe because the implication operator is short circuiting. Short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. Using the short circuiting property of the implication operator, along with the boolean “and” (&&), which is also short circuiting, is a common Dafny practice. The condition index < a.Length is necessary because otherwise the method could return a large integer which is not an index into the array. Together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nIf the key is not in the array, then we would like the method to return a negative number. In this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. To express this property, we turn to another common Dafny tool: quantifiers.\n\n\n# Quantifiers\n\nA quantifier in Dafny most often takes the form of a forall expression, also called a universal quantifier. As its name suggests, this expression is true if some property holds for all elements of some set. For now, we will consider the set of integers. An example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\nA quantifier introduces a temporary name for each element of the set it is considering. This is called the bound variable, in this case k. The bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (In general, one can have any number of bound variables, a topic we will return to later.) A pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). In this case, the property is that adding one to any integer makes a strictly larger integer. Dafny is able to prove this simple property automatically. Generally it is not very useful to quantify over infinite sets, such as all the integers. Instead, quantifiers are typically used to quantify over all elements in an array or data structure. We do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\nThis says that some property holds for each element of the array. The implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. Dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nWith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\nThus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nAs you can see, we have omitted the loop invariants on the while loop, so Dafny gives us a verification error on one of the postconditions. The reason we get an error is that Dafny does not know that the loop actually covers all the elements. In order to convince Dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). Just like the postcondition, we can use a quantifier to express this property:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThis says that everything before, but excluding, the current index is not the key. Notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. This common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. This means that it is true when entering the loop. We test the value of the array before we extend the non-key part of the array, so Dafny can prove that this invariant is preserved. One problem arises when we try to add this invariant: Dafny complains about the index being out of range for the array access within the invariant.\n\nThis code does not verify because there is no invariant on index, so it could be greater than the length of the array. Then the bound variable, k, could exceed the length of the array. To fix this, we put the standard bounds on index, 0 <= index <= a.Length. Note that because we say k < index, the array access is still protected from error even when index == a.Length. The use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. The complete method is given below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 12. Write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the array’s elements. Annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nA linear search is not very efficient, especially when many queries are made of the same data. If the array is sorted, then we can use the very efficient binary search procedure to find the key. But in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. We could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# Predicates\n\nA predicate is a function which returns a boolean. It is a simple but powerful idea that occurs throughout Dafny programs. For example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. The use of predicates makes our code shorter, as we do not need to write out a long property over and over. It can also make our code easier to read by giving a common property a name.\n\nThere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. We can write a quantifier that expresses the property, “if x is before y in the array, then x <= y,” as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\nHere we have two bound variables, j and k, which are both integers. The comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. Then the second part says that they are ordered properly with respect to one another. Quantifiers are just a type of boolean valued expression in Dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nNote that there is no return type, because predicates always return a boolean.\n\nDafny rejects this code as given, claiming that the predicate cannot read a. Fixing this issue requires another annotation, the reads annotation.\n\n\n# Framing\n\nThe sorted predicate is not able to access the array because the array was not included in the function’s reading frame. The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. The reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. For example, we might have two arrays, one of which we know is sorted. If we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. While we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. In this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nA reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. Instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. The name of an array, like a in the above example, stands for all the elements of that array. One can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. Dafny will check that you do not read any memory location that is not stated in the reading frame. This means that function calls within a function must have reading frames that are a subset of the calling function’s reading frame. One thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nFrames also affect methods. As you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. Methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. They are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. In combination with reads, modification restrictions allow Dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow Dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that Dafny can reason about.\n\nNote that framing only applies to the heap, or memory accessed through references. Local variables are not stored on the heap, so they cannot be mentioned in reads annotations. Note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. Arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nExercise 13. Modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nExercise 14. What happens if you remove the precondition a != null? Change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Binary Search\n\nPredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nWe have the same postconditions that we did for the linear search, as the goal is the same. The difference is that now we know the array is sorted. Because Dafny can unwrap functions, inside the body of the method it knows this too. We can then use that property to prove the correctness of the search. The method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nThis is a fairly standard binary search implementation. First we declare our range to search over. This can be thought of as the remaining space where the key could possibly be. The range is inclusive-exclusive, meaning it encompasses indices [low, high). The first invariant expresses the fact that this range is within the array. The second says that the key is not anywhere outside of this range. In the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. We need the addition of one when moving the lower end of the range because it is inclusive on the low side. If we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. We could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. In the above formulation, this is unnecessary because when low == high, the loop exits. But this means that no elements are left in the search range, so the key was not found. This can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nWhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). Thus the invariant says that all elements in the array are not the key, and the second postcondition holds. As you can see, it is easy to introduce subtle off by one errors in this code. With the invariants, not only can Dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nExercise 15. Change the assignments in the body of BinarySearch to set low to mid or to set high to mid - 1. In each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Conclusion\n\nWe’ve seen a whirlwind tour of the major features of Dafny, and used it for some interesting, if a little on the small side, examples of what Dafny can do. But to really take advantage of the power Dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. Now that you are familiar with the basics of Dafny, you can peruse the tutorials on each of these topics at your leisure. Each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. The examples are also a good place to look for model Dafny programs. Finally, the reference contains the gritty details of Dafny syntax and semantics, for when you just need to know what the disjoint set operator is (it’s !!, for those interested).\n\nEven if you do not use Dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. Invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. When modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. They also ensure that APIs are used correctly, by formalizing behavior and requirements and enforcing correct usage. Reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',normalizedContent:'dafny documentation\n\n\n#\n\n\n# getting started with dafny: a guide\n\nbe sure to follow along with the code examples by clicking the “load in editor” link in the corner. see what the tool says, try to fix programs on your own, and experiment!\n\n\n# introduction\n\ndafny is a language that is designed to make it easy to write correct code. this means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. to accomplish this, dafny relies on high-level annotations to reason about and prove correctness of code. the effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. this is often easier than writing the code, because annotations are shorter and more direct. for example, the following fragment of annotation in dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nthis says that for all integers k that are indices into the array, the value at that index is greater than zero. by writing these annotations, one is confident that the code is correct. further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nin addition to proving a correspondence to user supplied annotations, dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. this guarantee is a powerful one, and is a strong case in and of itself for the use of dafny and tools like it. dafny also proves the termination of code, except in specially designated loops.\n\nlet’s get started writing some dafny programs.\n\n\n# methods\n\ndafny resembles a typical imperative programming language in many ways. there are methods, variables, types, loops, if statements, arrays, integers, and more. one of the basic units of any dafny program is the method. a method is a piece of imperative, executable code. in other languages, they might be called procedures, or functions, but in dafny the term “function” is reserved for a different concept that we will cover later. a method is declared in the following way:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a method called “abs” which takes a single integer parameter, called “x”, and returns a single integer, called “y”. note that the types are required for each parameter and return value, and follow each name after a colon (:). also, the return values are named, and there can be multiple return values, as in below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthe method body is the code contained within the braces, which until now has been cleverly represented as “...” (which is not dafny syntax). the body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. for example, the multiplereturns method may be implemented as:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nassignments do not use “=”, but rather “:=”. (in fact, as dafny uses “==” for equality, there is no use of a single equals sign in dafny expressions.) simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. to return a value from a method, the value is assigned to one of the named return values sometime before a return statement. in fact, the return values act very much like local variables, and can be assigned to more than once. the input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. there are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (other comparison operators are <=, >, >=, != and ==, with the expected meaning. see the reference for more on operators.)\n\n\n# pre- and postconditions\n\nnone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). the real power of dafny comes from the ability to annotate these methods to specify their behavior. for example, one property that we observe with the abs method is that the result is always greater than or equal to zero, regardless of the input. we could put this observation in a comment, but then we would have no way to know whether the method actually had this property. further, if someone came along and changed the method, we wouldn’t be guaranteed that the comment was changed to match. with annotations, we can have dafny prove that the property we claim of the method is true. there are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nthis property of the abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. postconditions, declared with the ensures keyword, are given as part of the method’s declaration, after the return values (if present) and before the method body. the keyword is followed by the boolean expression. like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. in the case of the abs method, a reasonable postcondition is the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nyou can see here why return values are given names. this makes them easy to refer to in the postcondition of a method. when the expression is true, we say that the postcondition holds. the postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). in this case, the only property we are expressing is that the return value is always at least zero.\n\nsometimes there are multiple properties that we would like to establish about our code. in this case, we have two options. we can either join the two conditions together with the boolean “and” operator (&&), or we can write multiple ensures specifications. the latter is basically the same as the former, but it seperates distinct properties. for example, the return value names from the multiplereturns method might lead one to guess the following postconditions:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition can also be written:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in dafny. (in general, most of the comparison operators can be chained, but only “in one direction”, i.e. not mixing “greater than” and “less than”. see the reference for details.)\n\nthe first way of expressing the postconditions separates the “less” part from the “more” part, which may be desirable. another thing to note is that we have included one of the input parameters in the postcondition. this is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\ndafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). this means that dafny wasn’t able to prove that this annotation holds every time the method returns. in general, there are two main causes for dafny verification errors: specifications that are inconsistent with the code, and situations where it is not “clever” enough to prove the required properties. differentiating between these two possibilities can be a difficult task, but fortunately, dafny and the boogie/z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nin this situation, dafny is correct in saying there is an error with the code. the key to the problem is that y is an integer, so it can be negative. if y is negative (or zero), then more can actually be smaller than or equal to x. our method will not work as intended unless y is strictly larger than zero. this is precisely the idea of a precondition. a precondition is similar to a postcondition, except that it is something that must be true before a method is called. when you call a method, it is your job to establish (make true) the preconditions, something dafny will enforce using a proof. likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. the caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. we can give the necessary precondition to multiplereturns as below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlike postconditions, multiple preconditions can be written either with the boolean “and” operator (&&), or by multiple requires keywords. traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). with the addition of this condition, dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nexercise 0. write a method max that takes two integer parameters and returns their maximum. add appropriate annotations and make sure your code verifies.\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnot all methods necessarily have preconditions. for example, the abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). even though it has no need of preconditions, the abs function as it stands now is not very useful. to investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# assertions\n\nunlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. an assertion says that a particular expression always holds when control reaches that part of the code. for example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try "asserting" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny proves this method correct, as 2 is always less than 3. asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. you can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. assertions are a powerful tool for debugging annotations, by checking what dafny is able to prove about your code. for example, we can use it to investigate what dafny knows about the abs function.\n\nto do this, we need one more concept: local variables. local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (see the reference for details.) local variables are declared with the var keyword, and can optionally have type declarations. unlike method parameters, where types are required, dafny can infer the types of local variables in almost all situations. this is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nthe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nmultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nexplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. we needed variables because we want to talk about the return value of the abs method. we cannot put abs inside a specification directly, as the method could change memory state, among other problems. so we capture the return value of a call to abs as follows:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is an example of a situation where we can ask dafny what it knows about the values in the code, in this case v. we do this by adding assertions, like the one above. every time dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. in this example, there is only one control path through the method, and dafny is able to prove the annotation easily because it is exactly the postcondition of the abs method. abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to abs.\n\nexercise 1. write a test method that calls your max method from exercise 0 and then asserts something about the result.\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbut we know something stronger about the abs method. in particular, for non-negative x, abs(x) == x. specifically, in the above program, the value of v is 3. if we try adding an assertion (or changing the existing one) to say:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that dafny cannot prove our assertion, and gives an error. the reason this happens is that dafny “forgets” about the body of every method except the one it is currently working on. this simplifies dafny’s job tremendously, and is one of the reasons it is able to operate at reasonable speeds. it also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). we don’t care at all what happens inside each method when we call it, as long as it satisfies its annotations. this works because dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nfor the abs method, this means that the only thing dafny knows in the testing method about the value returned from abs is what the postconditions say about it, and nothing more. this means that dafny won’t know the nice property about abs and non-negative integers unless we tell it by putting this in the postcondition of the abs method. another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. in the abs case, we might have written:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nthis method satisfies the postconditions, but clearly the program fragment:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. dafny is considering, in an abstract way, all methods with those annotations. the mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. we need stronger postconditions to eliminate these other possibilities, and “fix” the method down to exactly the one we want. we can partially do this with the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. the second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean “and” and comparisons, so the above says 0 <= x implies y == x). the left and right sides must both be boolean expressions.\n\nthe postcondition says that after abs is called, if the value of x was non-negative, then y is equal to x. one caveat of the implication is that it is still true if the left part (the antecedent) is false. so the second postcondition is trivially true when x is negative. in fact, the only thing that the annotations say when x is negative is that the result, y, is positive. but this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nthese annotations are enough to require that our method actually computes the absolute value of x. these postconditions are not the only way to express this property. for example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nin general, there can be many ways to write down a given property. most of the time it doesn’t matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nbut we still have an issue: there seems to be a lot of duplication. the body of the method is reflected very closely in the annotations. while this is correct code, we want to eliminate this redundancy. as you might guess, dafny provides a means of doing this: functions.\n\nexercise 2. using a precondition, change abs to say it can only be called on negative values. simplify the body of abs into just one return statement and make sure the method still verifies.\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 3. keeping the postconditions of abs the same as above, change the body of abs to just y := x + 2. what precondition do you need to annotate the method with in order for the verification to go through? what precondition do you need if the body is y := x + 1? what does that precondition say about when you can call the method?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a function called abs which takes a single integer, and returns an integer (the second int). unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. here our body must be an integer expression. in order to implement the absolute value function, we need to use an if expression. an if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nobviously, the condition must be a boolean expression, and the two branches must have the same type. you might wonder why anyone would bother with functions, if they are so limited compared to methods. the power of functions comes from the fact that they can be used directly in specifications. so we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nin fact, not only can we write this statement directly without capturing to a local variable, we didn’t even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). the limitations of functions are precisely what let dafny do this. unlike methods, dafny does not forget the body of a function when considering other functions. so it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nexercise 4. write a function max that returns the larger of two given integer parameters. write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat of functions is that not only can they appear in annotations, they can only appear in annotations. one cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. functions are never part of the final compiled program, they are just tools to help us verify our code. sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. note that there are restrictions on what functions can be function methods (see the reference for details).\n\nexercise 5. change your test method from exercise 4 to capture the value of max to a variable, and then do the checks from exercise 4 using the variable. dafny will reject this program because you are calling max from real code. fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexercise 6. now that we have an abs function, change the postcondition of method abs to make use of abs. after confirming the method still verifies, change the body of abs to also use abs. (after doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nunlike methods, functions can appear in expressions. thus we can do something like implement the mathematical fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nhere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. it turns out that we could make this function a function method if we wanted to. but this would be extremely slow, as this version of calculating the fibonacci numbers has exponential complexity. there are much better ways to calculate the fibonacci function. but this function is still useful, as we can have dafny prove that a fast version really matches the mathematical definition. we can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nwe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwe haven’t written the body yet, so dafny will complain that our postcondition doesn’t hold. we need an algorithm to calculate the nth fibonacci number. the basic idea is to keep a counter, and repeatedly calculate adjacent pairs of fibonacci numbers until the desired number is reached. to do this, we need a loop. in dafny, this is done via a while loop. a while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nthis is a trivial loop that just increments i until it reaches n. this will form the core of our loop to calculate fibonacci numbers.\n\n\n# loop invariants\n\nwhile loops present a problem for dafny. there is no way for dafny to know in advance how many times the code will go around the loop. but dafny needs to consider all paths through a program, which could include going around the loop any number of times. to make it possible for dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\na loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. it captures something that is invariant, i.e. does not change, about every step of the loop. now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldn’t need the loop. like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. for example, we see in the above loop that if i starts off positive, then it stays positive. so we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwhen you specify an invariant, dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. by preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). just as dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nin our example, the point of the loop is to build up the fibonacci numbers one (well, two) at a time until we reach the desired number. after we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. we can use our assertion trick to check to see if dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nwe find that this assertion fails. as far as dafny knows, it is possible that i somehow became much larger than n at some point during the loop. all it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. in this case, this amounts to n <= i and 0 <= i. but this is not enough to guarantee that i == n, just that n <= i. somehow we need to eliminate the possibility of i exceeding n. one first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthis does not verify, as dafny complains that the invariant is not preserved (also known as not maintained) by the loop. we want to be able to say that after the loop exits, then all the invariants hold. our invariant holds for every execution of the loop except for the very last one. because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nnow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows dafny to prove the assertion i == n. the challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nexercise 7. change the loop invariant to 0 <= i <= n+2. does the loop still verify? does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexercise 8. with the original loop invariant, change the loop guard from i < n to i != n. do the loop and the assertion after the loop still verify? why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nin addition to the counter, our algorithm called for a pair of numbers which represent adjacent fibonacci numbers in the sequence. unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. to find these invariants, we employ a common dafny trick: working backwards from the postconditions.\n\nour postcondition for the fibonacci method is that the return value b is equal to fib(n). but after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. this might make a good invariant, as it relates something to the loop counter. this observation is surprisingly common throughout dafny programs. often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. so we have that the variable b, which is conveniently our out parameter, will be the current fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nwe also note that in our algorithm, we can compute any fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. so we want a way of tracking the previous fibonacci number, which we will call a. another invariant will express that number’s relation to the loop counter. the invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nat each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nhere a is the trailing number, and b is the leading number. the parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nwe also have made a change to the loop counter i. because we also want to track the trailing number, we can’t start the counter at zero, as otherwise we would have to calculate a negative fibonacci number. the problem with doing this is that the loop counter invariant may not hold when we enter the loop. the only problem is when n is zero. this can be eliminated as a special case, by testing for this condition at the beginning of the loop. the completed fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nexercise 9. the computefib method above is more complicated than necessary. write a simpler program by not introducing a as the fibonacci number that precedes b, but instead introducing a variable c that succeeds b. verify your program is correct according to the mathematical definition of fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nexercise 10. starting with the completed computefib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\none of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. for example, we could have omitted the entire body of the loop in the previous program. the invariants would be correct, because they are still true upon entering the loop, and since the loop doesn’t change anything, they would be preserved by the loop. we know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# termination\n\ndafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. for many things, dafny is able to guess the right annotations, but sometimes it needs to be made explicit. in fact, for all of the code we have seen so far, dafny has been able to do this proof on its own, which is why we haven’t seen the decreases annotation explicitly yet. there are two places dafny proves termination: loops and recursion. both of these situations require either an explicit annotation or a correct guess by dafny.\n\na decreases annotation, as its name suggests, gives dafny an expression that decreases with every loop iteration or recursive call. there are two conditions that dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (see the reference for details.) in the case of integers, the bound is assumed to be zero. for example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nhere dafny has all the ingredients it needs to prove termination. the variable i gets smaller each loop iteration, and is bounded below by zero. this is fine, except the loop is backwards from most loops, which tend to count up instead of down. in this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. a simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis is actually dafny’s guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. the upper bound of the loop invariant implies that 0 <= n – i, and gives dafny a lower bound on the quantity. this also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nexercise 11. in the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. note that if the loop guard were instead written as i != n (as in exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. change the loop guard to i != n and delete the invariant annotation. does the program verify? what happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe other situation that requires a termination proof is when methods or functions are recursive. similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. when dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nas before, dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# arrays\n\nall that we have considered is fine for toy functions and little mathematical exercises, but it really isn’t helpful for real programs. so far we have only considered a handful of values at a time in local variables. now we turn our attention to arrays of data. arrays are a built-in part of the language, with their own type, array<t>, where t is another type. for now we only consider arrays of integers, array<int>. arrays can be null, and have a built-in length field, a.length. element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. all array accesses must be proven to be within bounds, which is part of dafny’s no-runtime-errors safety guarantee. because bounds checks are proven at verification time, no runtime checks need to be made. to create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (see the tutorial on memory for more on allocation.)\n\none of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. we have two outcomes for a search, with a different correctness condition for each. if the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. this might be expressed as follows:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe array index here is safe because the implication operator is short circuiting. short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. using the short circuiting property of the implication operator, along with the boolean “and” (&&), which is also short circuiting, is a common dafny practice. the condition index < a.length is necessary because otherwise the method could return a large integer which is not an index into the array. together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nif the key is not in the array, then we would like the method to return a negative number. in this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. to express this property, we turn to another common dafny tool: quantifiers.\n\n\n# quantifiers\n\na quantifier in dafny most often takes the form of a forall expression, also called a universal quantifier. as its name suggests, this expression is true if some property holds for all elements of some set. for now, we will consider the set of integers. an example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\na quantifier introduces a temporary name for each element of the set it is considering. this is called the bound variable, in this case k. the bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (in general, one can have any number of bound variables, a topic we will return to later.) a pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). in this case, the property is that adding one to any integer makes a strictly larger integer. dafny is able to prove this simple property automatically. generally it is not very useful to quantify over infinite sets, such as all the integers. instead, quantifiers are typically used to quantify over all elements in an array or data structure. we do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\nthis says that some property holds for each element of the array. the implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nwith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\nthus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nas you can see, we have omitted the loop invariants on the while loop, so dafny gives us a verification error on one of the postconditions. the reason we get an error is that dafny does not know that the loop actually covers all the elements. in order to convince dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). just like the postcondition, we can use a quantifier to express this property:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthis says that everything before, but excluding, the current index is not the key. notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. this common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. this means that it is true when entering the loop. we test the value of the array before we extend the non-key part of the array, so dafny can prove that this invariant is preserved. one problem arises when we try to add this invariant: dafny complains about the index being out of range for the array access within the invariant.\n\nthis code does not verify because there is no invariant on index, so it could be greater than the length of the array. then the bound variable, k, could exceed the length of the array. to fix this, we put the standard bounds on index, 0 <= index <= a.length. note that because we say k < index, the array access is still protected from error even when index == a.length. the use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. the complete method is given below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 12. write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the array’s elements. annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\na linear search is not very efficient, especially when many queries are made of the same data. if the array is sorted, then we can use the very efficient binary search procedure to find the key. but in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. we could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# predicates\n\na predicate is a function which returns a boolean. it is a simple but powerful idea that occurs throughout dafny programs. for example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. the use of predicates makes our code shorter, as we do not need to write out a long property over and over. it can also make our code easier to read by giving a common property a name.\n\nthere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. we can write a quantifier that expresses the property, “if x is before y in the array, then x <= y,” as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\nhere we have two bound variables, j and k, which are both integers. the comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. then the second part says that they are ordered properly with respect to one another. quantifiers are just a type of boolean valued expression in dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nnote that there is no return type, because predicates always return a boolean.\n\ndafny rejects this code as given, claiming that the predicate cannot read a. fixing this issue requires another annotation, the reads annotation.\n\n\n# framing\n\nthe sorted predicate is not able to access the array because the array was not included in the function’s reading frame. the reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. the reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. for example, we might have two arrays, one of which we know is sorted. if we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. while we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. in this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. the name of an array, like a in the above example, stands for all the elements of that array. one can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. dafny will check that you do not read any memory location that is not stated in the reading frame. this means that function calls within a function must have reading frames that are a subset of the calling function’s reading frame. one thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nframes also affect methods. as you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. they are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. in combination with reads, modification restrictions allow dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that dafny can reason about.\n\nnote that framing only applies to the heap, or memory accessed through references. local variables are not stored on the heap, so they cannot be mentioned in reads annotations. note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nexercise 13. modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexercise 14. what happens if you remove the precondition a != null? change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# binary search\n\npredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nwe have the same postconditions that we did for the linear search, as the goal is the same. the difference is that now we know the array is sorted. because dafny can unwrap functions, inside the body of the method it knows this too. we can then use that property to prove the correctness of the search. the method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nthis is a fairly standard binary search implementation. first we declare our range to search over. this can be thought of as the remaining space where the key could possibly be. the range is inclusive-exclusive, meaning it encompasses indices [low, high). the first invariant expresses the fact that this range is within the array. the second says that the key is not anywhere outside of this range. in the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. we need the addition of one when moving the lower end of the range because it is inclusive on the low side. if we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. we could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. in the above formulation, this is unnecessary because when low == high, the loop exits. but this means that no elements are left in the search range, so the key was not found. this can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nwhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). thus the invariant says that all elements in the array are not the key, and the second postcondition holds. as you can see, it is easy to introduce subtle off by one errors in this code. with the invariants, not only can dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nexercise 15. change the assignments in the body of binarysearch to set low to mid or to set high to mid - 1. in each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# conclusion\n\nwe’ve seen a whirlwind tour of the major features of dafny, and used it for some interesting, if a little on the small side, examples of what dafny can do. but to really take advantage of the power dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. now that you are familiar with the basics of dafny, you can peruse the tutorials on each of these topics at your leisure. each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. the examples are also a good place to look for model dafny programs. finally, the reference contains the gritty details of dafny syntax and semantics, for when you just need to know what the disjoint set operator is (it’s !!, for those interested).\n\neven if you do not use dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. when modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. they also ensure that apis are used correctly, by formalizing behavior and requirements and enforcing correct usage. reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Dafny type system",frontmatter:{title:"Dafny type system",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/a9c4a5/",categories:["语言","detailed-document"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/20.detailed-document/00.Dafny%20type%20system.html",relativePath:"80.语言/20.detailed-document/00.Dafny type system.md",key:"v-508d0816",path:"/pages/a9c4a5/",headers:[{level:2,title:"0. Basic types",slug:"_0-basic-types",normalizedTitle:"0. basic types",charIndex:355},{level:3,title:"0.0. Booleans",slug:"_0-0-booleans",normalizedTitle:"0.0. booleans",charIndex:371},{level:3,title:"0.1. Numeric types",slug:"_0-1-numeric-types",normalizedTitle:"0.1. numeric types",charIndex:386},{level:3,title:"0.2. Characters",slug:"_0-2-characters",normalizedTitle:"0.2. characters",charIndex:406},{level:2,title:"1. Type parameters",slug:"_1-type-parameters",normalizedTitle:"1. type parameters",charIndex:423},{level:2,title:"2. Collection types",slug:"_2-collection-types",normalizedTitle:"2. collection types",charIndex:443},{level:3,title:"2.0. Sets",slug:"_2-0-sets",normalizedTitle:"2.0. sets",charIndex:464},{level:3,title:"2.1. Multisets",slug:"_2-1-multisets",normalizedTitle:"2.1. multisets",charIndex:475},{level:3,title:"2.2. Sequences",slug:"_2-2-sequences",normalizedTitle:"2.2. sequences",charIndex:491},{level:4,title:"2.2.0. Strings",slug:"_2-2-0-strings",normalizedTitle:"2.2.0. strings",charIndex:507},{level:3,title:"2.3. Finite and Infinite Maps",slug:"_2-3-finite-and-infinite-maps",normalizedTitle:"2.3. finite and infinite maps",charIndex:523},{level:2,title:"3. Types that stand for other types",slug:"_3-types-that-stand-for-other-types",normalizedTitle:"3. types that stand for other types",charIndex:554},{level:3,title:"3.0. Type synonyms",slug:"_3-0-type-synonyms",normalizedTitle:"3.0. type synonyms",charIndex:591},{level:3,title:"3.1. Opaque types",slug:"_3-1-opaque-types",normalizedTitle:"3.1. opaque types",charIndex:611},{level:2,title:"4. Datatypes",slug:"_4-datatypes",normalizedTitle:"4. datatypes",charIndex:630},{level:3,title:"4.0. Inductive datatypes",slug:"_4-0-inductive-datatypes",normalizedTitle:"4.0. inductive datatypes",charIndex:644},{level:3,title:"4.1. Tuple types",slug:"_4-1-tuple-types",normalizedTitle:"4.1. tuple types",charIndex:670},{level:3,title:"4.2. Co-inductive datatypes",slug:"_4-2-co-inductive-datatypes",normalizedTitle:"4.2. co-inductive datatypes",charIndex:688},{level:2,title:"5. Reference types",slug:"_5-reference-types",normalizedTitle:"5. reference types",charIndex:717},{level:3,title:"5.0. Classes",slug:"_5-0-classes",normalizedTitle:"5.0. classes",charIndex:737},{level:3,title:"5.1. Arrays",slug:"_5-1-arrays",normalizedTitle:"5.1. arrays",charIndex:751},{level:4,title:"5.1.0. One-dimensional arrays",slug:"_5-1-0-one-dimensional-arrays",normalizedTitle:"5.1.0. one-dimensional arrays",charIndex:764},{level:4,title:"5.1.1. Multi-dimensional arrays",slug:"_5-1-1-multi-dimensional-arrays",normalizedTitle:"5.1.1. multi-dimensional arrays",charIndex:795},{level:3,title:"5.2. Traits",slug:"_5-2-traits",normalizedTitle:"5.2. traits",charIndex:828},{level:3,title:"5.3. Type object",slug:"_5-3-type-object",normalizedTitle:"5.3. type object",charIndex:841},{level:3,title:"5.4. Iterator types",slug:"_5-4-iterator-types",normalizedTitle:"5.4. iterator types",charIndex:859},{level:3,title:"5.5. Async-task types",slug:"_5-5-async-task-types",normalizedTitle:"5.5. async-task types",charIndex:880},{level:2,title:"6. Function types",slug:"_6-function-types",normalizedTitle:"6. function types",charIndex:903},{level:3,title:"6.0. Lambda expressions",slug:"_6-0-lambda-expressions",normalizedTitle:"6.0. lambda expressions",charIndex:922},{level:2,title:"7. Newtypes",slug:"_7-newtypes",normalizedTitle:"7. newtypes",charIndex:947},{level:3,title:"7.0. Numeric conversion operations",slug:"_7-0-numeric-conversion-operations",normalizedTitle:"7.0. numeric conversion operations",charIndex:960},{level:2,title:"8. Subset types",slug:"_8-subset-types",normalizedTitle:"8. subset types",charIndex:996},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:58798}],headersStr:"0. Basic types 0.0. Booleans 0.1. Numeric types 0.2. Characters 1. Type parameters 2. Collection types 2.0. Sets 2.1. Multisets 2.2. Sequences 2.2.0. Strings 2.3. Finite and Infinite Maps 3. Types that stand for other types 3.0. Type synonyms 3.1. Opaque types 4. Datatypes 4.0. Inductive datatypes 4.1. Tuple types 4.2. Co-inductive datatypes 5. Reference types 5.0. Classes 5.1. Arrays 5.1.0. One-dimensional arrays 5.1.1. Multi-dimensional arrays 5.2. Traits 5.3. Type object 5.4. Iterator types 5.5. Async-task types 6. Function types 6.0. Lambda expressions 7. Newtypes 7.0. Numeric conversion operations 8. Subset types Acknowledgments",content:"# Types in Dafny\n\nManuscript KRML 243 27 February 2015\n\nK. Rustan M. Leinoleino@microsoft.com\n\nThis part of the Dafny language reference describes the types in the Dafny programming language. What is described is what is implemented in version 1.9.3.20107 of Dafny, with the exception of async-task types which have not yet made it into the main branch.\n\n0. Basic types\n\n0.0. Booleans\n\n0.1. Numeric types\n\n0.2. Characters\n\n1. Type parameters\n\n2. Collection types\n\n2.0. Sets\n\n2.1. Multisets\n\n2.2. Sequences\n\n2.2.0. Strings\n\n2.3. Finite and Infinite Maps\n\n3. Types that stand for other types\n\n3.0. Type synonyms\n\n3.1. Opaque types\n\n4. Datatypes\n\n4.0. Inductive datatypes\n\n4.1. Tuple types\n\n4.2. Co-inductive datatypes\n\n5. Reference types\n\n5.0. Classes\n\n5.1. Arrays\n\n5.1.0. One-dimensional arrays\n\n5.1.1. Multi-dimensional arrays\n\n5.2. Traits\n\n5.3. Type object\n\n5.4. Iterator types\n\n5.5. Async-task types\n\n6. Function types\n\n6.0. Lambda expressions\n\n7. Newtypes\n\n7.0. Numeric conversion operations\n\n8. Subset types\n\n\n# 0. Basic types\n\nDafny offers three basic types, bool for booleans, int for integers, and real for reals.\n\n\n# 0.0. Booleans\n\nThere are two boolean values and each has a corresponding literal in the language: false and true.\n\nIn addition to equality (==) and disequality (!=), which are defined on all types, type bool supports the following operations:\n\n           \noperator   description\n           \n<==>       equivalence (if and only if)\n           \n==>        implication (implies)\n<==        reverse implication (follows from)\n           \n&&         conjunction (and)\n||         disjunction (or)\n           \n!          negation (not)\n           \n\nNegation is unary; the others are binary. The table shows the operators in groups of increasing binding power, with equality binding stronger than conjunction and disjunction, and weaker than negation. Within each group, different operators do not associate, so parentheses need to be used. For example,\n\nA && B || C    // error\n\n\n1\n\n\nwould be ambiguous and instead has to be written as either\n\n(A && B) || C\n\n\n1\n\n\nor\n\nA && (B || C)\n\n\n1\n\n\ndepending on the intended meaning.\n\nThe expressions A <==> B and A == B give the same value, but note that <==> is associative whereas == is chaining. So,\n\nA <==> B <==> C\n\n\n1\n\n\nis the same as\n\nA <==> (B <==> C)\n\n\n1\n\n\nand\n\n(A <==> B) <==> C\n\n\n1\n\n\nwhereas\n\nA == B == C\n\n\n1\n\n\nis simply a shorthand for\n\nA == B && B == C\n\n\n1\n\n\nConjunction is associative and so is disjunction. These operators are are short circuiting (from left to right), meaning that their second argument is evaluated only if the evaluation of the first operand does not determine the value of the expression. Logically speaking, the expression A && B is defined when A is defined and either A evaluates to false or B is defined. When A && B is defined, its meaning is the same as the ordinary, symmetric mathematical conjunction ∧. The same holds for || and ∨.\n\nImplication is right associative and is short-circuiting from left to right. Reverse implication B <== A is exactly the same as A ==> B, but gives the ability to write the operands in the opposite order. Consequently, reverse implication is left associative and is short-circuiting from right to left. To illustrate the associativity rules, each of the following four lines expresses the same property, for any A, B, and C of type bool:\n\nA ==> B ==> C\nA ==> (B ==> C)  // parentheses redundant, since ==> is right associative\nC <== B <== A\n(C <== B) <== A  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nTo illustrate the short-circuiting rules, note that the expression a.Length is defined for an array a only if a is not null (see Section 5), which means the following two expressions are well-formed:\n\na != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n\n\n1\n2\n\n\nThe contrapositive of these two expressions would be:\n\na.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n\n\n1\n2\n\n\nbut these expressions are not well-formed, since well-formedness requires the left (and right, respectively) operand, a.Length < 0, to be well-formed by itself.\n\nImplication A ==> B is equivalent to the disjunction !A || B, but is sometimes (especially in specifications) clearer to read. Since, || is short-circuiting from left to right, note that\n\na == null || 0 <= a.Length\n\n\n1\n\n\nis well-formed, whereas\n\n0 <= a.Length || a == null  // not well-formed\n\n\n1\n\n\nis not.\n\nIn addition, booleans support logical quantifiers (forall and exists), described in a different part of the Dafny language reference.\n\n\n# 0.1. Numeric types\n\nDafny supports numeric types of two kinds, integer-based, which includes the basic type int of all integers, and real-based, which includes the basic type real of all real numbers. User-defined numeric types based on int and real, called newtypes, are described in Section 7. Also, the subset type nat, representing the non-negative subrange of int, is described in Section 8.\n\nThe language includes a literal for each non-negative integer, like 0, 13, and 1985. Integers can also be written in hexadecimal using the prefix “0x”, as in 0x0, 0xD, and 0x7c1 (always with a lower case x, but the hexadecimal digits themselves are case insensitive). Leading zeros are allowed. To form negative integers, use the unary minus operator.\n\nThere are also literals for some of the non-negative reals. These are written as a decimal point with a nonempty sequence of decimal digits on both sides. For example, 1.0, 1609.344, and 0.5772156649.\n\nFor integers (in both decimal and hexidecimal form) and reals, any two digits in a literal may be separated by an underscore in order to improve human readability of the literals. For example:\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 Ångström\n\n\n1\n2\n3\n4\n\n\nIn addition to equality and disequality, numeric types support the following relational operations:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nLike equality and disequality, these operators are chaining, as long as they are chained in the “same direction”. That is,\n\nA <= B < C == D <= E\n\n\n1\n\n\nis simply a shorthand for\n\nA <= B && B < C && C == D && D <= E\n\n\n1\n\n\nwhereas\n\nA < B > C\n\n\n1\n\n\nis not allowed.\n\nThere are also operators on each numeric type:\n\n           \noperator   description\n           \n+          addition (plus)\n-          subtraction (minus)\n           \n*          multiplication (times)\n/          division (divided by)\n%          modulus (mod)\n           \n-          negation (unary minus)\n           \n\nThe binary operators are left associative, and they associate with each other in the two groups. The groups are listed in order of increasing binding power, with equality binding more strongly than the multiplicative operators and weaker than the unary operator. Modulus is supported only for integer-based numeric types. Integer division and modulus are the Euclidean division and modulus. This means that modulus always returns a non-negative, regardless of the signs of the two operands. More precisely, for any integer a and non-zero integer b,\n\na == a / b * b + a % b\n0 <= a % b < B\n\n\n1\n2\n\n\nwhere B denotes the absolute value of b.\n\nReal-based numeric types have a member Trunc that returns the floor of the real value, that is, the largest integer not exceeding the real value. For example, the following properties hold, for any r and r' of type real:\n\n3.14.Trunc == 3\n(-2.5).Trunc == -3\n-2.5.Trunc == -2\nreal(r.Trunc) <= r\nr <= r' ==> r.Trunc <= r'.Trunc\n\n\n1\n2\n3\n4\n5\n\n\nNote in the third line that member access (like .Trunc) binds stronger than unary minus. The fourth line uses the conversion function real from int to real, as described in Section 7.0.\n\n\n# 0.2. Characters\n\nDafny supports a type char of characters. Character literals are enclosed in single quotes, as in 'D'. To write a single quote as a character literal, it is necessary to use an escape sequence. Escape sequences can also be used to write other characters. The supported escape sequences are as follows:\n\n                  \nescape sequence   meaning\n                  \n\\'                the character '\n\"                 the character \"\n\\\\                the character \\\n\\0                the null character, same as \\u0000\n\\n                line feed\n\\r                carriage return\n\\t                horizontal tab\n\\u*xxxx*          universal character whose hexadecimal code is *xxxx*\n                  \n\nThe escape sequence for a double quote is redundant, because '\"' and '\"' denote the same character—both forms are provided in order to support the same escape sequences as for string literals (Section 2.2.0). In the form \\u*xxxx*, the u is always lower case, but the four hexadecimal digits are case insensitive.\n\nCharacter values are ordered and can be compared using the standard relational operators:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nSequences of characters represent strings, as described in Section 2.2.0.\n\n\n# 1. Type parameters\n\nMany of the types (as well as functions and methods) in Dafny can be parameterized by types. These type parameters are typically declared inside angle brackets and can stand for any type. It is sometimes necessary to restrict these type parameters so that they can only be instantiated by certain families of types. As such, Dafny distinguishes types that support the equality operation not only in ghost contexts but also in compiled contexts. To indicate that a type parameter is restricted to such equality supporting types, the name of the type parameter takes the suffix “(==)”.0 For example,\n\nmethod Compare〈T(==)〉(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\nis a method whose type parameter is restricted to equality-supporting types. Again, note that all types support equality in ghost contexts; the difference is only for non-ghost (that is, compiled) code. Co-inductive datatypes, function types, as well as inductive datatypes with ghost parameters are examples of types that are not equality supporting.\n\nDafny has some inference support that makes certain signatures less cluttered (described in a different part of the Dafny language reference). In some cases, this support will infer that a type parameter must be restricted to equality-supporting types, in which case Dafny adds the “(==)” automatically.\n\n\n# 2. Collection types\n\nDafny offers several built-in collection types.\n\n\n# 2.0. Sets\n\nFor any type T, each value of type set〈T〉 is a finite set of T values. Set membership is determined by equality in the type T, so set〈T〉 can be used in a non-ghost context only if T is equality supporting.\n\nA set can be formed using a set display expression, which is a possibly empty, unordered, duplicate-insensitive list of expressions enclosed in curly braces. To illustrate,\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of set displays. There is also a set comprehension expression (with a binder, like in logical quantifications), described in a different part of the Dafny language reference.\n\nIn addition to equality and disequality, set types support the following relational operations:\n\n           \noperator   description\n           \n<          proper subset\n<=         subset\n>=         superset\n>          proper superset\n           \n\nLike the arithmetic relational operators, these operators are chaining.\n\nSets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         disjointness\n           \n+          set union\n-          set difference\n           \n*          set intersection\n           \n\nThe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. The expression A !! B, whose binding power is the same as equality (but which neither associates nor chains with equality), says that sets A and B have no elements in common, that is, it is equivalent to\n\nA * B == {}\n\n\n1\n\n\nHowever, the disjointness operator is chaining, so A !! B !! C !! D means:\n\nA * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n\n\n1\n\n\nIn addition, for any set s of type set〈T〉 and any expression e of type T, sets support the following operations:\n\n             \nexpression   description\n             \n|s|          set cardinality\ne in s       set membership\ne !in s      set non-membership\n             \n\nThe expression e !in s is a syntactic shorthand for !(e in s).\n\n\n# 2.1. Multisets\n\nA multiset is similar to a set, but keeps track of the multiplicity of each element, not just its presence or absence. For any type T, each value of type multiset〈T〉 is a map from T values to natural numbers denoting each element's multiplicity. Multisets in Dafny are finite, that is, they contain a finite number of each of a finite set of elements. Stated differently, a multiset maps only a finite number of elements to non-zero (finite) multiplicities.\n\nLike sets, multiset membership is determined by equality in the type T, so multiset〈T〉 can be used in a non-ghost context only if T is equality supporting.\n\nA multiset can be formed using a multiset display expression, which is a possibly empty, unordered list of expressions enclosed in curly braces after the keyword multiset. To illustrate,\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of multiset displays. There is no multiset comprehension expression.\n\nIn addition to equality and disequality, multiset types support the following relational operations:\n\n           \noperator   description\n           \n<          proper multiset subset\n<=         multiset subset\n>=         multiset superset\n>          proper multiset superset\n           \n\nLike the arithmetic relational operators, these operators are chaining.\n\nMultisets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         multiset disjointness\n           \n+          multiset union\n-          multiset difference\n           \n*          multiset intersection\n           \n\nThe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. The expression A !! B says that multisets A and B have no elements in common, that is, it is equivalent to\n\nA * B == multiset{}\n\n\n1\n\n\nLike the analogous set operator, !! is chaining.\n\nIn addition, for any multiset s of type multiset〈T〉, expression e of type T, and non-negative integer-based numeric n, multisets support the following operations:\n\n             \nexpression   description\n             \n|s|          multiset cardinality\ne in s       multiset membership\ne !in s      multiset non-membership\ns[e]         multiplicity of e in s\ns[e := n]    multiset update (change of multiplicity)\n             \n\nThe expression e in s returns true if and only if s[e] != 0. The expression e !in s is a syntactic shorthand for !(e in s). The expression s[e := n] denotes a multiset like s, but where the multiplicity of element e is n. Note that the multiset update s[e := 0] results in a multiset like s but without any occurrences of e (whether or not s has occurrences of e in the first place). As another example, note that s - multiset{e} is equivalent to:\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2. Sequences\n\nFor any type T, a value of type seq〈T〉 denotes a sequence of T elements, that is, a mapping from a finite set of consecutive natural numbers (called indicies) to T values. (Thinking of it as a map, a sequence is therefore something of a dual of a multiset.)\n\nA sequence can be formed using a sequence display expression, which is a possibly empty, ordered list of expressions enclosed in square brackets. To illustrate,\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\nare three examples of sequence displays. There is no sequence comprehension expression.\n\nIn addition to equality and disequality, sequence types support the following relational operations:\n\n           \noperator   description\n           \n<          proper prefix\n<=         prefix\n           \n\nLike the arithmetic relational operators, these operators are chaining. Note the absence of > and >=.\n\nSequences support the following binary operator:\n\n           \noperator   description\n           \n+          concatenation\n           \n\nOperator + is associative, like the arithmetic operator with the same name.\n\nIn addition, for any sequence s of type seq〈T〉, expression e of type T, integer-based numeric i satisfying 0 <= i < |s|, and integer-based numerics lo and hi satisfying 0 <= lo <= hi <= |s|, sequences support the following operations:\n\n              \nexpression    description\n              \n|s|           sequence length\ns[i]          sequence selection\ns[i := e]     sequence update\ne in s        sequence membership\ne !in s       sequence non-membership\ns[lo..hi]     subsequence\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   slice\nmultiset(s)   sequence conversion to a multiset〈T〉\n              \n\nExpression s[i := e] returns a sequence like s, except that the element at index i is e. The expression e in s says there exists an index i such that s[i] == e. It is allowed in non-ghost contexts only if the element type T is equality supporting. The expression e !in s is a syntactic shorthand for !(e in s).\n\nExpression s[lo..hi] yields a sequence formed by taking the first hi elements and then dropping the first lo elements. The resulting sequence thus has length hi - lo. Note that s[0..|s|] equals s. If the upper bound is omitted, it defaults to |s|, so s[lo..] yields the sequence formed by dropping the first lo elements of s. If the lower bound is omitted, it defaults to 0, so s[..hi] yields the sequence formed by taking the first hi elements of s.\n\nIn the sequence slice operation, *slices* is a nonempty list of length designators separated and optionally terminated by a colon, and there is at least one colon. Each length designator is a non-negative integer-based numeric, whose sum is no greater than |s|. If there are k colons, the operation produces k consecutive subsequences from s, each of the length indicated by the corresponding length designator, and returns these as a sequence of sequences.1 If *slices* is terminated by a colon, then the length of the last slice extends until the end of s, that is, its length is |s| minus the sum of the given length designators. For example, the following equalities hold, for any sequence s of length at least 10:\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe operation multiset(s) yields the multiset of elements of sequence s. It is allowed in non-ghost contexts only if the element type T is equality supporting.\n\n# 2.2.0. Strings\n\nA special case of a sequence type is seq〈char〉, for which Dafny provides a synonym: string. Strings are like other sequences, but provide additional syntax for sequence display expressions, namely string literals. There are two forms of the syntax for string literals: the standard form and the verbatim form.\n\nString literals of the standard form are enclosed in double quotes, as in \"Dafny\". To include a double quote in such a string literal, it is necessary to use an escape sequence. Escape sequences can also be used to include other characters. The supported escape sequences are the same as those for character literals, see Section 0.2. For example, the Dafny expression \"say \\\"yes\\\"\" represents the string say \"yes\". The escape sequence for a single quote is redundant, because \"'\" and \"'\" denote the same string—both forms are provided in order to support the same escape sequences as for character literals.\n\nString literals of the verbatim form are bracketed by @\" and \", as in @\"Dafny\". To include a double quote in such a string literal, it is necessary to use the escape sequence \"\", that is, to write the character twice. In the verbatim form, there are no other escape sequences. Even characters like newline can be written inside the string literal (hence spanning more than one line in the program text).\n\nFor example, the following three expressions denote the same string:\n\n\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nSince strings are sequences, the relational operators < and <= are defined on them. Note, however, that these operators still denote proper prefix and prefix, respectively, not some kind of alphabetic comparison as might be desireable, for example, when sorting strings.\n\n\n# 2.3. Finite and Infinite Maps\n\nFor any types T and U, a value of type map〈T,U〉 denotes a (finite) map from T to U. In other words, it is a look-up table indexed by T. The domain of the map is a finite set of T values that have associated U values. Since the keys in the domain are compared using equality in the type T, type map〈T,U〉 can be used in a non-ghost context only if T is equality supporting.\n\nSimilarly, for any types T and U, a value of type imap〈T,U〉 denotes a (possibly) infinite map. In most regards, imap〈T,U〉 is like map〈T,U〉, but a map of type imap〈T,U〉 is allowed to have an infinite domain.\n\nA map can be formed using a map display expression, which is a possibly empty, ordered list of maplets, each maplet having the form t := u where t is an expression of type T and u is an expression of type U, enclosed in square brackets after the keyword map. To illustrate,\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\nare three examples of map displays. By using the keyword imap instead of map, the map produced will be of type imap〈T,U〉 instead of map〈T,U〉. Note that an infinite map (imap) is allowed to have a finite domain, whereas a finite map (map) is not allowed to have an infinite domain. If the same key occurs more than once, only the last occurrence appears in the resulting map.2 There is also a map comprehension expression, explained in a different part of the Dafny language reference.\n\nFor any map fm of type map〈T,U〉, any map m of type map〈T,U〉 or imap〈T,U〉, any expression t of type T, any expression u of type U, and any d in the domain of m (that is, satisfying d in m), maps support the following operations:\n\n             \nexpression   description\n             \n|fm|         map cardinality\nm[d]         map selection\nm[t := u]    map update\nt in m       map domain membership\nt !in m      map domain non-membership\n             \n\n|fm| denotes the number of mappings in fm, that is, the cardinality of the domain of fm. Note that the cardinality operator is not supported for infinite maps. Expression m[d] returns the U value that m associates with d. Expression m[t := u] is a map like m, except that the element at key t is u. The expression t in m says t is in the domain of m and t !in m is a syntactic shorthand for !(t in m).3\n\nHere is a small example, where a map cache of type map〈int,real〉 is used to cache computed values of Joule-Thomson coefficients for some fixed gas at a given temperature:\n\nif K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJouleThomsonCoefficient(K);  // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3. Types that stand for other types\n\nIt is sometimes useful to know a type by several names or to treat a type abstractly.\n\n\n# 3.0. Type synonyms\n\nA type synonym declaration:\n\ntype Y〈T〉 = G\n\n\n1\n\n\ndeclares Y〈T〉 to be a synonym for the type G. Here, T is a nonempty list of type parameters (each of which is optionally designated with the suffix “(==)”), which can be used as free type variables in G. If the synonym has no type parameters, the “〈T〉” is dropped. In all cases, a type synonym is just a synonym. That is, there is never a difference, other than possibly in error messages produced, between Y〈T〉 and G.\n\nFor example, the names of the following type synonyms may improve the readability of a program:\n\ntype Replacements〈T〉 = map〈T,T〉\ntype Vertex = int\n\n\n1\n2\n\n\nAs already described in Section 2.2.0, string is a built-in type synonym for seq〈char〉, as if it would have been declared as follows:\n\ntype string = seq〈char〉\n\n\n1\n\n\n\n# 3.1. Opaque types\n\nA special case of a type synonym is one that is underspecified. Such a type is declared simply by:\n\ntype Y〈T〉\n\n\n1\n\n\nIt is a known as an opaque type. Its definition can be revealed in a refining module. To indicate that Y designates an equality-supporting type, “(==)” can be written immediately following the name “Y”.\n\nFor example, the declarations\n\ntype T\nfunction F(t: T): T\n\n\n1\n2\n\n\ncan be used to model an uninterpreted function F on some arbitrary type T. As another example,\n\ntype Monad〈T〉\n\n\n1\n\n\ncan be used abstractly to represent an arbitrary parameterized monad.\n\n\n# 4. Datatypes\n\nDafny offers two kinds of algebraic datatypes, those defined inductively and those defined co-inductively. The salient property of every datatype is that each value of the type uniquely identifies one of the datatype's constructors and each constructor is injective in its parameters.\n\n\n# 4.0. Inductive datatypes\n\nThe values of inductive datatypes can be seen as finite trees where the leaves are values of basic types, numeric types, reference types, co-inductive datatypes, or function types. Indeed, values of inductive datatypes can be compared using Dafny's well-founded < ordering.\n\nAn inductive datatype is declared as follows:\n\ndatatype D〈T〉 = Ctors\n\n\n1\n\n\nwhere *Ctors* is a nonempty |-separated list of (datatype) constructors for the datatype. Each constructor has the form:\n\nC(params)\n\n\n1\n\n\nwhere *params* is a comma-delimited list of types, optionally preceded by a name for the parameter and a colon, and optionally preceded by the keyword ghost. If a constructor has no parameters, the parentheses after the constructor name can be omitted. If no constructor takes a parameter, the type is usually called an enumeration; for example:\n\ndatatype Friends = Agnes | Agatha | Jermaine | Jack\n\n\n1\n\n\nFor every constructor C, Dafny defines a discriminator C?, which is a member that returns true if and only if the datatype value has been constructed using C. For every named parameter p of a constructor C, Dafny defines a destructor p, which is a member that returns the p parameter from the C call used to construct the datatype value; its use requires that C? holds. For example, for the standard List type\n\ndatatype List〈T〉 = Nil | Cons(head: T, tail: List〈T〉)\n\n\n1\n\n\nthe following holds:\n\nCons(5, Nil).Cons? && Cons(5, Nil).head == 5\n\n\n1\n\n\nNote that the expression\n\nCons(5, Nil).tail.head\n\n\n1\n\n\nis not well-formed, since Cons(5, Nil).tail does not satisfy Cons?.\n\nThe names of the destructors must be unique across all the constructors of the datatype. A constructor can have the same name as the enclosing datatype; this is especially useful for single-constructor datatypes, which are often called record types. For example, a record type for black-and-white pixels might be represented as follows:\n\ndatatype Pixel = Pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nTo call a constructor, it is usually necessary only to mention the name of the constructor, but if this is ambiguous, it is always possible to qualify the name of constructor by the name of the datatype. For example, Cons(5, Nil) above can be written\n\nList.Cons(5, List.Nil)\n\n\n1\n\n\nAs an alternative to calling a datatype constructor explicitly, a datatype value can be constructed as a change in one parameter from a given datatype value using the datatype update expression. For any d whose type is a datatype that includes a constructor C that has a parameter (destructor) named f of type T, and any expression t of type T,\n\nd[f := t]\n\n\n1\n\n\nconstructs a value like d but whose f parameter is t. The operation requires that d satisfies C?. For example, the following equality holds:\n\nCons(4, Nil)[tail := Cons(3, Nil)] == Cons(4, Cons(3, Nil))\n\n\n1\n\n\n\n# 4.1. Tuple types\n\nDafny builds in record types that correspond to tuples and gives these a convenient special syntax, namely parentheses. For example, what might have been declared as:\n\ndatatype Pair〈T,U〉 = Pair(0: T, 1: U)\n\n\n1\n\n\nDafny provides as the type (T, U) and the constructor (t, u), as if the datatype's name were “” and its type arguments are given in round parentheses, and as if the constructor name were “”. Note that the destructor names are 0 and 1, which are legal identifier names for members. For example, showing the use of a tuple destructor, here is a property that holds of 2-tuples (that is, pairs):\n\n(5, true).1 == true\n\n\n1\n\n\nDafny declares n-tuples where n is 0 or 2 or up. There are no 1-tuples, since parentheses around a single type or a single value have no semantic meaning. The 0-tuple type, (), is often known as the unit type and its single value, also written (), is known as unit.\n\n\n# 4.2. Co-inductive datatypes\n\nWhereas Dafny insists that there is a way to construct every inductive datatype value from the ground up, Dafny also supports co-inductive datatypes, whose constructors are evaluated lazily and hence allows infinite structures. A co-inductive datatype is declared using the keyword codatatype; other than that, it is declared and used like an inductive datatype.\n\nFor example,\n\ncodatatype IList〈T〉 = Nil | Cons(head: T, tail: IList〈T〉)\ncodatatype Stream〈T〉 = More(head: T, tail: Stream〈T〉)\ncodatatype Tree〈T〉 = Node(left: Tree〈T〉, value: T, right: Tree〈T〉)\n\n\n1\n2\n3\n\n\ndeclare possibly infinite lists (that is, lists that can be either finite or infinite), infinite streams (that is, lists that are always infinite), and infinite binary trees (that is, trees where every branch goes on forever), respectively.\n\n\n# 5. Reference types\n\nDafny offers a host of reference types. These represent references to objects allocated dynamically in the program heap. To access the members of an object, a reference to (that is, a pointer to or object identity of) the object is dereferenced.\n\nThe special value null is part of every reference type.4\n\n\n# 5.0. Classes\n\nA class C is a reference type declared as follows:\n\nclass C〈T〉 extends J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere the list of type parameters T is optional and so is “extends J”, which says that the class extends a trait J. The members of a class are fields, functions, and methods. These are accessed or invoked by dereferencing a reference to a C instance. A function or method is invoked on an instance of C, unless the function or method is declared static. Mechanically, this just means the method takes an implicit receiver parameter, namely, the instance used to access the member. In the specification and body of an instance function or method, the receiver parameter can be referred to explicitly by the keyword this. However, in such places, members of this can also be mentioned without any qualification. To illustrate, the qualified this.f and the unqualified f refer to the same field of the same object in the following example:\n\nclass C {\n  var f: int;\n  method Example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nso the method body always assigns true to the out-parameter b. There is no semantic difference between qualified and unqualified accesses to the same receiver and member.\n\nA C instance is created using new, for example:\n\nc := new C;\n\n\n1\n\n\nNote that new simply allocates a C object and returns a reference to it; the initial values of its fields are arbitrary values of their respective types. Therefore, it is common to invoke a method, known as an initialization method, immediately after creation, for example:\n\nc := new C;\nc.InitFromList(xs, 3);\n\n\n1\n2\n\n\nWhen an initialization method has no out-parameters and modifies no more than this, then the two statements above can be combined into one:\n\nc := new C.InitFromList(xs, 3);\n\n\n1\n\n\nNote that a class can contain several initialization methods, that these methods can be invoked at any time, not just as part of a new, and that new does not require that an initialization method be invoked at creation.\n\nTo write structured object-oriented programs, one often relies on that objects are constructed only in certain ways. For this purpose, Dafny provides constructor (method)s, which are a restricted form of initialization methods. A constructor is declared with the keyword constructor instead of method. When a class contains a constructor, every call to new for that class must be accompanied with a call to one of the constructors. Moreover, a constructor cannot be called at other times, only during object creation. Other than these restrictions, there is no semantic difference between using ordinary initialization methods and using constructors.\n\nThe Dafny design allows the constructors to be named, which promotes using names like InitFromList above. Still, many classes have just one constructor or have a typical constructor. Therefore, Dafny allows one anonymous constructor, that is, a constructor whose name is essentially “”. For example:\n\nclass Item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nWhen invoking this constructor, the “.” is dropped, as in:\n\nm := new Item(45, 29);\n\n\n1\n\n\nNote that an anonymous constructor is just one way to name a constructor; there can be other constructors as well.\n\n\n# 5.1. Arrays\n\nDafny supports mutable fixed-length array types of any positive dimension. Array types are reference types.\n\n# 5.1.0. One-dimensional arrays\n\nA one-dimensional array of n T elements is created as follows:\n\na := new T[n];\n\n\n1\n\n\nThe initial values of the array elements are arbitrary values of type T. The length of an array is retrieved using the immutable Length member. For example, the array allocated above satisfies:\n\na.Length == n\n\n\n1\n\n\nFor any integer-based numeric i in the range 0 <= i < a.Length, the array selection expression a[i] retrieves element i (that is, the element preceded by i elements in the array). The element stored at i can be changed to a value t using the array update statement:\n\na[i] := t;\n\n\n1\n\n\nCaveat: The type of the array created by new T[n] is array〈T〉. A mistake that is simple to make and that can lead to befuddlement is to write array〈T〉 instead of T after new. For example, consider the following:\n\nvar a := new array〈T〉;\nvar b := new array〈T〉[n];\nvar c := new array〈T〉(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nThe first statement allocates an array of type array〈T〉, but of unknown length. The second allocates an array of type array〈array〈T〉〉 of length n, that is, an array that holds n values of type array〈T〉. The third statement allocates an array of type array〈T〉 and then attempts to invoke an anonymous constructor on this array, passing argument n. Since array has no constructors, let alone an anonymous constructor, this statement gives rise to an error. If the type-parameter list is omitted for a type that expects type parameters, Dafny will attempt to fill these in, so as long as the array type parameter can be inferred, it is okay to leave off the “〈T〉” in the fourth statement above. However, as with the third statement, array has no anonymous constructor, so an error message is generated.\n\nOne-dimensional arrays support operations that convert a stretch of consecutive elements into a sequence. For any array a of type array〈T〉, integer-based numerics lo and hi satisfying 0 <= lo <= hi <= a.Length, the following operations each yields a seq〈T〉:\n\n             \nexpression   description\n             \na[lo..hi]    subarray conversion to sequence\na[lo..]      drop\na[..hi]      take\na[..]        array conversion to sequence\n             \n\nThe expression a[lo..hi] takes the first hi elements of the array, then drops the first lo elements thereof and returns what remains as a sequence. The resulting sequence thus has length hi - lo. The other operations are special instances of the first. If lo is omitted, it defaults to 0 and if hi is omitted, it defaults to a.Length. In the last operation, both lo and hi have been omitted, thus a[..] returns the sequence consisting of all the array elements of a.\n\nThe subarray operations are especially useful in specifications. For example, the loop invariant of a binary search algorithm that uses variables lo and hi to delimit the subarray where the search key may be still found can be expressed as follows:\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nAnother use is to say that a certain range of array elements have not been changed since the beginning of a method:\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\nor since the beginning of a loop:\n\nghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nNote that the type of prevElements in this example is seq〈T〉, if a has type array〈T〉.\n\nA final example of the subarray operation lies in expressing that an array's elements are a permutation of the array's elements at the beginning of a method, as would be done in most sorting algorithms. Here, the subarray operation is combined with the sequence-to-multiset conversion:\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1. Multi-dimensional arrays\n\nAn array of 2 or more dimensions is mostly like a one-dimensional array, except that new takes more length arguments (one for each dimension), and the array selection expression and the array update statement take more indices. For example:\n\nmatrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\ncreate a 2-dimensional array whose dimensions have lengths m and n, respectively, and then swaps the elements at i,j and x,y. The type of matrix is array2〈T〉, and similarly for higher-dimensional arrays (array3〈T〉, array4〈T〉, etc.). Note, however, that there is no type array0〈T〉, and what could have been array1〈T〉 is actually named just array〈T〉.\n\nThe new operation above requires m and n to be non-negative integer-based numerics. These lengths can be retrieved using the immutable fields Length0 and Length1. For example, the following holds of the array created above:\n\nmatrix.Length0 == m && matrix.Length1 == n\n\n\n1\n\n\nHigher-dimensional arrays are similar (Length0, Length1, Length2, …). The array selection expression and array update statement require that the indices are in bounds. For example, the swap statement above is well-formed only if:\n\n0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n\n\n1\n2\n\n\nIn contrast to one-dimensional arrays, there is no operation to convert stretches of elements from a multi-dimensional array to a sequence.\n\n\n# 5.2. Traits\n\nA trait is an “abstract superclass”, or call it an “interface” or “mixin”. Traits are new to Dafny and are likely to evolve for a while.\n\nThe declaration of a trait is much like that of a class:\n\ntrait J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere *members* can include fields, functions, and methods, but no constructor methods. The functions and methods are allowed to be declared static.\n\nA reference type C that extends a trait J is assignable to J, but not the other way around. The members of J are available as members of C. A member in J is not allowed to be redeclared in C, except if the member is a non-static function or method without a body in J. By doing so, type C can supply a stronger specification and a body for the member.\n\nnew is not allowed to be used with traits. Therefore, there is no object whose allocated type is a trait. But there can of course be objects of a class C that implements a trait J, and a reference to such a C object can be used as a value of type J.\n\nAs an example, the following trait represents movable geometric shapes:\n\ntrait Shape\n{\n  function method Width(): real\n    reads this\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMembers Width and Move are abstract (that is, body less) and can be implemented differently by different classes that extend the trait. The implementation of method MoveH is given in the trait and thus gets used by all classes that extend Shape. Here are two classes that each extends Shape:\n\nclass UnitSquare extends Shape\n{\n  var x: real, y: real;\n  function method Width(): real {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real;\n  function method Width(): real\n    reads this\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nNote that the classes can declare additional members, that they supply implementations for the abstract members of the trait, that they repeat the member signatures, and that they are responsible for providing their own member specifications that both strengthen the corresponding specification in the trait and are satisfied by the provided body. Finally, here is some code that creates two class instances and uses them together as shapes:\n\nvar myShapes: seq〈Shape〉;\nvar A := new UnitSquare;\nmyShapes := [A];\nvar tri := new LowerRightTriangle;\nmyShapes := myShapes + [tri];  // myShapes contains two Shape values, of different classes\nmyShapes[1].MoveH(myShapes[0].Width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3. Type object\n\nThere is a built-in reference type object that is like a supertype of all reference types.5 The purpose of type object is to enable a uniform treatment of dynamic frames. In particular, it is useful to keep a ghost field (typically named Repr for “representation”) of type set〈object〉.\n\n\n# 5.4. Iterator types\n\nAn iterator provides a programming abstraction for writing code that iteratively returns elements. These CLU-style iterators are co-routines in the sense that they keep track of their own program counter and control can be transferred into and out of the iterator body.\n\nAn iterator is declared as follows:\n\niterator Iter〈T〉(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhere T is a list of type parameters (as usual, if there are no type parameters, “〈T〉” is omitted). This declaration gives rise to a reference type with the same name, Iter〈T〉. In the signature, in-parameters and yield-parameters are the iterator's analog of a method's in-parameters and out-parameters. The difference is that the out-parameters of a method are returned to a caller just once, whereas the yield-parameters of an iterator are returned each time the iterator body performs a yield. The details of the specification are described in a different part of the Dafny language reference. The body consists of statements, like in a method body, but with the availability also of yield statements.\n\nFrom the perspective of an iterator client, the iterator declaration can be understood as generating a class Iter〈T〉 with various members, a simplified version of which is described next.\n\nThe Iter〈T〉 class contains an anonymous constructor whose parameters are the iterator's in-parameters:\n\npredicate Valid()\nconstructor (in-params)\n  modifies this\n  ensures Valid()\n\n\n1\n2\n3\n4\n\n\nAn iterator is created using new and this anonymous constructor. For example, an iterator willing to return ten consecutive integers from start can be declared as follows:\n\niterator Gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nAn instance of this iterator is created using:\n\niter := new Gen(30);\n\n\n1\n\n\nThe predicate Valid() says when the iterator is in a state where one can attempt to compute more elements. It is a postcondition of the constructor and occurs in the specification of the MoveNext member:\n\nmethod MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n\n\n1\n2\n3\n4\n\n\nNote that the iterator remains valid as long as MoveNext returns true. Once MoveNext returns false, the MoveNext method can no longer be called. Note, the client is under no obligation to keep calling MoveNext until it returns false, and the body of the iterator is allowed to keep returning elements forever.\n\nThe in-parameters of the iterator are stored in immutable fields of the iterator class. To illustrate in terms of the example above, the iterator class Gen contains the following field:\n\nvar start: int;\n\n\n1\n\n\nThe yield-parameters also result in members of the iterator class:\n\nvar x: int;\n\n\n1\n\n\nThese fields are set by the MoveNext method. If MoveNext returns true, the latest yield values are available in these fields and the client can read them from there.\n\nTo aid in writing specifications, the iterator class also contains ghost members that keep the history of values returned by MoveNext. The names of these ghost fields follow the names of the yield-parameters with an “s” appended to the name (to suggest plural). Name checking rules make sure these names do not give rise to ambiguities. The iterator class for Gen above thus contains:\n\nghost var xs: seq〈int〉;\n\n\n1\n\n\nThese history fields are changed automatically by MoveNext, but are not assignable by user code.\n\nFinally, the iterator class contains some special fields for use in specifications. In particular, the iterator specification gets recorded in the following immutable fields:\n\nghost var _reads: set〈object〉;\nghost var _modifies: set〈object〉;\nghost var _decreases0: T0;\nghost var _decreases1: T1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nwhere there is a _decreases*i*: T*i* field for each component of the iterator's decreases clause.6 In addition, there is a field:\n\nghost var _new: set〈object〉;\n\n\n1\n\n\nto which any objects allocated on behalf of the iterator body get added. The iterator body is allowed to remove elements from the _new set, but cannot by assignment to _new add any elements.\n\nNote, in the precondition of the iterator, which is to hold upon construction of the iterator, the in-parameters are indeed in-parameters, not fields of this.\n\n\n# 5.5. Async-task types\n\nAnother experimental feature in Dafny that is likely to undergo some evolution is asynchronous methods. When an asynchronous method is called, it does not return values for the out-parameters, but instead returns an instance of an async-task type. An asynchronous method declared in a class C with the following signature:\n\nasync method AM〈T〉(in-params) returns (out-params)\n\n\n1\n\n\nalso gives rise to an async-task type AM〈T〉 (outside the enclosing class, the name of the type needs the qualification C.AM〈T〉). The async-task type is a reference type and can be understood as a class with various members, a simplified version of which is described next.\n\nEach in-parameter x of type X of the asynchronous method gives rise to a immutable ghost field of the async-task type:\n\nghost var x: X;\n\n\n1\n\n\nEach out-parameter y of type Y gives rise to a field\n\nvar y: Y;\n\n\n1\n\n\nThese fields are changed automatically by the time the asynchronous method is successfully awaited, but are not assignable by user code.\n\nThe async-task type also gets a number of special fields that are used to keep track of dependencies, outstanding tasks, newly allocated objects, etc. These fields will be described in more detail as the design of asynchronous methods evolves.\n\n\n# 6. Function types\n\nFunctions are first-class values in Dafny. Function types have the form (T) -> U where T is a comma-delimited list of types and U is a type. T is called the function's domain type(s) and U is its range type. For example, the type of a function\n\nfunction F(x: int, b: bool): real\n\n\n1\n\n\nis (int, bool) -> real. Parameters are not allowed to be ghost.\n\nTo simplify the appearance of the basic case where a function's domain consist of a list of exactly one type, the parentheses around the domain type can be dropped in this case, as in T -> U. This innocent simplification requires additional explanation in the case where that one type is a tuple type, since tuple types are also written with enclosing parentheses. If the function takes a single argument that is a tuple, an additional set of parentheses is needed. For example, the function\n\nfunction G(pair: (int, bool)): real\n\n\n1\n\n\nhas type ((int, bool)) -> real. Note the necessary double parentheses. Similarly, a function that takes no arguments is different from one that takes a 0-tuple as an argument. For instance, the functions\n\nfunction NoArgs(): real\nfunction Z(unit: ()): real\n\n\n1\n2\n\n\nhave types () -> real and (()) -> real, respectively.\n\nThe function arrow, ->, is right associative, so A -> B -> C means A -> (B -> C). The other association requires explicit parentheses: (A -> B) -> C.\n\nNote that the receiver parameter of a named function is not part of the type. Rather, it is used when looking up the function and can then be thought of as being captured into the function definition. For example, suppose function F above is declared in a class C and that c references an object of type C; then, the following is type correct:\n\nvar f: (int, bool) -> real := c.F;\n\n\n1\n\n\nwhereas it would have been incorrect to have written something like:\n\nvar f': (C, int, bool) -> real := F;  // not correct\n\n\n1\n\n\nOutside its type signature, each function value has three properties, described next.\n\nEvery function implicitly takes the heap as an argument. No function ever depends on the entire heap, however. A property of the function is its declared upper bound on the set of heap locations it depends on for a given input. This lets the verifier figure out that certain heap modifications have no effect on the value returned by a certain function. For a function f: T -> U and a value t of type T, the dependency set is denoted f.reads(t) and has type set〈object〉.\n\nThe second property of functions stems from that every function is potentially partial. In other words, a property of a function is its precondition. For a function f: T -> U, the precondition of f for a parameter value t of type T is denoted f.requires(t) and has type bool.\n\nThe third property of a function is more obvious—the function's body. For a function f: T -> U, the value that the function yields for an input t of type T is denoted f(t) and has type U.\n\nNote that f.reads and f.requires are themselves functions. Suppose f has type T -> U and t has type T. Then, f.reads is a function of type T -> set〈object〉 whose reads and requires properties are:\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires is a function of type T -> bool whose reads and requires properties are:\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0. Lambda expressions\n\nIn addition to named functions, Dafny supports expressions that define functions. These are called lambda (expression)s (some languages know them as anonymous functions). A lambda expression has the form:\n\n(params) specification => body\n\n\n1\n\n\nwhere *params* is a comma-delimited list of parameter declarations, each of which has the form x or x: T. The type T of a parameter can be omitted when it can be inferred. If the identifier x is not needed, it can be replaced by “_”. If *params* consists of a single parameter x (or _) without an explicit type, then the parentheses can be dropped; for example, the function that returns the successor of a given integer can be written as the following lambda expression:\n\nx => x + 1\n\n\n1\n\n\nThe *specification* is a list of clauses requires E or reads W, where E is a boolean expression and W is a frame expression.\n\n*body* is an expression that defines the function's return value. The body must be well-formed for all possible values of the parameters that satisfy the precondition (just like the bodies of named functions and methods). In some cases, this means it is necessary to write explicit requires and reads clauses. For example, the lambda expression\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nwould not be well-formed if the requires clause were omitted, because of the possibility of division-by-zero.\n\nIn settings where functions cannot be partial and there are no restrictions on reading the heap, the eta expansion of a function F: T -> U (that is, the wrapping of F inside a lambda expression in such a way that the lambda expression is equivalent to F) would be written x => F(x). In Dafny, eta expansion must also account for the precondition and reads set of the function, so the eta expansion of F looks like:\n\nx requires F.requires(x) reads F.reads(x) => F(x)\n\n\n1\n\n\n\n# 7. Newtypes\n\nA new numeric type can be declared with the newtype declaration7\n\nnewtype N = x: M | Q\n\n\n1\n\n\nwhere M is a numeric type and Q is a boolean expression that can use x as a free variable. If M is an integer-based numeric type, then so is N; if M is real-based, then so is N. If the type M can be inferred from Q, the “: M” can be omitted. If Q is just true, then the declaration can be given simply as:\n\nnewtype N = M\n\n\n1\n\n\nType M is known as the base type of N.\n\nA newtype is a numeric type that supports the same operations as its base type. The newtype is distinct from and incompatible with other numeric types; in particular, it is not assignable to its base type without an explicit conversion. An important difference between the operations on a newtype and the operations on its base type is that the newtype operations are defined only if the result satisfies the predicate Q, and likewise for the literals of the newtype.8\n\nFor example, suppose lo and hi are integer-based numerics that satisfy 0 <= lo <= hi and consider the following code fragment:\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nIf lo and hi have type int, then the code fragment is legal; in particular, it never overflows, since int has no upper bound. In contrast, if lo and hi are variables of a newtype int32 declared as follows:\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\nthen the code fragment is erroneous, since the result of the addition may fail to satisfy the predicate in the definition of int32. The code fragment can be rewritten as\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nin which case it is legal for both int and int32.\n\nSince a newtype is incompatible with its base type and since all results of the newtype's operations are members of the newtype, a compiler for Dafny is free to specialize the run-time representation of the newtype. For example, by scrutinizing the definition of int32 above, a compiler may decide to store int32 values using signed 32-bit integers in the target hardware.\n\nNote that the bound variable x in Q has type M, not N. nConsequently, it may not be possible to state Q about the N value. For example, consider the following type of 8-bit 2's complement integers:\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nand consider a variable c of type int8. The expression\n\n-128 <= c < 128\n\n\n1\n\n\nis not well-defined, because the comparisons require each operand to have type int8, which means the literal 128 is checked to be of type int8, which it is not. A proper way to write this expression would be to use a conversion operation, described next, on c to convert it to the base type:\n\n-128 <= int(c) < 128\n\n\n1\n\n\nThere is a restriction that the value 0 must be part of every newtype.9\n\n\n# 7.0. Numeric conversion operations\n\nFor every numeric type N, there is a conversion function with the same name. It is a partial identity function. It is defined when the given value, which can be of any numeric type, is a member of the type converted to. When the conversion is from a real-based numeric type to an integer-based numeric type, the operation requires that the real-based argument has no fractional part. (To round a real-based numeric value down to the nearest integer, use the .Trunc member, see Section 0.1.)\n\nTo illustrate using the example from above, if lo and hi have type int32, then the code fragment can legally be written as follows:\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nwhere the type of mid is inferred to be int. Since the result value of the division is a member of type int32, one can introduce yet another conversion operation to make the type of mid be int32:\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nIf the compiler does specialize the run-time representation for int32, then these statements come at the expense of two, respectively three, run-time conversions.\n\n\n# 8. Subset types\n\nA subset type is a restricted use of an existing type, called the base type of the subset type. A subset type is like a combined use of the base type and a predicate on the base type.\n\nAn assignment from a subset type to its base type is always allowed. An assignment in the other direction, from the base type to a subset type, is allowed provided the value assigned does indeed satisfy the predicate of the subset type. (Note, in contrast, assignments between a newtype and its base type are never allowed, even if the value assigned is a value of the target type. For such assignments, an explicit conversion must be used, see Section 7.0.)\n\nDafny supports one subset type, namely the built-in type nat, whose base type is int.10 Type nat designates the non-negative subrange of int. A simple example that puts subset type nat to good use is the standard Fibonacci function:\n\nfunction Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\nAn equivalent, but clumsy, formulation of this function (modulo the wording of any error messages produced at call sites) would be to use type int and to write the restricting predicate in pre- and postconditions:\n\nfunction Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nType inference will never infer the type of a variable to be a subset type. It will instead infer the type to be the base type of the subset type. For example, the type of x in\n\nforall x :: P(x)\n\n\n1\n\n\nwill be int, even if predicate P declares its argument to have type nat.\n\n# Acknowledgments\n\nThis document has been improved as a result of helpful comments from Nadia Polikarpova and Paqui Lucio.\n\n----------------------------------------\n\n0.Being equality-supporting is just one of many modes that one can imagine types in a rich type system to have. For example, other modes could include having a total order, being zero-initializable, and possibly being uninhabited. If Dafny were to support more modes in the future, the “( )”-suffix syntax may be extended. For now, the suffix can only indicate the equality-supporting mode. ↩\n\n1.Now that Dafny supports built-in tuples, the plan is to change the sequence slice operation to return not a sequence of subsequences, but a tuple of subsequences. ↩\n\n2.This is likely to change in the future to disallow multiple occurrences of the same key. ↩\n\n3.This is likely to change in the future as follows: The in and !in operations will no longer be supported on maps. Instead, for any map m, m.Domain will return its domain as a set and m.Range will return, also as a set, the image of m under its domain. ↩\n\n4.This will change in a future version of Dafny that will support both nullable and (by default) non-null reference types. ↩\n\n5.Soon, object will be made into a built-in trait rather than being a built-in special class. When this happens, it will no longer be possible to do new object. The current compiler restriction that object cannot be used as a type parameter will then also go away. ↩\n\n6.It would make sense to rename the special fields _reads and _modifies to have the same names as the corresponding keywords, reads and modifies, as is done for function values. Also, the various _decreases*i* fields can combined into one field named decreases whose type is a n-tuple.\n\n↩\n\n7.Should newtype perhaps be renamed to numtype? ↩\n\n8.Would it be useful to also automatically define predicate N?(m: M) { Q }? ↩\n\n9.The restriction is due to a current limitation in the compiler. This will change in the future and will also open up the possibility for subset types and non-null reference types. ↩\n\n10.A future version of Dafny will support user-defined subset types. ↩",normalizedContent:"# types in dafny\n\nmanuscript krml 243 27 february 2015\n\nk. rustan m. leinoleino@microsoft.com\n\nthis part of the dafny language reference describes the types in the dafny programming language. what is described is what is implemented in version 1.9.3.20107 of dafny, with the exception of async-task types which have not yet made it into the main branch.\n\n0. basic types\n\n0.0. booleans\n\n0.1. numeric types\n\n0.2. characters\n\n1. type parameters\n\n2. collection types\n\n2.0. sets\n\n2.1. multisets\n\n2.2. sequences\n\n2.2.0. strings\n\n2.3. finite and infinite maps\n\n3. types that stand for other types\n\n3.0. type synonyms\n\n3.1. opaque types\n\n4. datatypes\n\n4.0. inductive datatypes\n\n4.1. tuple types\n\n4.2. co-inductive datatypes\n\n5. reference types\n\n5.0. classes\n\n5.1. arrays\n\n5.1.0. one-dimensional arrays\n\n5.1.1. multi-dimensional arrays\n\n5.2. traits\n\n5.3. type object\n\n5.4. iterator types\n\n5.5. async-task types\n\n6. function types\n\n6.0. lambda expressions\n\n7. newtypes\n\n7.0. numeric conversion operations\n\n8. subset types\n\n\n# 0. basic types\n\ndafny offers three basic types, bool for booleans, int for integers, and real for reals.\n\n\n# 0.0. booleans\n\nthere are two boolean values and each has a corresponding literal in the language: false and true.\n\nin addition to equality (==) and disequality (!=), which are defined on all types, type bool supports the following operations:\n\n           \noperator   description\n           \n<==>       equivalence (if and only if)\n           \n==>        implication (implies)\n<==        reverse implication (follows from)\n           \n&&         conjunction (and)\n||         disjunction (or)\n           \n!          negation (not)\n           \n\nnegation is unary; the others are binary. the table shows the operators in groups of increasing binding power, with equality binding stronger than conjunction and disjunction, and weaker than negation. within each group, different operators do not associate, so parentheses need to be used. for example,\n\na && b || c    // error\n\n\n1\n\n\nwould be ambiguous and instead has to be written as either\n\n(a && b) || c\n\n\n1\n\n\nor\n\na && (b || c)\n\n\n1\n\n\ndepending on the intended meaning.\n\nthe expressions a <==> b and a == b give the same value, but note that <==> is associative whereas == is chaining. so,\n\na <==> b <==> c\n\n\n1\n\n\nis the same as\n\na <==> (b <==> c)\n\n\n1\n\n\nand\n\n(a <==> b) <==> c\n\n\n1\n\n\nwhereas\n\na == b == c\n\n\n1\n\n\nis simply a shorthand for\n\na == b && b == c\n\n\n1\n\n\nconjunction is associative and so is disjunction. these operators are are short circuiting (from left to right), meaning that their second argument is evaluated only if the evaluation of the first operand does not determine the value of the expression. logically speaking, the expression a && b is defined when a is defined and either a evaluates to false or b is defined. when a && b is defined, its meaning is the same as the ordinary, symmetric mathematical conjunction ∧. the same holds for || and ∨.\n\nimplication is right associative and is short-circuiting from left to right. reverse implication b <== a is exactly the same as a ==> b, but gives the ability to write the operands in the opposite order. consequently, reverse implication is left associative and is short-circuiting from right to left. to illustrate the associativity rules, each of the following four lines expresses the same property, for any a, b, and c of type bool:\n\na ==> b ==> c\na ==> (b ==> c)  // parentheses redundant, since ==> is right associative\nc <== b <== a\n(c <== b) <== a  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nto illustrate the short-circuiting rules, note that the expression a.length is defined for an array a only if a is not null (see section 5), which means the following two expressions are well-formed:\n\na != null ==> 0 <= a.length\n0 <= a.length <== a != null\n\n\n1\n2\n\n\nthe contrapositive of these two expressions would be:\n\na.length < 0 ==> a == null  // not well-formed\na == null <== a.length < 0  // not well-formed\n\n\n1\n2\n\n\nbut these expressions are not well-formed, since well-formedness requires the left (and right, respectively) operand, a.length < 0, to be well-formed by itself.\n\nimplication a ==> b is equivalent to the disjunction !a || b, but is sometimes (especially in specifications) clearer to read. since, || is short-circuiting from left to right, note that\n\na == null || 0 <= a.length\n\n\n1\n\n\nis well-formed, whereas\n\n0 <= a.length || a == null  // not well-formed\n\n\n1\n\n\nis not.\n\nin addition, booleans support logical quantifiers (forall and exists), described in a different part of the dafny language reference.\n\n\n# 0.1. numeric types\n\ndafny supports numeric types of two kinds, integer-based, which includes the basic type int of all integers, and real-based, which includes the basic type real of all real numbers. user-defined numeric types based on int and real, called newtypes, are described in section 7. also, the subset type nat, representing the non-negative subrange of int, is described in section 8.\n\nthe language includes a literal for each non-negative integer, like 0, 13, and 1985. integers can also be written in hexadecimal using the prefix “0x”, as in 0x0, 0xd, and 0x7c1 (always with a lower case x, but the hexadecimal digits themselves are case insensitive). leading zeros are allowed. to form negative integers, use the unary minus operator.\n\nthere are also literals for some of the non-negative reals. these are written as a decimal point with a nonempty sequence of decimal digits on both sides. for example, 1.0, 1609.344, and 0.5772156649.\n\nfor integers (in both decimal and hexidecimal form) and reals, any two digits in a literal may be separated by an underscore in order to improve human readability of the literals. for example:\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 angstrom\n\n\n1\n2\n3\n4\n\n\nin addition to equality and disequality, numeric types support the following relational operations:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nlike equality and disequality, these operators are chaining, as long as they are chained in the “same direction”. that is,\n\na <= b < c == d <= e\n\n\n1\n\n\nis simply a shorthand for\n\na <= b && b < c && c == d && d <= e\n\n\n1\n\n\nwhereas\n\na < b > c\n\n\n1\n\n\nis not allowed.\n\nthere are also operators on each numeric type:\n\n           \noperator   description\n           \n+          addition (plus)\n-          subtraction (minus)\n           \n*          multiplication (times)\n/          division (divided by)\n%          modulus (mod)\n           \n-          negation (unary minus)\n           \n\nthe binary operators are left associative, and they associate with each other in the two groups. the groups are listed in order of increasing binding power, with equality binding more strongly than the multiplicative operators and weaker than the unary operator. modulus is supported only for integer-based numeric types. integer division and modulus are the euclidean division and modulus. this means that modulus always returns a non-negative, regardless of the signs of the two operands. more precisely, for any integer a and non-zero integer b,\n\na == a / b * b + a % b\n0 <= a % b < b\n\n\n1\n2\n\n\nwhere b denotes the absolute value of b.\n\nreal-based numeric types have a member trunc that returns the floor of the real value, that is, the largest integer not exceeding the real value. for example, the following properties hold, for any r and r' of type real:\n\n3.14.trunc == 3\n(-2.5).trunc == -3\n-2.5.trunc == -2\nreal(r.trunc) <= r\nr <= r' ==> r.trunc <= r'.trunc\n\n\n1\n2\n3\n4\n5\n\n\nnote in the third line that member access (like .trunc) binds stronger than unary minus. the fourth line uses the conversion function real from int to real, as described in section 7.0.\n\n\n# 0.2. characters\n\ndafny supports a type char of characters. character literals are enclosed in single quotes, as in 'd'. to write a single quote as a character literal, it is necessary to use an escape sequence. escape sequences can also be used to write other characters. the supported escape sequences are as follows:\n\n                  \nescape sequence   meaning\n                  \n\\'                the character '\n\"                 the character \"\n\\\\                the character \\\n\\0                the null character, same as \\u0000\n\\n                line feed\n\\r                carriage return\n\\t                horizontal tab\n\\u*xxxx*          universal character whose hexadecimal code is *xxxx*\n                  \n\nthe escape sequence for a double quote is redundant, because '\"' and '\"' denote the same character—both forms are provided in order to support the same escape sequences as for string literals (section 2.2.0). in the form \\u*xxxx*, the u is always lower case, but the four hexadecimal digits are case insensitive.\n\ncharacter values are ordered and can be compared using the standard relational operators:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nsequences of characters represent strings, as described in section 2.2.0.\n\n\n# 1. type parameters\n\nmany of the types (as well as functions and methods) in dafny can be parameterized by types. these type parameters are typically declared inside angle brackets and can stand for any type. it is sometimes necessary to restrict these type parameters so that they can only be instantiated by certain families of types. as such, dafny distinguishes types that support the equality operation not only in ghost contexts but also in compiled contexts. to indicate that a type parameter is restricted to such equality supporting types, the name of the type parameter takes the suffix “(==)”.0 for example,\n\nmethod compare〈t(==)〉(a: t, b: t) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\nis a method whose type parameter is restricted to equality-supporting types. again, note that all types support equality in ghost contexts; the difference is only for non-ghost (that is, compiled) code. co-inductive datatypes, function types, as well as inductive datatypes with ghost parameters are examples of types that are not equality supporting.\n\ndafny has some inference support that makes certain signatures less cluttered (described in a different part of the dafny language reference). in some cases, this support will infer that a type parameter must be restricted to equality-supporting types, in which case dafny adds the “(==)” automatically.\n\n\n# 2. collection types\n\ndafny offers several built-in collection types.\n\n\n# 2.0. sets\n\nfor any type t, each value of type set〈t〉 is a finite set of t values. set membership is determined by equality in the type t, so set〈t〉 can be used in a non-ghost context only if t is equality supporting.\n\na set can be formed using a set display expression, which is a possibly empty, unordered, duplicate-insensitive list of expressions enclosed in curly braces. to illustrate,\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of set displays. there is also a set comprehension expression (with a binder, like in logical quantifications), described in a different part of the dafny language reference.\n\nin addition to equality and disequality, set types support the following relational operations:\n\n           \noperator   description\n           \n<          proper subset\n<=         subset\n>=         superset\n>          proper superset\n           \n\nlike the arithmetic relational operators, these operators are chaining.\n\nsets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         disjointness\n           \n+          set union\n-          set difference\n           \n*          set intersection\n           \n\nthe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. the expression a !! b, whose binding power is the same as equality (but which neither associates nor chains with equality), says that sets a and b have no elements in common, that is, it is equivalent to\n\na * b == {}\n\n\n1\n\n\nhowever, the disjointness operator is chaining, so a !! b !! c !! d means:\n\na * b == {} && (a + b) * c == {} && (a + b + c) * d == {}\n\n\n1\n\n\nin addition, for any set s of type set〈t〉 and any expression e of type t, sets support the following operations:\n\n             \nexpression   description\n             \n|s|          set cardinality\ne in s       set membership\ne !in s      set non-membership\n             \n\nthe expression e !in s is a syntactic shorthand for !(e in s).\n\n\n# 2.1. multisets\n\na multiset is similar to a set, but keeps track of the multiplicity of each element, not just its presence or absence. for any type t, each value of type multiset〈t〉 is a map from t values to natural numbers denoting each element's multiplicity. multisets in dafny are finite, that is, they contain a finite number of each of a finite set of elements. stated differently, a multiset maps only a finite number of elements to non-zero (finite) multiplicities.\n\nlike sets, multiset membership is determined by equality in the type t, so multiset〈t〉 can be used in a non-ghost context only if t is equality supporting.\n\na multiset can be formed using a multiset display expression, which is a possibly empty, unordered list of expressions enclosed in curly braces after the keyword multiset. to illustrate,\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of multiset displays. there is no multiset comprehension expression.\n\nin addition to equality and disequality, multiset types support the following relational operations:\n\n           \noperator   description\n           \n<          proper multiset subset\n<=         multiset subset\n>=         multiset superset\n>          proper multiset superset\n           \n\nlike the arithmetic relational operators, these operators are chaining.\n\nmultisets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         multiset disjointness\n           \n+          multiset union\n-          multiset difference\n           \n*          multiset intersection\n           \n\nthe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. the expression a !! b says that multisets a and b have no elements in common, that is, it is equivalent to\n\na * b == multiset{}\n\n\n1\n\n\nlike the analogous set operator, !! is chaining.\n\nin addition, for any multiset s of type multiset〈t〉, expression e of type t, and non-negative integer-based numeric n, multisets support the following operations:\n\n             \nexpression   description\n             \n|s|          multiset cardinality\ne in s       multiset membership\ne !in s      multiset non-membership\ns[e]         multiplicity of e in s\ns[e := n]    multiset update (change of multiplicity)\n             \n\nthe expression e in s returns true if and only if s[e] != 0. the expression e !in s is a syntactic shorthand for !(e in s). the expression s[e := n] denotes a multiset like s, but where the multiplicity of element e is n. note that the multiset update s[e := 0] results in a multiset like s but without any occurrences of e (whether or not s has occurrences of e in the first place). as another example, note that s - multiset{e} is equivalent to:\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2. sequences\n\nfor any type t, a value of type seq〈t〉 denotes a sequence of t elements, that is, a mapping from a finite set of consecutive natural numbers (called indicies) to t values. (thinking of it as a map, a sequence is therefore something of a dual of a multiset.)\n\na sequence can be formed using a sequence display expression, which is a possibly empty, ordered list of expressions enclosed in square brackets. to illustrate,\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\nare three examples of sequence displays. there is no sequence comprehension expression.\n\nin addition to equality and disequality, sequence types support the following relational operations:\n\n           \noperator   description\n           \n<          proper prefix\n<=         prefix\n           \n\nlike the arithmetic relational operators, these operators are chaining. note the absence of > and >=.\n\nsequences support the following binary operator:\n\n           \noperator   description\n           \n+          concatenation\n           \n\noperator + is associative, like the arithmetic operator with the same name.\n\nin addition, for any sequence s of type seq〈t〉, expression e of type t, integer-based numeric i satisfying 0 <= i < |s|, and integer-based numerics lo and hi satisfying 0 <= lo <= hi <= |s|, sequences support the following operations:\n\n              \nexpression    description\n              \n|s|           sequence length\ns[i]          sequence selection\ns[i := e]     sequence update\ne in s        sequence membership\ne !in s       sequence non-membership\ns[lo..hi]     subsequence\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   slice\nmultiset(s)   sequence conversion to a multiset〈t〉\n              \n\nexpression s[i := e] returns a sequence like s, except that the element at index i is e. the expression e in s says there exists an index i such that s[i] == e. it is allowed in non-ghost contexts only if the element type t is equality supporting. the expression e !in s is a syntactic shorthand for !(e in s).\n\nexpression s[lo..hi] yields a sequence formed by taking the first hi elements and then dropping the first lo elements. the resulting sequence thus has length hi - lo. note that s[0..|s|] equals s. if the upper bound is omitted, it defaults to |s|, so s[lo..] yields the sequence formed by dropping the first lo elements of s. if the lower bound is omitted, it defaults to 0, so s[..hi] yields the sequence formed by taking the first hi elements of s.\n\nin the sequence slice operation, *slices* is a nonempty list of length designators separated and optionally terminated by a colon, and there is at least one colon. each length designator is a non-negative integer-based numeric, whose sum is no greater than |s|. if there are k colons, the operation produces k consecutive subsequences from s, each of the length indicated by the corresponding length designator, and returns these as a sequence of sequences.1 if *slices* is terminated by a colon, then the length of the last slice extends until the end of s, that is, its length is |s| minus the sum of the given length designators. for example, the following equalities hold, for any sequence s of length at least 10:\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe operation multiset(s) yields the multiset of elements of sequence s. it is allowed in non-ghost contexts only if the element type t is equality supporting.\n\n# 2.2.0. strings\n\na special case of a sequence type is seq〈char〉, for which dafny provides a synonym: string. strings are like other sequences, but provide additional syntax for sequence display expressions, namely string literals. there are two forms of the syntax for string literals: the standard form and the verbatim form.\n\nstring literals of the standard form are enclosed in double quotes, as in \"dafny\". to include a double quote in such a string literal, it is necessary to use an escape sequence. escape sequences can also be used to include other characters. the supported escape sequences are the same as those for character literals, see section 0.2. for example, the dafny expression \"say \\\"yes\\\"\" represents the string say \"yes\". the escape sequence for a single quote is redundant, because \"'\" and \"'\" denote the same string—both forms are provided in order to support the same escape sequences as for character literals.\n\nstring literals of the verbatim form are bracketed by @\" and \", as in @\"dafny\". to include a double quote in such a string literal, it is necessary to use the escape sequence \"\", that is, to write the character twice. in the verbatim form, there are no other escape sequences. even characters like newline can be written inside the string literal (hence spanning more than one line in the program text).\n\nfor example, the following three expressions denote the same string:\n\n\"c:\\\\tmp.txt\"\n@\"c:\\tmp.txt\"\n['c', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nsince strings are sequences, the relational operators < and <= are defined on them. note, however, that these operators still denote proper prefix and prefix, respectively, not some kind of alphabetic comparison as might be desireable, for example, when sorting strings.\n\n\n# 2.3. finite and infinite maps\n\nfor any types t and u, a value of type map〈t,u〉 denotes a (finite) map from t to u. in other words, it is a look-up table indexed by t. the domain of the map is a finite set of t values that have associated u values. since the keys in the domain are compared using equality in the type t, type map〈t,u〉 can be used in a non-ghost context only if t is equality supporting.\n\nsimilarly, for any types t and u, a value of type imap〈t,u〉 denotes a (possibly) infinite map. in most regards, imap〈t,u〉 is like map〈t,u〉, but a map of type imap〈t,u〉 is allowed to have an infinite domain.\n\na map can be formed using a map display expression, which is a possibly empty, ordered list of maplets, each maplet having the form t := u where t is an expression of type t and u is an expression of type u, enclosed in square brackets after the keyword map. to illustrate,\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\nare three examples of map displays. by using the keyword imap instead of map, the map produced will be of type imap〈t,u〉 instead of map〈t,u〉. note that an infinite map (imap) is allowed to have a finite domain, whereas a finite map (map) is not allowed to have an infinite domain. if the same key occurs more than once, only the last occurrence appears in the resulting map.2 there is also a map comprehension expression, explained in a different part of the dafny language reference.\n\nfor any map fm of type map〈t,u〉, any map m of type map〈t,u〉 or imap〈t,u〉, any expression t of type t, any expression u of type u, and any d in the domain of m (that is, satisfying d in m), maps support the following operations:\n\n             \nexpression   description\n             \n|fm|         map cardinality\nm[d]         map selection\nm[t := u]    map update\nt in m       map domain membership\nt !in m      map domain non-membership\n             \n\n|fm| denotes the number of mappings in fm, that is, the cardinality of the domain of fm. note that the cardinality operator is not supported for infinite maps. expression m[d] returns the u value that m associates with d. expression m[t := u] is a map like m, except that the element at key t is u. the expression t in m says t is in the domain of m and t !in m is a syntactic shorthand for !(t in m).3\n\nhere is a small example, where a map cache of type map〈int,real〉 is used to cache computed values of joule-thomson coefficients for some fixed gas at a given temperature:\n\nif k in cache {  // check if temperature is in domain of cache\n  coeff := cache[k];  // read result in cache\n} else {\n  coeff := computejoulethomsoncoefficient(k);  // do expensive computation\n  cache := cache[k := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3. types that stand for other types\n\nit is sometimes useful to know a type by several names or to treat a type abstractly.\n\n\n# 3.0. type synonyms\n\na type synonym declaration:\n\ntype y〈t〉 = g\n\n\n1\n\n\ndeclares y〈t〉 to be a synonym for the type g. here, t is a nonempty list of type parameters (each of which is optionally designated with the suffix “(==)”), which can be used as free type variables in g. if the synonym has no type parameters, the “〈t〉” is dropped. in all cases, a type synonym is just a synonym. that is, there is never a difference, other than possibly in error messages produced, between y〈t〉 and g.\n\nfor example, the names of the following type synonyms may improve the readability of a program:\n\ntype replacements〈t〉 = map〈t,t〉\ntype vertex = int\n\n\n1\n2\n\n\nas already described in section 2.2.0, string is a built-in type synonym for seq〈char〉, as if it would have been declared as follows:\n\ntype string = seq〈char〉\n\n\n1\n\n\n\n# 3.1. opaque types\n\na special case of a type synonym is one that is underspecified. such a type is declared simply by:\n\ntype y〈t〉\n\n\n1\n\n\nit is a known as an opaque type. its definition can be revealed in a refining module. to indicate that y designates an equality-supporting type, “(==)” can be written immediately following the name “y”.\n\nfor example, the declarations\n\ntype t\nfunction f(t: t): t\n\n\n1\n2\n\n\ncan be used to model an uninterpreted function f on some arbitrary type t. as another example,\n\ntype monad〈t〉\n\n\n1\n\n\ncan be used abstractly to represent an arbitrary parameterized monad.\n\n\n# 4. datatypes\n\ndafny offers two kinds of algebraic datatypes, those defined inductively and those defined co-inductively. the salient property of every datatype is that each value of the type uniquely identifies one of the datatype's constructors and each constructor is injective in its parameters.\n\n\n# 4.0. inductive datatypes\n\nthe values of inductive datatypes can be seen as finite trees where the leaves are values of basic types, numeric types, reference types, co-inductive datatypes, or function types. indeed, values of inductive datatypes can be compared using dafny's well-founded < ordering.\n\nan inductive datatype is declared as follows:\n\ndatatype d〈t〉 = ctors\n\n\n1\n\n\nwhere *ctors* is a nonempty |-separated list of (datatype) constructors for the datatype. each constructor has the form:\n\nc(params)\n\n\n1\n\n\nwhere *params* is a comma-delimited list of types, optionally preceded by a name for the parameter and a colon, and optionally preceded by the keyword ghost. if a constructor has no parameters, the parentheses after the constructor name can be omitted. if no constructor takes a parameter, the type is usually called an enumeration; for example:\n\ndatatype friends = agnes | agatha | jermaine | jack\n\n\n1\n\n\nfor every constructor c, dafny defines a discriminator c?, which is a member that returns true if and only if the datatype value has been constructed using c. for every named parameter p of a constructor c, dafny defines a destructor p, which is a member that returns the p parameter from the c call used to construct the datatype value; its use requires that c? holds. for example, for the standard list type\n\ndatatype list〈t〉 = nil | cons(head: t, tail: list〈t〉)\n\n\n1\n\n\nthe following holds:\n\ncons(5, nil).cons? && cons(5, nil).head == 5\n\n\n1\n\n\nnote that the expression\n\ncons(5, nil).tail.head\n\n\n1\n\n\nis not well-formed, since cons(5, nil).tail does not satisfy cons?.\n\nthe names of the destructors must be unique across all the constructors of the datatype. a constructor can have the same name as the enclosing datatype; this is especially useful for single-constructor datatypes, which are often called record types. for example, a record type for black-and-white pixels might be represented as follows:\n\ndatatype pixel = pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nto call a constructor, it is usually necessary only to mention the name of the constructor, but if this is ambiguous, it is always possible to qualify the name of constructor by the name of the datatype. for example, cons(5, nil) above can be written\n\nlist.cons(5, list.nil)\n\n\n1\n\n\nas an alternative to calling a datatype constructor explicitly, a datatype value can be constructed as a change in one parameter from a given datatype value using the datatype update expression. for any d whose type is a datatype that includes a constructor c that has a parameter (destructor) named f of type t, and any expression t of type t,\n\nd[f := t]\n\n\n1\n\n\nconstructs a value like d but whose f parameter is t. the operation requires that d satisfies c?. for example, the following equality holds:\n\ncons(4, nil)[tail := cons(3, nil)] == cons(4, cons(3, nil))\n\n\n1\n\n\n\n# 4.1. tuple types\n\ndafny builds in record types that correspond to tuples and gives these a convenient special syntax, namely parentheses. for example, what might have been declared as:\n\ndatatype pair〈t,u〉 = pair(0: t, 1: u)\n\n\n1\n\n\ndafny provides as the type (t, u) and the constructor (t, u), as if the datatype's name were “” and its type arguments are given in round parentheses, and as if the constructor name were “”. note that the destructor names are 0 and 1, which are legal identifier names for members. for example, showing the use of a tuple destructor, here is a property that holds of 2-tuples (that is, pairs):\n\n(5, true).1 == true\n\n\n1\n\n\ndafny declares n-tuples where n is 0 or 2 or up. there are no 1-tuples, since parentheses around a single type or a single value have no semantic meaning. the 0-tuple type, (), is often known as the unit type and its single value, also written (), is known as unit.\n\n\n# 4.2. co-inductive datatypes\n\nwhereas dafny insists that there is a way to construct every inductive datatype value from the ground up, dafny also supports co-inductive datatypes, whose constructors are evaluated lazily and hence allows infinite structures. a co-inductive datatype is declared using the keyword codatatype; other than that, it is declared and used like an inductive datatype.\n\nfor example,\n\ncodatatype ilist〈t〉 = nil | cons(head: t, tail: ilist〈t〉)\ncodatatype stream〈t〉 = more(head: t, tail: stream〈t〉)\ncodatatype tree〈t〉 = node(left: tree〈t〉, value: t, right: tree〈t〉)\n\n\n1\n2\n3\n\n\ndeclare possibly infinite lists (that is, lists that can be either finite or infinite), infinite streams (that is, lists that are always infinite), and infinite binary trees (that is, trees where every branch goes on forever), respectively.\n\n\n# 5. reference types\n\ndafny offers a host of reference types. these represent references to objects allocated dynamically in the program heap. to access the members of an object, a reference to (that is, a pointer to or object identity of) the object is dereferenced.\n\nthe special value null is part of every reference type.4\n\n\n# 5.0. classes\n\na class c is a reference type declared as follows:\n\nclass c〈t〉 extends j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere the list of type parameters t is optional and so is “extends j”, which says that the class extends a trait j. the members of a class are fields, functions, and methods. these are accessed or invoked by dereferencing a reference to a c instance. a function or method is invoked on an instance of c, unless the function or method is declared static. mechanically, this just means the method takes an implicit receiver parameter, namely, the instance used to access the member. in the specification and body of an instance function or method, the receiver parameter can be referred to explicitly by the keyword this. however, in such places, members of this can also be mentioned without any qualification. to illustrate, the qualified this.f and the unqualified f refer to the same field of the same object in the following example:\n\nclass c {\n  var f: int;\n  method example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nso the method body always assigns true to the out-parameter b. there is no semantic difference between qualified and unqualified accesses to the same receiver and member.\n\na c instance is created using new, for example:\n\nc := new c;\n\n\n1\n\n\nnote that new simply allocates a c object and returns a reference to it; the initial values of its fields are arbitrary values of their respective types. therefore, it is common to invoke a method, known as an initialization method, immediately after creation, for example:\n\nc := new c;\nc.initfromlist(xs, 3);\n\n\n1\n2\n\n\nwhen an initialization method has no out-parameters and modifies no more than this, then the two statements above can be combined into one:\n\nc := new c.initfromlist(xs, 3);\n\n\n1\n\n\nnote that a class can contain several initialization methods, that these methods can be invoked at any time, not just as part of a new, and that new does not require that an initialization method be invoked at creation.\n\nto write structured object-oriented programs, one often relies on that objects are constructed only in certain ways. for this purpose, dafny provides constructor (method)s, which are a restricted form of initialization methods. a constructor is declared with the keyword constructor instead of method. when a class contains a constructor, every call to new for that class must be accompanied with a call to one of the constructors. moreover, a constructor cannot be called at other times, only during object creation. other than these restrictions, there is no semantic difference between using ordinary initialization methods and using constructors.\n\nthe dafny design allows the constructors to be named, which promotes using names like initfromlist above. still, many classes have just one constructor or have a typical constructor. therefore, dafny allows one anonymous constructor, that is, a constructor whose name is essentially “”. for example:\n\nclass item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nwhen invoking this constructor, the “.” is dropped, as in:\n\nm := new item(45, 29);\n\n\n1\n\n\nnote that an anonymous constructor is just one way to name a constructor; there can be other constructors as well.\n\n\n# 5.1. arrays\n\ndafny supports mutable fixed-length array types of any positive dimension. array types are reference types.\n\n# 5.1.0. one-dimensional arrays\n\na one-dimensional array of n t elements is created as follows:\n\na := new t[n];\n\n\n1\n\n\nthe initial values of the array elements are arbitrary values of type t. the length of an array is retrieved using the immutable length member. for example, the array allocated above satisfies:\n\na.length == n\n\n\n1\n\n\nfor any integer-based numeric i in the range 0 <= i < a.length, the array selection expression a[i] retrieves element i (that is, the element preceded by i elements in the array). the element stored at i can be changed to a value t using the array update statement:\n\na[i] := t;\n\n\n1\n\n\ncaveat: the type of the array created by new t[n] is array〈t〉. a mistake that is simple to make and that can lead to befuddlement is to write array〈t〉 instead of t after new. for example, consider the following:\n\nvar a := new array〈t〉;\nvar b := new array〈t〉[n];\nvar c := new array〈t〉(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nthe first statement allocates an array of type array〈t〉, but of unknown length. the second allocates an array of type array〈array〈t〉〉 of length n, that is, an array that holds n values of type array〈t〉. the third statement allocates an array of type array〈t〉 and then attempts to invoke an anonymous constructor on this array, passing argument n. since array has no constructors, let alone an anonymous constructor, this statement gives rise to an error. if the type-parameter list is omitted for a type that expects type parameters, dafny will attempt to fill these in, so as long as the array type parameter can be inferred, it is okay to leave off the “〈t〉” in the fourth statement above. however, as with the third statement, array has no anonymous constructor, so an error message is generated.\n\none-dimensional arrays support operations that convert a stretch of consecutive elements into a sequence. for any array a of type array〈t〉, integer-based numerics lo and hi satisfying 0 <= lo <= hi <= a.length, the following operations each yields a seq〈t〉:\n\n             \nexpression   description\n             \na[lo..hi]    subarray conversion to sequence\na[lo..]      drop\na[..hi]      take\na[..]        array conversion to sequence\n             \n\nthe expression a[lo..hi] takes the first hi elements of the array, then drops the first lo elements thereof and returns what remains as a sequence. the resulting sequence thus has length hi - lo. the other operations are special instances of the first. if lo is omitted, it defaults to 0 and if hi is omitted, it defaults to a.length. in the last operation, both lo and hi have been omitted, thus a[..] returns the sequence consisting of all the array elements of a.\n\nthe subarray operations are especially useful in specifications. for example, the loop invariant of a binary search algorithm that uses variables lo and hi to delimit the subarray where the search key may be still found can be expressed as follows:\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nanother use is to say that a certain range of array elements have not been changed since the beginning of a method:\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\nor since the beginning of a loop:\n\nghost var prevelements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevelements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nnote that the type of prevelements in this example is seq〈t〉, if a has type array〈t〉.\n\na final example of the subarray operation lies in expressing that an array's elements are a permutation of the array's elements at the beginning of a method, as would be done in most sorting algorithms. here, the subarray operation is combined with the sequence-to-multiset conversion:\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1. multi-dimensional arrays\n\nan array of 2 or more dimensions is mostly like a one-dimensional array, except that new takes more length arguments (one for each dimension), and the array selection expression and the array update statement take more indices. for example:\n\nmatrix := new t[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\ncreate a 2-dimensional array whose dimensions have lengths m and n, respectively, and then swaps the elements at i,j and x,y. the type of matrix is array2〈t〉, and similarly for higher-dimensional arrays (array3〈t〉, array4〈t〉, etc.). note, however, that there is no type array0〈t〉, and what could have been array1〈t〉 is actually named just array〈t〉.\n\nthe new operation above requires m and n to be non-negative integer-based numerics. these lengths can be retrieved using the immutable fields length0 and length1. for example, the following holds of the array created above:\n\nmatrix.length0 == m && matrix.length1 == n\n\n\n1\n\n\nhigher-dimensional arrays are similar (length0, length1, length2, …). the array selection expression and array update statement require that the indices are in bounds. for example, the swap statement above is well-formed only if:\n\n0 <= i < matrix.length0 && 0 <= j < matrix.length1 &&\n0 <= x < matrix.length0 && 0 <= y < matrix.length1\n\n\n1\n2\n\n\nin contrast to one-dimensional arrays, there is no operation to convert stretches of elements from a multi-dimensional array to a sequence.\n\n\n# 5.2. traits\n\na trait is an “abstract superclass”, or call it an “interface” or “mixin”. traits are new to dafny and are likely to evolve for a while.\n\nthe declaration of a trait is much like that of a class:\n\ntrait j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere *members* can include fields, functions, and methods, but no constructor methods. the functions and methods are allowed to be declared static.\n\na reference type c that extends a trait j is assignable to j, but not the other way around. the members of j are available as members of c. a member in j is not allowed to be redeclared in c, except if the member is a non-static function or method without a body in j. by doing so, type c can supply a stronger specification and a body for the member.\n\nnew is not allowed to be used with traits. therefore, there is no object whose allocated type is a trait. but there can of course be objects of a class c that implements a trait j, and a reference to such a c object can be used as a value of type j.\n\nas an example, the following trait represents movable geometric shapes:\n\ntrait shape\n{\n  function method width(): real\n    reads this\n  method move(dx: real, dy: real)\n    modifies this\n  method moveh(dx: real)\n    modifies this\n  {\n    move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmembers width and move are abstract (that is, body less) and can be implemented differently by different classes that extend the trait. the implementation of method moveh is given in the trait and thus gets used by all classes that extend shape. here are two classes that each extends shape:\n\nclass unitsquare extends shape\n{\n  var x: real, y: real;\n  function method width(): real {  // note the empty reads clause\n    1.0\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass lowerrighttriangle extends shape\n{\n  var xnw: real, ynw: real, xse: real, yse: real;\n  function method width(): real\n    reads this\n  {\n    xse - xnw\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    xnw, ynw, xse, yse := xnw + dx, ynw + dy, xse + dx, yse + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nnote that the classes can declare additional members, that they supply implementations for the abstract members of the trait, that they repeat the member signatures, and that they are responsible for providing their own member specifications that both strengthen the corresponding specification in the trait and are satisfied by the provided body. finally, here is some code that creates two class instances and uses them together as shapes:\n\nvar myshapes: seq〈shape〉;\nvar a := new unitsquare;\nmyshapes := [a];\nvar tri := new lowerrighttriangle;\nmyshapes := myshapes + [tri];  // myshapes contains two shape values, of different classes\nmyshapes[1].moveh(myshapes[0].width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3. type object\n\nthere is a built-in reference type object that is like a supertype of all reference types.5 the purpose of type object is to enable a uniform treatment of dynamic frames. in particular, it is useful to keep a ghost field (typically named repr for “representation”) of type set〈object〉.\n\n\n# 5.4. iterator types\n\nan iterator provides a programming abstraction for writing code that iteratively returns elements. these clu-style iterators are co-routines in the sense that they keep track of their own program counter and control can be transferred into and out of the iterator body.\n\nan iterator is declared as follows:\n\niterator iter〈t〉(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhere t is a list of type parameters (as usual, if there are no type parameters, “〈t〉” is omitted). this declaration gives rise to a reference type with the same name, iter〈t〉. in the signature, in-parameters and yield-parameters are the iterator's analog of a method's in-parameters and out-parameters. the difference is that the out-parameters of a method are returned to a caller just once, whereas the yield-parameters of an iterator are returned each time the iterator body performs a yield. the details of the specification are described in a different part of the dafny language reference. the body consists of statements, like in a method body, but with the availability also of yield statements.\n\nfrom the perspective of an iterator client, the iterator declaration can be understood as generating a class iter〈t〉 with various members, a simplified version of which is described next.\n\nthe iter〈t〉 class contains an anonymous constructor whose parameters are the iterator's in-parameters:\n\npredicate valid()\nconstructor (in-params)\n  modifies this\n  ensures valid()\n\n\n1\n2\n3\n4\n\n\nan iterator is created using new and this anonymous constructor. for example, an iterator willing to return ten consecutive integers from start can be declared as follows:\n\niterator gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nan instance of this iterator is created using:\n\niter := new gen(30);\n\n\n1\n\n\nthe predicate valid() says when the iterator is in a state where one can attempt to compute more elements. it is a postcondition of the constructor and occurs in the specification of the movenext member:\n\nmethod movenext() returns (more: bool)\n  requires valid()\n  modifies this\n  ensures more ==> valid()\n\n\n1\n2\n3\n4\n\n\nnote that the iterator remains valid as long as movenext returns true. once movenext returns false, the movenext method can no longer be called. note, the client is under no obligation to keep calling movenext until it returns false, and the body of the iterator is allowed to keep returning elements forever.\n\nthe in-parameters of the iterator are stored in immutable fields of the iterator class. to illustrate in terms of the example above, the iterator class gen contains the following field:\n\nvar start: int;\n\n\n1\n\n\nthe yield-parameters also result in members of the iterator class:\n\nvar x: int;\n\n\n1\n\n\nthese fields are set by the movenext method. if movenext returns true, the latest yield values are available in these fields and the client can read them from there.\n\nto aid in writing specifications, the iterator class also contains ghost members that keep the history of values returned by movenext. the names of these ghost fields follow the names of the yield-parameters with an “s” appended to the name (to suggest plural). name checking rules make sure these names do not give rise to ambiguities. the iterator class for gen above thus contains:\n\nghost var xs: seq〈int〉;\n\n\n1\n\n\nthese history fields are changed automatically by movenext, but are not assignable by user code.\n\nfinally, the iterator class contains some special fields for use in specifications. in particular, the iterator specification gets recorded in the following immutable fields:\n\nghost var _reads: set〈object〉;\nghost var _modifies: set〈object〉;\nghost var _decreases0: t0;\nghost var _decreases1: t1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nwhere there is a _decreases*i*: t*i* field for each component of the iterator's decreases clause.6 in addition, there is a field:\n\nghost var _new: set〈object〉;\n\n\n1\n\n\nto which any objects allocated on behalf of the iterator body get added. the iterator body is allowed to remove elements from the _new set, but cannot by assignment to _new add any elements.\n\nnote, in the precondition of the iterator, which is to hold upon construction of the iterator, the in-parameters are indeed in-parameters, not fields of this.\n\n\n# 5.5. async-task types\n\nanother experimental feature in dafny that is likely to undergo some evolution is asynchronous methods. when an asynchronous method is called, it does not return values for the out-parameters, but instead returns an instance of an async-task type. an asynchronous method declared in a class c with the following signature:\n\nasync method am〈t〉(in-params) returns (out-params)\n\n\n1\n\n\nalso gives rise to an async-task type am〈t〉 (outside the enclosing class, the name of the type needs the qualification c.am〈t〉). the async-task type is a reference type and can be understood as a class with various members, a simplified version of which is described next.\n\neach in-parameter x of type x of the asynchronous method gives rise to a immutable ghost field of the async-task type:\n\nghost var x: x;\n\n\n1\n\n\neach out-parameter y of type y gives rise to a field\n\nvar y: y;\n\n\n1\n\n\nthese fields are changed automatically by the time the asynchronous method is successfully awaited, but are not assignable by user code.\n\nthe async-task type also gets a number of special fields that are used to keep track of dependencies, outstanding tasks, newly allocated objects, etc. these fields will be described in more detail as the design of asynchronous methods evolves.\n\n\n# 6. function types\n\nfunctions are first-class values in dafny. function types have the form (t) -> u where t is a comma-delimited list of types and u is a type. t is called the function's domain type(s) and u is its range type. for example, the type of a function\n\nfunction f(x: int, b: bool): real\n\n\n1\n\n\nis (int, bool) -> real. parameters are not allowed to be ghost.\n\nto simplify the appearance of the basic case where a function's domain consist of a list of exactly one type, the parentheses around the domain type can be dropped in this case, as in t -> u. this innocent simplification requires additional explanation in the case where that one type is a tuple type, since tuple types are also written with enclosing parentheses. if the function takes a single argument that is a tuple, an additional set of parentheses is needed. for example, the function\n\nfunction g(pair: (int, bool)): real\n\n\n1\n\n\nhas type ((int, bool)) -> real. note the necessary double parentheses. similarly, a function that takes no arguments is different from one that takes a 0-tuple as an argument. for instance, the functions\n\nfunction noargs(): real\nfunction z(unit: ()): real\n\n\n1\n2\n\n\nhave types () -> real and (()) -> real, respectively.\n\nthe function arrow, ->, is right associative, so a -> b -> c means a -> (b -> c). the other association requires explicit parentheses: (a -> b) -> c.\n\nnote that the receiver parameter of a named function is not part of the type. rather, it is used when looking up the function and can then be thought of as being captured into the function definition. for example, suppose function f above is declared in a class c and that c references an object of type c; then, the following is type correct:\n\nvar f: (int, bool) -> real := c.f;\n\n\n1\n\n\nwhereas it would have been incorrect to have written something like:\n\nvar f': (c, int, bool) -> real := f;  // not correct\n\n\n1\n\n\noutside its type signature, each function value has three properties, described next.\n\nevery function implicitly takes the heap as an argument. no function ever depends on the entire heap, however. a property of the function is its declared upper bound on the set of heap locations it depends on for a given input. this lets the verifier figure out that certain heap modifications have no effect on the value returned by a certain function. for a function f: t -> u and a value t of type t, the dependency set is denoted f.reads(t) and has type set〈object〉.\n\nthe second property of functions stems from that every function is potentially partial. in other words, a property of a function is its precondition. for a function f: t -> u, the precondition of f for a parameter value t of type t is denoted f.requires(t) and has type bool.\n\nthe third property of a function is more obvious—the function's body. for a function f: t -> u, the value that the function yields for an input t of type t is denoted f(t) and has type u.\n\nnote that f.reads and f.requires are themselves functions. suppose f has type t -> u and t has type t. then, f.reads is a function of type t -> set〈object〉 whose reads and requires properties are:\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires is a function of type t -> bool whose reads and requires properties are:\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0. lambda expressions\n\nin addition to named functions, dafny supports expressions that define functions. these are called lambda (expression)s (some languages know them as anonymous functions). a lambda expression has the form:\n\n(params) specification => body\n\n\n1\n\n\nwhere *params* is a comma-delimited list of parameter declarations, each of which has the form x or x: t. the type t of a parameter can be omitted when it can be inferred. if the identifier x is not needed, it can be replaced by “_”. if *params* consists of a single parameter x (or _) without an explicit type, then the parentheses can be dropped; for example, the function that returns the successor of a given integer can be written as the following lambda expression:\n\nx => x + 1\n\n\n1\n\n\nthe *specification* is a list of clauses requires e or reads w, where e is a boolean expression and w is a frame expression.\n\n*body* is an expression that defines the function's return value. the body must be well-formed for all possible values of the parameters that satisfy the precondition (just like the bodies of named functions and methods). in some cases, this means it is necessary to write explicit requires and reads clauses. for example, the lambda expression\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nwould not be well-formed if the requires clause were omitted, because of the possibility of division-by-zero.\n\nin settings where functions cannot be partial and there are no restrictions on reading the heap, the eta expansion of a function f: t -> u (that is, the wrapping of f inside a lambda expression in such a way that the lambda expression is equivalent to f) would be written x => f(x). in dafny, eta expansion must also account for the precondition and reads set of the function, so the eta expansion of f looks like:\n\nx requires f.requires(x) reads f.reads(x) => f(x)\n\n\n1\n\n\n\n# 7. newtypes\n\na new numeric type can be declared with the newtype declaration7\n\nnewtype n = x: m | q\n\n\n1\n\n\nwhere m is a numeric type and q is a boolean expression that can use x as a free variable. if m is an integer-based numeric type, then so is n; if m is real-based, then so is n. if the type m can be inferred from q, the “: m” can be omitted. if q is just true, then the declaration can be given simply as:\n\nnewtype n = m\n\n\n1\n\n\ntype m is known as the base type of n.\n\na newtype is a numeric type that supports the same operations as its base type. the newtype is distinct from and incompatible with other numeric types; in particular, it is not assignable to its base type without an explicit conversion. an important difference between the operations on a newtype and the operations on its base type is that the newtype operations are defined only if the result satisfies the predicate q, and likewise for the literals of the newtype.8\n\nfor example, suppose lo and hi are integer-based numerics that satisfy 0 <= lo <= hi and consider the following code fragment:\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nif lo and hi have type int, then the code fragment is legal; in particular, it never overflows, since int has no upper bound. in contrast, if lo and hi are variables of a newtype int32 declared as follows:\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\nthen the code fragment is erroneous, since the result of the addition may fail to satisfy the predicate in the definition of int32. the code fragment can be rewritten as\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nin which case it is legal for both int and int32.\n\nsince a newtype is incompatible with its base type and since all results of the newtype's operations are members of the newtype, a compiler for dafny is free to specialize the run-time representation of the newtype. for example, by scrutinizing the definition of int32 above, a compiler may decide to store int32 values using signed 32-bit integers in the target hardware.\n\nnote that the bound variable x in q has type m, not n. nconsequently, it may not be possible to state q about the n value. for example, consider the following type of 8-bit 2's complement integers:\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nand consider a variable c of type int8. the expression\n\n-128 <= c < 128\n\n\n1\n\n\nis not well-defined, because the comparisons require each operand to have type int8, which means the literal 128 is checked to be of type int8, which it is not. a proper way to write this expression would be to use a conversion operation, described next, on c to convert it to the base type:\n\n-128 <= int(c) < 128\n\n\n1\n\n\nthere is a restriction that the value 0 must be part of every newtype.9\n\n\n# 7.0. numeric conversion operations\n\nfor every numeric type n, there is a conversion function with the same name. it is a partial identity function. it is defined when the given value, which can be of any numeric type, is a member of the type converted to. when the conversion is from a real-based numeric type to an integer-based numeric type, the operation requires that the real-based argument has no fractional part. (to round a real-based numeric value down to the nearest integer, use the .trunc member, see section 0.1.)\n\nto illustrate using the example from above, if lo and hi have type int32, then the code fragment can legally be written as follows:\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nwhere the type of mid is inferred to be int. since the result value of the division is a member of type int32, one can introduce yet another conversion operation to make the type of mid be int32:\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nif the compiler does specialize the run-time representation for int32, then these statements come at the expense of two, respectively three, run-time conversions.\n\n\n# 8. subset types\n\na subset type is a restricted use of an existing type, called the base type of the subset type. a subset type is like a combined use of the base type and a predicate on the base type.\n\nan assignment from a subset type to its base type is always allowed. an assignment in the other direction, from the base type to a subset type, is allowed provided the value assigned does indeed satisfy the predicate of the subset type. (note, in contrast, assignments between a newtype and its base type are never allowed, even if the value assigned is a value of the target type. for such assignments, an explicit conversion must be used, see section 7.0.)\n\ndafny supports one subset type, namely the built-in type nat, whose base type is int.10 type nat designates the non-negative subrange of int. a simple example that puts subset type nat to good use is the standard fibonacci function:\n\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\nan equivalent, but clumsy, formulation of this function (modulo the wording of any error messages produced at call sites) would be to use type int and to write the restricting predicate in pre- and postconditions:\n\nfunction fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype inference will never infer the type of a variable to be a subset type. it will instead infer the type to be the base type of the subset type. for example, the type of x in\n\nforall x :: p(x)\n\n\n1\n\n\nwill be int, even if predicate p declares its argument to have type nat.\n\n# acknowledgments\n\nthis document has been improved as a result of helpful comments from nadia polikarpova and paqui lucio.\n\n----------------------------------------\n\n0.being equality-supporting is just one of many modes that one can imagine types in a rich type system to have. for example, other modes could include having a total order, being zero-initializable, and possibly being uninhabited. if dafny were to support more modes in the future, the “( )”-suffix syntax may be extended. for now, the suffix can only indicate the equality-supporting mode. ↩\n\n1.now that dafny supports built-in tuples, the plan is to change the sequence slice operation to return not a sequence of subsequences, but a tuple of subsequences. ↩\n\n2.this is likely to change in the future to disallow multiple occurrences of the same key. ↩\n\n3.this is likely to change in the future as follows: the in and !in operations will no longer be supported on maps. instead, for any map m, m.domain will return its domain as a set and m.range will return, also as a set, the image of m under its domain. ↩\n\n4.this will change in a future version of dafny that will support both nullable and (by default) non-null reference types. ↩\n\n5.soon, object will be made into a built-in trait rather than being a built-in special class. when this happens, it will no longer be possible to do new object. the current compiler restriction that object cannot be used as a type parameter will then also go away. ↩\n\n6.it would make sense to rename the special fields _reads and _modifies to have the same names as the corresponding keywords, reads and modifies, as is done for function values. also, the various _decreases*i* fields can combined into one field named decreases whose type is a n-tuple.\n\n↩\n\n7.should newtype perhaps be renamed to numtype? ↩\n\n8.would it be useful to also automatically define predicate n?(m: m) { q }? ↩\n\n9.the restriction is due to a current limitation in the compiler. this will change in the future and will also open up the possibility for subset types and non-null reference types. ↩\n\n10.a future version of dafny will support user-defined subset types. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Style Guide for Dafny programs",frontmatter:{title:"Style Guide for Dafny programs",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/c0c2c7/",categories:["语言","detailed-document"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/20.detailed-document/10.Style%20Guide%20for%20Dafny%20programers.html",relativePath:"80.语言/20.detailed-document/10.Style Guide for Dafny programers.md",key:"v-0789c349",path:"/pages/c0c2c7/",headers:[{level:3,title:"Naming Convention",slug:"naming-convention",normalizedTitle:"naming convention",charIndex:47},{level:4,title:"Method Prefix",slug:"method-prefix",normalizedTitle:"method prefix",charIndex:70},{level:3,title:"Code Layout",slug:"code-layout",normalizedTitle:"code layout",charIndex:87},{level:4,title:"Braces",slug:"braces",normalizedTitle:"braces",charIndex:104},{level:4,title:"Imports",slug:"imports",normalizedTitle:"imports",charIndex:116},{level:3,title:"Indentation and Line Breaks",slug:"indentation-and-line-breaks",normalizedTitle:"indentation and line breaks",charIndex:127},{level:4,title:"Tabs or Spaces?",slug:"tabs-or-spaces",normalizedTitle:"tabs or spaces?",charIndex:160},{level:4,title:"Maximum Character Limit",slug:"maximum-character-limit",normalizedTitle:"maximum character limit",charIndex:181},{level:4,title:"Newlines",slug:"newlines",normalizedTitle:"newlines",charIndex:210},{level:4,title:"Functions, Methods, Predicates, and Lemmas",slug:"functions-methods-predicates-and-lemmas",normalizedTitle:"functions, methods, predicates, and lemmas",charIndex:224},{level:3,title:"Things to Avoid",slug:"things-to-avoid",normalizedTitle:"things to avoid",charIndex:270},{level:4,title:"Parentheses",slug:"parentheses",normalizedTitle:"parentheses",charIndex:291},{level:4,title:"Whitespace",slug:"whitespace",normalizedTitle:"whitespace",charIndex:308},{level:5,title:"Type Declaration",slug:"type-declaration",normalizedTitle:"type declaration",charIndex:326},{level:5,title:"Function, Method, Predicate, and Lemma Declaration",slug:"function-method-predicate-and-lemma-declaration",normalizedTitle:"function, method, predicate, and lemma declaration",charIndex:350},{level:3,title:"Recommendations",slug:"recommendations",normalizedTitle:"recommendations",charIndex:404},{level:4,title:"Externs",slug:"externs",normalizedTitle:"externs",charIndex:425},{level:4,title:"Things to Consider",slug:"things-to-consider",normalizedTitle:"things to consider",charIndex:438}],headersStr:"Naming Convention Method Prefix Code Layout Braces Imports Indentation and Line Breaks Tabs or Spaces? Maximum Character Limit Newlines Functions, Methods, Predicates, and Lemmas Things to Avoid Parentheses Whitespace Type Declaration Function, Method, Predicate, and Lemma Declaration Recommendations Externs Things to Consider",content:'Dafny Documentation\n\n\n#\n\nDafny Style Guide\n\n * Naming Convention\n   * Method Prefix\n * Code Layout\n   * Braces\n   * Imports\n * Indentation and Line Breaks\n   * Tabs or Spaces?\n   * Maximum Character Limit\n   * Newlines\n   * Functions, Methods, Predicates, and Lemmas\n * Things to Avoid\n   * Parentheses\n   * Whitespace\n     * Type Declaration\n     * Function, Method, Predicate, and Lemma Declaration\n * Recommendations\n   * Externs\n   * Things to Consider\n\nThis style guide provides coding conventions for the Dafny code.\n\nThis documentation is still in progress. Please feel free to add more suggestions.\n\n\n# Naming Convention\n\nAny variables are named with camelCase.\n\nvar minValue := 1;\nvar cipherMessage := "Hello World";\n\n\n1\n2\n\n\nAny lemmas, predicates, functions, methods, classes, modules, datatypes, and newtypes are named with PascalCase.\n\nmethod FindIndex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nAny static or global constants are named with UPPERCASE_WITH_UNDERSCORES.\n\nstatic const MONTHS_IN_A_YEAR := 12\n\n\n1\n\n\n# Method Prefix\n\nAvoid redundant names when variables or methods are in a class/module.\n\nclass Integer {\n\n    // The following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to ToString()\n    // so that the method call is Integer.ToString(i)\n    // instead of Integer.IntegerToString(i).\n\n    // YES\n    method ToString(i: int) returns (s: string)\n        ...\n\n    // NO\n    method IntegerToString(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Code Layout\n\n# Braces\n\nOpening braces go on the same line by default.\n\nmodule M {\n    ...\n    method Met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nIn case the method (or function, lemma, etc) signature is too long to fit in one line, or in case the signature has at least one specification clause, the opening brace goes on a new line.\n\nmodule M {\n    ...\n    method Met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThis applies to every scope: module, class, predicate, if, while, and more.\n\n# Imports\n\nBy default, import modules without opening them.\n\nimport Coffee\n...\n\n\n1\n2\n\n\nHowever, if some members of a module are used very frequently, import it using opened:\n\nimport opened Donut\n...\n\n\n1\n2\n\n\nWhen a file uses two modules and both of them define a method of the same name, do not import them opened.\n\nimport MyModule\nimport YourModule\n...\nmethod MyMethod() {\n    MyModule.foo();\n    YourModule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIn this case, if you want to shorten the module name, import it with a shorthand name.\n\nimport M = MyModuleWithACumbersomeName\nimport Y = YourModuleWithACumbersomeName\n...\nmethod MyMethod() {\n    M.foo();\n    Y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nCommon imports, such as StandardLibrary and Native, should be grouped together, followed by custom module imports with a blank line in-between.\n\nimport opened StandardLibrary\nimport opened Native\n\nimport opened Donut\nimport Coffee\n\n\n1\n2\n3\n4\n5\n\n\nAlthough not required, it’s recommended to keep the order of imports and includes alphabetical, except when it makes more sense to group them logically.\n\n\n# Indentation and Line Breaks\n\n# Tabs or Spaces?\n\nSpaces are preferred over tabs. Tabs should only be used to remain consistent with existing code containing tabs.\n\nUse 2 spaces for each indentation.\n\n# Maximum Character Limit\n\nAlthough there is no strict requirement, it is generally recommended to have a maximum of 120 characters per line.\n\n# Newlines\n\nUse newlines between sequential functions, methods, predicates, and lemmas to increase readability.\n\nEnd each file with a newline.\n\n# Functions, Methods, Predicates, and Lemmas\n\nEvery Dafny method has the following signature.\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type) returns (ret: Type)\n    requires P()\n    modifies param2\n    ensures Q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nWhen possible, put MethodName and the returns statement on the same line, as the keyword returns is distinct from other method specification clauses, such as requires, modifies, ensures, and decreases, which should appear in this order. Each method specification clause should be on a separate line, indented.\n\nIn case the Method signature is too long, we can break it down.\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type,\n        param3: Type, param4: Type, param5: Type)\n    returns (ret1: Type, ret2: Type, ret3: Type, ret4: Type,\n        ret5: Type)\n    requires P1()\n    requires P2()\n    requires P3()\n    modifies param2\n    modifies param3\n    ensures Q1()\n    ensures Q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMultiple requires or ensures can be combined into one:\n\nrequires\n    && P1()\n    && P2()\n    && P3()\n\n\n1\n2\n3\n4\n\n\nThe same rules apply to function, predicate, and lemma definitions.\n\n\n# Things to Avoid\n\n# Parentheses\n\nIn many cases, Dafny does not require parentheses around expressions. Here are some examples.\n\n * If-Else-While Statements\n\n// YES\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// NO\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * Statements That Take Expression Arguments\n\n// YES\nassert x < 100;\nprint x;\n\n// NO\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Simple Boolean/Arithmetic Expressions\n\n// YES\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// NO\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# Whitespace\n\nAvoid unnecessary whitespace inside expressions.\n\n# Type Declaration\n\nA type declaration should have a form of variableName: variableType.\n\n// YES\nconst one: int := 1\nclass {:extern} Util {\n    var {:extern} Exception: System.String\n}\n\n// NO\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} Util {\n    var {:extern} Exception : System.String // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIf the type can be inferred by Dafny, leave it out, unless you think it provides useful documentation in the program. So, constant one above is better declared as\n\nconst one := 1\n\n\n1\n\n\n# Function, Method, Predicate, and Lemma Declaration\n\nThe function, method, predicate, and lemma definitions should have the form FunctionName(parameterName: parameterType, ...).\n\n// YES\nfunction method Foo<int>(i: int): int\n\n// NO\nfunction method Foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\nAvoid too little or too much whitespace that reduces the overall readability.\n\n// YES\nlemma MyLemma<A, B>(x: seq<seq<A>>, y: B) {\n    ...\n}\n\n// NO\nlemma MyLemma <A,B> ( x : seq<seq<A>> , y :B){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Recommendations\n\nThis section describes a few recommendations that can help make code more readable and easy to follow, although not strictly enforced.\n\n# Externs\n\nTry to name them the same in Dafny and the target language (e.g. C#, Java, etc) whenever possible, so that in Dafny we only have to write {:extern}, not {:extern "<name>"}.\n\n# Things to Consider\n\nAsk these questions before designing / implementing a program in Dafny.\n\n * Is this variable name / function name X a good name?\n * Does it make sense that this method M is in module X? Shouldn’t it be in module Y instead?\n * Does the definition X belong to the file Y.dfy?\n * Is X.dfy a good filename?',normalizedContent:'dafny documentation\n\n\n#\n\ndafny style guide\n\n * naming convention\n   * method prefix\n * code layout\n   * braces\n   * imports\n * indentation and line breaks\n   * tabs or spaces?\n   * maximum character limit\n   * newlines\n   * functions, methods, predicates, and lemmas\n * things to avoid\n   * parentheses\n   * whitespace\n     * type declaration\n     * function, method, predicate, and lemma declaration\n * recommendations\n   * externs\n   * things to consider\n\nthis style guide provides coding conventions for the dafny code.\n\nthis documentation is still in progress. please feel free to add more suggestions.\n\n\n# naming convention\n\nany variables are named with camelcase.\n\nvar minvalue := 1;\nvar ciphermessage := "hello world";\n\n\n1\n2\n\n\nany lemmas, predicates, functions, methods, classes, modules, datatypes, and newtypes are named with pascalcase.\n\nmethod findindex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nany static or global constants are named with uppercase_with_underscores.\n\nstatic const months_in_a_year := 12\n\n\n1\n\n\n# method prefix\n\navoid redundant names when variables or methods are in a class/module.\n\nclass integer {\n\n    // the following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to tostring()\n    // so that the method call is integer.tostring(i)\n    // instead of integer.integertostring(i).\n\n    // yes\n    method tostring(i: int) returns (s: string)\n        ...\n\n    // no\n    method integertostring(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# code layout\n\n# braces\n\nopening braces go on the same line by default.\n\nmodule m {\n    ...\n    method met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nin case the method (or function, lemma, etc) signature is too long to fit in one line, or in case the signature has at least one specification clause, the opening brace goes on a new line.\n\nmodule m {\n    ...\n    method met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nthis applies to every scope: module, class, predicate, if, while, and more.\n\n# imports\n\nby default, import modules without opening them.\n\nimport coffee\n...\n\n\n1\n2\n\n\nhowever, if some members of a module are used very frequently, import it using opened:\n\nimport opened donut\n...\n\n\n1\n2\n\n\nwhen a file uses two modules and both of them define a method of the same name, do not import them opened.\n\nimport mymodule\nimport yourmodule\n...\nmethod mymethod() {\n    mymodule.foo();\n    yourmodule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nin this case, if you want to shorten the module name, import it with a shorthand name.\n\nimport m = mymodulewithacumbersomename\nimport y = yourmodulewithacumbersomename\n...\nmethod mymethod() {\n    m.foo();\n    y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ncommon imports, such as standardlibrary and native, should be grouped together, followed by custom module imports with a blank line in-between.\n\nimport opened standardlibrary\nimport opened native\n\nimport opened donut\nimport coffee\n\n\n1\n2\n3\n4\n5\n\n\nalthough not required, it’s recommended to keep the order of imports and includes alphabetical, except when it makes more sense to group them logically.\n\n\n# indentation and line breaks\n\n# tabs or spaces?\n\nspaces are preferred over tabs. tabs should only be used to remain consistent with existing code containing tabs.\n\nuse 2 spaces for each indentation.\n\n# maximum character limit\n\nalthough there is no strict requirement, it is generally recommended to have a maximum of 120 characters per line.\n\n# newlines\n\nuse newlines between sequential functions, methods, predicates, and lemmas to increase readability.\n\nend each file with a newline.\n\n# functions, methods, predicates, and lemmas\n\nevery dafny method has the following signature.\n\nmethod {:<attributes>} methodname(param1: type, param2: type) returns (ret: type)\n    requires p()\n    modifies param2\n    ensures q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nwhen possible, put methodname and the returns statement on the same line, as the keyword returns is distinct from other method specification clauses, such as requires, modifies, ensures, and decreases, which should appear in this order. each method specification clause should be on a separate line, indented.\n\nin case the method signature is too long, we can break it down.\n\nmethod {:<attributes>} methodname(param1: type, param2: type,\n        param3: type, param4: type, param5: type)\n    returns (ret1: type, ret2: type, ret3: type, ret4: type,\n        ret5: type)\n    requires p1()\n    requires p2()\n    requires p3()\n    modifies param2\n    modifies param3\n    ensures q1()\n    ensures q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmultiple requires or ensures can be combined into one:\n\nrequires\n    && p1()\n    && p2()\n    && p3()\n\n\n1\n2\n3\n4\n\n\nthe same rules apply to function, predicate, and lemma definitions.\n\n\n# things to avoid\n\n# parentheses\n\nin many cases, dafny does not require parentheses around expressions. here are some examples.\n\n * if-else-while statements\n\n// yes\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// no\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * statements that take expression arguments\n\n// yes\nassert x < 100;\nprint x;\n\n// no\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * simple boolean/arithmetic expressions\n\n// yes\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// no\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# whitespace\n\navoid unnecessary whitespace inside expressions.\n\n# type declaration\n\na type declaration should have a form of variablename: variabletype.\n\n// yes\nconst one: int := 1\nclass {:extern} util {\n    var {:extern} exception: system.string\n}\n\n// no\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} util {\n    var {:extern} exception : system.string // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nif the type can be inferred by dafny, leave it out, unless you think it provides useful documentation in the program. so, constant one above is better declared as\n\nconst one := 1\n\n\n1\n\n\n# function, method, predicate, and lemma declaration\n\nthe function, method, predicate, and lemma definitions should have the form functionname(parametername: parametertype, ...).\n\n// yes\nfunction method foo<int>(i: int): int\n\n// no\nfunction method foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\navoid too little or too much whitespace that reduces the overall readability.\n\n// yes\nlemma mylemma<a, b>(x: seq<seq<a>>, y: b) {\n    ...\n}\n\n// no\nlemma mylemma <a,b> ( x : seq<seq<a>> , y :b){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# recommendations\n\nthis section describes a few recommendations that can help make code more readable and easy to follow, although not strictly enforced.\n\n# externs\n\ntry to name them the same in dafny and the target language (e.g. c#, java, etc) whenever possible, so that in dafny we only have to write {:extern}, not {:extern "<name>"}.\n\n# things to consider\n\nask these questions before designing / implementing a program in dafny.\n\n * is this variable name / function name x a good name?\n * does it make sense that this method m is in module x? shouldn’t it be in module y instead?\n * does the definition x belong to the file y.dfy?\n * is x.dfy a good filename?',charsets:{},lastUpdated:"2022/03/26, 23:17:20",lastUpdatedTimestamp:164830784e4},{title:"Automatic Induction",frontmatter:{title:"Automatic Induction",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/a9363c/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/00.Automatic%20Induction.html",relativePath:"80.语言/30.publication-lecture/00.Automatic Induction.md",key:"v-4069c5f8",path:"/pages/a9363c/",headers:[{level:2,title:"0. Running example",slug:"_0-running-example",normalizedTitle:"0. running example",charIndex:702},{level:3,title:"0.0. List and function definitions",slug:"_0-0-list-and-function-definitions",normalizedTitle:"0.0. list and function definitions",charIndex:725},{level:3,title:"0.1. A lemma and proof",slug:"_0-1-a-lemma-and-proof",normalizedTitle:"0.1. a lemma and proof",charIndex:1360},{level:3,title:"0.2. Termination in more detail",slug:"_0-2-termination-in-more-detail",normalizedTitle:"0.2. termination in more detail",charIndex:4848},{level:3,title:"0.3. Other termination metrics for RangeLength",slug:"_0-3-other-termination-metrics-for-rangelength",normalizedTitle:"0.3. other termination metrics for rangelength",charIndex:7999},{level:3,title:"0.4. A shorter proof",slug:"_0-4-a-shorter-proof",normalizedTitle:"0.4. a shorter proof",charIndex:10684},{level:3,title:"0.5. Strong induction",slug:"_0-5-strong-induction",normalizedTitle:"0.5. strong induction",charIndex:11781},{level:2,title:"1. Automatic induction",slug:"_1-automatic-induction",normalizedTitle:"1. automatic induction",charIndex:14076},{level:3,title:"1.0. The detailed recipe for automatic induction",slug:"_1-0-the-detailed-recipe-for-automatic-induction",normalizedTitle:"1.0. the detailed recipe for automatic induction",charIndex:14772},{level:3,title:"1.1. Example: missing decreases",slug:"_1-1-example-missing-decreases",normalizedTitle:"1.1. example: missing decreases",charIndex:17045},{level:3,title:"1.2. Example: quantifying over just len",slug:"_1-2-example-quantifying-over-just-len",normalizedTitle:"1.2. example: quantifying over just len",charIndex:17738},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:19139},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:19291}],headersStr:"0. Running example 0.0. List and function definitions 0.1. A lemma and proof 0.2. Termination in more detail 0.3. Other termination metrics for RangeLength 0.4. A shorter proof 0.5. Strong induction 1. Automatic induction 1.0. The detailed recipe for automatic induction 1.1. Example: missing decreases 1.2. Example: quantifying over just len Acknowledgments References",content:"Dafny Power User: Automatic Induction\n\nK. Rustan M. Leino\n\nManuscript KRML 269, 31 May 2019\n\nAbstract. For simple examples, Dafny's automatic induction is powerful enough to prove some lemmas without manual input and helps reduce the manual input required to prove others. This note explains how automatic induction is applied and how the two main knobs are used to adjust what the automation does.\n\nDafny not only supports manually written lemmas, but also provides some automation that assists in proving lemmas by induction [0]. Let's start with variations of a manual proof, then see how automatic induction provides or fails to provide a proof, and finally how to adjust what automation does.\n\n\n# 0. Running example\n\n\n# 0.0. List and function definitions\n\nConsider the following standard definition of recursively defined lists along with a Length function and a function that constructs a list of increasing integers.\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Range(start: int, len: nat): List<int>\n  decreases len\n{\n  if len == 0 then Nil else Cons(start, Range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWith these definitions, let's set out to prove that the length of the list Range(start, len) is len.\n\n\n# 0.1. A lemma and proof\n\nSo, we're going to prove that the length of the list Range(start, len) is len. We start with a manual proof. To be sure that automatic induction does not help us along in this first example, I have marked with lemmas with the attribute {:induction false}.\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      Length(Range(start, len));\n    ==  // def. Range, since len > 0\n      Length(Cons(start, Range(start+1, len-1)));\n    ==  // def. Length on Cons\n      1 + Length(Range(start+1, len-1));\n    ==  { RangeLength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nFor the purpose of this note, I assume you have a basic understanding of how to write proof like this manually, either in Dafny or on paper. I will describe the elements of the proof here, but won't try to explain all possible considerations.\n\nThe lemma is called RangeLength and is parameterized by start and len, just like the Range function is. The property that the lemma proves is stated in the ensures clause. It is also called the proof goal.\n\nThe signature part of the lemma also defines a decreases clause, which says that the expression len is to be used as the termination metric for any recursive calls of the lemma. This termination metric is the same as the one of the Range function. This is common, because the structure of a proof typically follows the structure of a function in the lemma's proof goal.\n\nThe body of the lemma is divided up into two cases, following the cases in the definition of Range. The first case is len == 0 and gives rise to a very simple proof: when len == 0, Range returns Nil whose length is 0.\n\nThe other case makes use of a verified calculation, commonly known as a calc statement [1]. This calculation starts with the expression Length(Range(start, len)) and uses equality-preserving transformations to arrive at len, which is exactly what the proof goal says the lemma has to prove. The first two steps of the calculation apply the definitions of Range and Length to rewrite the expression into a form where we see the expression\n\nLength(Range(start+1, len-1))\n\n\n1\n\n\nThis is where the one interesting step of the proof takes place. We want to replace this expression with len - 1, which requires a justification that the expression indeed equals len - 1. With the right parameterization, this is exactly what the lemma we're trying to prove says. Therefore, we use a calc-statement hint and call the lemma:\n\nRangeLength(start+1, len-1);\n\n\n1\n\n\nBecause this is a recursive call to the lemma we're trying to prove, we must prove termination. A recursive call to a lemma is commonly known as an application of the induction hypothesis. In that way, our termination check corresponds to making sure that the induction is well-founded. In Dafny, termination is proved by showing that every recursive call decreases some termination metric, which is to say that some expression evaluates to a smaller value for the recursive call than it does for the caller. What is this termination-metric expression that is to be smaller and what does “smaller” mean? The expression is len, as given by the decreases clause, and since len is an integer, Dafny uses \"integer less-than, bounded below by 0\" as the order.\n\n\n# 0.2. Termination in more detail\n\nThat was a mouthful. Let's review that last part again, the part about termination.\n\nTo prove that recursive calls to a (function or method or) lemma terminate, we associate each invocation of the lemma with a value in a well-founded order. Being well-founded means that there are no infinite descending chains. That is, there is fixed ordering and every sequence of successively smaller values in that ordering is finite. For example, in the \"integer less-than, bounded below by 0\" ordering, one descending chain is\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nThis chain is finite. No matter what descending chain you write down, it will be finite in this ordering (otherwise, you would eventually get a negative number, but remember we said \"bounded below by 0\"0).\n\nDafny builds in a fixed well-founded order for every type.1 It also supports lexicographic tuples of values, and the well-founded order for such tuples is the lexicographic ordering of the types on each component.\n\nThe way we associate a lemma invocation with a value in this fixed well-founded order is that we declare a decreases clause. It takes as its argument a list of expressions, and these form a lexicographic tuple. For our RangeLength lemma, we used decreases len. This says that each invocation of the lemma will be associated with the same value as is passed in as parameter len.\n\nFunction Range is also recursive, and for its invocations, we also used len as the termination metric. Function Length is recursive, too, but evidently we didn't give a decreases clause for it. In the absence of a decreases clause, Dafny provides one for us, namely the lexicographic tuple consisting of the function/method/lemma's parameters, in the order given.2 So, the termination metric of Length is list (and Dafny's well-founded order for inductive datatypes is structural inclusion). Dafny's IDEs provide a tool tip (which you can see by hovering over the function/method/lemma declaration) that tells you which decreases clause it picks for recursive functions/methods/lemmas.\n\nSo far, I've said that Dafny defines a fixed well-founded ordering and the way to associate lemma invocation with a value in that ordering is to declare a decreases clause. How does the verifier use these things to prove termination? It proves that the value associated with a callee is strictly below the value associated with the caller. In other words, it proves that every recursive call takes a step in a descending chain. Because every chain is finite, it follows that there is no infinite recursion. In other words, the recursive calls terminate.\n\nIn the example, there's a recursive call from RangeLength(start, len) to RangeLength(start+1, len-1). The lemma uses decreases len, so the verifier checks that len-1 < len, which proves termination.\n\nSimilarly, there is a recursive call from Range(start, len) to Range(start+1, len-1). The verifier checks len-1 < len and this proves termination.\n\nFinally, there is a recursive call from Length(list) to Length(tail), where tail is structurally included in list. Thus, the verifier is able to prove termination here as well.\n\n\n# 0.3. Other termination metrics for RangeLength\n\nIt is instructive to consider what would happen if we had chosen a different termination metric for RangeLength. For each one we consider, the proof obligation is constructed the same way: the value for RangeLength(start+1, len-1) must be smaller than the value for RangeLength(start, len).\n\nSuppose we declared RangeLength with decreases 10*len + 28. Yes, this termination metric is good enough to prove termination, because 10*len + 18 is less than 10*len + 28.\n\nWhat about decreases len - 6? No, Dafny will complain about not being able to prove termination if you give it this termination metric. It will fail to prove that len-7 is below len-6 in the integer ordering, because these could be negative.3\n\nLet's try decreases start + len. No, because start+1 + len-1 is not less than start + len.\n\nHow about decreases start + 2*len. Yes, this proves termination, because start+1 + 2*(len-1) is less than start + 2*len.\n\nWhat about using the lexicographic tuple decreases start, len? No, this won't prove termination, because start+1, len-1 is not lexicographically smaller than start, len (in fact, it is lexicographically larger). Had we left off the decreases clause from RangeLength altogether, Dafny would have generated one for us. It generates it to be decreases start, len, because the parameters of RangeLength are start and len, in that order. So, without an explicit decreases clause, Dafny would complain about not being able to prove termination.\n\nHow about switching the order of the arguments, as in decreases len, start? Yes, this proves termination, because len-1, start+1 is smaller than len, start.\n\nIf you change RangeLength to swap its parameters start and len (and do the same swapping for the recursive call to RangeLength), then you could have left off the decreases clause. In this case, Dafny would generate decreases len, start, and that proves termination. However, it's usually advisable to stick with the parameter ordering that is most natural for the function/method/lemma at hand.\n\nLastly, how about this quirky termination metric: decreases 7, len? When you first read this out loud, you might say\n\n> Decreases 7? How can anything decrease 7? 7 is what it was when my great-grandparents were alive, and 7 will always be just that. There is no way to decrease 7!\n\nYou are right, but that's not what the decreases clause says. The decreases clause simply says how to map each lemma invocation to a value in the well-founded order. So, with this quirky termination metric, the proof obligation is to check that 7, len-1 is lexicographically smaller than 7, len, which it is. Not so quirky after all.\n\n\n# 0.4. A shorter proof\n\nLet's simplify the manual proof we wrote for RangeLength. The calc statement is helpful when we write a proof in the first place, and it also gives a readable presentation of the proof. But once we have figured out a proof, we sometimes choose to shorten it, perhaps because in retrospect we found we were too punctilious even for our own taste.\n\nThe calc statement we wrote above really just has one non-trivial step, the application of the induction hypothesis. In fact, we can replace the entire calc statement with just that one call:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSince the “then” branch of the if is empty, we can of course also negate the guard, swap the branches, and omit the empty else:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 0.5. Strong induction\n\nCan we do even better than that one if statement? Well, that depends on what you think is better, but there is a way in Dafny to eliminate this branch. We can do that by replacing the entire if statement and its one call to RangeLength by a forall statement that calls RangeLength for a whole bunch of values.\n\nTo get this started, suppose we tried using the following as the body of RangeLength:\n\nforall start', len' {\n  RangeLength(start', len');\n}\n\n\n1\n2\n3\n\n\nThis rather cavalier statement calls RangeLength for all possible values of start' and len'. Well, this doesn't work, because many of those recursive calls won't terminate. We need to restrict ourselves to values of start' and len' that decrease the termination metric.\n\nSo, let's try this:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  forall start', len' | 0 <= len' < len {\n    RangeLength(start', len');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThis calls RangeLength for all values of start' and all values of len' smaller than len. That is, this forall statement makes an infinite number of recursive calls to RangeLength, all at once. Each of these infinitely many calls terminates, because the value of len' is smaller than len.4\n\nThis version of RangeLength verifies. The mathematical name for calling an induction hypothesis for all smaller values like this is called strong induction.\n\nWell, values of start' can be larger than start (in that, it is crucial for the proof that start + 1 is one of those values). So, you may opine that the forall statement above does more than just strong induction. Indeed, some may argue that this forall statement also performs what is called generalizing the lemma to all values of start'. But if you consider the ordering that determines “smaller” to be one that just compares the len component, then start', len' is indeed smaller than start, len, as long as len' is smaller than len. However you want to think about it or whatever mathematical name you want to give to it, Dafny accepts the forall statement above as a proof. In programming terms, all we're doing is proving that each recursive call terminates, and that follows from the way we defined the termination metric by decreases len.\n\n\n# 1. Automatic induction\n\nWith all that background, we are finally ready to learn what Dafny does to automate induction. Here's the short of it: if you remove the attribute {:induction false} (which I introduced only to disable automatic induction while we were discussing what makes a proof in the first place), then what Dafny does by default is insert the forall statement we just saw. This means you can remove the manually inserted forall statement, because Dafny will add it for you. In other words, Dafny accepts the following as a proof of the lemma:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nShort and sweet.\n\n\n# 1.0. The detailed recipe for automatic induction\n\nDafny automated induction all comes down to the maneuver of automatically generating one forall statement at the beginning of every lemma. This does not solve all problems of induction, but I'm amazed at how many simple problems of induction that this simple maneuver does solve. Let's look at the ingredients that go into the maneuver.\n\nFor a lemma L with formal arguments args, precondition P(args),5 and termination metric T(args), Dafny automatic induction inserts the following forall statement at the beginning of the body of L:\n\nforall aa' | P(args') && T(args') < T(args) {\n  L(args');\n}\n\n\n1\n2\n3\n\n\nwhere\n\n * aa is a subset of the formal parameters args,\n * aa' is aa, suitably renamed to have fresh names,\n * args' denotes args but with every variable in aa replaced by the corresponding one in aa', and\n * < denotes Dafny's well-founded lexicographic order.\n\nThe subset aa of the variables args can be customized by placing the attribute {:induction aa} on the lemma. If no such attribute is given, then Dafny picks aa heuristically. Dafny reports what it picks in a tool tip that the Dafny IDEs show when you hover over the name of the lemma.\n\nWe might think of {:induction x} as saying we're \"doing induction over x“, but be a little bit careful with this. I find that common mathematical usage of the phrase ”do induction over …\" conflates several ideas. So, to be precise about it, what the {:induction aa} attribute specifies is which parameters are to be universally quantified over.\n\nThere is one more subtlety that is easy to forget: the decreases clause matters. When we write a lemma like RangeLength, we might expect the proof to be simple enough that Dafny's automatic induction will take care of it automatically. If so, we might just write down the type signature of the lemma and the (pre- and) postcondition. This often is all that's needed, but in the case of RangeLength, it is also necessary to supply a decreases clause. Usually, if the main function that the lemma is about (Range in the running example) needs an explicit decreases clause, then the lemma does, too. Alas, this can be easy to forget.\n\nNext, let's consider some ways of customizing the automatic induction for RangeLength.\n\n\n# 1.1. Example: missing decreases\n\nWhat happens if you do forget the decreases clause of RangeLength? The lemma then looks like this:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nFor this lemma, Dafny comes up with {:induction start, len} and decreases start, len.6 That means the implicit forall statement that the induction maneuver inserts is\n\nforall start': nat, len': nat |\n  start' < start || (start' == start && len' < len)\n{\n  RangeLength(start', len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nAs we explored in the previous section, this does not prove the lemma, because the crucial call RangeLength(start+1, len-1) is not among the calls performed.\n\n\n# 1.2. Example: quantifying over just len\n\nWhat if we manually override the quantified variables and list only len?\n\nlemma {:induction len} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nWe then get the following forall statement:\n\nforall len': nat |\n  start < start || (start == start && len' < len)\n{\n  RangeLength(start, len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nNotice how there is no start' in this example. Rather, the original formal parameter start is used in the formulaic range expression\n\nP(start, len') && T(start, len') < T(start, len)\n\n\n1\n\n\nThere is no precondition in the example, so the P part is true. Because we didn't supply an explicit decreases clause, Dafny generates decreases start, len. Therefore, the range expression that restricts the universally quantified variables (that is, len') is\n\nstart < start || (start == start && len' < len)\n\n\n1\n\n\nwhich simplifies to len' < len.\n\nAgain, since the recursive calls entailed by this forall statement does not include the crucial call RangeLength(start+1, len-1), Dafny will report an error that the lemma's postcondition might not hold.\n\nThe result would be the same even if we supplied a decreases clause manually. That would still restrict len' to values that are smaller than len, which is fine, but the problem is still that the inductive hypothesis is only considered for the given value of start.\n\n# Acknowledgments\n\nI'm grateful to Sean McLaughlin, who provided both the running example and the question about automatic induction for RangeLength.\n\n\n# References\n\n[0]K. Rustan M. Leino. Automating induction with an SMT solver. In Viktor Kuncak and Andrey Rybalchenko, editors, Verification, Model Checking, and Abstract Interpretation — 13th International Conference, VMCAI 2012, volume 7148 of Lecture Notes in Computer Science, pages 315–331. Springer, January 2012. 🔎\n\n[1]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments — 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170–190. Springer, 2014. 🔎\n\n----------------------------------------\n\n0.I'm simplifying a little bit. Dafny's well-founded order on integers is actually “integer less-than, with no more than one negative value”. So, a chain is allowed to dip down below 0, but once the chain includes a negative number, it must stop. This extension is a well-founded order, because there is still no way to make an infinite descending chain. ↩\n\n1.I'm simplifying a little bit. Dafny's fixed well-founded order also orders some values across different types. ↩\n\n2.This is a slight simplification. Dafny's heuristic for coming up with a decreases clause for a recursive function/method/lemma omits parameters whose types aren't helpful in letting you prove termination. For example, a parameter whose type is a type parameter is omitted from automatically generated decreases clauses. ↩\n\n3.I was fast and loose in the previous example, because I should have also pointed out that 10*len + 18 is non-negative.) ↩\n\n4.“An infinite number of calls?!”, you say to yourself. “How is that termination, even if each such call terminates?” I won't delve into that here, but I will at least point out that we're calling a lemma, not a compiled method. So, you don't need to worry about having enough computational resources to make an infinite number of calls. ↩\n\n5.A precondition of a lemma is declared using the keyword requires. It is like an antecedent of the lemma, and it is checked to hold at every call site. The running example does not include a precondition. A simple way to include one would be to change the type of start from nat to int and to add requires 0 <= start. ↩\n\n6.I mentioned that tool tips in the Dafny IDEs show you what decreases clause Dafny picks. As of this writing, such a tool tip is shown only when the body of the function/method/lemma includes an explicit recursive call. In particular, if the body of the lemma is empty, there is no tool tip that shows you what decreases clause is generated. ↩",normalizedContent:"dafny power user: automatic induction\n\nk. rustan m. leino\n\nmanuscript krml 269, 31 may 2019\n\nabstract. for simple examples, dafny's automatic induction is powerful enough to prove some lemmas without manual input and helps reduce the manual input required to prove others. this note explains how automatic induction is applied and how the two main knobs are used to adjust what the automation does.\n\ndafny not only supports manually written lemmas, but also provides some automation that assists in proving lemmas by induction [0]. let's start with variations of a manual proof, then see how automatic induction provides or fails to provide a proof, and finally how to adjust what automation does.\n\n\n# 0. running example\n\n\n# 0.0. list and function definitions\n\nconsider the following standard definition of recursively defined lists along with a length function and a function that constructs a list of increasing integers.\n\ndatatype list<a> = nil | cons(a, list<a>)\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method range(start: int, len: nat): list<int>\n  decreases len\n{\n  if len == 0 then nil else cons(start, range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwith these definitions, let's set out to prove that the length of the list range(start, len) is len.\n\n\n# 0.1. a lemma and proof\n\nso, we're going to prove that the length of the list range(start, len) is len. we start with a manual proof. to be sure that automatic induction does not help us along in this first example, i have marked with lemmas with the attribute {:induction false}.\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      length(range(start, len));\n    ==  // def. range, since len > 0\n      length(cons(start, range(start+1, len-1)));\n    ==  // def. length on cons\n      1 + length(range(start+1, len-1));\n    ==  { rangelength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nfor the purpose of this note, i assume you have a basic understanding of how to write proof like this manually, either in dafny or on paper. i will describe the elements of the proof here, but won't try to explain all possible considerations.\n\nthe lemma is called rangelength and is parameterized by start and len, just like the range function is. the property that the lemma proves is stated in the ensures clause. it is also called the proof goal.\n\nthe signature part of the lemma also defines a decreases clause, which says that the expression len is to be used as the termination metric for any recursive calls of the lemma. this termination metric is the same as the one of the range function. this is common, because the structure of a proof typically follows the structure of a function in the lemma's proof goal.\n\nthe body of the lemma is divided up into two cases, following the cases in the definition of range. the first case is len == 0 and gives rise to a very simple proof: when len == 0, range returns nil whose length is 0.\n\nthe other case makes use of a verified calculation, commonly known as a calc statement [1]. this calculation starts with the expression length(range(start, len)) and uses equality-preserving transformations to arrive at len, which is exactly what the proof goal says the lemma has to prove. the first two steps of the calculation apply the definitions of range and length to rewrite the expression into a form where we see the expression\n\nlength(range(start+1, len-1))\n\n\n1\n\n\nthis is where the one interesting step of the proof takes place. we want to replace this expression with len - 1, which requires a justification that the expression indeed equals len - 1. with the right parameterization, this is exactly what the lemma we're trying to prove says. therefore, we use a calc-statement hint and call the lemma:\n\nrangelength(start+1, len-1);\n\n\n1\n\n\nbecause this is a recursive call to the lemma we're trying to prove, we must prove termination. a recursive call to a lemma is commonly known as an application of the induction hypothesis. in that way, our termination check corresponds to making sure that the induction is well-founded. in dafny, termination is proved by showing that every recursive call decreases some termination metric, which is to say that some expression evaluates to a smaller value for the recursive call than it does for the caller. what is this termination-metric expression that is to be smaller and what does “smaller” mean? the expression is len, as given by the decreases clause, and since len is an integer, dafny uses \"integer less-than, bounded below by 0\" as the order.\n\n\n# 0.2. termination in more detail\n\nthat was a mouthful. let's review that last part again, the part about termination.\n\nto prove that recursive calls to a (function or method or) lemma terminate, we associate each invocation of the lemma with a value in a well-founded order. being well-founded means that there are no infinite descending chains. that is, there is fixed ordering and every sequence of successively smaller values in that ordering is finite. for example, in the \"integer less-than, bounded below by 0\" ordering, one descending chain is\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nthis chain is finite. no matter what descending chain you write down, it will be finite in this ordering (otherwise, you would eventually get a negative number, but remember we said \"bounded below by 0\"0).\n\ndafny builds in a fixed well-founded order for every type.1 it also supports lexicographic tuples of values, and the well-founded order for such tuples is the lexicographic ordering of the types on each component.\n\nthe way we associate a lemma invocation with a value in this fixed well-founded order is that we declare a decreases clause. it takes as its argument a list of expressions, and these form a lexicographic tuple. for our rangelength lemma, we used decreases len. this says that each invocation of the lemma will be associated with the same value as is passed in as parameter len.\n\nfunction range is also recursive, and for its invocations, we also used len as the termination metric. function length is recursive, too, but evidently we didn't give a decreases clause for it. in the absence of a decreases clause, dafny provides one for us, namely the lexicographic tuple consisting of the function/method/lemma's parameters, in the order given.2 so, the termination metric of length is list (and dafny's well-founded order for inductive datatypes is structural inclusion). dafny's ides provide a tool tip (which you can see by hovering over the function/method/lemma declaration) that tells you which decreases clause it picks for recursive functions/methods/lemmas.\n\nso far, i've said that dafny defines a fixed well-founded ordering and the way to associate lemma invocation with a value in that ordering is to declare a decreases clause. how does the verifier use these things to prove termination? it proves that the value associated with a callee is strictly below the value associated with the caller. in other words, it proves that every recursive call takes a step in a descending chain. because every chain is finite, it follows that there is no infinite recursion. in other words, the recursive calls terminate.\n\nin the example, there's a recursive call from rangelength(start, len) to rangelength(start+1, len-1). the lemma uses decreases len, so the verifier checks that len-1 < len, which proves termination.\n\nsimilarly, there is a recursive call from range(start, len) to range(start+1, len-1). the verifier checks len-1 < len and this proves termination.\n\nfinally, there is a recursive call from length(list) to length(tail), where tail is structurally included in list. thus, the verifier is able to prove termination here as well.\n\n\n# 0.3. other termination metrics for rangelength\n\nit is instructive to consider what would happen if we had chosen a different termination metric for rangelength. for each one we consider, the proof obligation is constructed the same way: the value for rangelength(start+1, len-1) must be smaller than the value for rangelength(start, len).\n\nsuppose we declared rangelength with decreases 10*len + 28. yes, this termination metric is good enough to prove termination, because 10*len + 18 is less than 10*len + 28.\n\nwhat about decreases len - 6? no, dafny will complain about not being able to prove termination if you give it this termination metric. it will fail to prove that len-7 is below len-6 in the integer ordering, because these could be negative.3\n\nlet's try decreases start + len. no, because start+1 + len-1 is not less than start + len.\n\nhow about decreases start + 2*len. yes, this proves termination, because start+1 + 2*(len-1) is less than start + 2*len.\n\nwhat about using the lexicographic tuple decreases start, len? no, this won't prove termination, because start+1, len-1 is not lexicographically smaller than start, len (in fact, it is lexicographically larger). had we left off the decreases clause from rangelength altogether, dafny would have generated one for us. it generates it to be decreases start, len, because the parameters of rangelength are start and len, in that order. so, without an explicit decreases clause, dafny would complain about not being able to prove termination.\n\nhow about switching the order of the arguments, as in decreases len, start? yes, this proves termination, because len-1, start+1 is smaller than len, start.\n\nif you change rangelength to swap its parameters start and len (and do the same swapping for the recursive call to rangelength), then you could have left off the decreases clause. in this case, dafny would generate decreases len, start, and that proves termination. however, it's usually advisable to stick with the parameter ordering that is most natural for the function/method/lemma at hand.\n\nlastly, how about this quirky termination metric: decreases 7, len? when you first read this out loud, you might say\n\n> decreases 7? how can anything decrease 7? 7 is what it was when my great-grandparents were alive, and 7 will always be just that. there is no way to decrease 7!\n\nyou are right, but that's not what the decreases clause says. the decreases clause simply says how to map each lemma invocation to a value in the well-founded order. so, with this quirky termination metric, the proof obligation is to check that 7, len-1 is lexicographically smaller than 7, len, which it is. not so quirky after all.\n\n\n# 0.4. a shorter proof\n\nlet's simplify the manual proof we wrote for rangelength. the calc statement is helpful when we write a proof in the first place, and it also gives a readable presentation of the proof. but once we have figured out a proof, we sometimes choose to shorten it, perhaps because in retrospect we found we were too punctilious even for our own taste.\n\nthe calc statement we wrote above really just has one non-trivial step, the application of the induction hypothesis. in fact, we can replace the entire calc statement with just that one call:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsince the “then” branch of the if is empty, we can of course also negate the guard, swap the branches, and omit the empty else:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 0.5. strong induction\n\ncan we do even better than that one if statement? well, that depends on what you think is better, but there is a way in dafny to eliminate this branch. we can do that by replacing the entire if statement and its one call to rangelength by a forall statement that calls rangelength for a whole bunch of values.\n\nto get this started, suppose we tried using the following as the body of rangelength:\n\nforall start', len' {\n  rangelength(start', len');\n}\n\n\n1\n2\n3\n\n\nthis rather cavalier statement calls rangelength for all possible values of start' and len'. well, this doesn't work, because many of those recursive calls won't terminate. we need to restrict ourselves to values of start' and len' that decrease the termination metric.\n\nso, let's try this:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  forall start', len' | 0 <= len' < len {\n    rangelength(start', len');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthis calls rangelength for all values of start' and all values of len' smaller than len. that is, this forall statement makes an infinite number of recursive calls to rangelength, all at once. each of these infinitely many calls terminates, because the value of len' is smaller than len.4\n\nthis version of rangelength verifies. the mathematical name for calling an induction hypothesis for all smaller values like this is called strong induction.\n\nwell, values of start' can be larger than start (in that, it is crucial for the proof that start + 1 is one of those values). so, you may opine that the forall statement above does more than just strong induction. indeed, some may argue that this forall statement also performs what is called generalizing the lemma to all values of start'. but if you consider the ordering that determines “smaller” to be one that just compares the len component, then start', len' is indeed smaller than start, len, as long as len' is smaller than len. however you want to think about it or whatever mathematical name you want to give to it, dafny accepts the forall statement above as a proof. in programming terms, all we're doing is proving that each recursive call terminates, and that follows from the way we defined the termination metric by decreases len.\n\n\n# 1. automatic induction\n\nwith all that background, we are finally ready to learn what dafny does to automate induction. here's the short of it: if you remove the attribute {:induction false} (which i introduced only to disable automatic induction while we were discussing what makes a proof in the first place), then what dafny does by default is insert the forall statement we just saw. this means you can remove the manually inserted forall statement, because dafny will add it for you. in other words, dafny accepts the following as a proof of the lemma:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nshort and sweet.\n\n\n# 1.0. the detailed recipe for automatic induction\n\ndafny automated induction all comes down to the maneuver of automatically generating one forall statement at the beginning of every lemma. this does not solve all problems of induction, but i'm amazed at how many simple problems of induction that this simple maneuver does solve. let's look at the ingredients that go into the maneuver.\n\nfor a lemma l with formal arguments args, precondition p(args),5 and termination metric t(args), dafny automatic induction inserts the following forall statement at the beginning of the body of l:\n\nforall aa' | p(args') && t(args') < t(args) {\n  l(args');\n}\n\n\n1\n2\n3\n\n\nwhere\n\n * aa is a subset of the formal parameters args,\n * aa' is aa, suitably renamed to have fresh names,\n * args' denotes args but with every variable in aa replaced by the corresponding one in aa', and\n * < denotes dafny's well-founded lexicographic order.\n\nthe subset aa of the variables args can be customized by placing the attribute {:induction aa} on the lemma. if no such attribute is given, then dafny picks aa heuristically. dafny reports what it picks in a tool tip that the dafny ides show when you hover over the name of the lemma.\n\nwe might think of {:induction x} as saying we're \"doing induction over x“, but be a little bit careful with this. i find that common mathematical usage of the phrase ”do induction over …\" conflates several ideas. so, to be precise about it, what the {:induction aa} attribute specifies is which parameters are to be universally quantified over.\n\nthere is one more subtlety that is easy to forget: the decreases clause matters. when we write a lemma like rangelength, we might expect the proof to be simple enough that dafny's automatic induction will take care of it automatically. if so, we might just write down the type signature of the lemma and the (pre- and) postcondition. this often is all that's needed, but in the case of rangelength, it is also necessary to supply a decreases clause. usually, if the main function that the lemma is about (range in the running example) needs an explicit decreases clause, then the lemma does, too. alas, this can be easy to forget.\n\nnext, let's consider some ways of customizing the automatic induction for rangelength.\n\n\n# 1.1. example: missing decreases\n\nwhat happens if you do forget the decreases clause of rangelength? the lemma then looks like this:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nfor this lemma, dafny comes up with {:induction start, len} and decreases start, len.6 that means the implicit forall statement that the induction maneuver inserts is\n\nforall start': nat, len': nat |\n  start' < start || (start' == start && len' < len)\n{\n  rangelength(start', len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nas we explored in the previous section, this does not prove the lemma, because the crucial call rangelength(start+1, len-1) is not among the calls performed.\n\n\n# 1.2. example: quantifying over just len\n\nwhat if we manually override the quantified variables and list only len?\n\nlemma {:induction len} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nwe then get the following forall statement:\n\nforall len': nat |\n  start < start || (start == start && len' < len)\n{\n  rangelength(start, len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nnotice how there is no start' in this example. rather, the original formal parameter start is used in the formulaic range expression\n\np(start, len') && t(start, len') < t(start, len)\n\n\n1\n\n\nthere is no precondition in the example, so the p part is true. because we didn't supply an explicit decreases clause, dafny generates decreases start, len. therefore, the range expression that restricts the universally quantified variables (that is, len') is\n\nstart < start || (start == start && len' < len)\n\n\n1\n\n\nwhich simplifies to len' < len.\n\nagain, since the recursive calls entailed by this forall statement does not include the crucial call rangelength(start+1, len-1), dafny will report an error that the lemma's postcondition might not hold.\n\nthe result would be the same even if we supplied a decreases clause manually. that would still restrict len' to values that are smaller than len, which is fine, but the problem is still that the inductive hypothesis is only considered for the given value of start.\n\n# acknowledgments\n\ni'm grateful to sean mclaughlin, who provided both the running example and the question about automatic induction for rangelength.\n\n\n# references\n\n[0]k. rustan m. leino. automating induction with an smt solver. in viktor kuncak and andrey rybalchenko, editors, verification, model checking, and abstract interpretation — 13th international conference, vmcai 2012, volume 7148 of lecture notes in computer science, pages 315–331. springer, january 2012. 🔎\n\n[1]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments — 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170–190. springer, 2014. 🔎\n\n----------------------------------------\n\n0.i'm simplifying a little bit. dafny's well-founded order on integers is actually “integer less-than, with no more than one negative value”. so, a chain is allowed to dip down below 0, but once the chain includes a negative number, it must stop. this extension is a well-founded order, because there is still no way to make an infinite descending chain. ↩\n\n1.i'm simplifying a little bit. dafny's fixed well-founded order also orders some values across different types. ↩\n\n2.this is a slight simplification. dafny's heuristic for coming up with a decreases clause for a recursive function/method/lemma omits parameters whose types aren't helpful in letting you prove termination. for example, a parameter whose type is a type parameter is omitted from automatically generated decreases clauses. ↩\n\n3.i was fast and loose in the previous example, because i should have also pointed out that 10*len + 18 is non-negative.) ↩\n\n4.“an infinite number of calls?!”, you say to yourself. “how is that termination, even if each such call terminates?” i won't delve into that here, but i will at least point out that we're calling a lemma, not a compiled method. so, you don't need to worry about having enough computational resources to make an infinite number of calls. ↩\n\n5.a precondition of a lemma is declared using the keyword requires. it is like an antecedent of the lemma, and it is checked to hold at every call site. the running example does not include a precondition. a simple way to include one would be to change the type of start from nat to int and to add requires 0 <= start. ↩\n\n6.i mentioned that tool tips in the dafny ides show you what decreases clause dafny picks. as of this writing, such a tool tip is shown only when the body of the function/method/lemma includes an explicit recursive call. in particular, if the body of the lemma is empty, there is no tool tip that shows you what decreases clause is generated. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Calling Lemmas Automatically",frontmatter:{title:"Calling Lemmas Automatically",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/30441e/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/05.Calling%20Lemmas%20Automatically.html",relativePath:"80.语言/30.publication-lecture/05.Calling Lemmas Automatically.md",key:"v-4d8171d5",path:"/pages/30441e/",headers:[{level:3,title:"Uber Lemmas",slug:"uber-lemmas",normalizedTitle:"uber lemmas",charIndex:2196},{level:3,title:"Aggregate Lemma Invocations",slug:"aggregate-lemma-invocations",normalizedTitle:"aggregate lemma invocations",charIndex:2705},{level:3,title:"Function Postconditions",slug:"function-postconditions",normalizedTitle:"function postconditions",charIndex:3843},{level:3,title:"Basic/premium function pairs",slug:"basic-premium-function-pairs",normalizedTitle:"basic/premium function pairs",charIndex:5460},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:6928}],headersStr:"Uber Lemmas Aggregate Lemma Invocations Function Postconditions Basic/premium function pairs Acknowledgments",content:"Dafny Power User: Calling Lemmas Automatically\n\nK. Rustan M. Leino\n\nManuscript KRML 265, 8 June 2019\n\nAbstract. Some properties of a function are more useful than others. If you have proved such a property as a lemma, you may want to have it be applied automatically. This note considers ways to achieve something like that in Dafny.\n\nOn https://github.com/Microsoft/dafny/issues/231, a Dafny user asked:\n\n> Is there a way in Dafny to mark a lemma as “automatic” and add it to the knowledge base of z3 ?\n> \n> For student homeworks, we often stumble on specifications that are just a bit too complex for Dafny to prove, and require some hand-crafted asserts or lemmas.\n> \n> It would be nice if we could define those lemmas to augment boogie/z3 search space with domain-specific knowledge, avoiding the need to explain to our students how lemmas work, and the tedious and difficult task to find and use the required lemmas.\n> \n> Is something like an {:auto} annotation feasible ? Can we augment the .bpl axiomatization ?\n\nHere is an example that shows the issue. Suppose you declare a function and prove a property about it:\n\nfunction FibFib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else FibFib(n-2) + FibFib(n-1)\n}\n\nlemma FibFibIsEven(n: nat)\n  ensures FibFib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nFor your application, it may be crucial that FibFib always returns an even number. Using the declarations above, you would then have to call the lemma FibFibIsEven every time you use the function. This is tedious. Is there some way to instruct Dafny to automatically apply FibFibIsEven whenever it's needed?\n\nNo, there's no such feature in Dafny. (VCC had such a feature, for example.) In some situations, such automation may work well. In other situations, it may cause the lemma to be invoked too many times (say, an infinite number of times), which is problematic.\n\nIf you have an interest in trying out some kind of {:autoLemma} feature, please feel free to play around with the open Dafny sources. In the present state, I have four suggestions that you may try, and which may alleviate some of the tedium you're experiencing.\n\n\n# Uber Lemmas\n\nOne suggestion is to create an “uber lemma” that collects the statements of several other lemmas. For example, if you already have:\n\nlemma Lemma0(x: X) ensures P0(x) { ... }\nlemma Lemma1(x: X) ensures P1(x) { ... }\nlemma Lemma2(x: X) ensures P2(x) { ... }\n\n\n1\n2\n3\n\n\nthen you can combine them into one:\n\nlemma Everything(x: X)\n  ensures P0(x) && P1(x) && P2(x)\n{\n  Lemma0(x: X);\n  Lemma1(x: X);\n  Lemma2(x: X);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThis lets you get all 3 properties by calling a single lemma.\n\n\n# Aggregate Lemma Invocations\n\nAnother suggestion is to invoke a lemma on many values at the same time. Given:\n\nlemma LemmaForOneX(x: X) ensures P(x) { ... }\n\n\n1\n\n\nyou can invoke this lemma for all values of X simultaneously:\n\nforall x {\n  LemmaForOneX(x);\n}\n\n\n1\n2\n3\n\n\nBy placing this forall statement at the beginning of some code you're trying to prove, you have in effect called it for every imaginable value of X. You can of course also tuck this statement into a lemma of its own and then call this one lemma:\n\nlemma LemmaForEveryX()\n  ensures forall x :: P(x)\n{\n  forall x {\n    LemmaForOneX(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIn many cases, this will work fine. In other cases, the verifier may not realize that you have called the lemma on the value that needs the individual lemma, so you may still need to invoke LemmaForOneX manually. Also, Dafny takes measure to avoid “matching loops” in the quantifiers generated for the lemma calls above (“matching loops” are what can cause an infinite number of uses of the lemmas). However, the mechanism is not perfect, so this added automation may in some cases cause degraded performance.\n\n\n# Function Postconditions\n\nA third suggestion is to declare some of the most useful properties of a function in the postcondition of the function, rather than in a separate lemma. For example, instead of:\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nyou can declare:\n\nfunction F(x: X): int\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nTo obtain the property stated by the lemma, you must call the lemma. In contrast, any property stated in the postcondition of a function is automatically applied every time you call the function.\n\nAs I've mentioned, more information can help the verifier do more things automatically, but too much information can also overwhelm and confuse the verifier. Therefore, my suggestion is to use function postconditions only for those properties that you think every user of the function will need. Properties needed more rarely are better off declared in lemmas that have to be manually invoked.\n\nAlso, there are limits to what you can write in a function postcondition. In particular, what you write must “terminate”. In practice, this means you may have problems mentioning the function applied to other arguments in the postcondition. For example,\n\npredicate R(x: X, y: X)\n  // commutativity:\n  ensures R(x, y) <==> R(y, x)\n  // transitivity:\n  ensures forall z :: R(x, z) && R(z, y) ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nis not admitted, because there are self-referential non-terminating (that is, infinitely recursive) calls in the postcondition. Thus, properties like commutativity and transitivity always need to be stated as separate lemmas.\n\n\n# Basic/premium function pairs\n\nA function postcondition conveniently provides all users of a function with the property that it states, alleviating the need to call the lemma explicitly. If the property is not interesting for all users, a fourth suggestion is to declare two functions. The basic function gives the actual definition of the function and an accompanying lemma states the property about it. The premium function calls the basic function and states the property as its postcondition, which is proved by a call to the lemma.\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\nfunction F_premium(x: X): int\n  ensures F_premium(x) % 2 == 0\n{ AboutF(x); F(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nUsers can now choose: a call to F_premium obtains both the value of the function and the proved property, whereas a call to F obtains only the value. If you expect the premium version to be more popular than the basic version, you can of course rename F and F_premium to F_basic and F, respectively.\n\nOther than the postcondition, the two functions are synonyms. Semantically. A note of caution is that the mechanism the verifier uses as a guide to its use of quantifiers is syntactic. Therefore, which of the two functions you use in the body of a quantifier can make a difference in when the verifier decides to instantiate the quantifier. For this reason, I suggest you use the basic version of the function inside any quantifier you write.\n\n# Acknowledgments\n\nBryan Parno provided the fourth suggestion of wrapping a basic version of a function and its lemma into a premium version of the function.",normalizedContent:"dafny power user: calling lemmas automatically\n\nk. rustan m. leino\n\nmanuscript krml 265, 8 june 2019\n\nabstract. some properties of a function are more useful than others. if you have proved such a property as a lemma, you may want to have it be applied automatically. this note considers ways to achieve something like that in dafny.\n\non https://github.com/microsoft/dafny/issues/231, a dafny user asked:\n\n> is there a way in dafny to mark a lemma as “automatic” and add it to the knowledge base of z3 ?\n> \n> for student homeworks, we often stumble on specifications that are just a bit too complex for dafny to prove, and require some hand-crafted asserts or lemmas.\n> \n> it would be nice if we could define those lemmas to augment boogie/z3 search space with domain-specific knowledge, avoiding the need to explain to our students how lemmas work, and the tedious and difficult task to find and use the required lemmas.\n> \n> is something like an {:auto} annotation feasible ? can we augment the .bpl axiomatization ?\n\nhere is an example that shows the issue. suppose you declare a function and prove a property about it:\n\nfunction fibfib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else fibfib(n-2) + fibfib(n-1)\n}\n\nlemma fibfibiseven(n: nat)\n  ensures fibfib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nfor your application, it may be crucial that fibfib always returns an even number. using the declarations above, you would then have to call the lemma fibfibiseven every time you use the function. this is tedious. is there some way to instruct dafny to automatically apply fibfibiseven whenever it's needed?\n\nno, there's no such feature in dafny. (vcc had such a feature, for example.) in some situations, such automation may work well. in other situations, it may cause the lemma to be invoked too many times (say, an infinite number of times), which is problematic.\n\nif you have an interest in trying out some kind of {:autolemma} feature, please feel free to play around with the open dafny sources. in the present state, i have four suggestions that you may try, and which may alleviate some of the tedium you're experiencing.\n\n\n# uber lemmas\n\none suggestion is to create an “uber lemma” that collects the statements of several other lemmas. for example, if you already have:\n\nlemma lemma0(x: x) ensures p0(x) { ... }\nlemma lemma1(x: x) ensures p1(x) { ... }\nlemma lemma2(x: x) ensures p2(x) { ... }\n\n\n1\n2\n3\n\n\nthen you can combine them into one:\n\nlemma everything(x: x)\n  ensures p0(x) && p1(x) && p2(x)\n{\n  lemma0(x: x);\n  lemma1(x: x);\n  lemma2(x: x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthis lets you get all 3 properties by calling a single lemma.\n\n\n# aggregate lemma invocations\n\nanother suggestion is to invoke a lemma on many values at the same time. given:\n\nlemma lemmaforonex(x: x) ensures p(x) { ... }\n\n\n1\n\n\nyou can invoke this lemma for all values of x simultaneously:\n\nforall x {\n  lemmaforonex(x);\n}\n\n\n1\n2\n3\n\n\nby placing this forall statement at the beginning of some code you're trying to prove, you have in effect called it for every imaginable value of x. you can of course also tuck this statement into a lemma of its own and then call this one lemma:\n\nlemma lemmaforeveryx()\n  ensures forall x :: p(x)\n{\n  forall x {\n    lemmaforonex(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nin many cases, this will work fine. in other cases, the verifier may not realize that you have called the lemma on the value that needs the individual lemma, so you may still need to invoke lemmaforonex manually. also, dafny takes measure to avoid “matching loops” in the quantifiers generated for the lemma calls above (“matching loops” are what can cause an infinite number of uses of the lemmas). however, the mechanism is not perfect, so this added automation may in some cases cause degraded performance.\n\n\n# function postconditions\n\na third suggestion is to declare some of the most useful properties of a function in the postcondition of the function, rather than in a separate lemma. for example, instead of:\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nyou can declare:\n\nfunction f(x: x): int\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nto obtain the property stated by the lemma, you must call the lemma. in contrast, any property stated in the postcondition of a function is automatically applied every time you call the function.\n\nas i've mentioned, more information can help the verifier do more things automatically, but too much information can also overwhelm and confuse the verifier. therefore, my suggestion is to use function postconditions only for those properties that you think every user of the function will need. properties needed more rarely are better off declared in lemmas that have to be manually invoked.\n\nalso, there are limits to what you can write in a function postcondition. in particular, what you write must “terminate”. in practice, this means you may have problems mentioning the function applied to other arguments in the postcondition. for example,\n\npredicate r(x: x, y: x)\n  // commutativity:\n  ensures r(x, y) <==> r(y, x)\n  // transitivity:\n  ensures forall z :: r(x, z) && r(z, y) ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nis not admitted, because there are self-referential non-terminating (that is, infinitely recursive) calls in the postcondition. thus, properties like commutativity and transitivity always need to be stated as separate lemmas.\n\n\n# basic/premium function pairs\n\na function postcondition conveniently provides all users of a function with the property that it states, alleviating the need to call the lemma explicitly. if the property is not interesting for all users, a fourth suggestion is to declare two functions. the basic function gives the actual definition of the function and an accompanying lemma states the property about it. the premium function calls the basic function and states the property as its postcondition, which is proved by a call to the lemma.\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\nfunction f_premium(x: x): int\n  ensures f_premium(x) % 2 == 0\n{ aboutf(x); f(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nusers can now choose: a call to f_premium obtains both the value of the function and the proved property, whereas a call to f obtains only the value. if you expect the premium version to be more popular than the basic version, you can of course rename f and f_premium to f_basic and f, respectively.\n\nother than the postcondition, the two functions are synonyms. semantically. a note of caution is that the mechanism the verifier uses as a guide to its use of quantifiers is syntactic. therefore, which of the two functions you use in the body of a quantifier can make a difference in when the verifier decides to instantiate the quantifier. for this reason, i suggest you use the basic version of the function inside any quantifier you write.\n\n# acknowledgments\n\nbryan parno provided the fourth suggestion of wrapping a basic version of a function and its lemma into a premium version of the function.",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Case study of definitions, proofs, algorithm correctness GCD",frontmatter:{title:"Case study of definitions, proofs, algorithm correctness GCD",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/746026/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/10.Case%20study%20of%20definitions,%20proofs,%20algorithm%20correctness%20GCD.html",relativePath:"80.语言/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md",key:"v-0c0b63a6",path:"/pages/746026/",headers:[{level:2,title:"0. Problem description",slug:"_0-problem-description",normalizedTitle:"0. problem description",charIndex:507},{level:2,title:"1. Positive integers",slug:"_1-positive-integers",normalizedTitle:"1. positive integers",charIndex:1254},{level:2,title:"2. Factors",slug:"_2-factors",normalizedTitle:"2. factors",charIndex:2184},{level:2,title:"3. Max of a set",slug:"_3-max-of-a-set",normalizedTitle:"3. max of a set",charIndex:4838},{level:2,title:"4. GCD",slug:"_4-gcd",normalizedTitle:"4. gcd",charIndex:8306},{level:2,title:"5. Properties of GCD",slug:"_5-properties-of-gcd",normalizedTitle:"5. properties of gcd",charIndex:9854},{level:2,title:"6. Euclid's algorithm",slug:"_6-euclid-s-algorithm",normalizedTitle:"6. euclid's algorithm",charIndex:12775},{level:2,title:"7. GCD subtract property",slug:"_7-gcd-subtract-property",normalizedTitle:"7. gcd subtract property",charIndex:15740},{level:2,title:"8. More symmetry",slug:"_8-more-symmetry",normalizedTitle:"8. more symmetry",charIndex:17850},{level:2,title:"9. Main",slug:"_9-main",normalizedTitle:"9. main",charIndex:19872},{level:2,title:"10. Conclusions",slug:"_10-conclusions",normalizedTitle:"10. conclusions",charIndex:20470},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:21343},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:21436}],headersStr:"0. Problem description 1. Positive integers 2. Factors 3. Max of a set 4. GCD 5. Properties of GCD 6. Euclid's algorithm 7. GCD subtract property 8. More symmetry 9. Main 10. Conclusions Acknowledgments References",content:"Dafny Power User: Case study of definitions, proofs, algorithm correctness: GCD\n\nK. Rustan M. Leino\n\nManuscript KRML 279, 22 June 2021\n\nAbstract. The purpose of this note is to show an example development of a program, introducing definitions that support the specification of the program, stating and proving lemmas about those definitions, and using the lemmas in proving the correctness of the program. Euclid's subtractive algorithm for computing the greatest common divisor is used as the example.\n\n\n# 0. Problem description\n\nLet's specify and verify an algorithm to compute the greatest common divisor (GCD) of two numbers. For the specification, we will introduce a function whose definition is intended to be “obviously correct”. We won't use that function to compute the GCD, because the “obviously correct” definition would give really inefficient code if compiled directly. Instead, we'll use Euclid's algorithm for computing the value that the “obviously correct” function defines. We'll prove that the algorithm does compute that value.\n\nIn essence, we'll have\n\nfunction Gcd(x: pos, y: pos): pos\n\nmethod EuclidGcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nwhere pos denotes the type of positive integers.\n\n\n# 1. Positive integers\n\nEverything we do will concern (strictly) positive integers. Dafny builds in a type for natural numbers (that is, non-negative integers), but not positive integers. We can define these using a subset type in Dafny:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\nDafny wants to know if this type has any inhabitants, and it doesn't figure that out by itself. This doesn't matter for our example, but we do need to address the error we're getting. To do that, we supply a witness clause:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nIf we really didn't care to exhibit a witness that shows the type to be nonempty, we could have written witness *, which causes Dafny to treat the type pos as possibly empty. For our example, you can do either, but since it's easy to supply an actual witness, we do that.\n\nIn the sequel, I will just say number when I mean positive integer.\n\n\n# 2. Factors\n\nThe divisors of a number are its factors. We define a predicate that says what it means for a number p to be a factor of a number x:\n\npredicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\nIn words, p is a factor of x iff there is a multiplicand q such that x is the product p * q.\n\nTo talk about all the factors of a number, we introduce a function Factors that we define using a set comprehension. A straightforward definition would be:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | IsFactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\nA set in Dafny denotes a finite set (for possibly infinite sets, use iset). In this case, Dafny doesn't immediately see that the comprehension would generate a finite set. Luckily, it is simple for us to add another conjunct to the comprehension that lets Dafny see that the set is finite:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\n\n\n1\n2\n3\n\n\nIn adding this conjunct, there's a risk we're making a mistake, because perhaps the new set doesn't include all the factors we'd like. Our conjunct p <= x certainly looks innocent enough, but why not prove that adding it does not accidentally leave out any factors. We can do that by proving that this set has the same elements as the possibly infinite set:\n\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nThe proof of a lemma is given in the lemma's body (that is, between the pair of curly braces that follow the lemma's specification). In this case, the proof is empty, because Dafny proves the lemma automatically without any further help from us.\n\nBefore leaving the definition of factors, let's state and prove two simple lemmas. These lemmas act as sanity checks on our definitions, and they will also be helpful later in our development.\n\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nTo prove that a number n (here, 1 or x) is in the set Factors(x), we need to establish that n satisfies the condition in the set comprehension (in the body of Factors(x)). The conjunct n <= x is proved automatically, but the conjunct IsFactor(n, x) is not. By the definition of IsFactor, we need to prove the existence of a multiplicand q for which n * q == x. Such a proof typically involves demonstrating a witness, which is what the assert statements in the two lemmas above do. From those assertions, the verifier completes the proofs of the lemmas.\n\n\n# 3. Max of a set\n\nTo talk about the greatest common divisor, we need a function that picks out the largest number in a set. A somewhat declarative way to do that is to use the such-that construct. In particular, for a set s, the let-such-that expression\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nsays to bind x to a value satisfying the condition x in s && forall y :: y in s ==> y <= x, and then return the value of the expression x. The condition says that x is in the set s, and that, among all the numbers in s, x is the largest.\n\nUse of a such-that construct comes with a proof obligation that a value satisfying the given condition exists. If we require s to be nonempty, then the x in s condition is easily satisfied, but it takes more work to convince the verifier that a value for x satisfies the quantifier. We'll define a lemma for that purpose. We'll name the lemma MaxExists and then we can write our function Max as follows:\n\nfunction Max(s: set<pos>): pos\n  requires s != {}\n{\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafny uses the lemma invocation MaxExists(s) in establishing the well-formedness of the subsequent expression. Note, by the way, that Max (and lemma MaxExists, too) has a precondition s != {} (keyword requires). This means that the function (and the lemma, too) can only be called for a nonempty set.\n\nAlright, so then how do we prove MaxExists? The most straightforward way to prove the existence of such an x is to compute an x satisfying the desired properties. We'll introduce another function for computing the max, call it FindMax, and use it in the proof of the MaxExists lemma. Function FindMax will be implemented recursively.\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := FindMax(s);\n}\n \nfunction FindMax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= FindMax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nAren't we going in circles now? Yes, in some ways we're making life more difficult than necessary. If we have FindMax, we don't need Max, and then we also don't need lemma MaxExists. Indeed, we could have written and used just FindMax and never introduced Max or MaxExists. But for this example, I wanted the primary definitions to be as clear as possible without concern for how things are computed. In that sense, the body of Max is more declarative than the body we are about to write for FindMax.\n\nHere is the full definition of FindMax:\n\nfunction FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := FindMax(s');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWhen a function postcondition wants to mention the result value of the function, you can just use the function itself, with the arguments given: FindMax(s). I did this when I first introduced FindMax above. In the full definition, I show an alternative way of doing this, which is to introduce a name for the result value: max. That name is usable only in the postcondition of the function. Many times, introducing such a name for the result leads to a shorter specification.\n\n\n# 4. GCD\n\nWith the functions we defined, we're now ready to define GCD. Take the factors of x and the factors of y, intersect them to get their common factors, and then take the maximum thereof:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  Max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nFor this simple definition, the verifier reports a precondition violation, because it's unable to prove that common satisfies the precondition of Max. We know that common is nonempty, because we know that 1 is a common factor of any two numbers x and y. To bring that information to the verifier's attention, we write an assertion:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common;  // error: assertion violation\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nAlas, the verifier is not able to prove this assertion. But we can see that the presence of the assertion is enough to eliminate the precondition violation. So, we now focus on proving the assertion. This is where we use the FactorsContains1 lemma we introduced earlier. Two calls to that lemma will prove the assertion, which is best captured in the program text by changing the assert to an assert by and giving the proof of the assertion in the by block:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThat does it! We have now given a well-formed definition of Gcd.\n\n\n# 5. Properties of GCD\n\nWe'll prove three properties of our Gcd function—call them sanity checks, if you will. (We'll need a fourth property as well, but I'll introduce it later.)\n\nAs a first sanity check, we expect Gcd(x, y) to return a number that is a factor of both x and y. Furthermore, among all the numbers that are factors of both x and y, what Gcd(x, y) returns should be the largest.\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nThe first two postconditions of this lemma are proved automatically, but not the third. How do we go about proving that a universal quantifier (that is, a forall expression) holds? We use Dafny's forall statement. When used in a proof, the forall statement corresponds to the “universal introduction” rule in logic. This is the rule that says \"if you want to prove forall x :: P(x), then all you need to do is pick an arbitrary x and prove P(x) for that x.\n\nWe introduce the forall statement like this:\n\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n\n\n1\n2\n\n\nTo prove it, we only need to bring up the fact that p, which is a factor of both x and y, is in the intersection of factors of x and y. The verifier is then able to complete the proof.\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe Dafny verifier often needs help with properties like this. To prove them, just write them as an assertion. In other words, the verifier knows this property about set intersection, but it isn't creative enough the bring that property into the proof. By asserting the property, we're asking the verifier to confirm the property (which it's able to do) and then to use that property in the rest of the proof (which in this case completes the proof).\n\nAs a second sanity check, we prove that Gcd is symmetric.\n\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nThe proof comes down to the fact that set intersection is symmetric, which we bring to the verifier's attention by writing it as a lemma.\n\nAs a third sanity check, we prove that Gcd is idempotent. That is, if you give it the same argument twice, it will return that argument.\n\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThe proof of this property comes down to the fact that set intersection is idempotent, as well as the property that a number is one of its own factors.\n\n\n# 6. Euclid's algorithm\n\nEuclid's subtractive algorithm for finding the GCD of two numbers is to repeatedly subtract the smaller of the numbers from the larger until they are both equal. Each such subtraction preserves the GCD—an invariant that we will need to prove—and the GCD of two equal numbers is that number—which we established by lemma GcdIdempotent above.\n\nThe algorithm, with the loop invariant and idempotence lemma, thus looks like this:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis method uses a while-case loop. (If you're familiar with Dijkstra's guarded commands [1], this is the do-od loop.) Each iteration of this loop chooses one of the cases to execute. The case chosen must be one whose guard condition evaluates to true (and if the guards of several cases evaluate to true, the loop chooses arbitrarily between those cases) . If no such guard condition evaluates to true, then the loop stops iterating. The loop in EuclidGcd could of course be an ordinary while x != y loop, but the symmetry of the two cases afforded by the while-case loop makes it aesthetically pleasing.\n\nIn addition to a loop invariant, the loop also declares a termination metric (keyword decreases). Proving that the loop terminates comes down to proving that each iteration makes the value of the termination metric decrease (in Dafny's built-in well-founded order on integers).\n\nThe EuclidGcd method above does not verify, because the verifier is unable to prove that each iteration maintains the loop invariant. For this, we need the fourth property of GCD that I alluded to above:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n\n\n1\n2\n3\n\n\nUsing this lemma and the symmetry of GCD, we can complete the proof of Gcd:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nThis version adds a call to GcdSubtract in the first branch of the loop. In the second branch of the loop, the proof calculation uses equality-preserving steps to transform the expression Gcd(x, y) into Gcd(x - y, y). The hints given in the steps appeal to the GcdSubtract and GcdSymmetric lemmas.\n\n\n# 7. GCD subtract property\n\nThe proof of GcdSubtract is more involved than any of the other definitions and lemmas in this case study.\n\nThe proof starts by introducing a name for Gcd(x, y):\n\n  var p := Gcd(x, y);\n\n\n1\n\n\nWe know from the definition of Gcd that p is a factor of both x and y, and we can prove that p is also a factor of y - x:\n\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nTo prove IsFactor(p, y - x), we introduce names a and b for the multiplicands that the definition of IsFactor tells us exist (since p is a factor of both x and y). A simple calculation using basic arithmetic steps then gives us that p can be multiplied another number (namely, b - a) to get y - x.\n\nSince p is a factor of both x and y - x, we have that it's in the common factors of x and y - x. We write two lines to make sure the verifier is on board with this property, phrased in terms of set intersection:\n\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\nLastly, we need to show that p is the largest such common factor. We state this property using a forall statement:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nTo prove this property, we fill in the body of the forall statement. For q, which denotes an arbitrary number in the set common, we give names to the multiplicands that yield the products x and y - x, respectively:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nUsing simple arithmetic steps, we can use a proof calculation to establish that q is also a factor of y:\n\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nSo, since q is a factor of both x and y, the definition of Gcd(x, y) tells us q <= Gcd(x, y). By giving yet another hint about set intersection:\n\n    assert q in Factors(x) * Factors(y);\n  }\n\n\n1\n2\n\n\nthe verifier completes the proof.\n\n\n# 8. More symmetry\n\nWhile we now have a full proof of the GCD algorithm, your aesthetic sense may be bothered by the asymmetry in how we supplied the proofs in the two cases of the loop. Since the while-case loop affords us a symmetric rendition of the two cases, it would be nice if we could make the proofs of the two cases more similar as well.\n\nThere are several ways we can improve on this situation. One is to refactor the proof calculation of the second case into its own lemma. Then, then each case would have one line of proof.\n\nJust for fun, let me describe another “trick” to make the two cases (not entirely symmetric, but at least) more similar. The trick is to make the (already asymmetric) GcdSubtract lemma also swap the arguments to Gcd. We rewrite it into:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x)\n{\n  GcdSymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that the left-hand side of the postcondition is now Gcd(y, x), not Gcd(x, y) as it had been in our first version of this lemma. The only change required for the proof is to appeal to the symmetry of Gcd, which we can do by one lemma call immediately inside the body of the lemma. This gives us a proof of our reformulated GcdSubtract lemma.\n\nWith this reformulation, we can simplify the second case of EuclidGcd, at the expense of making the first case more complicated. Essentially, we're moving one lemma call from the second case to the first, so instead of having 1 and 3 lemma calls in the two respective cases, we'll have 2 and 2.\n\n    case x < y =>\n      GcdSubtract(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIt's not entirely symmetric, but perhaps you still like it. Or perhaps you'll remember this trick for another situation where the shoe fits perfectly. If nothing else, you can stick with the first complete proof we developed above.\n\n\n# 9. Main\n\nIf the proof itself doesn't satisfy you and still want to see the algorithm in action, you can write a Main method and compile and run the program. (A simple way of doing that from the command line is to use the /compile:3 option with the dafny tool. It will verify and then run the program.)\n\nHere is a sample Main:\n\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\n\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 10. Conclusions\n\nThis case study shows how to define a domain of interest (here, factors of numbers, leading up to the definition of GCD), state and prove some lemmas about those definitions, and then use these in the proof of a small program.\n\nThe program, including all lemmas and other proof obligations associated with the definitions, takes the Dafny verifier less than 3 seconds to verify. You can find the entire program in the Dafny test suite [3].\n\nEuclid's GCD algorithm is a familiar textbook example. It's proved in different forms in various verifiers. For example, the TLA+ tutorial uses this program as an example [0]. It assumes the mathematical properties of GCD that we proved here. The gallery of Why3 programs contains a version of Euclid's GCD algorithm that uses modulo instead of subtraction with each step, which results in fewer iterations [2].\n\n# Acknowledgments\n\nI thank Reto Kramer for suggesting this problem as a useful case study.\n\n\n# References\n\n[0]TLA proof system. https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html. 🔎\n\n[1]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. 🔎\n\n[2]Jean-Christophe Filliâtre and Claude Marché. Greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. 🔎\n\n[3]K. Rustan M. Leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy, June 2021. 🔎",normalizedContent:"dafny power user: case study of definitions, proofs, algorithm correctness: gcd\n\nk. rustan m. leino\n\nmanuscript krml 279, 22 june 2021\n\nabstract. the purpose of this note is to show an example development of a program, introducing definitions that support the specification of the program, stating and proving lemmas about those definitions, and using the lemmas in proving the correctness of the program. euclid's subtractive algorithm for computing the greatest common divisor is used as the example.\n\n\n# 0. problem description\n\nlet's specify and verify an algorithm to compute the greatest common divisor (gcd) of two numbers. for the specification, we will introduce a function whose definition is intended to be “obviously correct”. we won't use that function to compute the gcd, because the “obviously correct” definition would give really inefficient code if compiled directly. instead, we'll use euclid's algorithm for computing the value that the “obviously correct” function defines. we'll prove that the algorithm does compute that value.\n\nin essence, we'll have\n\nfunction gcd(x: pos, y: pos): pos\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nwhere pos denotes the type of positive integers.\n\n\n# 1. positive integers\n\neverything we do will concern (strictly) positive integers. dafny builds in a type for natural numbers (that is, non-negative integers), but not positive integers. we can define these using a subset type in dafny:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\ndafny wants to know if this type has any inhabitants, and it doesn't figure that out by itself. this doesn't matter for our example, but we do need to address the error we're getting. to do that, we supply a witness clause:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nif we really didn't care to exhibit a witness that shows the type to be nonempty, we could have written witness *, which causes dafny to treat the type pos as possibly empty. for our example, you can do either, but since it's easy to supply an actual witness, we do that.\n\nin the sequel, i will just say number when i mean positive integer.\n\n\n# 2. factors\n\nthe divisors of a number are its factors. we define a predicate that says what it means for a number p to be a factor of a number x:\n\npredicate isfactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\nin words, p is a factor of x iff there is a multiplicand q such that x is the product p * q.\n\nto talk about all the factors of a number, we introduce a function factors that we define using a set comprehension. a straightforward definition would be:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | isfactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\na set in dafny denotes a finite set (for possibly infinite sets, use iset). in this case, dafny doesn't immediately see that the comprehension would generate a finite set. luckily, it is simple for us to add another conjunct to the comprehension that lets dafny see that the set is finite:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | p <= x && isfactor(p, x)\n}\n\n\n1\n2\n3\n\n\nin adding this conjunct, there's a risk we're making a mistake, because perhaps the new set doesn't include all the factors we'd like. our conjunct p <= x certainly looks innocent enough, but why not prove that adding it does not accidentally leave out any factors. we can do that by proving that this set has the same elements as the possibly infinite set:\n\nlemma factorshasallfactors(x: pos)\n  ensures forall n :: n in factors(x) <==> n in iset p: pos | isfactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nthe proof of a lemma is given in the lemma's body (that is, between the pair of curly braces that follow the lemma's specification). in this case, the proof is empty, because dafny proves the lemma automatically without any further help from us.\n\nbefore leaving the definition of factors, let's state and prove two simple lemmas. these lemmas act as sanity checks on our definitions, and they will also be helpful later in our development.\n\nlemma factorscontains1(x: pos)\n  ensures 1 in factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma factorscontainsself(x: pos)\n  ensures x in factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nto prove that a number n (here, 1 or x) is in the set factors(x), we need to establish that n satisfies the condition in the set comprehension (in the body of factors(x)). the conjunct n <= x is proved automatically, but the conjunct isfactor(n, x) is not. by the definition of isfactor, we need to prove the existence of a multiplicand q for which n * q == x. such a proof typically involves demonstrating a witness, which is what the assert statements in the two lemmas above do. from those assertions, the verifier completes the proofs of the lemmas.\n\n\n# 3. max of a set\n\nto talk about the greatest common divisor, we need a function that picks out the largest number in a set. a somewhat declarative way to do that is to use the such-that construct. in particular, for a set s, the let-such-that expression\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nsays to bind x to a value satisfying the condition x in s && forall y :: y in s ==> y <= x, and then return the value of the expression x. the condition says that x is in the set s, and that, among all the numbers in s, x is the largest.\n\nuse of a such-that construct comes with a proof obligation that a value satisfying the given condition exists. if we require s to be nonempty, then the x in s condition is easily satisfied, but it takes more work to convince the verifier that a value for x satisfies the quantifier. we'll define a lemma for that purpose. we'll name the lemma maxexists and then we can write our function max as follows:\n\nfunction max(s: set<pos>): pos\n  requires s != {}\n{\n  maxexists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafny uses the lemma invocation maxexists(s) in establishing the well-formedness of the subsequent expression. note, by the way, that max (and lemma maxexists, too) has a precondition s != {} (keyword requires). this means that the function (and the lemma, too) can only be called for a nonempty set.\n\nalright, so then how do we prove maxexists? the most straightforward way to prove the existence of such an x is to compute an x satisfying the desired properties. we'll introduce another function for computing the max, call it findmax, and use it in the proof of the maxexists lemma. function findmax will be implemented recursively.\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := findmax(s);\n}\n \nfunction findmax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= findmax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\naren't we going in circles now? yes, in some ways we're making life more difficult than necessary. if we have findmax, we don't need max, and then we also don't need lemma maxexists. indeed, we could have written and used just findmax and never introduced max or maxexists. but for this example, i wanted the primary definitions to be as clear as possible without concern for how things are computed. in that sense, the body of max is more declarative than the body we are about to write for findmax.\n\nhere is the full definition of findmax:\n\nfunction findmax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := findmax(s');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwhen a function postcondition wants to mention the result value of the function, you can just use the function itself, with the arguments given: findmax(s). i did this when i first introduced findmax above. in the full definition, i show an alternative way of doing this, which is to introduce a name for the result value: max. that name is usable only in the postcondition of the function. many times, introducing such a name for the result leads to a shorter specification.\n\n\n# 4. gcd\n\nwith the functions we defined, we're now ready to define gcd. take the factors of x and the factors of y, intersect them to get their common factors, and then take the maximum thereof:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nfor this simple definition, the verifier reports a precondition violation, because it's unable to prove that common satisfies the precondition of max. we know that common is nonempty, because we know that 1 is a common factor of any two numbers x and y. to bring that information to the verifier's attention, we write an assertion:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common;  // error: assertion violation\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nalas, the verifier is not able to prove this assertion. but we can see that the presence of the assertion is enough to eliminate the precondition violation. so, we now focus on proving the assertion. this is where we use the factorscontains1 lemma we introduced earlier. two calls to that lemma will prove the assertion, which is best captured in the program text by changing the assert to an assert by and giving the proof of the assertion in the by block:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common by {\n    factorscontains1(x);\n    factorscontains1(y);\n  }\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthat does it! we have now given a well-formed definition of gcd.\n\n\n# 5. properties of gcd\n\nwe'll prove three properties of our gcd function—call them sanity checks, if you will. (we'll need a fourth property as well, but i'll introduce it later.)\n\nas a first sanity check, we expect gcd(x, y) to return a number that is a factor of both x and y. furthermore, among all the numbers that are factors of both x and y, what gcd(x, y) returns should be the largest.\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nthe first two postconditions of this lemma are proved automatically, but not the third. how do we go about proving that a universal quantifier (that is, a forall expression) holds? we use dafny's forall statement. when used in a proof, the forall statement corresponds to the “universal introduction” rule in logic. this is the rule that says \"if you want to prove forall x :: p(x), then all you need to do is pick an arbitrary x and prove p(x) for that x.\n\nwe introduce the forall statement like this:\n\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n\n\n1\n2\n\n\nto prove it, we only need to bring up the fact that p, which is a factor of both x and y, is in the intersection of factors of x and y. the verifier is then able to complete the proof.\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n{\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n  {\n    assert p in factors(x) * factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe dafny verifier often needs help with properties like this. to prove them, just write them as an assertion. in other words, the verifier knows this property about set intersection, but it isn't creative enough the bring that property into the proof. by asserting the property, we're asking the verifier to confirm the property (which it's able to do) and then to use that property in the rest of the proof (which in this case completes the proof).\n\nas a second sanity check, we prove that gcd is symmetric.\n\nlemma gcdsymmetric(x: pos, y: pos)\n  ensures gcd(x, y) == gcd(y, x)\n{\n  assert factors(x) * factors(y) == factors(y) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nthe proof comes down to the fact that set intersection is symmetric, which we bring to the verifier's attention by writing it as a lemma.\n\nas a third sanity check, we prove that gcd is idempotent. that is, if you give it the same argument twice, it will return that argument.\n\nlemma gcdidempotent(x: pos)\n  ensures gcd(x, x) == x\n{\n  factorscontainsself(x);\n  assert x in factors(x) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthe proof of this property comes down to the fact that set intersection is idempotent, as well as the property that a number is one of its own factors.\n\n\n# 6. euclid's algorithm\n\neuclid's subtractive algorithm for finding the gcd of two numbers is to repeatedly subtract the smaller of the numbers from the larger until they are both equal. each such subtraction preserves the gcd—an invariant that we will need to prove—and the gcd of two equal numbers is that number—which we established by lemma gcdidempotent above.\n\nthe algorithm, with the loop invariant and idempotence lemma, thus looks like this:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis method uses a while-case loop. (if you're familiar with dijkstra's guarded commands [1], this is the do-od loop.) each iteration of this loop chooses one of the cases to execute. the case chosen must be one whose guard condition evaluates to true (and if the guards of several cases evaluate to true, the loop chooses arbitrarily between those cases) . if no such guard condition evaluates to true, then the loop stops iterating. the loop in euclidgcd could of course be an ordinary while x != y loop, but the symmetry of the two cases afforded by the while-case loop makes it aesthetically pleasing.\n\nin addition to a loop invariant, the loop also declares a termination metric (keyword decreases). proving that the loop terminates comes down to proving that each iteration makes the value of the termination metric decrease (in dafny's built-in well-founded order on integers).\n\nthe euclidgcd method above does not verify, because the verifier is unable to prove that each iteration maintains the loop invariant. for this, we need the fourth property of gcd that i alluded to above:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(x, y) == gcd(x, y - x)\n\n\n1\n2\n3\n\n\nusing this lemma and the symmetry of gcd, we can complete the proof of gcd:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)\n    decreases x + y\n  {\n    case x < y =>\n      gcdsubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        gcd(x, y);\n      ==  { gcdsymmetric(x, y); }\n        gcd(y, x);\n      ==  { gcdsubtract(y, x); }\n        gcd(y, x - y);\n      ==  { gcdsymmetric(y, x - y); }\n        gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nthis version adds a call to gcdsubtract in the first branch of the loop. in the second branch of the loop, the proof calculation uses equality-preserving steps to transform the expression gcd(x, y) into gcd(x - y, y). the hints given in the steps appeal to the gcdsubtract and gcdsymmetric lemmas.\n\n\n# 7. gcd subtract property\n\nthe proof of gcdsubtract is more involved than any of the other definitions and lemmas in this case study.\n\nthe proof starts by introducing a name for gcd(x, y):\n\n  var p := gcd(x, y);\n\n\n1\n\n\nwe know from the definition of gcd that p is a factor of both x and y, and we can prove that p is also a factor of y - x:\n\n  assert isfactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nto prove isfactor(p, y - x), we introduce names a and b for the multiplicands that the definition of isfactor tells us exist (since p is a factor of both x and y). a simple calculation using basic arithmetic steps then gives us that p can be multiplied another number (namely, b - a) to get y - x.\n\nsince p is a factor of both x and y - x, we have that it's in the common factors of x and y - x. we write two lines to make sure the verifier is on board with this property, phrased in terms of set intersection:\n\n  var common := factors(x) * factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\nlastly, we need to show that p is the largest such common factor. we state this property using a forall statement:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nto prove this property, we fill in the body of the forall statement. for q, which denotes an arbitrary number in the set common, we give names to the multiplicands that yield the products x and y - x, respectively:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nusing simple arithmetic steps, we can use a proof calculation to establish that q is also a factor of y:\n\n    assert isfactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nso, since q is a factor of both x and y, the definition of gcd(x, y) tells us q <= gcd(x, y). by giving yet another hint about set intersection:\n\n    assert q in factors(x) * factors(y);\n  }\n\n\n1\n2\n\n\nthe verifier completes the proof.\n\n\n# 8. more symmetry\n\nwhile we now have a full proof of the gcd algorithm, your aesthetic sense may be bothered by the asymmetry in how we supplied the proofs in the two cases of the loop. since the while-case loop affords us a symmetric rendition of the two cases, it would be nice if we could make the proofs of the two cases more similar as well.\n\nthere are several ways we can improve on this situation. one is to refactor the proof calculation of the second case into its own lemma. then, then each case would have one line of proof.\n\njust for fun, let me describe another “trick” to make the two cases (not entirely symmetric, but at least) more similar. the trick is to make the (already asymmetric) gcdsubtract lemma also swap the arguments to gcd. we rewrite it into:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(y, x) == gcd(x, y - x)\n{\n  gcdsymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that the left-hand side of the postcondition is now gcd(y, x), not gcd(x, y) as it had been in our first version of this lemma. the only change required for the proof is to appeal to the symmetry of gcd, which we can do by one lemma call immediately inside the body of the lemma. this gives us a proof of our reformulated gcdsubtract lemma.\n\nwith this reformulation, we can simplify the second case of euclidgcd, at the expense of making the first case more complicated. essentially, we're moving one lemma call from the second case to the first, so instead of having 1 and 3 lemma calls in the two respective cases, we'll have 2 and 2.\n\n    case x < y =>\n      gcdsubtract(x, y);\n      gcdsymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      gcdsymmetric(x - y, y);\n      gcdsubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nit's not entirely symmetric, but perhaps you still like it. or perhaps you'll remember this trick for another situation where the shoe fits perfectly. if nothing else, you can stick with the first complete proof we developed above.\n\n\n# 9. main\n\nif the proof itself doesn't satisfy you and still want to see the algorithm in action, you can write a main method and compile and run the program. (a simple way of doing that from the command line is to use the /compile:3 option with the dafny tool. it will verify and then run the program.)\n\nhere is a sample main:\n\nmethod main() {\n  test(15, 9);\n  test(14, 22);\n  test(371, 1);\n  test(1, 2);\n  test(1, 1);\n  test(13, 13);\n  test(60, 60);\n}\n\nmethod test(x: pos, y: pos) {\n  var gcd := euclidgcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 10. conclusions\n\nthis case study shows how to define a domain of interest (here, factors of numbers, leading up to the definition of gcd), state and prove some lemmas about those definitions, and then use these in the proof of a small program.\n\nthe program, including all lemmas and other proof obligations associated with the definitions, takes the dafny verifier less than 3 seconds to verify. you can find the entire program in the dafny test suite [3].\n\neuclid's gcd algorithm is a familiar textbook example. it's proved in different forms in various verifiers. for example, the tla+ tutorial uses this program as an example [0]. it assumes the mathematical properties of gcd that we proved here. the gallery of why3 programs contains a version of euclid's gcd algorithm that uses modulo instead of subtraction with each step, which results in fewer iterations [2].\n\n# acknowledgments\n\ni thank reto kramer for suggesting this problem as a useful case study.\n\n\n# references\n\n[0]tla proof system. https://tla.msr-inria.inria.fr/tlaps/content/documentation/tutorial/the_example.html. 🔎\n\n[1]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. 🔎\n\n[2]jean-christophe filliatre and claude marche. greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. 🔎\n\n[3]k. rustan m. leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/test/dafny4/gcd.dfy, june 2021. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Comprehensions",frontmatter:{title:"Comprehensions",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/da6921/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/15.Comprehensions.html",relativePath:"80.语言/30.publication-lecture/15.Comprehensions.md",key:"v-4470a5a9",path:"/pages/da6921/",headers:[{level:2,title:"0. Quantifiers",slug:"_0-quantifiers",normalizedTitle:"0. quantifiers",charIndex:863},{level:3,title:"Basic quantifier syntax",slug:"basic-quantifier-syntax",normalizedTitle:"basic quantifier syntax",charIndex:882},{level:3,title:"Types of bound variables",slug:"types-of-bound-variables",normalizedTitle:"types of bound variables",charIndex:2238},{level:3,title:"Multiple bound variables",slug:"multiple-bound-variables",normalizedTitle:"multiple bound variables",charIndex:3110},{level:3,title:"The typical forms of quantifier bodies",slug:"the-typical-forms-of-quantifier-bodies",normalizedTitle:"the typical forms of quantifier bodies",charIndex:4085},{level:3,title:"Range predicates",slug:"range-predicates",normalizedTitle:"range predicates",charIndex:5949},{level:2,title:"1. Program Statements for Quantifier Reasoning",slug:"_1-program-statements-for-quantifier-reasoning",normalizedTitle:"1. program statements for quantifier reasoning",charIndex:8013},{level:3,title:"Aggregate statements",slug:"aggregate-statements",normalizedTitle:"aggregate statements",charIndex:8264},{level:3,title:"Existential introduction and elimination",slug:"existential-introduction-and-elimination",normalizedTitle:"existential introduction and elimination",charIndex:9966},{level:3,title:"Lemmas with out-parameters",slug:"lemmas-with-out-parameters",normalizedTitle:"lemmas with out-parameters",charIndex:14075},{level:3,title:"Binding guards",slug:"binding-guards",normalizedTitle:"binding guards",charIndex:15486},{level:2,title:"2. Sets and Maps",slug:"_2-sets-and-maps",normalizedTitle:"2. sets and maps",charIndex:16410},{level:3,title:"Set comprehensions",slug:"set-comprehensions",normalizedTitle:"set comprehensions",charIndex:655},{level:3,title:"Simplified set comprehensions",slug:"simplified-set-comprehensions",normalizedTitle:"simplified set comprehensions",charIndex:20013},{level:3,title:"Map comprehensions",slug:"map-comprehensions",normalizedTitle:"map comprehensions",charIndex:20842},{level:3,title:"Lambda expressions",slug:"lambda-expressions",normalizedTitle:"lambda expressions",charIndex:22995},{level:2,title:"3. Summary",slug:"_3-summary",normalizedTitle:"3. summary",charIndex:23595},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:23954},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:24041}],headersStr:"0. Quantifiers Basic quantifier syntax Types of bound variables Multiple bound variables The typical forms of quantifier bodies Range predicates 1. Program Statements for Quantifier Reasoning Aggregate statements Existential introduction and elimination Lemmas with out-parameters Binding guards 2. Sets and Maps Set comprehensions Simplified set comprehensions Map comprehensions Lambda expressions 3. Summary Acknowledgments References",content:"Dafny Power User: Comprehensions\n\nK. Rustan M. Leino\n\nManuscript KRML 267, 27 May 2019\n\nAbstract. Dafny has a number of comprehension-like constructs. This note describes and compares these constructs, showing how they compare both syntactically and semantically.\n\nDafny supports universal and existential quantifications, along with constructs used to prove a universally quantified expression or make use of an existentially quantified expression. Section 0 describes these logical quantifiers in Dafny. Section 1 shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.\n\nSet comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. Section 2 shows the general and common forms of these comprehensions.\n\n\n# 0. Quantifiers\n\n\n# Basic quantifier syntax\n\nIn mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . It says that the predicate holds for all values of . In programming-language lingo, we say that is a bound variable whose scope is the body of the quantifier, . That is, any free occurrences of in are bound to the introduced by the quantifier.\n\nIn Dafny, the same universal quantifier is written forall x :: P. From a parsing perspective, the body of the quantifier extends “as far as possible”. Thus, the program snippet\n\nforall x :: R ==> Q\n\n\n1\n\n\nis parsed as\n\n(forall x :: (R ==> Q))\n\n\n1\n\n\nnot as\n\n(forall x :: R) ==> Q\n\n\n1\n\n\nNote that “as far as possible” does not stop at line endings. For example, a common pitfall is to write (here shown for a precondition)\n\nrequires\n  forall x :: R ==> Q &&\n  S\n\n\n1\n2\n3\n\n\nwith the intention that forall x :: R ==> Q and S are two separate preconditions. Contrary to this expectation, the meaning of declaration, as written here, is\n\nrequires (forall x :: (R ==> (Q && S)))\n\n\n1\n\n\nIf you intended to write the conjunction of the quantifier and S, then the proper syntax is\n\nrequires\n  (forall x :: R ==> Q) &&\n  S\n\n\n1\n2\n3\n\n\nA familiar mathematical notation for an existential quantifier is . It says that the predicate holds for some value of . In Dafny, the syntax is exists x :: P.0\n\n\n# Types of bound variables\n\nEach variable in Dafny has a type. Typically, the type of a bound variable is inferred, but Dafny also allows the type to be declared explicitly. For example,\n\nforall x: X :: P\n\n\n1\n\n\ndeclares the type of x to be X. For brevity, and to show the typical ways of writing quantifiers and comprehensions, I will leave off types throughout this note, but remember that you can always include them if you want to.\n\nA common mathematical notation for quantifiers when the bound variables are drawn from some set is . A Dafny-like rendering of this expression is\n\nforall x in S :: P  // error: syntax error\n\n\n1\n\n\nHowever, this is incorrect Dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. The proper way to write such a quantifier in Dafny is\n\nforall x :: x in S ==> P\n\n\n1\n\n\n\n# Multiple bound variables\n\nA quantifier can have more than one bound variable. For example,\n\nforall x, y :: P\n\n\n1\n\n\nsays that P holds for all values of x and y. It is logically equivalent to the nested quantifiers\n\nforall x :: forall y :: P\n\n\n1\n\n\nFor that matter, it is logically equivalent also to\n\nforall y :: forall x :: P\n\n\n1\n\n\nCommon practice in Dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise.1\n\nIn the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. For example,\n\nforall x: X, y: Y :: P\n\n\n1\n\n\nsays that x has type X and y has type Y. If you only include the type of y, as in\n\nforall x, y: Y :: P\n\n\n1\n\n\nthen you are saying that y has type Y and that the type of x is to be inferred. In other words, you can think of this \":“ as having strong binding power than the ”,\".\n\n\n# The typical forms of quantifier bodies\n\nThe body of a universal quantifier is typically an implication, as in\n\nforall x :: R ==> P\n\n\n1\n\n\nYou can read this in one of the following ways:\n\n> \"for all x, the implication R ==> P holds\"\n> \n> \"for all x, R implies P\"\n> \n> \"for all x, if R holds, then so does P\"\n\nHowever, the antecedent of this implication (R) often serves the role of restricting (beyond just the type of x) the values of x under consideration. In other words, R tells you which values x ranges over. In that light, you would read the quantifier above in one of the following ways:\n\n> \"for all x satisfying R, P holds\n> \n> \"for all x such that R holds, P\"\n> \n> \"for all x (where x satisfies R), P holds\"\n> \n> \"for all x [insert your own descriptive phase for R], P\"\n\nAs a concrete instance of the last phrase, you may read forall x :: x in S ==> x % 2 == 0 as\n\n> \"for all x in S, x is even\"\n\nand you may read forall i :: 0 <= i < a.Length ==> a[i] == 5 as\n\n> \"for every index i of array a, a-sub-i is 5\"\n\nIn analogy to what I just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in\n\nexists x :: R && P\n\n\n1\n\n\nFor example:\n\nexists x :: x in S && x % 2 == 0\n\nexists i :: 0 <= i < a.Length && a[i] == 5\n\n\n1\n2\n3\n\n\nAgain thinking of R as telling you which values x ranges over, you may read these existential quantifiers as\n\n> \"there is an x in S for which x % 2 == 0 holds\"\n> \n> \"there is an index i into a such that a-sub-i is 5\"\n\nFollowing Why3 [1], Dafny issues a warning if you write R ==> P as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). If this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:\n\nexists x :: (R ==> P)\nexists x :: !R || P\nexists x :: P <== R\n\n\n1\n2\n3\n\n\n\n# Range predicates\n\nWhy did I just spend a page telling you ways to pronounce your quantifiers? Because that discussion spotlights the fact that the condition R, in either of\n\nforall x :: R ==> P\nexists x :: R && P\n\n\n1\n2\n\n\nplays a special role, even though R is really just a part of the body of these quantifiers. In fact, others have adopted a notation for quantifier that feature a special place for this range predicate R. Here are some examples:\n\n                                                \nUniversal quantifier   Existential quantifier   Source\n                                                \n                                                Dijkstra [3]\n                                                Chandy and Misra [2]\n                                                Gries and Schneider [4]\n\\forall X x; R; P      \\exists X x; R; P        JML [5]\n                                                \n\n(In the case of JML above, X denotes the type of x.) In textbooks using these notations, it is often remarked that \"for brevity, if R is true or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted\". These shortened forms are:\n\n                                                  \nRange listed separately   Range true or omitted   Source\n                                                  \n                                                  Dijkstra [3]\n                                                  Chandy and Misra [2]\n                                                  Gries and Schneider [4]\n\\forall X x; R; P         \\forall X x;; P         JML [5]\n                                                  \n\nThere's more. By using some notation that separates the R from P, the De Morgan's Law for quantifiers looks especially nice:\n\nBack to Dafny. If you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in Dafny, too. The syntax is:\n\nforall x | R :: P\nexists x | R :: P\n\n\n1\n2\n\n\n\n# 1. Program Statements for Quantifier Reasoning\n\nDafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. These have a syntax similar to those of quantifiers, but there are differences.\n\n\n# Aggregate statements\n\nThe forall statement in Dafny is an aggregate statement: it has the effect of performing a number of simultaneous operations. When used in proofs, the statement has the form:\n\nforall x | R\n  ensures P\n{\n  S;\n}\n\n\n1\n2\n3\n4\n5\n\n\nIt is used to establish the property forall x | R :: P, that is, forall x :: R ==> P. It does so by checking that the statement S establishes P for any x that satisfies R. In logic, the effect of this statement is called universal introduction.\n\nAs a simple example, suppose you have a lemma that proves n <= Fib(n) for any n at least 5, where Fib is the usual Fibonacci function:\n\nfunction Fib(n: nat): nat {\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\nlemma FibProperty(n: nat)\n  requires 5 <= n\n  ensures n <= Fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThis lemma gives you the property n <= Fib(n) for a given n. But suppose you want to have this property in the universally quantified form. That is, you'd like to prove the following lemma:\n\nlemma FibPropertyAll()\n  ensures forall n :: 5 <= n ==> n <= Fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nHow would we write this proof?2\n\nThe answer is to call FibProperty once for each n. All at once. For an infinite number of different values for n. That's what you do with the aggregate statement forall:\n\nforall n | 5 <= n\n  ensures n <= Fib(n)\n{\n  FibProperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nIn general, the body of a forall statement is more complicated than just one single lemma call. But for when the body is just one lemma call or just one calc statement, then Dafny infers the ensures clause automatically, so you can omit it:\n\nforall n | 5 <= n {\n  FibProperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# Existential introduction and elimination\n\nWorking with existential quantifications also uses a repertoire of proof features. I will demonstrate these by writing a proof that shows Fibonacci numbers can be arbitrarily large:\n\nlemma EverBigger(k: nat)\n  ensures exists n :: k <= Fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nLet's start the proof with some cases we can easily do, namely when k is small, let's say 0 or 1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\nDafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.\n\nTo prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular n for which the existential quantifier holds. That is, we want to give a witness to the existential quantifier. One such witness is 1, since k <= 1 == Fib(1). Another such witness is 12, since k <= 144 == Fib(12). Yet another such witness is k, since k <= k == Fib(k) in our simple case. Let's go with this one, so we add an assertion to the “then” branch of the if statement in the lemma body:\n\nassert k <= Fib(k);\n\n\n1\n\n\nDafny will prove this assertion3 and will then notice that k is an existential witness that proves the postcondition. In logic, this is called existential introduction. All that means is that if you have a value that satisfies a particular property, then such a value exists. Stated different, if you have a value “in your hands”, then a value exists—this seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that this is what you did for a living).\n\nSo what about the difficult case? We can prove it by induction, by first obtaining an n whose Fibonacci value is at least k-1 and then building an even larger Fibonacci value from there. To start this off, we call the lemma recursively on k-1:\n\nEverBigger(k-1);\n\n\n1\n\n\nThis lets us obtain the postcondition of EverBigger(k-1). To write that down explicitly in our proof—to check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property is—we can write an assertion:\n\nassert exists n' :: k-1 <= Fib(n');\n\n\n1\n\n\nGood so far. Next, we want to construct a Fibonacci number that is at least 1 larger than Fib(n'), because that would complete the proof. But what is this n' that i just mentioned? All the assertion above tells us that some such n' exists. We'd like to have such an n' “in our hands” so that we can work with it.\n\nGoing from something we know exists to something “in our hands” is called Skolemization or existential elimination. You achieve it in Dafny by the assign-such-that statement:\n\nvar m: nat :| k-1 <= Fib(m);\n\n\n1\n\n\nThis statement introduce a local variable m and gives it some arbitrary value that satisfies k-1 <= Fib(m). Of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an m exists. This proof obligation follows from the property we asserted just above.\n\nAlmost there. All that remains of our plan to establish the lemma's postcondition is to construct a Fibonacci number strictly larger than Fib(m). We observe that Fib(m) + Fib(m+1) is strictly larger than Fib(m), and thus we have that Fib(m+2) is strictly larger than Fib(m). Boom!\n\nOkay, let's be frank. Maybe we didn't so much “observe” this as we did “wish” or “conjecture” or “loosely think” that it may hold. Well, it does hold. (Phew!) We can check that by asking the verifier if it can prove it for us:\n\nassert k <= Fib(m) + Fib(m + 1) == Fib(m + 2);\n\n\n1\n\n\nThe verifier immediately prove this assertion.4 Moreover, by writing down this assertion, we are also showing the verifier the witness m+2, which proves the existential quantifier in the lemma's postcondition.\n\nThe point I set out to illustrate with this example is that you can Skolemize a quantifier\n\nexists x :: P\n\n\n1\n\n\nby the assign-such-that statement\n\nvar x :| P;\n\n\n1\n\n\nNotice the difference in punctuation.\n\n\n# Lemmas with out-parameters\n\nI just showed you an example that involves existential quantifiers. The example showed that the proof of the EverBigger lemma used existential introduction twice (Fib(k) in the simple case and Fib(m+2) in the difficult case), thus converting the k and the m+2 “in ours hands” into existential quantifications. The example also showed that the invocation of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an m “in our hands”. As impressive it is that Dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.\n\nIn mathematics, lemmas are parameterized by the variables they mention. These are like in-parameters. Rarely or never would a mathematical lemma be thought of as having out-parameters. In Dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. This can be quite useful. Instead of a lemma proving the existence of some value, it may as well just return some such value.\n\nHere is the EverBigger lemma from above, but with n declared as an out-parameter:\n\nlemma EverBigger(k: nat) returns (n: nat)\n  ensures k <= Fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := EverBigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Binding guards\n\nDafny includes one other feature that makes working with quantifiers more streamlined: if statements with binding guards. Such a statement answers the order “if there is one, gimmie one in my hand”.\n\nSuppose we write a proof that splits into two cases according whether or not the value y is a Fibonacci number. We could then write:\n\nif exists n :: y == Fib(n) {\n  var n :| y == Fib(n);\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThis expresses what we want, but feels a little clumsy, since we are repeating the condition y == Fib(n). Instead using a binding guard, we can write this if statement as\n\nif n :| y == Fib(n) {\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\nThe punctuation :| is the same as in the assign-such-that statement, not the :: in the similar position of the existential quantifier.\n\n\n# 2. Sets and Maps\n\nLogical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. This is also the case with set comprehensions and map comprehensions.\n\n\n# Set comprehensions\n\nIt is easy to write down a set in Dafny. For example,\n\n{ 2, 3, 5 }\n\n\n1\n\n\nis the set of the three smallest prime numbers. Such an expression, where the elements of the set are listed explicitly, is called a set display. But what if the set you want to define cannot be written as a set display?\n\nA set comprehension defines a set of elements in a schematic way. An example of a set comprehension in common mathematical notation is\n\nwhich defines the set of the smallest 100 natural numbers. Another example is\n\nwhich defines the 100 smallest perfect squares. The bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . Letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . That is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .\n\nMore generally, the mathematical notation takes some shape like . The reader is supposed to understand that is the bound variable. With the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :\n\nOr, to use the notation where the existential's range is given separately:\n\nIn Dafny, the same set comprehension has the following form:\n\nset x | R :: f(x)\n\n\n1\n\n\nx is the bound variable (or, more generally, a list of bound variables), R is the range predicate for the bound variables, and f(x) is the term expression of the set comprehension. The bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. The two example sets given above are written as follows in Dafny:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nAlthough at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.\n\nOne nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:\n\ny in (set x | R :: f(x))   <==>   exists x | R :: y == f(x)\n\n\n1\n\n\nAnother nicety is that one can easily list additional bound variables. Supposing that R is a predicate over both x and z, then here are two examples:\n\nset x,n | Fib(n) <= x < Fib(n) + n :: f(x)\nset x,n | Fib(n) <= x < Fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nThe first of these sets contains f(x) for every x that is within n of Fib(n) for some n. An equivalent way to write it in common mathematical notation is:\n\nThe second set contains g(x,n) for every x and n such that x is within n of Fib(n). Here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:\n\nDafny's general notation of making the bound variable explicit is also used by many authors (e.g., [3, 4]). It is also similar to the list-comprehension notation used in some other languages. For example, the Dafny set\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nwhich contains the pairs of natural numbers that sum to 100, contains the same elements as the Python list:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nand the Haskell list:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# Simplified set comprehensions\n\nI just spent many words describing the general set-comprehension notation in Dafny. However, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. For example, as we have seen, the set of the smallest 100 natural numbers is:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nFor this common case, Dafny lets you omit the term expression and simply write:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nThis expression looks like the common mathematical notation . Indeed, for these simplified set comprehensions, it is easy to “understand” what the mathematical notation intends to be the bound variables.\n\nAs a note about the verifier in Dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.\n\n\n# Map comprehensions\n\nA map is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). Like the display expressions for sets, a map can be defined by a map display. For example,\n\nmap[2 := 'c', 137 := 'a']\n\n\n1\n\n\nmaps the integer 2 to the character 'c' and maps the integer 137 to the character 'a'. Each pair like 2 := 'c' can be called a maplet. Also, the left-element of the maplet is called a key and the right-element gets the nondescript name value.\n\nLike the comprehensions for sets, a map can be defined by a map comprehension. It has the form:\n\nmap x | R :: f(x) := g(x)\n\n\n1\n\n\nFor example,\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\nis the map from each of the first 100 perfect squares to their respective square roots.\n\nIf you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. Nevertheless, I will offer some notes and point out some features specific to maps.\n\nOne thing to note is that the maplets must have unique keys. For example, the verifier will complain if you try to write a map comprehension like\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nbecause it says to map 4 to both 2 and -2, which is not functional.\n\nThe general map-comprehension expression is quite flexible. For example, suppose m is a map from numbers to characters, and suppose we want to create a new map n from a subset of the keys in m to some other characters. More precisely, whenever a key in m is in the image of a function f, say a key f(x) for some x, then we want n to map that key to h(x). We then define n as\n\nmap x | f(x) in m.Keys :: f(x) := h(x)\n\n\n1\n\n\nMost of the time, however, the map comprehensions we tend to write have the form\n\nmap x | R :: x := g(x)\n\n\n1\n\n\nFor these common maps, Dafny allows us to omit the \"x :=\" and write just\n\nmap x | R :: g(x)\n\n\n1\n\n\nAlmost all map comprehensions in practice can be written in this simplified form. But for when the simplified form is not sufficient (like in the example above with the maplets f(x) := h(x)), the general form is available.\n\n\n# Lambda expressions\n\nFinally, a note about the difference between maps and functions. You may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. For comparison, let's consider writing the map\n\nmap x | R :: g(x)\n\n\n1\n\n\nas a function.\n\nTypically, a function is declared with a name. The map above is then written along the lines of\n\nfunction F(x: X): Y\n  requires R\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\nA function can also be anonymous, in which case it is usually called a lambda expression. The example map is then written\n\nx requires R => g(x)\n\n\n1\n\n\n\n# 3. Summary\n\nHere is a listing of the syntactic forms discussed in this note:\n\nforall x :: P\nforall x | R :: P\nforall x | R ensures P { S; }\nexists x :: P\nexists x | R :: P\nvar x :| P;\nif x :| P { S; }\nset x | R :: f(x)\nset x | R\nmap x | R :: f(x) := h(x)\nmap x | R :: g(x)\nfunction F(x: X): Y { g(x) }\nx requires R => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# Acknowledgments\n\nI'm grateful to Jay Lorch for many helpful comments on this note.\n\n\n# References\n\n[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, Tests and Proofs — 8th International Conference, TAP 2014, volume 8570 of Lecture Notes in Computer Science, pages 20–35. Springer, July 2014. 🔎\n\n[1]François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich. Why3: Shepherd your herd of provers. In Boogie 2011: First International Workshop on Intermediate Verification Languages, pages 53–64, Wrocław, Poland, August 2011. https://hal.inria.fr/hal-00790310. 🔎\n\n[2]K. Mani Chandy and Jayadev Misra. Parallel Program Design: A Foundation. Addison-Wesley, 1988. 🔎\n\n[3]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. 🔎\n\n[4]David Gries and Fred B. Schneider. A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. Springer-Verlag, 1994. 🔎\n\n[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems, pages 175–188. Kluwer Academic Publishers, 1999. 🔎\n\n[6]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361–381. Springer, 2016. 🔎\n\n----------------------------------------\n\n0.The Emacs IDE for Dafny typesets certain Dafny constructs in the notation you're more likely to see in a paper. By default, it shows forall x :: P as and shows exists x :: P as . ↩\n\n1.Internally, the Dafny verifier works more effectively with certain quantifiers. The verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically [6]. For example, it may choose to un-nest some quantifiers. The goal of such rewrites is to support natural-looking programs while getting good prover performance. ↩\n\n2.As it turns out, Dafny's automatic induction will prove both FibProperty and FibPropertyAll automatically. If these were the only lemmas we cared about, there would be nothing else to say or do. Nevertheless, I'm using this example to show the forall statement. If you want to make sure what I'm about to say gives a proof, you can turn off automatic induction for FibPropertyAll by marking it with the attribute {:induction false}. ↩\n\n3.Dafny can also prove an assertion like assert Fib(12) == 144;. Internally, Dafny uses a “dual-rail encoding” of functions that lets it obtain the value of Fib(12) (since 12 is a literal constant) and Fib(k) (where k is a variable). If you're interested in how this is done, I refer you to [0]. ↩\n\n4.Here is a proof of the assertion k <= Fib(m) + Fib(m+1). The “difficult case” in our proof applies when k is at least 2, so k-1 is at least 1, so we know about Fib(m) that it is at least 1. From this, it follows that m cannot be 0, for Fib(0) == 0. This is important, because it means that m+1 is at least 2 and therefore the inductive case of the definition of Fib applies. In other words, we have Fib(m+1) == Fib(m) + Fib(m-1). We already concluded that Fib(m) is at least 1. On behalf of Fib returning a nat, we have that Fib(m-1) is at least 0. So, Fib(m+1) is at least 1. In other words, Fib(m) + Fib(m+1) is at least 1 more than Fib(m), which in turn is at least k-1. Thus, Fib(m) + Fib(m+1) is at least k.\n\nHad we split the “simple case” and “difficult case” up so that the “simple case” only covered k == 0, then we could not have concluded m != 0 in the argument above. Some users of other interactive proof assistants may be bothered by this, because they would say k has type nat and therefore the induction on k should use k == 0 as the base case. Mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of EverBigger into k < 2 and 2 <= k. ↩",normalizedContent:"dafny power user: comprehensions\n\nk. rustan m. leino\n\nmanuscript krml 267, 27 may 2019\n\nabstract. dafny has a number of comprehension-like constructs. this note describes and compares these constructs, showing how they compare both syntactically and semantically.\n\ndafny supports universal and existential quantifications, along with constructs used to prove a universally quantified expression or make use of an existentially quantified expression. section 0 describes these logical quantifiers in dafny. section 1 shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.\n\nset comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. section 2 shows the general and common forms of these comprehensions.\n\n\n# 0. quantifiers\n\n\n# basic quantifier syntax\n\nin mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . it says that the predicate holds for all values of . in programming-language lingo, we say that is a bound variable whose scope is the body of the quantifier, . that is, any free occurrences of in are bound to the introduced by the quantifier.\n\nin dafny, the same universal quantifier is written forall x :: p. from a parsing perspective, the body of the quantifier extends “as far as possible”. thus, the program snippet\n\nforall x :: r ==> q\n\n\n1\n\n\nis parsed as\n\n(forall x :: (r ==> q))\n\n\n1\n\n\nnot as\n\n(forall x :: r) ==> q\n\n\n1\n\n\nnote that “as far as possible” does not stop at line endings. for example, a common pitfall is to write (here shown for a precondition)\n\nrequires\n  forall x :: r ==> q &&\n  s\n\n\n1\n2\n3\n\n\nwith the intention that forall x :: r ==> q and s are two separate preconditions. contrary to this expectation, the meaning of declaration, as written here, is\n\nrequires (forall x :: (r ==> (q && s)))\n\n\n1\n\n\nif you intended to write the conjunction of the quantifier and s, then the proper syntax is\n\nrequires\n  (forall x :: r ==> q) &&\n  s\n\n\n1\n2\n3\n\n\na familiar mathematical notation for an existential quantifier is . it says that the predicate holds for some value of . in dafny, the syntax is exists x :: p.0\n\n\n# types of bound variables\n\neach variable in dafny has a type. typically, the type of a bound variable is inferred, but dafny also allows the type to be declared explicitly. for example,\n\nforall x: x :: p\n\n\n1\n\n\ndeclares the type of x to be x. for brevity, and to show the typical ways of writing quantifiers and comprehensions, i will leave off types throughout this note, but remember that you can always include them if you want to.\n\na common mathematical notation for quantifiers when the bound variables are drawn from some set is . a dafny-like rendering of this expression is\n\nforall x in s :: p  // error: syntax error\n\n\n1\n\n\nhowever, this is incorrect dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. the proper way to write such a quantifier in dafny is\n\nforall x :: x in s ==> p\n\n\n1\n\n\n\n# multiple bound variables\n\na quantifier can have more than one bound variable. for example,\n\nforall x, y :: p\n\n\n1\n\n\nsays that p holds for all values of x and y. it is logically equivalent to the nested quantifiers\n\nforall x :: forall y :: p\n\n\n1\n\n\nfor that matter, it is logically equivalent also to\n\nforall y :: forall x :: p\n\n\n1\n\n\ncommon practice in dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise.1\n\nin the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. for example,\n\nforall x: x, y: y :: p\n\n\n1\n\n\nsays that x has type x and y has type y. if you only include the type of y, as in\n\nforall x, y: y :: p\n\n\n1\n\n\nthen you are saying that y has type y and that the type of x is to be inferred. in other words, you can think of this \":“ as having strong binding power than the ”,\".\n\n\n# the typical forms of quantifier bodies\n\nthe body of a universal quantifier is typically an implication, as in\n\nforall x :: r ==> p\n\n\n1\n\n\nyou can read this in one of the following ways:\n\n> \"for all x, the implication r ==> p holds\"\n> \n> \"for all x, r implies p\"\n> \n> \"for all x, if r holds, then so does p\"\n\nhowever, the antecedent of this implication (r) often serves the role of restricting (beyond just the type of x) the values of x under consideration. in other words, r tells you which values x ranges over. in that light, you would read the quantifier above in one of the following ways:\n\n> \"for all x satisfying r, p holds\n> \n> \"for all x such that r holds, p\"\n> \n> \"for all x (where x satisfies r), p holds\"\n> \n> \"for all x [insert your own descriptive phase for r], p\"\n\nas a concrete instance of the last phrase, you may read forall x :: x in s ==> x % 2 == 0 as\n\n> \"for all x in s, x is even\"\n\nand you may read forall i :: 0 <= i < a.length ==> a[i] == 5 as\n\n> \"for every index i of array a, a-sub-i is 5\"\n\nin analogy to what i just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in\n\nexists x :: r && p\n\n\n1\n\n\nfor example:\n\nexists x :: x in s && x % 2 == 0\n\nexists i :: 0 <= i < a.length && a[i] == 5\n\n\n1\n2\n3\n\n\nagain thinking of r as telling you which values x ranges over, you may read these existential quantifiers as\n\n> \"there is an x in s for which x % 2 == 0 holds\"\n> \n> \"there is an index i into a such that a-sub-i is 5\"\n\nfollowing why3 [1], dafny issues a warning if you write r ==> p as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). if this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:\n\nexists x :: (r ==> p)\nexists x :: !r || p\nexists x :: p <== r\n\n\n1\n2\n3\n\n\n\n# range predicates\n\nwhy did i just spend a page telling you ways to pronounce your quantifiers? because that discussion spotlights the fact that the condition r, in either of\n\nforall x :: r ==> p\nexists x :: r && p\n\n\n1\n2\n\n\nplays a special role, even though r is really just a part of the body of these quantifiers. in fact, others have adopted a notation for quantifier that feature a special place for this range predicate r. here are some examples:\n\n                                                \nuniversal quantifier   existential quantifier   source\n                                                \n                                                dijkstra [3]\n                                                chandy and misra [2]\n                                                gries and schneider [4]\n\\forall x x; r; p      \\exists x x; r; p        jml [5]\n                                                \n\n(in the case of jml above, x denotes the type of x.) in textbooks using these notations, it is often remarked that \"for brevity, if r is true or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted\". these shortened forms are:\n\n                                                  \nrange listed separately   range true or omitted   source\n                                                  \n                                                  dijkstra [3]\n                                                  chandy and misra [2]\n                                                  gries and schneider [4]\n\\forall x x; r; p         \\forall x x;; p         jml [5]\n                                                  \n\nthere's more. by using some notation that separates the r from p, the de morgan's law for quantifiers looks especially nice:\n\nback to dafny. if you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in dafny, too. the syntax is:\n\nforall x | r :: p\nexists x | r :: p\n\n\n1\n2\n\n\n\n# 1. program statements for quantifier reasoning\n\ndafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. these have a syntax similar to those of quantifiers, but there are differences.\n\n\n# aggregate statements\n\nthe forall statement in dafny is an aggregate statement: it has the effect of performing a number of simultaneous operations. when used in proofs, the statement has the form:\n\nforall x | r\n  ensures p\n{\n  s;\n}\n\n\n1\n2\n3\n4\n5\n\n\nit is used to establish the property forall x | r :: p, that is, forall x :: r ==> p. it does so by checking that the statement s establishes p for any x that satisfies r. in logic, the effect of this statement is called universal introduction.\n\nas a simple example, suppose you have a lemma that proves n <= fib(n) for any n at least 5, where fib is the usual fibonacci function:\n\nfunction fib(n: nat): nat {\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\nlemma fibproperty(n: nat)\n  requires 5 <= n\n  ensures n <= fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthis lemma gives you the property n <= fib(n) for a given n. but suppose you want to have this property in the universally quantified form. that is, you'd like to prove the following lemma:\n\nlemma fibpropertyall()\n  ensures forall n :: 5 <= n ==> n <= fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nhow would we write this proof?2\n\nthe answer is to call fibproperty once for each n. all at once. for an infinite number of different values for n. that's what you do with the aggregate statement forall:\n\nforall n | 5 <= n\n  ensures n <= fib(n)\n{\n  fibproperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nin general, the body of a forall statement is more complicated than just one single lemma call. but for when the body is just one lemma call or just one calc statement, then dafny infers the ensures clause automatically, so you can omit it:\n\nforall n | 5 <= n {\n  fibproperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# existential introduction and elimination\n\nworking with existential quantifications also uses a repertoire of proof features. i will demonstrate these by writing a proof that shows fibonacci numbers can be arbitrarily large:\n\nlemma everbigger(k: nat)\n  ensures exists n :: k <= fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nlet's start the proof with some cases we can easily do, namely when k is small, let's say 0 or 1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\ndafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.\n\nto prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular n for which the existential quantifier holds. that is, we want to give a witness to the existential quantifier. one such witness is 1, since k <= 1 == fib(1). another such witness is 12, since k <= 144 == fib(12). yet another such witness is k, since k <= k == fib(k) in our simple case. let's go with this one, so we add an assertion to the “then” branch of the if statement in the lemma body:\n\nassert k <= fib(k);\n\n\n1\n\n\ndafny will prove this assertion3 and will then notice that k is an existential witness that proves the postcondition. in logic, this is called existential introduction. all that means is that if you have a value that satisfies a particular property, then such a value exists. stated different, if you have a value “in your hands”, then a value exists—this seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that this is what you did for a living).\n\nso what about the difficult case? we can prove it by induction, by first obtaining an n whose fibonacci value is at least k-1 and then building an even larger fibonacci value from there. to start this off, we call the lemma recursively on k-1:\n\neverbigger(k-1);\n\n\n1\n\n\nthis lets us obtain the postcondition of everbigger(k-1). to write that down explicitly in our proof—to check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property is—we can write an assertion:\n\nassert exists n' :: k-1 <= fib(n');\n\n\n1\n\n\ngood so far. next, we want to construct a fibonacci number that is at least 1 larger than fib(n'), because that would complete the proof. but what is this n' that i just mentioned? all the assertion above tells us that some such n' exists. we'd like to have such an n' “in our hands” so that we can work with it.\n\ngoing from something we know exists to something “in our hands” is called skolemization or existential elimination. you achieve it in dafny by the assign-such-that statement:\n\nvar m: nat :| k-1 <= fib(m);\n\n\n1\n\n\nthis statement introduce a local variable m and gives it some arbitrary value that satisfies k-1 <= fib(m). of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an m exists. this proof obligation follows from the property we asserted just above.\n\nalmost there. all that remains of our plan to establish the lemma's postcondition is to construct a fibonacci number strictly larger than fib(m). we observe that fib(m) + fib(m+1) is strictly larger than fib(m), and thus we have that fib(m+2) is strictly larger than fib(m). boom!\n\nokay, let's be frank. maybe we didn't so much “observe” this as we did “wish” or “conjecture” or “loosely think” that it may hold. well, it does hold. (phew!) we can check that by asking the verifier if it can prove it for us:\n\nassert k <= fib(m) + fib(m + 1) == fib(m + 2);\n\n\n1\n\n\nthe verifier immediately prove this assertion.4 moreover, by writing down this assertion, we are also showing the verifier the witness m+2, which proves the existential quantifier in the lemma's postcondition.\n\nthe point i set out to illustrate with this example is that you can skolemize a quantifier\n\nexists x :: p\n\n\n1\n\n\nby the assign-such-that statement\n\nvar x :| p;\n\n\n1\n\n\nnotice the difference in punctuation.\n\n\n# lemmas with out-parameters\n\ni just showed you an example that involves existential quantifiers. the example showed that the proof of the everbigger lemma used existential introduction twice (fib(k) in the simple case and fib(m+2) in the difficult case), thus converting the k and the m+2 “in ours hands” into existential quantifications. the example also showed that the invocation of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an m “in our hands”. as impressive it is that dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.\n\nin mathematics, lemmas are parameterized by the variables they mention. these are like in-parameters. rarely or never would a mathematical lemma be thought of as having out-parameters. in dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. this can be quite useful. instead of a lemma proving the existence of some value, it may as well just return some such value.\n\nhere is the everbigger lemma from above, but with n declared as an out-parameter:\n\nlemma everbigger(k: nat) returns (n: nat)\n  ensures k <= fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := everbigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# binding guards\n\ndafny includes one other feature that makes working with quantifiers more streamlined: if statements with binding guards. such a statement answers the order “if there is one, gimmie one in my hand”.\n\nsuppose we write a proof that splits into two cases according whether or not the value y is a fibonacci number. we could then write:\n\nif exists n :: y == fib(n) {\n  var n :| y == fib(n);\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthis expresses what we want, but feels a little clumsy, since we are repeating the condition y == fib(n). instead using a binding guard, we can write this if statement as\n\nif n :| y == fib(n) {\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\nthe punctuation :| is the same as in the assign-such-that statement, not the :: in the similar position of the existential quantifier.\n\n\n# 2. sets and maps\n\nlogical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. this is also the case with set comprehensions and map comprehensions.\n\n\n# set comprehensions\n\nit is easy to write down a set in dafny. for example,\n\n{ 2, 3, 5 }\n\n\n1\n\n\nis the set of the three smallest prime numbers. such an expression, where the elements of the set are listed explicitly, is called a set display. but what if the set you want to define cannot be written as a set display?\n\na set comprehension defines a set of elements in a schematic way. an example of a set comprehension in common mathematical notation is\n\nwhich defines the set of the smallest 100 natural numbers. another example is\n\nwhich defines the 100 smallest perfect squares. the bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . that is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .\n\nmore generally, the mathematical notation takes some shape like . the reader is supposed to understand that is the bound variable. with the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :\n\nor, to use the notation where the existential's range is given separately:\n\nin dafny, the same set comprehension has the following form:\n\nset x | r :: f(x)\n\n\n1\n\n\nx is the bound variable (or, more generally, a list of bound variables), r is the range predicate for the bound variables, and f(x) is the term expression of the set comprehension. the bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. the two example sets given above are written as follows in dafny:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nalthough at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.\n\none nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:\n\ny in (set x | r :: f(x))   <==>   exists x | r :: y == f(x)\n\n\n1\n\n\nanother nicety is that one can easily list additional bound variables. supposing that r is a predicate over both x and z, then here are two examples:\n\nset x,n | fib(n) <= x < fib(n) + n :: f(x)\nset x,n | fib(n) <= x < fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nthe first of these sets contains f(x) for every x that is within n of fib(n) for some n. an equivalent way to write it in common mathematical notation is:\n\nthe second set contains g(x,n) for every x and n such that x is within n of fib(n). here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:\n\ndafny's general notation of making the bound variable explicit is also used by many authors (e.g., [3, 4]). it is also similar to the list-comprehension notation used in some other languages. for example, the dafny set\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nwhich contains the pairs of natural numbers that sum to 100, contains the same elements as the python list:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nand the haskell list:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# simplified set comprehensions\n\ni just spent many words describing the general set-comprehension notation in dafny. however, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. for example, as we have seen, the set of the smallest 100 natural numbers is:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nfor this common case, dafny lets you omit the term expression and simply write:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nthis expression looks like the common mathematical notation . indeed, for these simplified set comprehensions, it is easy to “understand” what the mathematical notation intends to be the bound variables.\n\nas a note about the verifier in dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.\n\n\n# map comprehensions\n\na map is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). like the display expressions for sets, a map can be defined by a map display. for example,\n\nmap[2 := 'c', 137 := 'a']\n\n\n1\n\n\nmaps the integer 2 to the character 'c' and maps the integer 137 to the character 'a'. each pair like 2 := 'c' can be called a maplet. also, the left-element of the maplet is called a key and the right-element gets the nondescript name value.\n\nlike the comprehensions for sets, a map can be defined by a map comprehension. it has the form:\n\nmap x | r :: f(x) := g(x)\n\n\n1\n\n\nfor example,\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\nis the map from each of the first 100 perfect squares to their respective square roots.\n\nif you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. nevertheless, i will offer some notes and point out some features specific to maps.\n\none thing to note is that the maplets must have unique keys. for example, the verifier will complain if you try to write a map comprehension like\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nbecause it says to map 4 to both 2 and -2, which is not functional.\n\nthe general map-comprehension expression is quite flexible. for example, suppose m is a map from numbers to characters, and suppose we want to create a new map n from a subset of the keys in m to some other characters. more precisely, whenever a key in m is in the image of a function f, say a key f(x) for some x, then we want n to map that key to h(x). we then define n as\n\nmap x | f(x) in m.keys :: f(x) := h(x)\n\n\n1\n\n\nmost of the time, however, the map comprehensions we tend to write have the form\n\nmap x | r :: x := g(x)\n\n\n1\n\n\nfor these common maps, dafny allows us to omit the \"x :=\" and write just\n\nmap x | r :: g(x)\n\n\n1\n\n\nalmost all map comprehensions in practice can be written in this simplified form. but for when the simplified form is not sufficient (like in the example above with the maplets f(x) := h(x)), the general form is available.\n\n\n# lambda expressions\n\nfinally, a note about the difference between maps and functions. you may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. for comparison, let's consider writing the map\n\nmap x | r :: g(x)\n\n\n1\n\n\nas a function.\n\ntypically, a function is declared with a name. the map above is then written along the lines of\n\nfunction f(x: x): y\n  requires r\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\na function can also be anonymous, in which case it is usually called a lambda expression. the example map is then written\n\nx requires r => g(x)\n\n\n1\n\n\n\n# 3. summary\n\nhere is a listing of the syntactic forms discussed in this note:\n\nforall x :: p\nforall x | r :: p\nforall x | r ensures p { s; }\nexists x :: p\nexists x | r :: p\nvar x :| p;\nif x :| p { s; }\nset x | r :: f(x)\nset x | r\nmap x | r :: f(x) := h(x)\nmap x | r :: g(x)\nfunction f(x: x): y { g(x) }\nx requires r => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# acknowledgments\n\ni'm grateful to jay lorch for many helpful comments on this note.\n\n\n# references\n\n[0]nada amin, k. rustan m. leino, and tiark rompf. computing with an smt solver. in martina seidl and nikolai tillmann, editors, tests and proofs — 8th international conference, tap 2014, volume 8570 of lecture notes in computer science, pages 20–35. springer, july 2014. 🔎\n\n[1]francois bobot, jean-christophe filliatre, claude marche, and andrei paskevich. why3: shepherd your herd of provers. in boogie 2011: first international workshop on intermediate verification languages, pages 53–64, wrocław, poland, august 2011. https://hal.inria.fr/hal-00790310. 🔎\n\n[2]k. mani chandy and jayadev misra. parallel program design: a foundation. addison-wesley, 1988. 🔎\n\n[3]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. 🔎\n\n[4]david gries and fred b. schneider. a logical approach to discrete math. texts and monographs in computer science. springer-verlag, 1994. 🔎\n\n[5]gary t. leavens, albert l. baker, and clyde ruby. jml: a notation for detailed design. in haim kilov, bernhard rumpe, and ian simmonds, editors, behavioral specifications of businesses and systems, pages 175–188. kluwer academic publishers, 1999. 🔎\n\n[6]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361–381. springer, 2016. 🔎\n\n----------------------------------------\n\n0.the emacs ide for dafny typesets certain dafny constructs in the notation you're more likely to see in a paper. by default, it shows forall x :: p as and shows exists x :: p as . ↩\n\n1.internally, the dafny verifier works more effectively with certain quantifiers. the verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically [6]. for example, it may choose to un-nest some quantifiers. the goal of such rewrites is to support natural-looking programs while getting good prover performance. ↩\n\n2.as it turns out, dafny's automatic induction will prove both fibproperty and fibpropertyall automatically. if these were the only lemmas we cared about, there would be nothing else to say or do. nevertheless, i'm using this example to show the forall statement. if you want to make sure what i'm about to say gives a proof, you can turn off automatic induction for fibpropertyall by marking it with the attribute {:induction false}. ↩\n\n3.dafny can also prove an assertion like assert fib(12) == 144;. internally, dafny uses a “dual-rail encoding” of functions that lets it obtain the value of fib(12) (since 12 is a literal constant) and fib(k) (where k is a variable). if you're interested in how this is done, i refer you to [0]. ↩\n\n4.here is a proof of the assertion k <= fib(m) + fib(m+1). the “difficult case” in our proof applies when k is at least 2, so k-1 is at least 1, so we know about fib(m) that it is at least 1. from this, it follows that m cannot be 0, for fib(0) == 0. this is important, because it means that m+1 is at least 2 and therefore the inductive case of the definition of fib applies. in other words, we have fib(m+1) == fib(m) + fib(m-1). we already concluded that fib(m) is at least 1. on behalf of fib returning a nat, we have that fib(m-1) is at least 0. so, fib(m+1) is at least 1. in other words, fib(m) + fib(m+1) is at least 1 more than fib(m), which in turn is at least k-1. thus, fib(m) + fib(m+1) is at least k.\n\nhad we split the “simple case” and “difficult case” up so that the “simple case” only covered k == 0, then we could not have concluded m != 0 in the argument above. some users of other interactive proof assistants may be bothered by this, because they would say k has type nat and therefore the induction on k should use k == 0 as the base case. mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of everbigger into k < 2 and 2 <= k. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Different Styles of Proofs",frontmatter:{title:"Different Styles of Proofs",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/8d8607/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/20.Different%20Styles%20of%20Proofs.html",relativePath:"80.语言/30.publication-lecture/20.Different Styles of Proofs.md",key:"v-111c7b94",path:"/pages/8d8607/",headers:[{level:2,title:"0. A sample problem",slug:"_0-a-sample-problem",normalizedTitle:"0. a sample problem",charIndex:477},{level:2,title:"1. Proof calculation",slug:"_1-proof-calculation",normalizedTitle:"1. proof calculation",charIndex:2332},{level:2,title:"2. Direction and line-type of calculations",slug:"_2-direction-and-line-type-of-calculations",normalizedTitle:"2. direction and line-type of calculations",charIndex:5528},{level:2,title:"3. A minimal proof",slug:"_3-a-minimal-proof",normalizedTitle:"3. a minimal proof",charIndex:8007},{level:2,title:"4. Structured assertions",slug:"_4-structured-assertions",normalizedTitle:"4. structured assertions",charIndex:9243},{level:2,title:"5. Scopes",slug:"_5-scopes",normalizedTitle:"5. scopes",charIndex:10129},{level:2,title:"6. Assert by",slug:"_6-assert-by",normalizedTitle:"6. assert by",charIndex:12174},{level:2,title:"7. Proof by explicit ancestors",slug:"_7-proof-by-explicit-ancestors",normalizedTitle:"7. proof by explicit ancestors",charIndex:13321},{level:2,title:"8. Summary",slug:"_8-summary",normalizedTitle:"8. summary",charIndex:17801},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:18782}],headersStr:"0. A sample problem 1. Proof calculation 2. Direction and line-type of calculations 3. A minimal proof 4. Structured assertions 5. Scopes 6. Assert by 7. Proof by explicit ancestors 8. Summary References",content:"Dafny Power User: Different Styles of Proofs\n\nK. Rustan M. Leino\n\nManuscript KRML 276, 9 March 2020\n\nAbstract. Just like there are different sentence structures for expressing various ideas in writing and speaking, there are different proof structures to express proofs. This note shows some variations that are possible in Dafny.\n\nLet's consider various styles of writing proofs. As a running example, I'll start by defining a function and some axioms about its behavior.\n\n\n# 0. A sample problem\n\nConsider an integer function f with two arguments:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nSince I didn't provide a body for this function, Dafny treats it as an uninterpreted function. That means we don't know anything about it. Well, we do know it's a function, which means that its result value is determined entirely by its inputs. For example, we don't know which integer f(7, 3) evaluates to, but we know that if you call f again with those same arguments, you'll keep on getting the same value back.\n\nTo prove something about f, we'd like to know a little more of f's properties. Here are declarations of three lemmas that express such properties:\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nLike the function itself, these lemmas don't have bodies. It's the body of a lemma to justifies the postcondition of the lemma. In other words, the body is what gives the proof of the lemma. Since these lemmas don't have proofs, they are effectively axioms (that is, a claim you have to accept without proof).\n\nIf you run this function and these lemmas through the Dafny compiler, you'll get complaints that they don't have bodies. But for the purpose of this note, we don't care about getting executing code from the compiler. Our focus is on proofs, and the Dafny verifier has no objections about body-less declarations. As far as the verifier is concerned, a body-less declaration just says there is nothing to check.\n\nThe property we'll set out to prove, in various styles, is:\n\n> For any a, b, c, and x, if c <= x == f(a, b), then f(a, f(b, c)) <= x.\n\nThe proof of this property uses the three axioms from above.\n\n\n# 1. Proof calculation\n\nSometimes, one simple assert statement is enough of a hint for the Dafny verifier to complete a proof. Other times, what you need is a call to a lemma. When the situation isn't quite as simple as that, the most common way to write a proof in Dafny is a proof calculation [0, 3].\n\nA proof calculation is a chain of proof steps. Each step justifies one equality (e.g., A == B), inequality (e.g., A <= B), or logical consequence (e.g., A ==> B).\n\nA step is written vertically, to give some room to justify why the step holds. Here is a prototypical step:\n\n  A;\n==  // explain why A equals B\n  B;\n\n\n1\n2\n3\n\n\nAs this step illustrates, each formula in the chain is terminated with a semi-colon.\n\nIn the prototypical step above, I wrote the justification, also called the hint, as a comment. Such a comment is useful documentation. If the verifier cannot check your step without help, the hint needs to be more than a comment. Then, you write a block of code in curly braces, where the knowledge gained from that code is used by the verifier in proving the step. For example,\n\n  A;\n==  { LemmaThatJustifiesABEquality();  }\n  B;\n\n\n1\n2\n3\n\n\nIt's time to write our proof. Here it is:\n\nlemma CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nLet me read this proof calculation.\n\nThe first step says that, on account of associativity, the expression f(a, f(b, c)) equals f(f(a, b), c). Note that the hint calls the Associativity lemma with the particular parameters a, b, and c.\n\nThe second step says that f(f(a, b), c) is the same as f(x, c), because the antecedent (i.e., precondition) of the lemma we're proving says that x equals f(a, b). The verifier knows the equality x == f(a, b) from the precondition of the lemma we're proving, so the verifier does not need an explicit hint for this proof step. However, it can sometimes be nice to make such a statement in a machine-checked way, which you can do with an assert statement, like I showed here.\n\nThe third step proves f(x, c) <= f(x, x). The justification given for this step is that c <= x holds (it is given in the lemma precondition) and therefore it's okay to call the lemma Monotonicity (which requires c <= x as a precondition). The call to the Monotonicity(c, x) lemma gives us\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\nThe verifier figures out that instantiating this quantifier with x for w gives the inequality we're trying to prove in this step.\n\nThe fourth step proves f(x, x) to be equal to x. This property follows directly from axiom DiagonalIdentity, called with parameter x.\n\nOur four proof steps have justified the following four respective properties:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\nBy transitivity of == and <=, these four properties give us\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwhich is what we set out to prove.\n\n\n# 2. Direction and line-type of calculations\n\nGenerally speaking, I find proof calculations to be convincing and easy to read. You can check each step separately, and you can see how the formula is “transformed” from line to line.\n\nMany times, but far from always, I also find proof calculations to be straightforward to author. In the example above, we start the calculation with the left-hand side of the formula\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwe're trying to prove. Then, we look at the current line of the proof to figure out what properties we know about that expression, and what transformation we can apply next. To get more guidance in this process, it is generally best to start with the more complicated side of the formula we're trying to prove. Case in point, if you start with\n\ncalc {\n  x;\n\n\n1\n2\n\n\nit is far from obvious that a good next step is\n\n==  { DiagonalIdentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\nWe could continue this proof, writing the steps from the previous section in reverse order and reversing the direction of the operator in each step (for example, changing <= to >=):\n\n>=  { assert c <= x; Monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nRegardless of which direction we go in, each line in the calculations I have shown so far have type int. It also also possible to write the proof with a boolean formula in each line. Here is one such example:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { DiagonalIdentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { Associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; Monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nBy transitivity of ==, this proof calculation shows that formula f(a, f(b, c)) <= x has the value true.\n\nIf you choose such boolean expressions for the lines of your proof calculation, the operator in each step often turns out to be logical implication (==>, that is, “logical weakening”) or logical “explication” (<==, “logical strengthening”, or “follows from”). Of course, you must choose one of those two directions, not use both, or else your proof calculation wouldn't make any sense. Of these directions, <== usually gives you a nicer starting point, because you'd start from the formula you're trying to prove and you'd end up with true. However, in my experience, I see that many beginners are confused by the <== direction and write calculations as if they were in in the ==> direction. Use whichever direction makes sense to you.\n\n\n# 3. A minimal proof\n\nA proof calculation is a way to structure proof steps. It often contains more information than the verifier needs, especially if you, for your own benefit, write the proof in small steps. If you think a proof has too much detail, you can delete some of what is not needed. Whether or not that's a good idea—or, when it is, how much to delete—is mostly a matter of taste. If you come back to the proof later, the additional detail may provide useful documentation for how the proof was constructed in the first place.\n\nIf you were to reduce the hints in the proof calculations above, the first thing you'd probably do is delete the two assert statements that are part of the proofs, or at least the assertion c <= x. But you can do more.\n\nWith the above calculation in front of us, we can easily see which lemmas are used and, importantly, which values those lemmas are instantiated with. Once you know that, then you can leave off the proof calculation altogether. The whole proof would then look like this:\n\nlemma MinimalProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  Monotonicity(c, x);\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4. Structured assertions\n\nFor the purpose of this note, it is instructive to write the calculational proof without the calc statement. Here's what it would look like:\n\nlemma AssertProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; Monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  DiagonalIdentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nEach of these four groups of statements corresponds to one step in the calculation in Section 1. What was the hint in the calc statement precedes the assertion that concludes the equality or inequality that the step proves. The verifier then glues together the four conclusions to prove the postcondition of the lemma.\n\n\n# 5. Scopes\n\nThere is a difference between the calc statement in Section 1 and the broken-out assert statements in Section 4. The difference is that each hint in the calculation is local to the proof step. That is, the scope of a hint is just the step itself. For example, suppose you moved all the hints of the calc statement in Section 1 to the first proof step. Then, two of the proof steps would no longer verify:\n\ncalc {\n  f(a, f(b, c));\n==  { Associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; Monotonicity(c, x);\n      DiagonalIdentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThat is, the information gained from calling the three lemmas in the hint in the first step does not rub off on the other steps. In contrast, if you collected the hint at the start of the lemma body, the four equality and inequalities would verify fine:\n\n// hints\nAssociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; Monotonicity(c, x);\nDiagonalIdentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nYou can think of each step of a calc statement as being a little lemma in its own right, where the proof of that lemma is placed in the hint for that step. This makes a difference in writing your proof, not just because it tells the human reader that a certain hint applies to a particular proof step, but also because it limits where the verifier is able to apply a hint. For complicated proofs, this can make a big difference in practice, because the verifier can get “confused” with too much information—this manifests itself in poor verifier performance or some “butterfly effect” [2].\n\nIn conclusion, it's good to compartmentalize hints in a proof. The calc statement is good at that, but you can also do it with a form of the assert statement. Let's look at that next.\n\n\n# 6. Assert by\n\nThe statement assert E; says three things:\n\n 1. it declares that you expect condition E to hold\n 2. it asks the verifier to prove E\n 3. it lets what follows the assertion assume E\n\nYou may not have thought to separate these three aspects of an assertion, but it's useful to do that, because Dafny provides alternatives to (1) and (2).\n\nThe statement\n\nassert E by { Hint }\n\n\n1\n\n\nchanges aspect (1) to say that E is proved under the given hint, where Hint is a statement. The scope of the hint is just the assertion itself, so it is not available downstream of the assert. In this way, the assert by statement is equivalent to:\n\ncalc {\n  E;\n==  { Hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\nWe can rewrite the proof from Section 4 using assert by:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  Associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; Monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis provides better compartmentalization, and thus more directly expresses why each asserted condition holds.\n\n\n# 7. Proof by explicit ancestors\n\nThe proof in the Section 6 contains two assertions that restate what's written in the precondition. The idea behind those assertions is to make explicit where those preconditions are used. However, this has two shortcomings.\n\nOne shortcoming is that you have to compare the expression in the assertion with other expressions in the proof to realize that the assertion is just restating a previously available assumption. It would be nice if we could label the condition instead and then refer to the label.\n\nThe other shortcoming is that the preconditions are available regardless of if we restate the condition in an assertion. If we forget to write the assertion (perhaps because we don't realize that we're depending on this condition) or if we accidentally write the wrong precondition, then the proof still goes through. That is, the verifier is already able to use the precondition, so it doesn't care if you restate the condition, state a different (true) condition, or state nothing more. It would be nice if we could be more explicit about the scope of these assumptions.\n\nThere is one more form of the assert by statement. It relaxes aspect (2) from Section 6. This form looks like this:\n\nassert Label: E { Hint }\n\n\n1\n\n\nThis labeled assert statement says you expect condition E to hold and it offers statement Hint as a proof for E. The use of a label before the condition has the effect of suppressing the use of E as a downstream assumption.\n\nFor example, to prove f(12, 12) == 12 requires a use of axiom DiagonalIdentity. If you use a labeled assert by to prove this fact, then the proved fact is still not available after the labeled assert:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nWhy would you use such a statement if you can't use the fact you proved? Well, I should rather have said that the fact isn't automatically available after the labeled assertion. But you can explicitly request it. You do that with a reveal statement, in which you mention the label.\n\nHere is the example again, but with a reveal statement:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nreveal Label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nYou can play the same trick on preconditions. That is, usually in a lemma (or method or function), a precondition\n\nrequires E\n\n\n1\n\n\nis available throughout the body of the lemma. But if you label it, you have to use a reveal statement to bring out this assumption:\n\nrequires Label: E\n\n\n1\n\n\nBefore we see this in action, let me say something about labels. A label in Dafny can be any identifier, but it can also be something that, textually, looks like a numeric literal. Here are five example labels:\n\nMyLabel    Label57    L57    57    000_057\n\n\n1\n\n\nThese are five distinct labels—the fact that, as numerical literals, 57 and 000_057 represent the same number does not make them the same label. If they look different on the printed page, they are different labels. (This is also true for field names in classes, destructors of datatypes, and other type members, which also have the extended syntax of allowing literal-looking identifiers.)\n\nAlright, now we're ready to use labeled assertions in our running example:\n\nlemma DifferentStyleOfProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nIn this style of proof, which is common in some texts on logic, each assertion is explicitly justified by through its dependencies. If you think of the dependencies among assertions as forming a proof DAG, then this style of proof is being explicit about the ancestors in the DAG. You can use the hierarchical structuring of nested assert by statements and labeled assertions to approximate a Lamport-style proof [1].\n\n\n# 8. Summary\n\nThere are different styles of writing proofs. The absolutely simplest proofs are the ones that are done automatically and don't have to be further justified. Other simple proofs require an assert statement or a call to a lemma. Proof steps can be organized using calc statements and assert by statements. By labeling an assert by statement or a precondition, the condtion is suppressed from the proof until you explicitly ask for it back using a reveal statement.\n\nStructuring proofs is a good idea, for readability and clarity, as well as for improved mechanical-prover performance. You can think of a proof statement as having some number of input conditions. These are the conditions and labels that are available in the context of the proof statement. The output of a proof statement is the transitive connection of the first and last lines of a calc statement, the condition in an unlabeled assert or assert by statement, and the label of a labeled assertion.\n\n\n# References\n\n[0]Edsger W. Dijkstra and W. H. J. Feijen. A Method of Programming. Addison-Wesley, July 1988. 🔎\n\n[1]Leslie Lamport. How to write a 21st century proof. Technical report, Microsoft Research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. 🔎\n\n[2]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361–381. Springer, 2016. 🔎\n\n[3]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments — 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170–190. Springer, 2014. 🔎",normalizedContent:"dafny power user: different styles of proofs\n\nk. rustan m. leino\n\nmanuscript krml 276, 9 march 2020\n\nabstract. just like there are different sentence structures for expressing various ideas in writing and speaking, there are different proof structures to express proofs. this note shows some variations that are possible in dafny.\n\nlet's consider various styles of writing proofs. as a running example, i'll start by defining a function and some axioms about its behavior.\n\n\n# 0. a sample problem\n\nconsider an integer function f with two arguments:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nsince i didn't provide a body for this function, dafny treats it as an uninterpreted function. that means we don't know anything about it. well, we do know it's a function, which means that its result value is determined entirely by its inputs. for example, we don't know which integer f(7, 3) evaluates to, but we know that if you call f again with those same arguments, you'll keep on getting the same value back.\n\nto prove something about f, we'd like to know a little more of f's properties. here are declarations of three lemmas that express such properties:\n\nlemma associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma diagonalidentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlike the function itself, these lemmas don't have bodies. it's the body of a lemma to justifies the postcondition of the lemma. in other words, the body is what gives the proof of the lemma. since these lemmas don't have proofs, they are effectively axioms (that is, a claim you have to accept without proof).\n\nif you run this function and these lemmas through the dafny compiler, you'll get complaints that they don't have bodies. but for the purpose of this note, we don't care about getting executing code from the compiler. our focus is on proofs, and the dafny verifier has no objections about body-less declarations. as far as the verifier is concerned, a body-less declaration just says there is nothing to check.\n\nthe property we'll set out to prove, in various styles, is:\n\n> for any a, b, c, and x, if c <= x == f(a, b), then f(a, f(b, c)) <= x.\n\nthe proof of this property uses the three axioms from above.\n\n\n# 1. proof calculation\n\nsometimes, one simple assert statement is enough of a hint for the dafny verifier to complete a proof. other times, what you need is a call to a lemma. when the situation isn't quite as simple as that, the most common way to write a proof in dafny is a proof calculation [0, 3].\n\na proof calculation is a chain of proof steps. each step justifies one equality (e.g., a == b), inequality (e.g., a <= b), or logical consequence (e.g., a ==> b).\n\na step is written vertically, to give some room to justify why the step holds. here is a prototypical step:\n\n  a;\n==  // explain why a equals b\n  b;\n\n\n1\n2\n3\n\n\nas this step illustrates, each formula in the chain is terminated with a semi-colon.\n\nin the prototypical step above, i wrote the justification, also called the hint, as a comment. such a comment is useful documentation. if the verifier cannot check your step without help, the hint needs to be more than a comment. then, you write a block of code in curly braces, where the knowledge gained from that code is used by the verifier in proving the step. for example,\n\n  a;\n==  { lemmathatjustifiesabequality();  }\n  b;\n\n\n1\n2\n3\n\n\nit's time to write our proof. here it is:\n\nlemma calculationalstyleproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; monotonicity(c, x); }\n    f(x, x);\n  ==  { diagonalidentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nlet me read this proof calculation.\n\nthe first step says that, on account of associativity, the expression f(a, f(b, c)) equals f(f(a, b), c). note that the hint calls the associativity lemma with the particular parameters a, b, and c.\n\nthe second step says that f(f(a, b), c) is the same as f(x, c), because the antecedent (i.e., precondition) of the lemma we're proving says that x equals f(a, b). the verifier knows the equality x == f(a, b) from the precondition of the lemma we're proving, so the verifier does not need an explicit hint for this proof step. however, it can sometimes be nice to make such a statement in a machine-checked way, which you can do with an assert statement, like i showed here.\n\nthe third step proves f(x, c) <= f(x, x). the justification given for this step is that c <= x holds (it is given in the lemma precondition) and therefore it's okay to call the lemma monotonicity (which requires c <= x as a precondition). the call to the monotonicity(c, x) lemma gives us\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\nthe verifier figures out that instantiating this quantifier with x for w gives the inequality we're trying to prove in this step.\n\nthe fourth step proves f(x, x) to be equal to x. this property follows directly from axiom diagonalidentity, called with parameter x.\n\nour four proof steps have justified the following four respective properties:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\nby transitivity of == and <=, these four properties give us\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwhich is what we set out to prove.\n\n\n# 2. direction and line-type of calculations\n\ngenerally speaking, i find proof calculations to be convincing and easy to read. you can check each step separately, and you can see how the formula is “transformed” from line to line.\n\nmany times, but far from always, i also find proof calculations to be straightforward to author. in the example above, we start the calculation with the left-hand side of the formula\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwe're trying to prove. then, we look at the current line of the proof to figure out what properties we know about that expression, and what transformation we can apply next. to get more guidance in this process, it is generally best to start with the more complicated side of the formula we're trying to prove. case in point, if you start with\n\ncalc {\n  x;\n\n\n1\n2\n\n\nit is far from obvious that a good next step is\n\n==  { diagonalidentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\nwe could continue this proof, writing the steps from the previous section in reverse order and reversing the direction of the operator in each step (for example, changing <= to >=):\n\n>=  { assert c <= x; monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nregardless of which direction we go in, each line in the calculations i have shown so far have type int. it also also possible to write the proof with a boolean formula in each line. here is one such example:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { diagonalidentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nby transitivity of ==, this proof calculation shows that formula f(a, f(b, c)) <= x has the value true.\n\nif you choose such boolean expressions for the lines of your proof calculation, the operator in each step often turns out to be logical implication (==>, that is, “logical weakening”) or logical “explication” (<==, “logical strengthening”, or “follows from”). of course, you must choose one of those two directions, not use both, or else your proof calculation wouldn't make any sense. of these directions, <== usually gives you a nicer starting point, because you'd start from the formula you're trying to prove and you'd end up with true. however, in my experience, i see that many beginners are confused by the <== direction and write calculations as if they were in in the ==> direction. use whichever direction makes sense to you.\n\n\n# 3. a minimal proof\n\na proof calculation is a way to structure proof steps. it often contains more information than the verifier needs, especially if you, for your own benefit, write the proof in small steps. if you think a proof has too much detail, you can delete some of what is not needed. whether or not that's a good idea—or, when it is, how much to delete—is mostly a matter of taste. if you come back to the proof later, the additional detail may provide useful documentation for how the proof was constructed in the first place.\n\nif you were to reduce the hints in the proof calculations above, the first thing you'd probably do is delete the two assert statements that are part of the proofs, or at least the assertion c <= x. but you can do more.\n\nwith the above calculation in front of us, we can easily see which lemmas are used and, importantly, which values those lemmas are instantiated with. once you know that, then you can leave off the proof calculation altogether. the whole proof would then look like this:\n\nlemma minimalproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  monotonicity(c, x);\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4. structured assertions\n\nfor the purpose of this note, it is instructive to write the calculational proof without the calc statement. here's what it would look like:\n\nlemma assertproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  diagonalidentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\neach of these four groups of statements corresponds to one step in the calculation in section 1. what was the hint in the calc statement precedes the assertion that concludes the equality or inequality that the step proves. the verifier then glues together the four conclusions to prove the postcondition of the lemma.\n\n\n# 5. scopes\n\nthere is a difference between the calc statement in section 1 and the broken-out assert statements in section 4. the difference is that each hint in the calculation is local to the proof step. that is, the scope of a hint is just the step itself. for example, suppose you moved all the hints of the calc statement in section 1 to the first proof step. then, two of the proof steps would no longer verify:\n\ncalc {\n  f(a, f(b, c));\n==  { associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; monotonicity(c, x);\n      diagonalidentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthat is, the information gained from calling the three lemmas in the hint in the first step does not rub off on the other steps. in contrast, if you collected the hint at the start of the lemma body, the four equality and inequalities would verify fine:\n\n// hints\nassociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; monotonicity(c, x);\ndiagonalidentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nyou can think of each step of a calc statement as being a little lemma in its own right, where the proof of that lemma is placed in the hint for that step. this makes a difference in writing your proof, not just because it tells the human reader that a certain hint applies to a particular proof step, but also because it limits where the verifier is able to apply a hint. for complicated proofs, this can make a big difference in practice, because the verifier can get “confused” with too much information—this manifests itself in poor verifier performance or some “butterfly effect” [2].\n\nin conclusion, it's good to compartmentalize hints in a proof. the calc statement is good at that, but you can also do it with a form of the assert statement. let's look at that next.\n\n\n# 6. assert by\n\nthe statement assert e; says three things:\n\n 1. it declares that you expect condition e to hold\n 2. it asks the verifier to prove e\n 3. it lets what follows the assertion assume e\n\nyou may not have thought to separate these three aspects of an assertion, but it's useful to do that, because dafny provides alternatives to (1) and (2).\n\nthe statement\n\nassert e by { hint }\n\n\n1\n\n\nchanges aspect (1) to say that e is proved under the given hint, where hint is a statement. the scope of the hint is just the assertion itself, so it is not available downstream of the assert. in this way, the assert by statement is equivalent to:\n\ncalc {\n  e;\n==  { hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\nwe can rewrite the proof from section 4 using assert by:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nthis provides better compartmentalization, and thus more directly expresses why each asserted condition holds.\n\n\n# 7. proof by explicit ancestors\n\nthe proof in the section 6 contains two assertions that restate what's written in the precondition. the idea behind those assertions is to make explicit where those preconditions are used. however, this has two shortcomings.\n\none shortcoming is that you have to compare the expression in the assertion with other expressions in the proof to realize that the assertion is just restating a previously available assumption. it would be nice if we could label the condition instead and then refer to the label.\n\nthe other shortcoming is that the preconditions are available regardless of if we restate the condition in an assertion. if we forget to write the assertion (perhaps because we don't realize that we're depending on this condition) or if we accidentally write the wrong precondition, then the proof still goes through. that is, the verifier is already able to use the precondition, so it doesn't care if you restate the condition, state a different (true) condition, or state nothing more. it would be nice if we could be more explicit about the scope of these assumptions.\n\nthere is one more form of the assert by statement. it relaxes aspect (2) from section 6. this form looks like this:\n\nassert label: e { hint }\n\n\n1\n\n\nthis labeled assert statement says you expect condition e to hold and it offers statement hint as a proof for e. the use of a label before the condition has the effect of suppressing the use of e as a downstream assumption.\n\nfor example, to prove f(12, 12) == 12 requires a use of axiom diagonalidentity. if you use a labeled assert by to prove this fact, then the proved fact is still not available after the labeled assert:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nwhy would you use such a statement if you can't use the fact you proved? well, i should rather have said that the fact isn't automatically available after the labeled assertion. but you can explicitly request it. you do that with a reveal statement, in which you mention the label.\n\nhere is the example again, but with a reveal statement:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nreveal label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nyou can play the same trick on preconditions. that is, usually in a lemma (or method or function), a precondition\n\nrequires e\n\n\n1\n\n\nis available throughout the body of the lemma. but if you label it, you have to use a reveal statement to bring out this assumption:\n\nrequires label: e\n\n\n1\n\n\nbefore we see this in action, let me say something about labels. a label in dafny can be any identifier, but it can also be something that, textually, looks like a numeric literal. here are five example labels:\n\nmylabel    label57    l57    57    000_057\n\n\n1\n\n\nthese are five distinct labels—the fact that, as numerical literals, 57 and 000_057 represent the same number does not make them the same label. if they look different on the printed page, they are different labels. (this is also true for field names in classes, destructors of datatypes, and other type members, which also have the extended syntax of allowing literal-looking identifiers.)\n\nalright, now we're ready to use labeled assertions in our running example:\n\nlemma differentstyleofproof(a: int, b: int, c: int, x: int)\n  requires a: c <= x\n  requires b: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal b;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal a; }\n    monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    diagonalidentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nin this style of proof, which is common in some texts on logic, each assertion is explicitly justified by through its dependencies. if you think of the dependencies among assertions as forming a proof dag, then this style of proof is being explicit about the ancestors in the dag. you can use the hierarchical structuring of nested assert by statements and labeled assertions to approximate a lamport-style proof [1].\n\n\n# 8. summary\n\nthere are different styles of writing proofs. the absolutely simplest proofs are the ones that are done automatically and don't have to be further justified. other simple proofs require an assert statement or a call to a lemma. proof steps can be organized using calc statements and assert by statements. by labeling an assert by statement or a precondition, the condtion is suppressed from the proof until you explicitly ask for it back using a reveal statement.\n\nstructuring proofs is a good idea, for readability and clarity, as well as for improved mechanical-prover performance. you can think of a proof statement as having some number of input conditions. these are the conditions and labels that are available in the context of the proof statement. the output of a proof statement is the transitive connection of the first and last lines of a calc statement, the condition in an unlabeled assert or assert by statement, and the label of a labeled assertion.\n\n\n# references\n\n[0]edsger w. dijkstra and w. h. j. feijen. a method of programming. addison-wesley, july 1988. 🔎\n\n[1]leslie lamport. how to write a 21st century proof. technical report, microsoft research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. 🔎\n\n[2]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361–381. springer, 2016. 🔎\n\n[3]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments — 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170–190. springer, 2014. 🔎",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Functions over Set Elements",frontmatter:{title:"Functions over Set Elements",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/097ba0/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/30.Functions%20over%20Set%20Elements.html",relativePath:"80.语言/30.publication-lecture/30.Functions over Set Elements.md",key:"v-57bcc112",path:"/pages/097ba0/",headers:[{level:2,title:"0. Summing the elements of a set",slug:"_0-summing-the-elements-of-a-set",normalizedTitle:"0. summing the elements of a set",charIndex:583},{level:2,title:"1. Recursive definition of Sum",slug:"_1-recursive-definition-of-sum",normalizedTitle:"1. recursive definition of sum",charIndex:1163},{level:2,title:"2. The proof that fails",slug:"_2-the-proof-that-fails",normalizedTitle:"2. the proof that fails",charIndex:1868},{level:2,title:"3. Picking something else",slug:"_3-picking-something-else",normalizedTitle:"3. picking something else",charIndex:2638},{level:2,title:"4. Inlining Pick",slug:"_4-inlining-pick",normalizedTitle:"4. inlining pick",charIndex:4243},{level:2,title:"5. Let such that",slug:"_5-let-such-that",normalizedTitle:"5. let such that",charIndex:5436},{level:2,title:"6. Different choices",slug:"_6-different-choices",normalizedTitle:"6. different choices",charIndex:8483},{level:2,title:"7. Summary",slug:"_7-summary",normalizedTitle:"7. summary",charIndex:9935}],headersStr:"0. Summing the elements of a set 1. Recursive definition of Sum 2. The proof that fails 3. Picking something else 4. Inlining Pick 5. Let such that 6. Different choices 7. Summary",content:"Dafny Power User: Functions over Set Elements\n\nK. Rustan M. Leino\n\nManuscript KRML 274, 16 February 2020\n\nAbstract. In natural language, it is easy to say and understand a phrase like “the sum of the numbers in a set”. Defining and working with such functions in a formal settings is more work. The problem has to do with how a recursively defined function picks the next element from a set. This note describes a representative example and describes how to make the formal mumbo-jumbo work out. The solution can be applied to any commutative and associative operation on a set.\n\n\n# 0. Summing the elements of a set\n\nSuppose we have a function that returns the sum of the integers in a set:\n\nfunction Sum(s: set<int>): int\n\n\n1\n\n\nIf we add an element y to a set, we expect its sum to go up by y. That is, we expect that the following method is correctly implemented:\n\nmethod AddElement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == Sum(s) && y !in s\n  ensures t == s + {x} && b == Sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIt turns out, the proof is not automatic. Let's look at the details and fill in the proof.\n\n\n# 1. Recursive definition of Sum\n\nFunction Sum is defined recursively. The sum of the empty set is 0. If the set is nonempty, pick one of its elements, say x. Then, add x to the recursively computed sum of the remaining elements.\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nThis definition uses a function Pick, which returns an arbitrary element from a given set. Here is its definition:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nI'll come back to Pick later. All you need to understand at this time is that the caller of Pick has no control over which element of s is returned.\n\n\n# 2. The proof that fails\n\nTo prove AddElement, we need to show b == Sum(t) holds in its final state. Working backwards over the assignments, this means we need to show\n\na + y == Sum(s + {y})\n\n\n1\n\n\nin the initial state. Since a is Sum(s), our proof obligation comes down to\n\nSum(s) + y == Sum(s + {y})\n\n\n1\n\n\nwhere we are given that y is not in s.\n\nSuppose Pick(s + {y}) returns y. Then, we have\n\n  Sum(s + {y});\n==  // def. Sum\n  var x := Pick(s + {y}); x + Sum(s + {y} - {x});\n==  // using the assumption Pick(s + {y}) == y\n  y + Sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + Sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThat was easy and straightforward. But for this proof, we assumed that the relevant call to Pick returned y. What if Pick returns a different element from s?\n\n\n# 3. Picking something else\n\nBefore you realize Pick can choose a different element than the one you have in mind, the clouds start to clear. What we need is a lemma that says the choice is immaterial. That is, the lemma will let us treat Sum as if it picks, when doing its recursive call, an element that we specify.\n\nHere is that lemma. The proof is also a little tricky at first. It comes down to letting Pick choose whatever element it chooses, and then applying the induction hypothesis on the smaller set that Sum recurses on.\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x := Pick(s);\n  if y == x {\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nI stated the lemma to look like the expressions in the body of Sum, so the two arguments to Sum are s and s - {y}. Alternatively, we can state the property in terms of calls to Sum with the arguments s + {y} and s. This alternative is a simple corollary of the lemma above:\n\nlemma AddToSum(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  SumMyWay(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nUsing the lemma\n\nEquipped with the useful lemma, it's easy to get the proof of AddElement go through: change its body to\n\nt := s + {y};\nb := a + y;\nAddToSum(s, y);\n\n\n1\n2\n3\n\n\n\n# 4. Inlining Pick\n\nIn the development above, I define Pick as a separate function. Reading the word “pick” in the program text may help understand what Sum and SumMyWay do. But it's such a small function, so why not just inline it in the two places where it's used. Let's try it:\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to Pick\n    x + Sum(s - {x})\n}\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to Pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum        // error: this step might not hold\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nWe now get two errors!\n\nTo explain what's going on, let me say a little more about :| and what makes it unusual.\n\n\n# 5. Let such that\n\nThe let-such-that construct in Dafny has the form\n\nvar x :| P; E\n\n\n1\n\n\nIt evaluates to E, where x is bound to some value satisfying P. For example,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nevaluates to 14, 16, or 18. As the programmer, you have no control over which value of x is chosen. But you do get to know two important things. One is that x will be chosen to be a value that satisfies P. (The Dafny verifier gives an error if it cannot prove such a value to exist.) The other is that you will get the same value every time you evaluate the expression with the same inputs. In other words, the operator is deterministic.\n\nHere is another example to illustrate the point about determinism:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nThis expression chooses x to be one of the three smallest primes (2, 3, or 5) and then returns it. You don't know which of the three values you get, but you are guaranteed that every time this expression is evaluated within one run of a program, you will get the same value.\n\nLet's be more precise about what I mean by “this expression”. In Dafny, every textual occurrence of a let-such-that expression gets to make its own choices. One way to think about this is to go through the text of your program and to color each :| operator with a unique color. Then, you can rely on choices being the same only if they are performed by the same-color :|.\n\nHere is an illustrative example.\n\nlemma Choices(s: set<int>)\n  requires s != {}\n{\n  var a := Pick(s);\n  var b := Pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe first values assigned to a and b originate from the same :| operator. They are the results of choices of the same color. Therefore, they are known to be the same. In contrast, the next values assigned to a and b originate from different :| operators—ones of different colors. Therefore, you cannot be sure a and b are equal.\n\nActually, if you think about it a little more (or, maybe, a little less), then you realize that we know the first values assigned to a and b to be equal even without knowing anything about the body of Pick. After all, Pick is a function, and if you call a function twice on the same arguments, it will give you back the same value. Mathematics guarantees this, and so does Dafny. So, then what about the second assignments to a and b; aren't the :| operators in those expressions also functions? Yes, they are, but they are different functions. They are functions of different colors, to follow that analogy. As long as you think of every occurrence of :| in your program as being a different function, then all mathematics work out as you'd expect.\n\nThis is why it was easier for me to describe the Sum situation if I could use just one :|. To reuse that same :|, I placed it in a function, which I named Pick. I recommend you do the same if you're working with ghost functions that involve choices that you want to prove properties about.\n\n\n# 6. Different choices\n\nIf you tried to define Sum and use it in AddElement before understanding these issues, you would be perplexed. Now, you know that it is easier to put :| into a function by itself, and you know that you'll need to write a lemma like SumMyWay. You may be curious if it's possible to do without the Pick function. That is, you may wonder if there's any way to use one :| operator in Sum and another :| operator in SumMyWay. Yes, it is possible. Let me show you how.\n\nSuppose we inline Pick in function Sum. That is, suppose we define Sum as in Section 4 above. In that section, I mentioned that you'll get a couple of errors if you also inline Pick in SumMyWay. Both of those errors stem from the fact that Sum and SumMyWay make different choices. But we can be more specific in the lemma, to force it to choose the same element as the one chosen in Sum.\n\nYou can do that by saying you want x not just to be in s, but to be a value that makes\n\nSum(s) == x + Sum(s - {x})\n\n\n1\n\n\nhold true. Only one such x exists, and it's the one that Sum chooses. So, if you write lemma as follows:\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s && Sum(s) == x + Sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthen it verifies! This is good to know, but it seems cleaner to introduce the function Pick around your :|.\n\n\n# 7. Summary\n\nBeware that every textual occurrence of :| in your program is a different function. You'll have a simpler time working with :| if you roll it into a function that you name, because then you reduce the chance of becoming confused because of different kinds (different “colors”) of choices.\n\nAlso, beware that the choice made by :| may not be the choice you need. You'll probably want to prove a lemma that says any choice gives the same result in the end. Use lemma SumMyWay above as a template for your proof.",normalizedContent:"dafny power user: functions over set elements\n\nk. rustan m. leino\n\nmanuscript krml 274, 16 february 2020\n\nabstract. in natural language, it is easy to say and understand a phrase like “the sum of the numbers in a set”. defining and working with such functions in a formal settings is more work. the problem has to do with how a recursively defined function picks the next element from a set. this note describes a representative example and describes how to make the formal mumbo-jumbo work out. the solution can be applied to any commutative and associative operation on a set.\n\n\n# 0. summing the elements of a set\n\nsuppose we have a function that returns the sum of the integers in a set:\n\nfunction sum(s: set<int>): int\n\n\n1\n\n\nif we add an element y to a set, we expect its sum to go up by y. that is, we expect that the following method is correctly implemented:\n\nmethod addelement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == sum(s) && y !in s\n  ensures t == s + {x} && b == sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nit turns out, the proof is not automatic. let's look at the details and fill in the proof.\n\n\n# 1. recursive definition of sum\n\nfunction sum is defined recursively. the sum of the empty set is 0. if the set is nonempty, pick one of its elements, say x. then, add x to the recursively computed sum of the remaining elements.\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := pick(s);\n    x + sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nthis definition uses a function pick, which returns an arbitrary element from a given set. here is its definition:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\ni'll come back to pick later. all you need to understand at this time is that the caller of pick has no control over which element of s is returned.\n\n\n# 2. the proof that fails\n\nto prove addelement, we need to show b == sum(t) holds in its final state. working backwards over the assignments, this means we need to show\n\na + y == sum(s + {y})\n\n\n1\n\n\nin the initial state. since a is sum(s), our proof obligation comes down to\n\nsum(s) + y == sum(s + {y})\n\n\n1\n\n\nwhere we are given that y is not in s.\n\nsuppose pick(s + {y}) returns y. then, we have\n\n  sum(s + {y});\n==  // def. sum\n  var x := pick(s + {y}); x + sum(s + {y} - {x});\n==  // using the assumption pick(s + {y}) == y\n  y + sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthat was easy and straightforward. but for this proof, we assumed that the relevant call to pick returned y. what if pick returns a different element from s?\n\n\n# 3. picking something else\n\nbefore you realize pick can choose a different element than the one you have in mind, the clouds start to clear. what we need is a lemma that says the choice is immaterial. that is, the lemma will let us treat sum as if it picks, when doing its recursive call, an element that we specify.\n\nhere is that lemma. the proof is also a little tricky at first. it comes down to letting pick choose whatever element it chooses, and then applying the induction hypothesis on the smaller set that sum recurses on.\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x := pick(s);\n  if y == x {\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\ni stated the lemma to look like the expressions in the body of sum, so the two arguments to sum are s and s - {y}. alternatively, we can state the property in terms of calls to sum with the arguments s + {y} and s. this alternative is a simple corollary of the lemma above:\n\nlemma addtosum(s: set<int>, y: int)\n  requires y !in s\n  ensures sum(s + {y}) == sum(s) + y\n{\n  summyway(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nusing the lemma\n\nequipped with the useful lemma, it's easy to get the proof of addelement go through: change its body to\n\nt := s + {y};\nb := a + y;\naddtosum(s, y);\n\n\n1\n2\n3\n\n\n\n# 4. inlining pick\n\nin the development above, i define pick as a separate function. reading the word “pick” in the program text may help understand what sum and summyway do. but it's such a small function, so why not just inline it in the two places where it's used. let's try it:\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to pick\n    x + sum(s - {x})\n}\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum        // error: this step might not hold\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nwe now get two errors!\n\nto explain what's going on, let me say a little more about :| and what makes it unusual.\n\n\n# 5. let such that\n\nthe let-such-that construct in dafny has the form\n\nvar x :| p; e\n\n\n1\n\n\nit evaluates to e, where x is bound to some value satisfying p. for example,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nevaluates to 14, 16, or 18. as the programmer, you have no control over which value of x is chosen. but you do get to know two important things. one is that x will be chosen to be a value that satisfies p. (the dafny verifier gives an error if it cannot prove such a value to exist.) the other is that you will get the same value every time you evaluate the expression with the same inputs. in other words, the operator is deterministic.\n\nhere is another example to illustrate the point about determinism:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nthis expression chooses x to be one of the three smallest primes (2, 3, or 5) and then returns it. you don't know which of the three values you get, but you are guaranteed that every time this expression is evaluated within one run of a program, you will get the same value.\n\nlet's be more precise about what i mean by “this expression”. in dafny, every textual occurrence of a let-such-that expression gets to make its own choices. one way to think about this is to go through the text of your program and to color each :| operator with a unique color. then, you can rely on choices being the same only if they are performed by the same-color :|.\n\nhere is an illustrative example.\n\nlemma choices(s: set<int>)\n  requires s != {}\n{\n  var a := pick(s);\n  var b := pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe first values assigned to a and b originate from the same :| operator. they are the results of choices of the same color. therefore, they are known to be the same. in contrast, the next values assigned to a and b originate from different :| operators—ones of different colors. therefore, you cannot be sure a and b are equal.\n\nactually, if you think about it a little more (or, maybe, a little less), then you realize that we know the first values assigned to a and b to be equal even without knowing anything about the body of pick. after all, pick is a function, and if you call a function twice on the same arguments, it will give you back the same value. mathematics guarantees this, and so does dafny. so, then what about the second assignments to a and b; aren't the :| operators in those expressions also functions? yes, they are, but they are different functions. they are functions of different colors, to follow that analogy. as long as you think of every occurrence of :| in your program as being a different function, then all mathematics work out as you'd expect.\n\nthis is why it was easier for me to describe the sum situation if i could use just one :|. to reuse that same :|, i placed it in a function, which i named pick. i recommend you do the same if you're working with ghost functions that involve choices that you want to prove properties about.\n\n\n# 6. different choices\n\nif you tried to define sum and use it in addelement before understanding these issues, you would be perplexed. now, you know that it is easier to put :| into a function by itself, and you know that you'll need to write a lemma like summyway. you may be curious if it's possible to do without the pick function. that is, you may wonder if there's any way to use one :| operator in sum and another :| operator in summyway. yes, it is possible. let me show you how.\n\nsuppose we inline pick in function sum. that is, suppose we define sum as in section 4 above. in that section, i mentioned that you'll get a couple of errors if you also inline pick in summyway. both of those errors stem from the fact that sum and summyway make different choices. but we can be more specific in the lemma, to force it to choose the same element as the one chosen in sum.\n\nyou can do that by saying you want x not just to be in s, but to be a value that makes\n\nsum(s) == x + sum(s - {x})\n\n\n1\n\n\nhold true. only one such x exists, and it's the one that sum chooses. so, if you write lemma as follows:\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s && sum(s) == x + sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthen it verifies! this is good to know, but it seems cleaner to introduce the function pick around your :|.\n\n\n# 7. summary\n\nbeware that every textual occurrence of :| in your program is a different function. you'll have a simpler time working with :| if you roll it into a function that you name, because then you reduce the chance of becoming confused because of different kinds (different “colors”) of choices.\n\nalso, beware that the choice made by :| may not be the choice you need. you'll probably want to prove a lemma that says any choice gives the same result in the end. use lemma summyway above as a template for your proof.",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Iterating over a Collection",frontmatter:{title:"Iterating over a Collection",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c4484e/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/35.Iterating%20over%20a%20Collection.html",relativePath:"80.语言/30.publication-lecture/35.Iterating over a Collection.md",key:"v-6754fb32",path:"/pages/c4484e/",headers:[{level:2,title:"0. Map to sequence",slug:"_0-map-to-sequence",normalizedTitle:"0. map to sequence",charIndex:830},{level:2,title:"1. A ghost function",slug:"_1-a-ghost-function",normalizedTitle:"1. a ghost function",charIndex:2422},{level:2,title:"2. Making the function compilable",slug:"_2-making-the-function-compilable",normalizedTitle:"2. making the function compilable",charIndex:2944},{level:2,title:"3. Choosing the smallest integer",slug:"_3-choosing-the-smallest-integer",normalizedTitle:"3. choosing the smallest integer",charIndex:3844},{level:2,title:"4. Proving there's a minimum",slug:"_4-proving-there-s-a-minimum",normalizedTitle:"4. proving there's a minimum",charIndex:5155},{level:2,title:"5. Total orders",slug:"_5-total-orders",normalizedTitle:"5. total orders",charIndex:7175},{level:2,title:"6. Generic set to sequence",slug:"_6-generic-set-to-sequence",normalizedTitle:"6. generic set to sequence",charIndex:9034},{level:2,title:"7. Total order has minimum",slug:"_7-total-order-has-minimum",normalizedTitle:"7. total order has minimum",charIndex:9899},{level:2,title:"8. Coming back to map to sequence",slug:"_8-coming-back-to-map-to-sequence",normalizedTitle:"8. coming back to map to sequence",charIndex:13500},{level:2,title:"9. Conclusion",slug:"_9-conclusion",normalizedTitle:"9. conclusion",charIndex:14195},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:14306}],headersStr:"0. Map to sequence 1. A ghost function 2. Making the function compilable 3. Choosing the smallest integer 4. Proving there's a minimum 5. Total orders 6. Generic set to sequence 7. Total order has minimum 8. Coming back to map to sequence 9. Conclusion References",content:"Dafny Power User: Iterating over a Collection\n\nK. Rustan M. Leino\n\nManuscript KRML 275, 17 February 2020\n\nAbstract. Processing the contents of a set or map in a deterministic way takes some work. Using a representative example, this note shows a way to do it.\n\nMathematical collection types include sets, multisets, sequences, and maps. These are essential to specifications as well as programs. Defining functions over the elements of such collections is more difficult (or at least more labor intensive) than one would expect. In this note, I develop the program and proof for an example that converts a map to a sequence of pairs. The central part of the work concerns getting a compilable function that returns a set's elements into a predictable order.\n\nThroughout this note, the goal is to produce compilable functions.\n\n\n# 0. Map to sequence\n\nA map is set of key-value pairs, where no key is repeated. We can convert a map to a sequence by putting its keys into a sequence and then making pairs by retrieving the value for each key:\n\nfunction method MapToSequence<A,B>(m: map<A,B>): seq<(A,B)> {\n  var keys := SetToSequence(m.Keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor a map m, the expression m.Keys gives the set of keys. Function MapToSequence passes this set of keys to SetToSequence to obtain a sequence of these keys. Then, the sequence constructor\n\nseq(n, f)\n\n\n1\n\n\nproduces a sequence of length n, where the element with index i is specified to be f(i). In MapToSequence, the second argument to the sequence comprehension is a partial function given by the lambda expression\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nFor an index in the given range, this function returns a pair consisting of the key keys[i] and its corresponding value in m. It is necessary to give the range of i in the function's precondition, or else the expression keys[i] would give rise to an index-of-out-bounds error.\n\nTo avoid a key-is-not-in-map error in the expression m[keys[i]], we need to know that keys[i] is a key of m. That requires us to know a connection between m.Keys and keys, which is stated in the postcondition of the (not yet implemented) function SetToSequence.\n\nWe now need to implement SetToSequence.\n\n\n# 1. A ghost function\n\nLet's start easy. We'll define SetToSequence as a ghost function. The definition is recursive. When the given set is nonempty, the function uses the choose operator, aka the let-such-that operator and written :|, to pick an element from the set.\n\nfunction SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThat wasn't too bad.\n\n\n# 2. Making the function compilable\n\nTo make the SetToSequence we wrote above compilable, we change the keyword function to the keyword phrase function method. This generates an error message:\n\n> to be compilable, the value of a let-such-that expression must be uniquely determined\n\nExpressions—and functions, whose bodies are expressions—must be deterministic in Dafny. This means that\n\nvar x :| x in s;\n\n\n1\n\n\nalways needs to pick the same value for x when given the same s. This would be computationally expensive to do at run time, so Dafny instead puts this burden on the programmer (see [0]).\n\nOne idea is for us to strengthen the condition x in s to always pick “the minimum” value from s. This would uniquely determine the value of the let-such-that expression. But what does “minimum” mean? Let's start with integers, where we know what minimum is, and then work up to a general situation.\n\n\n# 3. Choosing the smallest integer\n\nFor now, we'll restrict our attention to integer sets. This lets us strengthen the condition in the let-such-that expression to uniquely talk about the minimum element of the set:\n\nfunction method SetToSequence(s: set<int>): seq<int>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThe “uniquely determined” requirement is now satisfied. However, since our new such-that predicate is more complicated, the verifier issues a different complaint:\n\n> cannot establish the existence of a LHS value that satisfies the such-that predicate\n\nIt may seem clear to us that a nonempty set has a minimum element, but we need to convince the verifier of it. Let's do this in a separate lemma, which we declare as follows:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\nWe'll insert a call to this lemma just before the let-such-expression in SetToSequence. The body of that function thus becomes\n\nif s == {} then [] else\n  ThereIsAMinimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + SetToSequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4. Proving there's a minimum\n\nOur next task is to give a proof for the ThereIsAMinimum lemma. Here is an annotated proof:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // The minimum in s might be x, or it might be the minimum\n    // in s - {x}. If we knew the minimum of the latter, then\n    // we could compare the two.\n    // Let's start by giving a name to the smaller set:\n    var s' := s - {x};\n    // So, s is the union of s' and {x}:\n    assert s == s' + {x};\n    // The following lemma call establishes that there is a\n    // minimum in s'.\n    ThereIsAMinimum(s');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThe proof starts by picking an arbitrary element, x, from s. It is the minimum if it's the only element in s. Otherwise, the proof brings out the fact that s is s' + {x}. The recursive call to the lemma gives us, through its postcondition, that there exists a minimum element in s'. The verifier automatically supplies the remaining proof glue, so we're done.\n\nThe assertion in the proof may seem silly. We just defined s' to be s - {x}. Since x is in s, the property s == s' + {x} follows immediately. Yes, it does. The verifier can easily confirm this, but verifier is not creative enough to realize that this is a good property to know. This is typical when working with collections. For example, if you're working with a sequence q, you may consider q[0] separately and do a recursive call on q[1..]. If so, you're likely to need to manually supply\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nAs with the set property, the verifier easily proves this property, but wouldn't have thought of it by itself.\n\nThe moral of the proof is that it's a good idea, when you split a collection into smaller pieces that you want to reason about separately, to assert that the whole collection equals the combination of the smaller pieces.\n\n\n# 5. Total orders\n\nThe restriction to integer sets above was nice to work with, because the minimum of a set of integers is easy to define and gives a unique element. To apply the same trick other types, we need to be able to define a “minimum” for those types, too. To define a minimum, you need a total order. Let's review what that means.\n\nA relation over a type A is a function (A, A) -> bool. Such a relation, call it R, is known as a partial order when the following three conditions hold:\n\n * R is reflexive, that is, forall a :: R(a, a)\n * R is antisymmetric, that is, forall a, b :: R(a, b) && R(b, a) ==> a == b\n * R is transitive, that is, forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c)\n\nA total order is a partial order that additionally satisfies the following condition:\n\n * R is connex (closely connected), that is, forall a, b :: R(a, b) || R(b, a)\n\nNote that connexity implies reflexivity.\n\nHere is a predicate that says whether or not a given relation is a total order:\n\npredicate IsTotalOrder<A(!new)>(R: (A, A) -> bool) {\n  // connexity\n  && (forall a, b :: R(a, b) || R(b, a))\n  // antisymmetry\n  && (forall a, b :: R(a, b) && R(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nDafny won't allow us to write these quantifiers in the predicate, unless it knows a little more about type A. If A were a class type, then forall in Dafny means quantifying over the allocated instances of class A. That would mean that allocating another A instance could cause IsTotalOrder(R) to change values. To prevent this, Dafny insists that unbounded quantifications like those in IsTotalOrder be over types that do not depend on the allocated state. We express that with the type characteristic (!new), which is written as a suffix of the type name in the type-parameter declaration.\n\n\n# 6. Generic set to sequence\n\nWe revise SetToSequence to also take a relation, R, which we require to be a total order. In doing so, we change the total order <= on integers to R, and we also add R as a parameter to the ThereIsAMinimum lemma:\n\nfunction method SetToSequence<A(!new)>(s: set<A>, R: (A, A) -> bool): seq<A>\n  requires IsTotalOrder(R)\n  ensures var q := SetToSequence(s, R);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    ThereIsAMinimum(s, R);\n    var x :| x in s && forall y :: y in s ==> R(x, y);\n    [x] + SetToSequence(s - {x}, R)\n}\n\nlemma ThereIsAMinimum<A(!new)>(s: set<A>, R: (A, A) -> bool)\n  requires s != {} && IsTotalOrder(R)\n  ensures exists x :: x in s && forall y :: y in s ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThe revised SetToSequence lemma verifies. Our remaining task is to prove the lemma.\n\n\n# 7. Total order has minimum\n\nWe start the proof of our generic ThereIsAMinimum like the analogous proof for integer sets above:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThe case that was “obvious” before is causing the verifier trouble this time. Let's help it out. Our proof obligation is to show there's some element in s that is as small as any element in s. If s is the singleton set {x}, then the element we're looking for can only be x. Now, if y is an element in s, we need to prove R(x, y). Since s is a singleton, we have y == x, and then R(x, y) follows from connexity. The verifier is missing one of both of these facts. Let's add an assertion about the first fact:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nAh, yes, the verifier can prove this assertion and can then do the rest of the proof.\n\nOn to the non-singleton case. We'll start like in the integer-set proof above:\n\n  } else {\n    var s' := s - {x};\n    assert s == s' + {x};\n    ThereIsAMinimum(s', R);\n\n\n1\n2\n3\n4\n\n\nThe verifier complains the lemma's postcondition might not hold, so we'll give the verifier more help.\n\nThe recursive call to the lemma (which, by the way, is known as “the induction hypothesis”) says there is a minimum in s'. Let's give it a name, which we do by introducing a local variable whose value we constrain to satisfy the condition in the lemma's postcondition's existential quantifier:\n\n    var z :| z in s' && forall y :: y in s' ==> R(z, y);\n\n\n1\n\n\nSince s is s' + {x}, the minimum we're looking for is either z or x. Let's treat these cases separately. We do that by using an if statement. Since the two cases are so symmetric, I think it looks nice to use Dafny's if-case statement:\n\n    // by connexity, one of the two cases below applies\n    if\n    case R(z, x) =>\n      // prove z is the minimum not just of s', but of s\n      // ...\n    case R(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nLet's do the R(z, x) case first. The hard part is likely to be the quantifier in the postcondition, so let's start with it. To give a proof of a universal quantifier, you use a forall statement.\n\n      forall y | y in s\n        ensures R(z, y)\n      {\n\n\n1\n2\n3\n\n\nFrom y in s, we know either y is x or y is in s'. For the former, the proof follows from the guard R(z, x). For the latter, the proof follows from the quantification in the such-that condition we used to introduce z. Somehow, the verifier is not picking up on this, so let's help it along. We start here:\n\n        assert x == y || y in s';\n      }\n\n\n1\n2\n\n\nLo and behold! That's all the verifier needed.\n\nIn the R(x, z) case, we'll lay down the analogous forall statement to prove the quantifier in the lemma's postcondition:\n\n      forall y | y in s\n        ensures R(x, y)\n      {\n\n\n1\n2\n3\n\n\nIf y is x, then R(x, y) follows from connexity. On the other hand, if y is in s', then the such-that condition that introduced z tells us R(z, y), so we get R(x, y) by transitivity. You may add these hints in various ways to make the proof go through. Here is one way:\n\n        assert y in s' ==> R(z, y);\n      }\n\n\n1\n2\n\n\nA final remark. When we proved ThereIsAMinimum for integer sets, I argued that it's often useful to include an assertion like:\n\n    assert s == s' + {x};\n\n\n1\n\n\nI included it in the generic ThereIsAMinimum as well. But as it turns out, it's not actually needed there (because we made up for it in the additional hints we gave in the two cases), so you can delete it, if you want.\n\n\n# 8. Coming back to map to sequence\n\nWe did it!\n\nWell, before we declare success, let's just make sure we can use our functions and lemmas to write the MapToSequence function that we set out to write. Here's the generic version, which needs a given total order:\n\nfunction method MapToSequence<A(!new),B>(m: map<A,B>, R: (A, A) -> bool): seq<(A,B)>\n  requires IsTotalOrder(R)\n{\n  var keys := SetToSequence(m.Keys, (a,a') => R(a, a'));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nWe can also specialize it for integer sets:\n\nfunction method IntMapToSequence<B>(m: map<int,B>): seq<(int,B)> {\n  MapToSequence(m, (a, a') => a <= a')\n}\n\n\n1\n2\n3\n\n\nWe did it!\n\n\n# 9. Conclusion\n\nI hope this long journey showed you a thing or two about working with collections in Dafny.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations, volume 35 of EPiC Series in Computing, pages 106–118. EasyChair, 2015. 🔎",normalizedContent:"dafny power user: iterating over a collection\n\nk. rustan m. leino\n\nmanuscript krml 275, 17 february 2020\n\nabstract. processing the contents of a set or map in a deterministic way takes some work. using a representative example, this note shows a way to do it.\n\nmathematical collection types include sets, multisets, sequences, and maps. these are essential to specifications as well as programs. defining functions over the elements of such collections is more difficult (or at least more labor intensive) than one would expect. in this note, i develop the program and proof for an example that converts a map to a sequence of pairs. the central part of the work concerns getting a compilable function that returns a set's elements into a predictable order.\n\nthroughout this note, the goal is to produce compilable functions.\n\n\n# 0. map to sequence\n\na map is set of key-value pairs, where no key is repeated. we can convert a map to a sequence by putting its keys into a sequence and then making pairs by retrieving the value for each key:\n\nfunction method maptosequence<a,b>(m: map<a,b>): seq<(a,b)> {\n  var keys := settosequence(m.keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor a map m, the expression m.keys gives the set of keys. function maptosequence passes this set of keys to settosequence to obtain a sequence of these keys. then, the sequence constructor\n\nseq(n, f)\n\n\n1\n\n\nproduces a sequence of length n, where the element with index i is specified to be f(i). in maptosequence, the second argument to the sequence comprehension is a partial function given by the lambda expression\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nfor an index in the given range, this function returns a pair consisting of the key keys[i] and its corresponding value in m. it is necessary to give the range of i in the function's precondition, or else the expression keys[i] would give rise to an index-of-out-bounds error.\n\nto avoid a key-is-not-in-map error in the expression m[keys[i]], we need to know that keys[i] is a key of m. that requires us to know a connection between m.keys and keys, which is stated in the postcondition of the (not yet implemented) function settosequence.\n\nwe now need to implement settosequence.\n\n\n# 1. a ghost function\n\nlet's start easy. we'll define settosequence as a ghost function. the definition is recursive. when the given set is nonempty, the function uses the choose operator, aka the let-such-that operator and written :|, to pick an element from the set.\n\nfunction settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthat wasn't too bad.\n\n\n# 2. making the function compilable\n\nto make the settosequence we wrote above compilable, we change the keyword function to the keyword phrase function method. this generates an error message:\n\n> to be compilable, the value of a let-such-that expression must be uniquely determined\n\nexpressions—and functions, whose bodies are expressions—must be deterministic in dafny. this means that\n\nvar x :| x in s;\n\n\n1\n\n\nalways needs to pick the same value for x when given the same s. this would be computationally expensive to do at run time, so dafny instead puts this burden on the programmer (see [0]).\n\none idea is for us to strengthen the condition x in s to always pick “the minimum” value from s. this would uniquely determine the value of the let-such-that expression. but what does “minimum” mean? let's start with integers, where we know what minimum is, and then work up to a general situation.\n\n\n# 3. choosing the smallest integer\n\nfor now, we'll restrict our attention to integer sets. this lets us strengthen the condition in the let-such-that expression to uniquely talk about the minimum element of the set:\n\nfunction method settosequence(s: set<int>): seq<int>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthe “uniquely determined” requirement is now satisfied. however, since our new such-that predicate is more complicated, the verifier issues a different complaint:\n\n> cannot establish the existence of a lhs value that satisfies the such-that predicate\n\nit may seem clear to us that a nonempty set has a minimum element, but we need to convince the verifier of it. let's do this in a separate lemma, which we declare as follows:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\nwe'll insert a call to this lemma just before the let-such-expression in settosequence. the body of that function thus becomes\n\nif s == {} then [] else\n  thereisaminimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + settosequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4. proving there's a minimum\n\nour next task is to give a proof for the thereisaminimum lemma. here is an annotated proof:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // the minimum in s might be x, or it might be the minimum\n    // in s - {x}. if we knew the minimum of the latter, then\n    // we could compare the two.\n    // let's start by giving a name to the smaller set:\n    var s' := s - {x};\n    // so, s is the union of s' and {x}:\n    assert s == s' + {x};\n    // the following lemma call establishes that there is a\n    // minimum in s'.\n    thereisaminimum(s');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthe proof starts by picking an arbitrary element, x, from s. it is the minimum if it's the only element in s. otherwise, the proof brings out the fact that s is s' + {x}. the recursive call to the lemma gives us, through its postcondition, that there exists a minimum element in s'. the verifier automatically supplies the remaining proof glue, so we're done.\n\nthe assertion in the proof may seem silly. we just defined s' to be s - {x}. since x is in s, the property s == s' + {x} follows immediately. yes, it does. the verifier can easily confirm this, but verifier is not creative enough to realize that this is a good property to know. this is typical when working with collections. for example, if you're working with a sequence q, you may consider q[0] separately and do a recursive call on q[1..]. if so, you're likely to need to manually supply\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nas with the set property, the verifier easily proves this property, but wouldn't have thought of it by itself.\n\nthe moral of the proof is that it's a good idea, when you split a collection into smaller pieces that you want to reason about separately, to assert that the whole collection equals the combination of the smaller pieces.\n\n\n# 5. total orders\n\nthe restriction to integer sets above was nice to work with, because the minimum of a set of integers is easy to define and gives a unique element. to apply the same trick other types, we need to be able to define a “minimum” for those types, too. to define a minimum, you need a total order. let's review what that means.\n\na relation over a type a is a function (a, a) -> bool. such a relation, call it r, is known as a partial order when the following three conditions hold:\n\n * r is reflexive, that is, forall a :: r(a, a)\n * r is antisymmetric, that is, forall a, b :: r(a, b) && r(b, a) ==> a == b\n * r is transitive, that is, forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c)\n\na total order is a partial order that additionally satisfies the following condition:\n\n * r is connex (closely connected), that is, forall a, b :: r(a, b) || r(b, a)\n\nnote that connexity implies reflexivity.\n\nhere is a predicate that says whether or not a given relation is a total order:\n\npredicate istotalorder<a(!new)>(r: (a, a) -> bool) {\n  // connexity\n  && (forall a, b :: r(a, b) || r(b, a))\n  // antisymmetry\n  && (forall a, b :: r(a, b) && r(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ndafny won't allow us to write these quantifiers in the predicate, unless it knows a little more about type a. if a were a class type, then forall in dafny means quantifying over the allocated instances of class a. that would mean that allocating another a instance could cause istotalorder(r) to change values. to prevent this, dafny insists that unbounded quantifications like those in istotalorder be over types that do not depend on the allocated state. we express that with the type characteristic (!new), which is written as a suffix of the type name in the type-parameter declaration.\n\n\n# 6. generic set to sequence\n\nwe revise settosequence to also take a relation, r, which we require to be a total order. in doing so, we change the total order <= on integers to r, and we also add r as a parameter to the thereisaminimum lemma:\n\nfunction method settosequence<a(!new)>(s: set<a>, r: (a, a) -> bool): seq<a>\n  requires istotalorder(r)\n  ensures var q := settosequence(s, r);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    thereisaminimum(s, r);\n    var x :| x in s && forall y :: y in s ==> r(x, y);\n    [x] + settosequence(s - {x}, r)\n}\n\nlemma thereisaminimum<a(!new)>(s: set<a>, r: (a, a) -> bool)\n  requires s != {} && istotalorder(r)\n  ensures exists x :: x in s && forall y :: y in s ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthe revised settosequence lemma verifies. our remaining task is to prove the lemma.\n\n\n# 7. total order has minimum\n\nwe start the proof of our generic thereisaminimum like the analogous proof for integer sets above:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthe case that was “obvious” before is causing the verifier trouble this time. let's help it out. our proof obligation is to show there's some element in s that is as small as any element in s. if s is the singleton set {x}, then the element we're looking for can only be x. now, if y is an element in s, we need to prove r(x, y). since s is a singleton, we have y == x, and then r(x, y) follows from connexity. the verifier is missing one of both of these facts. let's add an assertion about the first fact:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nah, yes, the verifier can prove this assertion and can then do the rest of the proof.\n\non to the non-singleton case. we'll start like in the integer-set proof above:\n\n  } else {\n    var s' := s - {x};\n    assert s == s' + {x};\n    thereisaminimum(s', r);\n\n\n1\n2\n3\n4\n\n\nthe verifier complains the lemma's postcondition might not hold, so we'll give the verifier more help.\n\nthe recursive call to the lemma (which, by the way, is known as “the induction hypothesis”) says there is a minimum in s'. let's give it a name, which we do by introducing a local variable whose value we constrain to satisfy the condition in the lemma's postcondition's existential quantifier:\n\n    var z :| z in s' && forall y :: y in s' ==> r(z, y);\n\n\n1\n\n\nsince s is s' + {x}, the minimum we're looking for is either z or x. let's treat these cases separately. we do that by using an if statement. since the two cases are so symmetric, i think it looks nice to use dafny's if-case statement:\n\n    // by connexity, one of the two cases below applies\n    if\n    case r(z, x) =>\n      // prove z is the minimum not just of s', but of s\n      // ...\n    case r(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlet's do the r(z, x) case first. the hard part is likely to be the quantifier in the postcondition, so let's start with it. to give a proof of a universal quantifier, you use a forall statement.\n\n      forall y | y in s\n        ensures r(z, y)\n      {\n\n\n1\n2\n3\n\n\nfrom y in s, we know either y is x or y is in s'. for the former, the proof follows from the guard r(z, x). for the latter, the proof follows from the quantification in the such-that condition we used to introduce z. somehow, the verifier is not picking up on this, so let's help it along. we start here:\n\n        assert x == y || y in s';\n      }\n\n\n1\n2\n\n\nlo and behold! that's all the verifier needed.\n\nin the r(x, z) case, we'll lay down the analogous forall statement to prove the quantifier in the lemma's postcondition:\n\n      forall y | y in s\n        ensures r(x, y)\n      {\n\n\n1\n2\n3\n\n\nif y is x, then r(x, y) follows from connexity. on the other hand, if y is in s', then the such-that condition that introduced z tells us r(z, y), so we get r(x, y) by transitivity. you may add these hints in various ways to make the proof go through. here is one way:\n\n        assert y in s' ==> r(z, y);\n      }\n\n\n1\n2\n\n\na final remark. when we proved thereisaminimum for integer sets, i argued that it's often useful to include an assertion like:\n\n    assert s == s' + {x};\n\n\n1\n\n\ni included it in the generic thereisaminimum as well. but as it turns out, it's not actually needed there (because we made up for it in the additional hints we gave in the two cases), so you can delete it, if you want.\n\n\n# 8. coming back to map to sequence\n\nwe did it!\n\nwell, before we declare success, let's just make sure we can use our functions and lemmas to write the maptosequence function that we set out to write. here's the generic version, which needs a given total order:\n\nfunction method maptosequence<a(!new),b>(m: map<a,b>, r: (a, a) -> bool): seq<(a,b)>\n  requires istotalorder(r)\n{\n  var keys := settosequence(m.keys, (a,a') => r(a, a'));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nwe can also specialize it for integer sets:\n\nfunction method intmaptosequence<b>(m: map<int,b>): seq<(int,b)> {\n  maptosequence(m, (a, a') => a <= a')\n}\n\n\n1\n2\n3\n\n\nwe did it!\n\n\n# 9. conclusion\n\ni hope this long journey showed you a thing or two about working with collections in dafny.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning — short presentations, volume 35 of epic series in computing, pages 106–118. easychair, 2015. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"old and unchanged",frontmatter:{title:"old and unchanged",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/7fe522/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/40.old%20and%20unchanged.html",relativePath:"80.语言/30.publication-lecture/40.old and unchanged.md",key:"v-6cd0ba1b",path:"/pages/7fe522/",headers:[{level:2,title:"0. The essence",slug:"_0-the-essence",normalizedTitle:"0. the essence",charIndex:195},{level:2,title:"1. modifies",slug:"_1-modifies",normalizedTitle:"1. modifies",charIndex:803},{level:2,title:"2. Frame expressions",slug:"_2-frame-expressions",normalizedTitle:"2. frame expressions",charIndex:2397},{level:3,title:"2.0. old",slug:"_2-0-old",normalizedTitle:"2.0. old",charIndex:2974},{level:3,title:"2.1. unchanged",slug:"_2-1-unchanged",normalizedTitle:"2.1. unchanged",charIndex:3807},{level:2,title:"3. The fine print",slug:"_3-the-fine-print",normalizedTitle:"3. the fine print",charIndex:4848},{level:3,title:"3.0. modifies determined in pre-state",slug:"_3-0-modifies-determined-in-pre-state",normalizedTitle:"3.0. modifies determined in pre-state",charIndex:4870},{level:3,title:"3.1. old only affects the heap",slug:"_3-1-old-only-affects-the-heap",normalizedTitle:"3.1. old only affects the heap",charIndex:6255},{level:3,title:"3.2. modifies permission is checked immediately",slug:"_3-2-modifies-permission-is-checked-immediately",normalizedTitle:"3.2. modifies permission is checked immediately",charIndex:9909},{level:2,title:"4. Advanced features",slug:"_4-advanced-features",normalizedTitle:"4. advanced features",charIndex:10738},{level:3,title:"4.0. More precise frame expressions",slug:"_4-0-more-precise-frame-expressions",normalizedTitle:"4.0. more precise frame expressions",charIndex:10763},{level:3,title:"4.1. State labels",slug:"_4-1-state-labels",normalizedTitle:"4.1. state labels",charIndex:13095}],headersStr:"0. The essence 1. modifies 2. Frame expressions 2.0. old 2.1. unchanged 3. The fine print 3.0. modifies determined in pre-state 3.1. old only affects the heap 3.2. modifies permission is checked immediately 4. Advanced features 4.0. More precise frame expressions 4.1. State labels",content:"Dafny Power User: old and unchanged\n\nK. Rustan M. Leino\n\nManuscript KRML 273, 15 February 2020\n\nAbstract. This note addresses the question \"What's the difference between old and unchanged?\".\n\n\n# 0. The essence\n\nIn a nutshell, the expression old(E) denotes the value of expression E evaluated in the pre-state of the enclosing method. The expression unchanged(R) says that the values of the fields of the object denoted by expression R are the same as in the pre-state.\n\nFor instance, consider the following classes, which I will use throughout this note:\n\nclass C {\n  var x: int\n  var y: D\n  // ...\n}\nclass D {\n  var z: int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIf c is a parameter of type C, then the expression unchanged(c)means\n\nold(c.x) == c.x && old(c.y) == c.y\n\n\n1\n\n\nBut there's more, if you want to know it.\n\n\n# 1. modifies\n\nLet's review modifies clauses on methods.\n\nA method must declare the set of (previously allocated) objects whose fields it might modify. So, if a method method M(c: C) wants to do an assignment like\n\nc.x := 10;\n\n\n1\n\n\nor\n\nc.x := c.x + 2;\n\n\n1\n\n\nthen its specification must include the object reference c in its modifies clause, like so:\n\nmethod M(c: C)\n  modifies c\n\n\n1\n2\n\n\nThis specification gives M permission to modify the fields of c.\n\nExercise 0. What does the following specification mean?\n\nmethod M(c: C, d: D)\n  modifies c.y\n\n\n1\n2\n\n\nAnswer. It gives M permission to modify the fields of c.y. For example, the body of M can do the following assignment:\n\nc.y.z := 15;\n\n\n1\n\n\nIt does not give M the permission to modify the y field of object c. For example, the following is not allowed:\n\nc.y := d;  // error: not allowed by modifies clause \n\n\n1\n\n\nA modifies clause is not transitive. That is, modifies c gives permission to modify the fields of c, but not their fields. In particular, the assignment\n\nc.y.z := 20;\n\n\n1\n\n\nis not allowed by the specification modifies c.\n\nMethods are always allowed to allocate new objects and modify their fields, even without any mention in the modifies clause. So, here's a way to ensure that c.y.z has a post-value of 20:\n\nmethod M(c: C)\n  modifies c\n  ensures c.y.z == 20\n{\n  c.y := new D;  // allowed because c is in the modifies clause\n  c.y.z := 20;   // allowed because c.y is newly allocated\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that this program swap out c.y for a new object. The object previously referenced by c.y is not changed by method M.\n\n\n# 2. Frame expressions\n\nWhat follows the modifies keyword is a list of frame expressions. A frame expression denotes a set of objects (or arrays).\n\nFor convenience, a frame expression can be given as a set of object or as a single object. The latter is shorthand for the singleton set containing that object. The modifies clause denotes the set union of the objects denoted by each frame expression in the list. For example,\n\nmethod P(c: C, d: D, S: set<object>)\n  modifies c, d, S\n\n\n1\n2\n\n\nis the same as\n\nmethod P(c: C, d: D, S: set<object>)\n  modifies {c} + {d} + S\n\n\n1\n2\n\n\n\n# 2.0. old\n\nIf you want to say that M has the effect of increasing the value of c.x, then you write a two-state postcondition that mentions the value of c.x in both the method's pre-state and the method's post-state. The former is notated by old(c.x), and the latter simply by c.x:\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) < c.x\n\n\n1\n2\n3\n\n\nThis specification says nothing about the post-value of c.y. More precisely, the modifies clause gives M permission to update all of the fields of c and the ensures clause does not constrain the final value of c.y.\n\nIf you want to specify that the value of c.y is not changed, then you can add another postcondition:\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) < c.x && old(c.y) == c.y\n\n\n1\n2\n3\n\n\nThis postcondition constrains the post-value of c.y to be the same as its pre-value.\n\n\n# 2.1. unchanged\n\nIf you want to say that all fields of an object are unchanged, you can use an unchanged expression. For example,\n\nmethod M(c: C, k: int)\n  modifies c\n  ensures k < 0 ==> unchanged(c)\n\n\n1\n2\n3\n\n\nThis specification gives M license to modify the fields of c. However, the postcondition constrains the fields to have the initial values if k is negative.\n\nAn unchanged expression accepts a variable number of arguments, each a frame expression. In other words, what you put inside the parentheses that follow the unchanged keyword has the same syntax as modifies clauses. For example,\n\nmethod P(c: C, d: D, S: set<object>, k: int)\n  modifies c, d, S\n  ensures k < 0 ==> unchanged(c, S)\n{\n  if d !in S {\n    d.z := 5;\n  }\n  if 0 <= k {\n    c.x := c.x + 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nis a method that verifies. Note that if d is in the set S and k is negative, then the postcondition says the fields of d must have their initial values, because unchanged(S) says that all fields of all objects in S must not have changed.\n\n\n# 3. The fine print\n\n\n# 3.0. modifies determined in pre-state\n\nA modifies clause is evaluated in the method's pre-state.\n\nmethod R(c: C, d: D)\n  modifies c, c.y\n{\n  var prevCY := c.y;\n  c.y := d;  // allowed by \"modifies c\"\n  prevCY.z := 9;  // allowed by \"modifies c.y\"\n  c.y.z := 9;  // not allowed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor the last assignment to be legal, the object denoted by c.y at the time of the assignment (namely, d) would have to be in the original modifies clause.\n\nExercise 1. Write a precondition for R that makes all assignments legal.\n\nAnswer.\n\nrequires c.y == d\n\n\n1\n\n\nThe frame expressions given in an unchanged expression are evaluated where the the unchanged is given. For example, the following method satisfies its specification, because the postcondition talks about the fields of the post-state value of c.y.\n\nmethod S(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(c.y)\n{\n  c.y.z := 12;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIf you change unchanged(c.y) to unchanged(old(c.y)), then the postcondition says that the fields of the object denoted by the pre-state value of c.y must not have changed:\n\nmethod S'(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(old(c.y))\n{\n  c.y := d;\n  d.z := d.z + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSo, the body of S' verifies. If the swap the implementations of methods S and S', then neither of them verifies.\n\n\n# 3.1. old only affects the heap\n\nold applies only to heap dereferences. If you want to think of it syntactically, then this means the . (dot) in field dereferences (including the . in this.x when you write just x and leave this implicit) and the [ ] (brackets) in array dereferences. In particular, in- and out-parameters, and local and bound variables are unaffected by old.\n\nFor example, consider\n\nmethod W0(c: C, d: D) returns (k: int)\n  modifies c\n  ensures old(k == c.y.z)  // k refers to the final value of k\n{\n  k := c.y.z;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition of W0 holds, because k refers to the output value for k (not the arbitrary value that k starts off with inside the body, which would be meaningless to a caller, anyhow). Also, c inside the old expression refers to (constant) value of in-parameter c.\n\nHere is another example method that verifies:\n\nmethod W1(c: C, a: array<int>)\n  requires 0 <= c.x < a.Length\n  modifies c, a\n{\n  var m := a[c.x];\n  a[c.x] := m + 5;\n  c.x := c.x + 1;\n  m := m + 2;\n  assert old(m == a[c.x] + 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe assertion in the body could equally well have been written\n\nassert m == old(a[c.x]) + 2;\n\n\n1\n\n\nExercise 2. What error message does Dafny produce for the following method?\n\nmethod W2() {\n  var d := new D;\n  d.z := 7;\n  assert old(d.z) == 7;  // error\n}\n\n\n1\n2\n3\n4\n5\n\n\nAnswer. The error is\n\n> receiver must be allocated in the state in which its fields are accessed\n\nThe expression old(d.z) tries to get pre-state value of the z field of (the current value of) d. But the object referenced by d was not allocated in the pre-state of the method, so it makes no sense to ask for the value of d.z in the method's pre-state. Dafny detects this and produces an error.\n\nExercise 3. Consider the following method:\n\nmethod W3(c: C, a: array<int>)\n  requires 100 <= c.x < a.Length\n  requires forall i :: 0 <= i < c.x ==> a[i] == 5\n  requires forall i :: c.x <= i < a.Length ==> a[i] == 6\n  modifies c, a\n  ensures 0 <= c.x < a.Length\n{\n  a[c.x] := 16;\n  c.x := c.x - 1;\n  a[c.x] := 15;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThis method takes an array with more than 100 elements. The first c.x of elements start off as 5, and the rest equal 6. The modifies clause and postcondition say that the method is allowed to modify both the fields of c and the elements of a. You can see that the method's implementation satisfies that specification.\n\nHow do you write a postcondition that refers to\n\na) the final (that is, post-state) value of the array element at the index given by the final value of c.x?\n\nb) the initial (that is, pre-state) value of the array element at the index given by the initial value of c.x?\n\nc) the final value of the array element at the index given by the initial value of c.x?\n\nd) (tricky!) the initial value of the array element at the index given by the final value of c.x?\n\nAnswer. a) Easy peasy:\n\nensures a[c.x] == 15\n\n\n1\n\n\nb) Easy peasy:\n\nensures old(a[c.x]) == 6\n\n\n1\n\n\nc) By wrapping old around c.x, the dereference (that is, the dot) picks up the initial value of c.x. By making sure you don't wrap the array dereference (that is, the brackets) inside old, the expression a[...] will pick up the final value of teh array element.\n\nensures a[old(c.x)] == 16\n\n\n1\n\n\nd) If we could, we'd wrap old around the brackets, but not the .. But that doesn't work, because what goes between the parentheses of old must syntactically be an expression, not just some random characters. Instead, we can use a let expression: let the bound variable k be the final value of c.x, and then use this bound variable inside old:\n\nensures var k := c.x; old(a[k]) == 5\n\n\n1\n\n\n\n# 3.2. modifies permission is checked immediately\n\nFor every heap assignment in a method, Dafny checks that the method has license to modify the indicated heap location. That is, the heap location must either be allowed by the modifies clause or be newly allocated (that is, allocated since the start of the enclosing method). If the method does not have this license, then the heap assignment is illegal, even if the method later restores the previous value. For example, the following is illegal:\n\nmethod M(c: C) {\n  c.x := c.x + 1;  // error\n  c.x := c.x - 1;\n}\n\n\n1\n2\n3\n4\n\n\nIn fact, this is also illegal:\n\nmethod M(c: C) {\n  c.x := c.x;  // error\n}\n\n\n1\n2\n3\n\n\nBut for a method with the following specification:\n\nmethod M(c: C)\n  modifies c\n  ensures unchanged(c)\n\n\n1\n2\n3\n\n\nboth of the method implementations above are legal.\n\n\n# 4. Advanced features\n\n\n# 4.0. More precise frame expressions\n\nIt is appropriate to think of Dafny's frame expressions as operating at the object granularity. That is, modifies clauses (and also unchanged expressions, as well as the reads clauses of functions) take a set of objects and give permission to modify the fields of those objects (or, for unchanged, say that the fields of those objects are not changed, or, for reads, say that the function is allowed to depend on the fields of those objects).\n\nIt can happen that you want to be more precise. For example, suppose you want to say that a method may modify the y field of a given parameter c, but not the x field. You can specify this behavior by\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) == c.x\n\n\n1\n2\n3\n\n\nThis works well if you want to modify most of the fields of c, but want to call out that some fields stay the same. (If a field never changes after construction, it is best to declare it as immutable, which you do with const.) But if instead most fields remain the same and you only want to modify one or two, then the use of old will feel verbose.\n\nDafny provides a way to give some frame expressions at the object-field granularity. You do this by appending a back-tick and the expression that denotes the object. For example, to specify that only the y field of c may change, you can write\n\nmethod M(c: C)\n  modifies c`y\n\n\n1\n2\n\n\nThis says M is not allowed to modify all fields of c, but only the y field. Note that this is quite different from saying modifies c.y, which gives M permission to modify all fields of the object denoted by c.y.\n\nThe object-field granularity can also be used in unchanged expressions (and reads clauses). For example, yet another way to specify the method M is\n\nmethod M(c: C)\n  modifies c\n  ensures unchanged(c`x)\n\n\n1\n2\n3\n\n\nJust like you can abbreviate this.x by just x (if there is no ambiguity with other local names), you can also abbreviate thisxby just ``x.\n\nRegrettably, Dafny does allow this back-tick notation for array elements, for it would be mighty nice to be able to write specifications like\n\nmethod P(a: array<int>, i: int, m: int, n: int)\n  requires 0 <= i < a.Length\n  requires 0 <= m <= n <= a.Length\n  modifies a`[i], a`[m..n]  // error: this syntax is not supported\n\n\n1\n2\n3\n4\n\n\nA future version of Dafny may support this syntax.\n\n\n# 4.1. State labels\n\nold and unchanged are examples of two-state predicates. That means they talk not just about the current state, but also about a previous state—namely, the pre-state of the enclosing method, in all the examples we've seen so far. (Well, old only talks about the previous state, not the current state, but it's still a two-state predicate, because it doesn't just talk about the current state.)\n\nThe primary use of two-state expressions is in postconditions. However, you can also use them, for example, in assertions in a method body, like so:\n\nmethod L(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.x := c.x + 3;\n  c.x := c.x + 4;\n  assert c.x == old(c.x) + 9 && unchanged(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSometimes, you want to talk about a heap value in some intermediate state. One way to do that is to use ghost variables. For example:\n\nmethod L1(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  ghost var g := c.x;\n  c.x := c.x + 3;\n  ghost var h := c.x;\n  c.x := c.x + 4;\n  assert c.x == h + 4 == g + 7 == old(c.x) + 9;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIf you want to refer to many values in the heap from an previous intermediate state, then you can use labels. These are the same labels as you would use to do a control-flow break out of a loop or other statement. Like in many other languages, the declaration of a label in Dafny ends with a : (colon). Unlike many other languages, Dafny also requires the declaration to start with the keyword label, which is intended to make the placement more prominent.\n\nold and unchanged can be followed with @ and a label, which makes them two-state predicates that refer to the current state and the previous state. Here is an example:\n\nmethod L2(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.y := new D;\n  label G:\n  c.x := c.x + 3;\n  label H:\n  c.x := c.x + 4;\n  assert c.x == old@H(c.x) + 4 == old@G(c.x) + 7 == old(c.x) + 9;\n  assert unchanged@G(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nHere's a more stimulating example:\n\nmethod Inc(c: C, m: nat, n: nat)\n  modifies c\n  ensures c.x == old(c.x) + 3 * m + 2 * n\n{\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant c.x == old(c.x) + 3 * i\n  {\n    c.x, i := c.x + 3, i + 1;\n  }\n  label Middle:\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c.x == old@Middle(c.x) + 2 * i\n  {\n    c.x, i := c.x + 2, i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"dafny power user: old and unchanged\n\nk. rustan m. leino\n\nmanuscript krml 273, 15 february 2020\n\nabstract. this note addresses the question \"what's the difference between old and unchanged?\".\n\n\n# 0. the essence\n\nin a nutshell, the expression old(e) denotes the value of expression e evaluated in the pre-state of the enclosing method. the expression unchanged(r) says that the values of the fields of the object denoted by expression r are the same as in the pre-state.\n\nfor instance, consider the following classes, which i will use throughout this note:\n\nclass c {\n  var x: int\n  var y: d\n  // ...\n}\nclass d {\n  var z: int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif c is a parameter of type c, then the expression unchanged(c)means\n\nold(c.x) == c.x && old(c.y) == c.y\n\n\n1\n\n\nbut there's more, if you want to know it.\n\n\n# 1. modifies\n\nlet's review modifies clauses on methods.\n\na method must declare the set of (previously allocated) objects whose fields it might modify. so, if a method method m(c: c) wants to do an assignment like\n\nc.x := 10;\n\n\n1\n\n\nor\n\nc.x := c.x + 2;\n\n\n1\n\n\nthen its specification must include the object reference c in its modifies clause, like so:\n\nmethod m(c: c)\n  modifies c\n\n\n1\n2\n\n\nthis specification gives m permission to modify the fields of c.\n\nexercise 0. what does the following specification mean?\n\nmethod m(c: c, d: d)\n  modifies c.y\n\n\n1\n2\n\n\nanswer. it gives m permission to modify the fields of c.y. for example, the body of m can do the following assignment:\n\nc.y.z := 15;\n\n\n1\n\n\nit does not give m the permission to modify the y field of object c. for example, the following is not allowed:\n\nc.y := d;  // error: not allowed by modifies clause \n\n\n1\n\n\na modifies clause is not transitive. that is, modifies c gives permission to modify the fields of c, but not their fields. in particular, the assignment\n\nc.y.z := 20;\n\n\n1\n\n\nis not allowed by the specification modifies c.\n\nmethods are always allowed to allocate new objects and modify their fields, even without any mention in the modifies clause. so, here's a way to ensure that c.y.z has a post-value of 20:\n\nmethod m(c: c)\n  modifies c\n  ensures c.y.z == 20\n{\n  c.y := new d;  // allowed because c is in the modifies clause\n  c.y.z := 20;   // allowed because c.y is newly allocated\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that this program swap out c.y for a new object. the object previously referenced by c.y is not changed by method m.\n\n\n# 2. frame expressions\n\nwhat follows the modifies keyword is a list of frame expressions. a frame expression denotes a set of objects (or arrays).\n\nfor convenience, a frame expression can be given as a set of object or as a single object. the latter is shorthand for the singleton set containing that object. the modifies clause denotes the set union of the objects denoted by each frame expression in the list. for example,\n\nmethod p(c: c, d: d, s: set<object>)\n  modifies c, d, s\n\n\n1\n2\n\n\nis the same as\n\nmethod p(c: c, d: d, s: set<object>)\n  modifies {c} + {d} + s\n\n\n1\n2\n\n\n\n# 2.0. old\n\nif you want to say that m has the effect of increasing the value of c.x, then you write a two-state postcondition that mentions the value of c.x in both the method's pre-state and the method's post-state. the former is notated by old(c.x), and the latter simply by c.x:\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) < c.x\n\n\n1\n2\n3\n\n\nthis specification says nothing about the post-value of c.y. more precisely, the modifies clause gives m permission to update all of the fields of c and the ensures clause does not constrain the final value of c.y.\n\nif you want to specify that the value of c.y is not changed, then you can add another postcondition:\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) < c.x && old(c.y) == c.y\n\n\n1\n2\n3\n\n\nthis postcondition constrains the post-value of c.y to be the same as its pre-value.\n\n\n# 2.1. unchanged\n\nif you want to say that all fields of an object are unchanged, you can use an unchanged expression. for example,\n\nmethod m(c: c, k: int)\n  modifies c\n  ensures k < 0 ==> unchanged(c)\n\n\n1\n2\n3\n\n\nthis specification gives m license to modify the fields of c. however, the postcondition constrains the fields to have the initial values if k is negative.\n\nan unchanged expression accepts a variable number of arguments, each a frame expression. in other words, what you put inside the parentheses that follow the unchanged keyword has the same syntax as modifies clauses. for example,\n\nmethod p(c: c, d: d, s: set<object>, k: int)\n  modifies c, d, s\n  ensures k < 0 ==> unchanged(c, s)\n{\n  if d !in s {\n    d.z := 5;\n  }\n  if 0 <= k {\n    c.x := c.x + 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nis a method that verifies. note that if d is in the set s and k is negative, then the postcondition says the fields of d must have their initial values, because unchanged(s) says that all fields of all objects in s must not have changed.\n\n\n# 3. the fine print\n\n\n# 3.0. modifies determined in pre-state\n\na modifies clause is evaluated in the method's pre-state.\n\nmethod r(c: c, d: d)\n  modifies c, c.y\n{\n  var prevcy := c.y;\n  c.y := d;  // allowed by \"modifies c\"\n  prevcy.z := 9;  // allowed by \"modifies c.y\"\n  c.y.z := 9;  // not allowed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor the last assignment to be legal, the object denoted by c.y at the time of the assignment (namely, d) would have to be in the original modifies clause.\n\nexercise 1. write a precondition for r that makes all assignments legal.\n\nanswer.\n\nrequires c.y == d\n\n\n1\n\n\nthe frame expressions given in an unchanged expression are evaluated where the the unchanged is given. for example, the following method satisfies its specification, because the postcondition talks about the fields of the post-state value of c.y.\n\nmethod s(c: c, d: d)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(c.y)\n{\n  c.y.z := 12;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif you change unchanged(c.y) to unchanged(old(c.y)), then the postcondition says that the fields of the object denoted by the pre-state value of c.y must not have changed:\n\nmethod s'(c: c, d: d)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(old(c.y))\n{\n  c.y := d;\n  d.z := d.z + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nso, the body of s' verifies. if the swap the implementations of methods s and s', then neither of them verifies.\n\n\n# 3.1. old only affects the heap\n\nold applies only to heap dereferences. if you want to think of it syntactically, then this means the . (dot) in field dereferences (including the . in this.x when you write just x and leave this implicit) and the [ ] (brackets) in array dereferences. in particular, in- and out-parameters, and local and bound variables are unaffected by old.\n\nfor example, consider\n\nmethod w0(c: c, d: d) returns (k: int)\n  modifies c\n  ensures old(k == c.y.z)  // k refers to the final value of k\n{\n  k := c.y.z;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition of w0 holds, because k refers to the output value for k (not the arbitrary value that k starts off with inside the body, which would be meaningless to a caller, anyhow). also, c inside the old expression refers to (constant) value of in-parameter c.\n\nhere is another example method that verifies:\n\nmethod w1(c: c, a: array<int>)\n  requires 0 <= c.x < a.length\n  modifies c, a\n{\n  var m := a[c.x];\n  a[c.x] := m + 5;\n  c.x := c.x + 1;\n  m := m + 2;\n  assert old(m == a[c.x] + 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe assertion in the body could equally well have been written\n\nassert m == old(a[c.x]) + 2;\n\n\n1\n\n\nexercise 2. what error message does dafny produce for the following method?\n\nmethod w2() {\n  var d := new d;\n  d.z := 7;\n  assert old(d.z) == 7;  // error\n}\n\n\n1\n2\n3\n4\n5\n\n\nanswer. the error is\n\n> receiver must be allocated in the state in which its fields are accessed\n\nthe expression old(d.z) tries to get pre-state value of the z field of (the current value of) d. but the object referenced by d was not allocated in the pre-state of the method, so it makes no sense to ask for the value of d.z in the method's pre-state. dafny detects this and produces an error.\n\nexercise 3. consider the following method:\n\nmethod w3(c: c, a: array<int>)\n  requires 100 <= c.x < a.length\n  requires forall i :: 0 <= i < c.x ==> a[i] == 5\n  requires forall i :: c.x <= i < a.length ==> a[i] == 6\n  modifies c, a\n  ensures 0 <= c.x < a.length\n{\n  a[c.x] := 16;\n  c.x := c.x - 1;\n  a[c.x] := 15;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthis method takes an array with more than 100 elements. the first c.x of elements start off as 5, and the rest equal 6. the modifies clause and postcondition say that the method is allowed to modify both the fields of c and the elements of a. you can see that the method's implementation satisfies that specification.\n\nhow do you write a postcondition that refers to\n\na) the final (that is, post-state) value of the array element at the index given by the final value of c.x?\n\nb) the initial (that is, pre-state) value of the array element at the index given by the initial value of c.x?\n\nc) the final value of the array element at the index given by the initial value of c.x?\n\nd) (tricky!) the initial value of the array element at the index given by the final value of c.x?\n\nanswer. a) easy peasy:\n\nensures a[c.x] == 15\n\n\n1\n\n\nb) easy peasy:\n\nensures old(a[c.x]) == 6\n\n\n1\n\n\nc) by wrapping old around c.x, the dereference (that is, the dot) picks up the initial value of c.x. by making sure you don't wrap the array dereference (that is, the brackets) inside old, the expression a[...] will pick up the final value of teh array element.\n\nensures a[old(c.x)] == 16\n\n\n1\n\n\nd) if we could, we'd wrap old around the brackets, but not the .. but that doesn't work, because what goes between the parentheses of old must syntactically be an expression, not just some random characters. instead, we can use a let expression: let the bound variable k be the final value of c.x, and then use this bound variable inside old:\n\nensures var k := c.x; old(a[k]) == 5\n\n\n1\n\n\n\n# 3.2. modifies permission is checked immediately\n\nfor every heap assignment in a method, dafny checks that the method has license to modify the indicated heap location. that is, the heap location must either be allowed by the modifies clause or be newly allocated (that is, allocated since the start of the enclosing method). if the method does not have this license, then the heap assignment is illegal, even if the method later restores the previous value. for example, the following is illegal:\n\nmethod m(c: c) {\n  c.x := c.x + 1;  // error\n  c.x := c.x - 1;\n}\n\n\n1\n2\n3\n4\n\n\nin fact, this is also illegal:\n\nmethod m(c: c) {\n  c.x := c.x;  // error\n}\n\n\n1\n2\n3\n\n\nbut for a method with the following specification:\n\nmethod m(c: c)\n  modifies c\n  ensures unchanged(c)\n\n\n1\n2\n3\n\n\nboth of the method implementations above are legal.\n\n\n# 4. advanced features\n\n\n# 4.0. more precise frame expressions\n\nit is appropriate to think of dafny's frame expressions as operating at the object granularity. that is, modifies clauses (and also unchanged expressions, as well as the reads clauses of functions) take a set of objects and give permission to modify the fields of those objects (or, for unchanged, say that the fields of those objects are not changed, or, for reads, say that the function is allowed to depend on the fields of those objects).\n\nit can happen that you want to be more precise. for example, suppose you want to say that a method may modify the y field of a given parameter c, but not the x field. you can specify this behavior by\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) == c.x\n\n\n1\n2\n3\n\n\nthis works well if you want to modify most of the fields of c, but want to call out that some fields stay the same. (if a field never changes after construction, it is best to declare it as immutable, which you do with const.) but if instead most fields remain the same and you only want to modify one or two, then the use of old will feel verbose.\n\ndafny provides a way to give some frame expressions at the object-field granularity. you do this by appending a back-tick and the expression that denotes the object. for example, to specify that only the y field of c may change, you can write\n\nmethod m(c: c)\n  modifies c`y\n\n\n1\n2\n\n\nthis says m is not allowed to modify all fields of c, but only the y field. note that this is quite different from saying modifies c.y, which gives m permission to modify all fields of the object denoted by c.y.\n\nthe object-field granularity can also be used in unchanged expressions (and reads clauses). for example, yet another way to specify the method m is\n\nmethod m(c: c)\n  modifies c\n  ensures unchanged(c`x)\n\n\n1\n2\n3\n\n\njust like you can abbreviate this.x by just x (if there is no ambiguity with other local names), you can also abbreviate thisxby just ``x.\n\nregrettably, dafny does allow this back-tick notation for array elements, for it would be mighty nice to be able to write specifications like\n\nmethod p(a: array<int>, i: int, m: int, n: int)\n  requires 0 <= i < a.length\n  requires 0 <= m <= n <= a.length\n  modifies a`[i], a`[m..n]  // error: this syntax is not supported\n\n\n1\n2\n3\n4\n\n\na future version of dafny may support this syntax.\n\n\n# 4.1. state labels\n\nold and unchanged are examples of two-state predicates. that means they talk not just about the current state, but also about a previous state—namely, the pre-state of the enclosing method, in all the examples we've seen so far. (well, old only talks about the previous state, not the current state, but it's still a two-state predicate, because it doesn't just talk about the current state.)\n\nthe primary use of two-state expressions is in postconditions. however, you can also use them, for example, in assertions in a method body, like so:\n\nmethod l(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.x := c.x + 3;\n  c.x := c.x + 4;\n  assert c.x == old(c.x) + 9 && unchanged(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsometimes, you want to talk about a heap value in some intermediate state. one way to do that is to use ghost variables. for example:\n\nmethod l1(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  ghost var g := c.x;\n  c.x := c.x + 3;\n  ghost var h := c.x;\n  c.x := c.x + 4;\n  assert c.x == h + 4 == g + 7 == old(c.x) + 9;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nif you want to refer to many values in the heap from an previous intermediate state, then you can use labels. these are the same labels as you would use to do a control-flow break out of a loop or other statement. like in many other languages, the declaration of a label in dafny ends with a : (colon). unlike many other languages, dafny also requires the declaration to start with the keyword label, which is intended to make the placement more prominent.\n\nold and unchanged can be followed with @ and a label, which makes them two-state predicates that refer to the current state and the previous state. here is an example:\n\nmethod l2(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.y := new d;\n  label g:\n  c.x := c.x + 3;\n  label h:\n  c.x := c.x + 4;\n  assert c.x == old@h(c.x) + 4 == old@g(c.x) + 7 == old(c.x) + 9;\n  assert unchanged@g(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nhere's a more stimulating example:\n\nmethod inc(c: c, m: nat, n: nat)\n  modifies c\n  ensures c.x == old(c.x) + 3 * m + 2 * n\n{\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant c.x == old(c.x) + 3 * i\n  {\n    c.x, i := c.x + 3, i + 1;\n  }\n  label middle:\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c.x == old@middle(c.x) + 2 * i\n  {\n    c.x, i := c.x + 2, i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Short-Circuit Operators",frontmatter:{title:"Short-Circuit Operators",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/369e25/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/45.Short-Circuit%20Operators.html",relativePath:"80.语言/30.publication-lecture/45.Short-Circuit Operators.md",key:"v-62c9c110",path:"/pages/369e25/",headers:[{level:2,title:"0. The Well-Definedness Rule",slug:"_0-the-well-definedness-rule",normalizedTitle:"0. the well-definedness rule",charIndex:613},{level:2,title:"1. Short-circuiting",slug:"_1-short-circuiting",normalizedTitle:"1. short-circuiting",charIndex:1490},{level:2,title:"2. Example: commutativity of and",slug:"_2-example-commutativity-of-and",normalizedTitle:"2. example: commutativity of and",charIndex:2636},{level:2,title:"3. Example: contrapositive",slug:"_3-example-contrapositive",normalizedTitle:"3. example: contrapositive",charIndex:3952},{level:2,title:"4. Symmetric well-definedness",slug:"_4-symmetric-well-definedness",normalizedTitle:"4. symmetric well-definedness",charIndex:5215},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:5770}],headersStr:"0. The Well-Definedness Rule 1. Short-circuiting 2. Example: commutativity of and 3. Example: contrapositive 4. Symmetric well-definedness References",content:"Dafny Power User: Short-Circuit Operators\n\nK. Rustan M. Leino\n\nManuscript KRML 268, 31 May 2019\n\nAbstract. The boolean operators (“and”, “or”, …) in Dafny are short-circuiting. This means, for example, that you cannot reverse the operands of “and” and expect your program to be unchanged. This is well known to programmers. But if you write specifications in the same programming language, should you not be nervous that “and” no longer appears to be commutative?\n\nThis note points out that the difference lies not in the meaning of the operators, but rather in what expressions are legal in the first place.\n\n\n# 0. The Well-Definedness Rule\n\nIn Dafny, a.Length gives the length of the array referenced by a and 5/x gives the integer quotient of 5 and x. But what if a is null or if x is 0, what do these expressions mean then? The Dafny verifier checks that you are never in a situation where you have to rely on what these expressions evaluate to for such operand values. So, in a legal Dafny program, expressions are known to be defined. This allows the verifier to do meaningful reasoning and allows the compiler to assume the absence of run-time failures. I'll call this the Well-Definedness Rule.\n\nTo enforce the Well-Definedness Rule, the Dafny verifier checks that every expression you write down is well-defined in every context where that expression could possibly be used. For example, the well-definedness of a.Length is a != null and the well-definedness of 5/x is x != 0.\n\n\n# 1. Short-circuiting\n\nThe boolean operators &&, ||, ==>, and <== are short-circuiting in Dafny. This notion is commonly described in terms of how an expression is evaluated at run time, namely: evaluation proceeds left-to-right (or right-to-left in the case of <==), but an operand is evaluated only if the operands evaluated so far do not already determine the value of the expression. In this way, if the first operand determines the value of the expression (as evaluating the first operand of && to false does), then the evaluation of the second operand is omitted.\n\nThe meaning of the boolean operators are the same in Dafny as in logic.\n\nHold it! How can that be? Conjunction (“and”) in logic is symmetric (that is, A && B is the same as B && A) and short-circuiting is inherently asymmetric. How can a short-circuiting operator have the same meaning as in logic? Here's how: Short-circuiting affects the well-definedness of expressions, not their meaning when defined.\n\nSo, I should have said: Expressions with boolean operators are not always defined in Dafny. But when they are defined, their meaning is the same in Dafny as in logic.\n\n\n# 2. Example: commutativity of and\n\nIn logic,\n\nx != 0 && 5/x == 1\n\n\n1\n\n\nis the very same thing as\n\n5/x == 1 && x != 0\n\n\n1\n\n\nThis is also true in Dafny, but only in situations where these are well-defined.\n\nx != 0 is always well-defined and 5/x == 1 is well-defined when x is non-0. That is, the well-definedness of x != 0 is true and the well-definedness of 5/x == 1 is x != 0.\n\nLet me use WDe to denote the well-definedness of an expression e. So, WDx != 0 is true and WD5/x == 1 is x != 0.\n\nFor conjunction, we have that WDe0 && e1 is\n\nWDe0 && (e0 ==> WDe1)\n\n\n1\n\n\nThat is, while the left argument has to be well-defined, the right argument only has to be well-defined when the left argument evaluates to true.\n\nSo, WDx != 0 && 5/x == 1 is\n\ntrue && (x != 0 ==> x != 0)\n\n\n1\n\n\nwhich simplifies to true. In contrast, WD5/x == 1 && x != 0 is\n\nx != 0 && (5/x == 1 ==> true)\n\n\n1\n\n\nwhich simplifies to x != 0.\n\nSummarizing the example, conjunction in logic is symmetric. This is also true in Dafny, provided that both ways of writing the expression are well-defined. As the example shows, the first conjunction is always well-defined, whereas the other is well-defined only when x != 0. So, if you're in a situation where you don't know if x != 0 holds or not, you're better off writing the first of these conjunctions.\n\n\n# 3. Example: contrapositive\n\nThe contrapositive of the implication A ==> B is !B ==> !A, that is, the implication with the arguments reversed and negated. In logic, these two implications are equivalent. This is also true in Dafny, provided both expressions are defined.\n\nAs an example, consider the expression a != null ==> a.Length > 0. We have that WDa != null ==> a.Length > 0 is\n\ntrue && (a != null ==> a != null)\n\n\n1\n\n\nwhich simplifies to true. For the contrapositive of the implication, we have that WDa.Length <= 0 ==> a == null is\n\na != null && (a.Length <= 0 ==> true)\n\n\n1\n\n\nwhich simplifies to a != null.\n\nIn Dafny, we can only talk about the meaning of expressions if they are well-defined. As we just worked out, the first of these implications is always well-defined whereas the other is well-defined when a != null. So, in any context where a != null is known to hold, the two implications have the same meaning and you can use them interchangeably. But if there's a possibility that a != null might not hold, then the first implication is still defined (and thus you can start to talk about what value the expression will evaluate to), whereas the second implication is not well-defined (and thus is flagged as an error by the Dafny verifier).\n\n\n# 4. Symmetric well-definedness\n\nAs a final remark, well-definedness of boolean operands in Dafny is defined to match the notion of short-circuiting. This is well understood by programmers. Indeed, no programmer in their right mind would even think of ever writing\n\np.x < 1000 && p != null\n\n\n1\n\n\nbut would write\n\np != null && p.x < 1000\n\n\n1\n\n\nAs we have seen, this gives rise to an asymmetric definition of well-definedness. But this is not the only way to define well-definedness. For more information, see an article by Darvas, Mehta, and Rudich [0].\n\n\n# References\n\n[0]Ádám Darvas, Farhad Mehta, and Arsenii Rudich. Efficient well-definedness checking. In Alessandro Armando, Peter Baumgartner, and Gilles Dowek, editors, Automated Reasoning, 4th International Joint Conference, IJCAR 2008, volume 5195 of Lecture Notes in Computer Science, pages 100–115. Springer, 2008. 🔎",normalizedContent:"dafny power user: short-circuit operators\n\nk. rustan m. leino\n\nmanuscript krml 268, 31 may 2019\n\nabstract. the boolean operators (“and”, “or”, …) in dafny are short-circuiting. this means, for example, that you cannot reverse the operands of “and” and expect your program to be unchanged. this is well known to programmers. but if you write specifications in the same programming language, should you not be nervous that “and” no longer appears to be commutative?\n\nthis note points out that the difference lies not in the meaning of the operators, but rather in what expressions are legal in the first place.\n\n\n# 0. the well-definedness rule\n\nin dafny, a.length gives the length of the array referenced by a and 5/x gives the integer quotient of 5 and x. but what if a is null or if x is 0, what do these expressions mean then? the dafny verifier checks that you are never in a situation where you have to rely on what these expressions evaluate to for such operand values. so, in a legal dafny program, expressions are known to be defined. this allows the verifier to do meaningful reasoning and allows the compiler to assume the absence of run-time failures. i'll call this the well-definedness rule.\n\nto enforce the well-definedness rule, the dafny verifier checks that every expression you write down is well-defined in every context where that expression could possibly be used. for example, the well-definedness of a.length is a != null and the well-definedness of 5/x is x != 0.\n\n\n# 1. short-circuiting\n\nthe boolean operators &&, ||, ==>, and <== are short-circuiting in dafny. this notion is commonly described in terms of how an expression is evaluated at run time, namely: evaluation proceeds left-to-right (or right-to-left in the case of <==), but an operand is evaluated only if the operands evaluated so far do not already determine the value of the expression. in this way, if the first operand determines the value of the expression (as evaluating the first operand of && to false does), then the evaluation of the second operand is omitted.\n\nthe meaning of the boolean operators are the same in dafny as in logic.\n\nhold it! how can that be? conjunction (“and”) in logic is symmetric (that is, a && b is the same as b && a) and short-circuiting is inherently asymmetric. how can a short-circuiting operator have the same meaning as in logic? here's how: short-circuiting affects the well-definedness of expressions, not their meaning when defined.\n\nso, i should have said: expressions with boolean operators are not always defined in dafny. but when they are defined, their meaning is the same in dafny as in logic.\n\n\n# 2. example: commutativity of and\n\nin logic,\n\nx != 0 && 5/x == 1\n\n\n1\n\n\nis the very same thing as\n\n5/x == 1 && x != 0\n\n\n1\n\n\nthis is also true in dafny, but only in situations where these are well-defined.\n\nx != 0 is always well-defined and 5/x == 1 is well-defined when x is non-0. that is, the well-definedness of x != 0 is true and the well-definedness of 5/x == 1 is x != 0.\n\nlet me use wde to denote the well-definedness of an expression e. so, wdx != 0 is true and wd5/x == 1 is x != 0.\n\nfor conjunction, we have that wde0 && e1 is\n\nwde0 && (e0 ==> wde1)\n\n\n1\n\n\nthat is, while the left argument has to be well-defined, the right argument only has to be well-defined when the left argument evaluates to true.\n\nso, wdx != 0 && 5/x == 1 is\n\ntrue && (x != 0 ==> x != 0)\n\n\n1\n\n\nwhich simplifies to true. in contrast, wd5/x == 1 && x != 0 is\n\nx != 0 && (5/x == 1 ==> true)\n\n\n1\n\n\nwhich simplifies to x != 0.\n\nsummarizing the example, conjunction in logic is symmetric. this is also true in dafny, provided that both ways of writing the expression are well-defined. as the example shows, the first conjunction is always well-defined, whereas the other is well-defined only when x != 0. so, if you're in a situation where you don't know if x != 0 holds or not, you're better off writing the first of these conjunctions.\n\n\n# 3. example: contrapositive\n\nthe contrapositive of the implication a ==> b is !b ==> !a, that is, the implication with the arguments reversed and negated. in logic, these two implications are equivalent. this is also true in dafny, provided both expressions are defined.\n\nas an example, consider the expression a != null ==> a.length > 0. we have that wda != null ==> a.length > 0 is\n\ntrue && (a != null ==> a != null)\n\n\n1\n\n\nwhich simplifies to true. for the contrapositive of the implication, we have that wda.length <= 0 ==> a == null is\n\na != null && (a.length <= 0 ==> true)\n\n\n1\n\n\nwhich simplifies to a != null.\n\nin dafny, we can only talk about the meaning of expressions if they are well-defined. as we just worked out, the first of these implications is always well-defined whereas the other is well-defined when a != null. so, in any context where a != null is known to hold, the two implications have the same meaning and you can use them interchangeably. but if there's a possibility that a != null might not hold, then the first implication is still defined (and thus you can start to talk about what value the expression will evaluate to), whereas the second implication is not well-defined (and thus is flagged as an error by the dafny verifier).\n\n\n# 4. symmetric well-definedness\n\nas a final remark, well-definedness of boolean operands in dafny is defined to match the notion of short-circuiting. this is well understood by programmers. indeed, no programmer in their right mind would even think of ever writing\n\np.x < 1000 && p != null\n\n\n1\n\n\nbut would write\n\np != null && p.x < 1000\n\n\n1\n\n\nas we have seen, this gives rise to an asymmetric definition of well-definedness. but this is not the only way to define well-definedness. for more information, see an article by darvas, mehta, and rudich [0].\n\n\n# references\n\n[0]adam darvas, farhad mehta, and arsenii rudich. efficient well-definedness checking. in alessandro armando, peter baumgartner, and gilles dowek, editors, automated reasoning, 4th international joint conference, ijcar 2008, volume 5195 of lecture notes in computer science, pages 100–115. springer, 2008. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Statement versus Expression Syntax",frontmatter:{title:"Statement versus Expression Syntax",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/f8c1c5/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/50.Statement%20versus%20Expression%20Syntax.html",relativePath:"80.语言/30.publication-lecture/50.Statement versus Expression Syntax.md",key:"v-75eb6ec4",path:"/pages/f8c1c5/",headers:[{level:2,title:"0. If Statements and If-Then-Else Expressions",slug:"_0-if-statements-and-if-then-else-expressions",normalizedTitle:"0. if statements and if-then-else expressions",charIndex:1145},{level:3,title:"0.0. If-case Statements",slug:"_0-0-if-case-statements",normalizedTitle:"0.0. if-case statements",charIndex:3805},{level:3,title:"0.1. Indiscriminate Choice",slug:"_0-1-indiscriminate-choice",normalizedTitle:"0.1. indiscriminate choice",charIndex:6432},{level:3,title:"0.2. Binding Guards",slug:"_0-2-binding-guards",normalizedTitle:"0.2. binding guards",charIndex:7062},{level:2,title:"1. Match Statements and Match Expressions",slug:"_1-match-statements-and-match-expressions",normalizedTitle:"1. match statements and match expressions",charIndex:8768},{level:2,title:"2. Local Variables and Let Bindings",slug:"_2-local-variables-and-let-bindings",normalizedTitle:"2. local variables and let bindings",charIndex:11138},{level:3,title:"2.0. Ghost Variables",slug:"_2-0-ghost-variables",normalizedTitle:"2.0. ghost variables",charIndex:14530},{level:3,title:"2.1. Patterns",slug:"_2-1-patterns",normalizedTitle:"2.1. patterns",charIndex:16645},{level:3,title:"2.2. Assign-Such-That Statements and Let-Such-That Expressions",slug:"_2-2-assign-such-that-statements-and-let-such-that-expressions",normalizedTitle:"2.2. assign-such-that statements and let-such-that expressions",charIndex:18e3},{level:3,title:"2.3. Upates",slug:"_2-3-upates",normalizedTitle:"2.3. upates",charIndex:21354},{level:2,title:"3. Statement Expressions",slug:"_3-statement-expressions",normalizedTitle:"3. statement expressions",charIndex:21761},{level:3,title:"3.0. Lemmas with out-parameters",slug:"_3-0-lemmas-with-out-parameters",normalizedTitle:"3.0. lemmas with out-parameters",charIndex:23342},{level:2,title:"4. Putting it all together",slug:"_4-putting-it-all-together",normalizedTitle:"4. putting it all together",charIndex:24887},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:26042},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:26125}],headersStr:"0. If Statements and If-Then-Else Expressions 0.0. If-case Statements 0.1. Indiscriminate Choice 0.2. Binding Guards 1. Match Statements and Match Expressions 2. Local Variables and Let Bindings 2.0. Ghost Variables 2.1. Patterns 2.2. Assign-Such-That Statements and Let-Such-That Expressions 2.3. Upates 3. Statement Expressions 3.0. Lemmas with out-parameters 4. Putting it all together Acknowledgments References",content:"Dafny Power User: Statement versus Expression Syntax\n\nK. Rustan M. Leino\n\nManuscript KRML 266, 17 May 2019\n\nAbstract. This note describes some constructs that exist in both a statement form and an expression form in Dafny. It points out the syntactic similarities and differences between the two forms, and discusses related constructs.\n\nDafny distinguishes between statements and expressions. For example, the body of a method is a statement whereas the body of a function is an expression. A statement can assign to local variables, allocate and mutate objects in the heap, use loops in control flow, and be nondeterministic. An expression cannot do any of those things. Instead, it can bind values to bound variables, read values in the heap, use recursion, and is always deterministic. Syntactically, most statements are terminated with a semi-colon and sometimes a sequence of statements is surrounded by curly braces. A few expressions contain semi-colons, but never at the end, and an expression can be surrounded by round parentheses.\n\nLet's take a look at some constructs that exist in both a statement form and an expression form.\n\n\n# 0. If Statements and If-Then-Else Expressions\n\nOf constructs that exist in both statement and expression form, the conditional (if) is probably the most common, and it is also the one with the most conspicuous difference between the two forms.\n\nThe conditional statement is the if statement, which has a “then” branch and an optional “else” branch. The “then” branch is always a block statement, which is necessarily surrounded by curly braces. The “else” branch, if present, is either a block statement or another if statement.\n\nFor example, the following statement declares local variables min and max that are assigned according to the relative sizes of x and y:\n\nvar min, max;\nif x < y {\n  min, max := x, y;\n} else {\n  min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nNotice that min and max are declared before the if statement (Dafny will infer the types of these two variables), which means they are still in scope after the whole if statement. If these variables were instead declared inside each branch, they would go out of scope at the curly brace that ends each respective block statement.\n\nThe conditional expression is the if-then-else expression. Unlike the if statement, the expression form uses the keyword then to separate the guard from the “then” branch, and always requires and explicit “else” branch. For example, an expression that returns the smaller of x and y is:\n\nif x < y then x else y\n\n\n1\n\n\nSuch expressions can be used as right-hand sides of assignments to local variables:\n\nvar min, max := if x < y then x else y, if x < y then y else x;\n\n\n1\n\n\nFor this example, we can also use a single if-then-else expression where each branch results in a pair. We can assign that pair to a variable, and then assign the pair's components to min and max:\n\nvar minmax := if x < y then (x,y) else (y,x);\nvar min, max := minmax.0, minmax.1;\n\n\n1\n2\n\n\nThe following shows an example of nested and cascaded if statements:\n\nvar middle;\nif x < y {\n  if y < z {\n    middle := y;\n  } else if z < x {\n    middle := x;\n  } else {\n    middle := z;\n  }\n} else {\n  if x < z {\n    middle := x;\n  } else if z < y {\n    middle := y;\n  } else {\n    middle := z;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nAnd here is the analogous program using conditional expressions:\n\nvar middle :=\n  if x < y then\n    if y < z then y else if z < x then x else z\n  else\n    if x < z then x else if z < y then y else z;\n\n\n1\n2\n3\n4\n5\n\n\nFor statements, there are some additional forms of conditionals. Because these forms allow nondeterminism, there statements do exist in an analogous expression form. The next few subsections describe these additional conditional statements.\n\n\n# 0.0. If-case Statements\n\nOne additional form of conditional statements is the if-case statement. Instead of two mutually exclusive branches, the if-case statement provides any number of branches (cases, alternatives), and their conditions need not be mutually exclusive. Syntactically, the if-case statement follows the keyword if with ones or more branches of the form\n\ncase Guard => Body\n\n\n1\n\n\nwhere Guard is an expression and Body is a list of statements.\n\nFor example, the computation of min/max can be written as follows:\n\nvar min, max;\nif\ncase x <= y =>\n  min, max := x, y;\ncase y <= x =>\n  min, max := y, x;\n\n\n1\n2\n3\n4\n5\n6\n\n\nNote that <= is the “at most” (or, some say “less than or equal to”) operator, whereas => is the piece of syntax that separates the guard and body of each case.\n\nThe if-case statement picks any one of the cases whose guard evaluates to true. The ordering of the cases is not relevant. In the example above, if x and y are equal, then the choice of which case to execute is nondeterminstic. For this example, it so happens that both cases have the same effect if x and y are equal, but that need not be so. Not having to specify which branch to take when the choice is irrelevant frees the programmer's mind and, arguably, results in a cleaner, more symmetric, and more abstract program.\n\nEach case gives rise to a new block scope, despite the fact that the body is a list of statements, not a block statement. In other words, any local variables declared in one case go out of scope where the case ends.\n\nThe body of a case continues until the next case begins or until the enclosing block ends. If you want to end the last case sooner, you could surround the entire if-case statement with a pair of curly braces, but that doesn't look so nice. Therefore, Dafny optionally allows the set of cases to be enclosed in a pair of curly braces, like this:\n\nvar min, max;\nif {\n  case x <= y =>\n    min, max := x, y;\n  case y <= x =>\n    min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nAn if-case statement can have any number of branches. For example:\n\nvar middle;\nif {\n  case x <= y <= z =>  middle := y;\n  case z <= y <= x =>  middle := y;\n  case y <= x <= z =>  middle := x;\n  case z <= x <= y =>  middle := x;\n  case y <= z <= x =>  middle := z;\n  case x <= z <= y =>  middle := z;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nAs I mentioned, if more than one guard evaluates to true, Dafny may choose to execute any one of the the corresponding bodies (but only one!). What if none of the guards evaluates to true? That is not allowed, and the verifier will report an error if it cannot prove that at least one case applies.\n\n\n# 0.1. Indiscriminate Choice\n\nWhen Dafny is used as a modeling language, one may want to write down several statements that can be chosen between indiscriminately. This can be done by writing * in place of the guard expression in the common if statement.\n\nFor example, the effect of the statement\n\nif * {\n  S;\n} else if * {\n  T;\n} else {\n  U;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nis to execute one of the statements S, T, or U, but you can never predict which one of those statements will be chosen.\n\nSuch an indiscriminate choice can also be written using an if-case statement:\n\nif\ncase true =>  S;\ncase true =>  T;\ncase true =>  U;\n\n\n1\n2\n3\n4\n\n\n\n# 0.2. Binding Guards\n\nFinally, both the common if statement and the if-case statement allow guards to introduce a variable with some constraints. These are called binding guards.\n\nFor example, suppose you want to perform an operation to an arbitrary even number in a given set, unless the set contains no even number, in which case you want to do something else. One way to accomplish this is to write an if statement whose then branch uses an assign-such-that statement to pick such an element:\n\nif exists x :: x in S && x % 2 == 0 {\n  var x :| x in S && x % 2 == 0;\n  ProcessEven(x);\n} else {\n  ProcessEmpty();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nBut there is a lot of duplication between the existential quantifier in the guard and the assign-such-that statement in the then branch. With a binding guard, the same program can be written as follows:\n\nif x :| x in S && x % 2 == 0 {\n  ProcessEven(x);\n} else {\n  ProcessEmpty();\n}\n\n\n1\n2\n3\n4\n5\n\n\nThis statement introduces x and picks as its value any value satisfying the condition following the :|. If no such x exists, the else branch is executed. The bound variable x is in scope only in the then branch.\n\nSimilarly, suppose you want to pick an even number from a set and apply some operation to it, or pick an odd number from the set and apply some other operation to it, or do something else if the set contains neither an even nor an odd number. Then you can use an if-case statement with binding guards:\n\nif\ncase x :| x in S && x % 2 == 0 =>\n  ProcessEven(x);\ncase x :| x in S && x % 2 == 1 =>\n  ProcessOdd(x);\ncase S == {} =>\n  ProcessEmpty();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that if S contains both even and odd numbers, then Dafny may pick either of the first two cases.\n\n\n# 1. Match Statements and Match Expressions\n\nAnother branching construct is match, which also comes in a statement form and in an expression form. The syntax of these two are identical, except that each body of the former is a list of statements where each body of the latter is an expression. These have the forms\n\nmatch s\ncase A(x) =>\n  StmtList0;\ncase B(y) =>\n  StmtList1;\ncase C(z) =>\n  StmtList2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nand\n\nmatch s\ncase A(x) => Expr0\ncase B(y) => Expr1\ncase C(z) => Expr2\n\n\n1\n2\n3\n4\n\n\nrespectively.\n\nWhat follows the keyword case is a pattern, which looks like an expression built of datatype constructors and bound variables. For example, consider the standard datatype definition for a list, parameterized by an element type T:\n\ndatatype List<T> = Nil | Cons(T, List<T>)\n\n\n1\n\n\nThe following expression returns the minimum of 2 and the length of a list xs:\n\nmatch xs\ncase Nil => 0\ncase Cons(x, Nil) => 1\ncase Cons(x, Cons(y, ys)) => 2\n\n\n1\n2\n3\n4\n\n\nUnlike in several other programming languages, the cases of a match in Dafny are unordered. A bound variable that is not used can be replaced by an underscore, _. So, the match expression above can be written equivalently as\n\nmatch xs\ncase Cons(_, Nil) => 1\ncase Cons(_, Cons(_, _)) => 2\ncase Nil => 0\n\n\n1\n2\n3\n4\n\n\nAnalogously to the if-case statement, each case of a match statement is implicitly a lexical scope. In other words, any local variables declared in one case goes out of scope at the end of that branch.\n\nAlso as for the if-case statement, each case of a match goes as far as possible, but not past another case. To end a case early, the set of cases can be enclosed in a pair of curly braces. For example:\n\nmatch xs\ncase Cons(_, ys) =>\n  match ys {\n    case Cons(_, _) => 2\n    case Nil => 1\n  }\ncase Nil => 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that curly braces, not parentheses, are used in this way for both match statements and match expressions. One can, of course, also surround an entire match expression with parentheses, so the expression above can be written equivalently as:\n\nmatch xs\ncase Cons(_, ys) =>\n  (match ys\n   case Cons(_, _) => 2\n   case Nil => 1)\ncase Nil => 0\n\n\n1\n2\n3\n4\n5\n6\n\n\nIn some situations, it may also be possible to simply reorder the cases for the same effect:\n\nmatch xs\ncase Nil => 0\ncase Cons(_, ys) =>\n  match ys\n  case Nil => 1\n  case Cons(_, _) => 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. Local Variables and Let Bindings\n\nThe statement that introduces a local variable has the form:\n\nvar x: int := 17;\n\n\n1\n\n\nThe type decoration \": int“ is needed only if Dafny cannot infer the type, so it is typically omitted. The assignment of an initial value, here ”:= 17\", can also be omitted, if the initial value of the variable is irrelevant. (If the variable is used before the program explicitly assigns to it, Dafny will initialize the variable to an arbitrary value of its type.) The variable introduced stays in scope until the current lexical scope ends (typically at the next close-curly-brace).\n\nA var statement can introduce several variables. If so, any type decoration acts only on the variable it follows. That is, you can think of : as having higher binding power than the , that separates the variable names. If an initial assignment is used, it must give a value to all variables being declared. For example,\n\nvar a, b: bool, c := 13, true, 8.29;\n\n\n1\n\n\ndeclares an integer variable a, a boolean variable b, and a real-valued variable c.\n\nThe following example introduces three local variables, z, x, and y, and arranges in a complicated way to set z to 0 (where k is some integer variable in the enclosing scope):\n\nvar z;\nvar x, y := k, k;\nz := x - y;\n\n\n1\n2\n3\n\n\nThere is a form of the var statement in expressions: the let expression. The variables introduced by let expressions are usually called bound variables or let-bound variables. The syntax of the let expression is like the var statement, but followed by an expression. For example, the expression\n\nvar w := 5; w + w\n\n\n1\n\n\nreturns 10. If you're used to functional programming, you may choose to read this statement as “let” (var) w “be” (:=) 5 “in” (;) w + w.\n\nThe syntax intentionally mimics that of the var statement, to deemphasize the distinction between statements and expressions. For example, the statement that assigns to z above can be written with a let expression:\n\nvar z :=\n  var x, y := k, k;\n  x - y;\n\n\n1\n2\n3\n\n\nexcept that, here, the variables x and y are only in scope in the body of the let expression (which ends at the semi-colon); in the statement above, x and y are introduced as local variables, which remain in scope until the end of the lexical block. Note that the first semi-colon is a separator in the let expression, whereas the second semi-colon terminates the var statement.\n\nLocal variables can be modified by assignment statements. In contrast, let-bound variables are immutable. In this light, we think of a let expression as binding a value to each of its let-bound variables. Whereas the right-hand side of the := in a var statement gives initial values to the local variable, the right-hand side of the := in a let expression provides defining values for the let-bound variables. A syntactic difference between the var statement and let expression is that a let expression must always include the := and the accompanying defining expressions.\n\nThe relation between var statements and let expressions is analogous to the relation between a case in a match statement and a case in a match expression. Recall, for the match constructs, each case takes the shape\n\ncase Pattern => StmtList;\n\n\n1\n\n\nor\n\ncase Pattern => Expr\n\n\n1\n\n\nrespectively. Analogously, var statements and let expressions take the respective shapes\n\nvar x := Expr; StmtList;\n\n\n1\n\n\nor\n\nvar x := Expr; Expr\n\n\n1\n\n\n\n# 2.0. Ghost Variables\n\nMany constructs in Dafny come in two manifestations: compiled or ghost. A ghost construct is used in specifications to reason about the correctness of the program, but is erased by the compiler and has no run-time cost. Local variables and let expressions come in both manifestations. The ones we saw above were all compiled manifestations. To declare local variables or let-bound variables as ghost, simply precede the var keyword with ghost.\n\nFor example,\n\nvar m := 20;\nghost var n := m + 3;\n\n\n1\n2\n\n\nintroduces a compiled variable m and a ghost variable n.\n\nDafny makes sure that ghost variables (and other ghost constructs) really can be erased by the compiler without changing the meaning of the program. One of the checks it performs is that the values of compiled variables never depend on ghost variables. For example, the following declaration of n as a compiled variable is not legal, because the use the value of a ghost variable in an assignment to a compiled variable:\n\nghost var m := 20;\nvar n := m + 3;  // error: illegal to assign a ghost to a compiled variable\n\n\n1\n2\n\n\nWhen a var statement or let expression omits the ghost keyword, all variables the statement introduces are declared as compiled. And when the ghost keyword is present, all variables the statement introduces are declared as ghost. There is one exception to this rule. The exception applies when a var statement that omits the ghost keyword gives a method call as the right-hand side. Then, any local variable that corresponds to a ghost out-parameter of the method called is implicitly declared as ghost, and if the method itself is ghost, then all of the local variables are implicitly declared as ghost.\n\nFor example, consider a method with two out-parameters, one compiled and one ghost:\n\nmethod M() returns (x: int, ghost y: int)\n\n\n1\n\n\nThe statement\n\nvar a, b := M();\n\n\n1\n\n\ndeclares a to be a compiled local variable and b to be a ghost local variable. If the statement explicitly uses the ghost keyword, as in\n\nghost var a, b := M();\n\n\n1\n\n\nthen both a and b are declared to be ghost local variables.\n\n\n# 2.1. Patterns\n\nIn a var statement and let expression, the left-hand side of := need not be a list of variables, but can be a list of patterns, just like the patterns in the cases of a match construct. This has the effect of deconstructing the right-hand side of := (that is, the initializing or defining expressions) and then assigning the new variables.\n\nFor example, using the datatype definition List from above, the var statement\n\nvar Cons(a, Cons(b, Nil)) := E;\n\n\n1\n\n\nintroduces two variables, a and b, and sets these to the first two elements of the list E. The value denoted by the right-hand side must match the pattern in the left-hand side, and this is enforced by the verifier. In the example, E must denote a list whose length is exactly 2.\n\nJust like in match patterns, any variable that is not needed can be replaced by an underscore. For example,\n\nvar Cons(_, Cons(b, _)) := E;\n\n\n1\n\n\nintroduces b and initializes it to the second element of the list E, where E is allowed to have more than two elements.\n\nTo discard a result from the right-hand side, use an underscore as the corresponding actual out-parameter. For example, if P is a method with one out-parameter,\n\nvar _ := P();\n\n\n1\n\n\ncalls P() and then discards its result. This is also allowed if P is a function, but then there's not much point in making the function call at all.\n\n\n# 2.2. Assign-Such-That Statements and Let-Such-That Expressions\n\nThe var statements and let expressions we've seen so far are precise about what value to assign or bind to the new variables. There's is a cousin to these constructs that instead prescribes a set of values, any one of which may be picked at run-time as the value assigned. It is the assign-such-that statement (in statement form) and the let-such-that expression (in expression form).\n\nFor example, the assign-such-that statement\n\nvar x :| x in S;\n\n\n1\n\n\nintroduces local variable x and says to set it to any value that satisfies the predicate x in S. In other words, this statement sets x to some value in S. (The verifier will complain for this example statement if it cannot prove S to be nonempty.)\n\nSyntactically, the difference between an ordinary assignment and an assign-such-that construct is that the former uses := whereas the latter uses :|. Also, in the ordinary assignment, the variables introduced are not in scope in the right-hand side, where the variables introduced are in scope in the right-hand side of the assign-such-that constructs. Like the var statement and let expression, the such-that forms can introduce multiple variables, but the left-hand side is always a list of variables, never patterns.\n\nHere is an example var statement with an assign-such-that statement that introduces three new variables, b, s, and t. It requires that either S is nonempty or N is strictly positive.\n\nvar b, s, t :| (b ==> s in S) && (!b ==> 0 <= t < N);\n\n\n1\n\n\nThe assign-such-that constructs give rise to a proof obligation that there exists some value for each of the new variables that satisfies the right-hand side. For the example above, the proof obligation thus amounts to that S is nonempty. A Dafny compiler may impose additional restrictions on the right-hand side, because it may not always be clever enough to generate executable code that is guaranteed to, in finite time, find values for the variables.\n\nThe assign-such-that statement and let-such-that expression are the same, but there is an additional restriction on compiled let-such-that expressions. The restriction stems from the fact that expressions in Dafny are always deterministic, that is, if you evaluate an expression twice in the same state, you will get the same value. This is important in order to let the verifier reason about “obvious” properties like\n\nE == E\n\n\n1\n\n\nStatements, on the other hand, can be nondeterministic, so assign-such-that statements may return different values each time they are executed:\n\nvar x :| x in S;\nvar y :| y in S;\nassert x == y;  // this condition is NOT guaranteed, unless |S| == 1\n\n\n1\n2\n3\n\n\nDafny's guarantee that let-such-that expressions be deterministic (within each run of the program) is unproblematic for ghost expressions, but the same guarantee for compiled let-such-that expressions would incur too high of a run-time cost (see [0]). Instead, Dafny restricts compiled such-that-expressions to those that uniquely specify the values of its variables. For example, if S is a nonempty set of integers, the compiled expression\n\nvar x :| x in S && forall y :: y in S ==> x <= y;\nx\n\n\n1\n2\n\n\nis legal and evaluates to the smallest element in S. Unfortunately, this restriction on compiled let-such-that expressions is sometimes more harsh than one would like.\n\n\n# 2.3. Upates\n\nLet-bound variables get their value at the time of declaration, but local variables can be subsequently updated with assignment statements or assign-such-that statements. These are like the assignments that provide the initial value of the local variables, except that patterns in the left-hand side are allowed only when the local variables are introduced, not in subsequent assignments.0\n\n\n# 3. Statement Expressions\n\nGenerally, statements contain expressions, but not the other way around. With one exception: the statement expression. It has the form S; E, where S is one of several ghost statements and E is an expression. The expression S; E evaluates to E. That is, statement S does not affect the value of the expression. The role of S is to provide information that will help prove the well-formedness of E.\n\nFor example, suppose there is a function F and a lemma AboutF that tells us something about the value returned by F:\n\nfunction method F(x: int): int\nlemma AboutF(x: int)\n  requires 0 <= x\n  ensures 0 < F(x)\n\n\n1\n2\n3\n4\n\n\nIn the example, the lemma AboutF, which can be used if x is non-negative, says that F(x) returns a positive value. Now, consider the following statement:\n\nif 0 <= y && 10 / F(y) == 2 {  // error: possible division by zero\n  // ...\n}\n\n\n1\n2\n3\n\n\nWithout further information, Dafny is unable to prove the absence of division-by-zero in the guard of this if statement. To help the verifier along, we can use the lemma. To do that, we might try calling the lemma just before the if statement:\n\nAboutF(y);  // error: precondition violation\nif 0 <= y && 10 / F(y) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nBut that doesn't work, because in that context, it could be that y is negative. By using a statement expression, we can insert the lemma call just where we need it:\n\nif 0 <= y && 10 / (AboutF(y); F(y)) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n\n\nA statement expression accepts five kinds of statements: lemma calls and assert, assume, reveal, and calc statements.\n\n\n# 3.0. Lemmas with out-parameters\n\nThere's a restriction on the lemma calls in statement expressions: the lemma must not have any out-parameters.1 This may be frustrating when it occasionally pops up.\n\nAs an example, consider the following declarations:\n\n// Some property that integers may have\npredicate P(k: int)\n\n// A lemma that, for every x, shows---by returning a witness---the\n// existence of a k satisfying P(k) \nlemma MyLemma(x: int) returns (k: int)\n  ensures P(k)\n\n// Two functions that need the P property\nfunction method G(x: int, ghost k: int): int\n  requires P(k)\nfunction method H(x: int): int\n  requires exists k :: P(k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nIt would be nice to be able to write an expression\n\nvar k := MyLemma(x); G(x, k)\n\n\n1\n\n\nor to write an expression\n\nvar _ := MyLemma(x); H(x)\n\n\n1\n\n\nwhen the out-parameter does not need to be named. But the restriction forbids these.\n\nThere are workarounds. They are rather clumsy, but they show how various expressions discussed in this note can be combined to produce the desired result.\n\nFor the latter case, a workaround is the expression\n\nassert exists k :: P(k) by {\n  var _ := MyLemma(x);\n}\nH(x)\n\n\n1\n2\n3\n4\n\n\nThe former is similar, but also uses a let-such-that expression to obtain a name for the value whose existence is proved by the first assert:\n\nassert exists k :: P(k) by {\n  var _ := MyLemma(x);\n}\nghost var k :| P(k);\nG(x, k)\n\n\n1\n2\n3\n4\n5\n\n\nNote that this let-such-that expression is ghost, so the restriction that k must be determined uniquely does not apply.\n\n\n# 4. Putting it all together\n\nDafny makes a distinction between statements and expressions, but the syntactic similarities I've discussed in this note make it less of a burden to remember what to write where. As a final example, consider the following (rather contrived) method and function for computing the same thing:\n\nmethod DoItByMethod(xs: List<int>) returns (r: nat)\n{\n  match xs\n  case Nil =>\n    return 0;\n  case Cons(x, _) =>\n    var square := x * x;\n    AboutF(square);\n    return F(square);\n}\n\nfunction method DoItByFunction(xs: List<int>): nat\n{\n  match xs\n  case Nil =>\n    0\n  case Cons(x, _) =>\n    var square := x * x;\n    AboutF(square);\n    F(square)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nTo be technical about it, the method uses a match statement, a var statement with a local variable, a lemma call, and the final function call that computes the result, whereas the function uses a match expression, a let expression with a let-bound variable, a statement expression featuring a lemma call, and the final function call.\n\nBut when you're in the midst of it, there's no need to dwell on those fine distinctions!\n\n# Acknowledgments\n\nI thank Matthias Schlaipfer for useful feedback on this note.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations, volume 35 of EPiC Series in Computer Science, pages 106–118. EasyChair, December 2015. 🔎\n\n----------------------------------------\n\n0.This restriction may be removed in some future version of the language. ↩\n\n1.This restriction may be removed in some future version of the language. ↩",normalizedContent:"dafny power user: statement versus expression syntax\n\nk. rustan m. leino\n\nmanuscript krml 266, 17 may 2019\n\nabstract. this note describes some constructs that exist in both a statement form and an expression form in dafny. it points out the syntactic similarities and differences between the two forms, and discusses related constructs.\n\ndafny distinguishes between statements and expressions. for example, the body of a method is a statement whereas the body of a function is an expression. a statement can assign to local variables, allocate and mutate objects in the heap, use loops in control flow, and be nondeterministic. an expression cannot do any of those things. instead, it can bind values to bound variables, read values in the heap, use recursion, and is always deterministic. syntactically, most statements are terminated with a semi-colon and sometimes a sequence of statements is surrounded by curly braces. a few expressions contain semi-colons, but never at the end, and an expression can be surrounded by round parentheses.\n\nlet's take a look at some constructs that exist in both a statement form and an expression form.\n\n\n# 0. if statements and if-then-else expressions\n\nof constructs that exist in both statement and expression form, the conditional (if) is probably the most common, and it is also the one with the most conspicuous difference between the two forms.\n\nthe conditional statement is the if statement, which has a “then” branch and an optional “else” branch. the “then” branch is always a block statement, which is necessarily surrounded by curly braces. the “else” branch, if present, is either a block statement or another if statement.\n\nfor example, the following statement declares local variables min and max that are assigned according to the relative sizes of x and y:\n\nvar min, max;\nif x < y {\n  min, max := x, y;\n} else {\n  min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nnotice that min and max are declared before the if statement (dafny will infer the types of these two variables), which means they are still in scope after the whole if statement. if these variables were instead declared inside each branch, they would go out of scope at the curly brace that ends each respective block statement.\n\nthe conditional expression is the if-then-else expression. unlike the if statement, the expression form uses the keyword then to separate the guard from the “then” branch, and always requires and explicit “else” branch. for example, an expression that returns the smaller of x and y is:\n\nif x < y then x else y\n\n\n1\n\n\nsuch expressions can be used as right-hand sides of assignments to local variables:\n\nvar min, max := if x < y then x else y, if x < y then y else x;\n\n\n1\n\n\nfor this example, we can also use a single if-then-else expression where each branch results in a pair. we can assign that pair to a variable, and then assign the pair's components to min and max:\n\nvar minmax := if x < y then (x,y) else (y,x);\nvar min, max := minmax.0, minmax.1;\n\n\n1\n2\n\n\nthe following shows an example of nested and cascaded if statements:\n\nvar middle;\nif x < y {\n  if y < z {\n    middle := y;\n  } else if z < x {\n    middle := x;\n  } else {\n    middle := z;\n  }\n} else {\n  if x < z {\n    middle := x;\n  } else if z < y {\n    middle := y;\n  } else {\n    middle := z;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nand here is the analogous program using conditional expressions:\n\nvar middle :=\n  if x < y then\n    if y < z then y else if z < x then x else z\n  else\n    if x < z then x else if z < y then y else z;\n\n\n1\n2\n3\n4\n5\n\n\nfor statements, there are some additional forms of conditionals. because these forms allow nondeterminism, there statements do exist in an analogous expression form. the next few subsections describe these additional conditional statements.\n\n\n# 0.0. if-case statements\n\none additional form of conditional statements is the if-case statement. instead of two mutually exclusive branches, the if-case statement provides any number of branches (cases, alternatives), and their conditions need not be mutually exclusive. syntactically, the if-case statement follows the keyword if with ones or more branches of the form\n\ncase guard => body\n\n\n1\n\n\nwhere guard is an expression and body is a list of statements.\n\nfor example, the computation of min/max can be written as follows:\n\nvar min, max;\nif\ncase x <= y =>\n  min, max := x, y;\ncase y <= x =>\n  min, max := y, x;\n\n\n1\n2\n3\n4\n5\n6\n\n\nnote that <= is the “at most” (or, some say “less than or equal to”) operator, whereas => is the piece of syntax that separates the guard and body of each case.\n\nthe if-case statement picks any one of the cases whose guard evaluates to true. the ordering of the cases is not relevant. in the example above, if x and y are equal, then the choice of which case to execute is nondeterminstic. for this example, it so happens that both cases have the same effect if x and y are equal, but that need not be so. not having to specify which branch to take when the choice is irrelevant frees the programmer's mind and, arguably, results in a cleaner, more symmetric, and more abstract program.\n\neach case gives rise to a new block scope, despite the fact that the body is a list of statements, not a block statement. in other words, any local variables declared in one case go out of scope where the case ends.\n\nthe body of a case continues until the next case begins or until the enclosing block ends. if you want to end the last case sooner, you could surround the entire if-case statement with a pair of curly braces, but that doesn't look so nice. therefore, dafny optionally allows the set of cases to be enclosed in a pair of curly braces, like this:\n\nvar min, max;\nif {\n  case x <= y =>\n    min, max := x, y;\n  case y <= x =>\n    min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nan if-case statement can have any number of branches. for example:\n\nvar middle;\nif {\n  case x <= y <= z =>  middle := y;\n  case z <= y <= x =>  middle := y;\n  case y <= x <= z =>  middle := x;\n  case z <= x <= y =>  middle := x;\n  case y <= z <= x =>  middle := z;\n  case x <= z <= y =>  middle := z;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nas i mentioned, if more than one guard evaluates to true, dafny may choose to execute any one of the the corresponding bodies (but only one!). what if none of the guards evaluates to true? that is not allowed, and the verifier will report an error if it cannot prove that at least one case applies.\n\n\n# 0.1. indiscriminate choice\n\nwhen dafny is used as a modeling language, one may want to write down several statements that can be chosen between indiscriminately. this can be done by writing * in place of the guard expression in the common if statement.\n\nfor example, the effect of the statement\n\nif * {\n  s;\n} else if * {\n  t;\n} else {\n  u;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nis to execute one of the statements s, t, or u, but you can never predict which one of those statements will be chosen.\n\nsuch an indiscriminate choice can also be written using an if-case statement:\n\nif\ncase true =>  s;\ncase true =>  t;\ncase true =>  u;\n\n\n1\n2\n3\n4\n\n\n\n# 0.2. binding guards\n\nfinally, both the common if statement and the if-case statement allow guards to introduce a variable with some constraints. these are called binding guards.\n\nfor example, suppose you want to perform an operation to an arbitrary even number in a given set, unless the set contains no even number, in which case you want to do something else. one way to accomplish this is to write an if statement whose then branch uses an assign-such-that statement to pick such an element:\n\nif exists x :: x in s && x % 2 == 0 {\n  var x :| x in s && x % 2 == 0;\n  processeven(x);\n} else {\n  processempty();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nbut there is a lot of duplication between the existential quantifier in the guard and the assign-such-that statement in the then branch. with a binding guard, the same program can be written as follows:\n\nif x :| x in s && x % 2 == 0 {\n  processeven(x);\n} else {\n  processempty();\n}\n\n\n1\n2\n3\n4\n5\n\n\nthis statement introduces x and picks as its value any value satisfying the condition following the :|. if no such x exists, the else branch is executed. the bound variable x is in scope only in the then branch.\n\nsimilarly, suppose you want to pick an even number from a set and apply some operation to it, or pick an odd number from the set and apply some other operation to it, or do something else if the set contains neither an even nor an odd number. then you can use an if-case statement with binding guards:\n\nif\ncase x :| x in s && x % 2 == 0 =>\n  processeven(x);\ncase x :| x in s && x % 2 == 1 =>\n  processodd(x);\ncase s == {} =>\n  processempty();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that if s contains both even and odd numbers, then dafny may pick either of the first two cases.\n\n\n# 1. match statements and match expressions\n\nanother branching construct is match, which also comes in a statement form and in an expression form. the syntax of these two are identical, except that each body of the former is a list of statements where each body of the latter is an expression. these have the forms\n\nmatch s\ncase a(x) =>\n  stmtlist0;\ncase b(y) =>\n  stmtlist1;\ncase c(z) =>\n  stmtlist2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nand\n\nmatch s\ncase a(x) => expr0\ncase b(y) => expr1\ncase c(z) => expr2\n\n\n1\n2\n3\n4\n\n\nrespectively.\n\nwhat follows the keyword case is a pattern, which looks like an expression built of datatype constructors and bound variables. for example, consider the standard datatype definition for a list, parameterized by an element type t:\n\ndatatype list<t> = nil | cons(t, list<t>)\n\n\n1\n\n\nthe following expression returns the minimum of 2 and the length of a list xs:\n\nmatch xs\ncase nil => 0\ncase cons(x, nil) => 1\ncase cons(x, cons(y, ys)) => 2\n\n\n1\n2\n3\n4\n\n\nunlike in several other programming languages, the cases of a match in dafny are unordered. a bound variable that is not used can be replaced by an underscore, _. so, the match expression above can be written equivalently as\n\nmatch xs\ncase cons(_, nil) => 1\ncase cons(_, cons(_, _)) => 2\ncase nil => 0\n\n\n1\n2\n3\n4\n\n\nanalogously to the if-case statement, each case of a match statement is implicitly a lexical scope. in other words, any local variables declared in one case goes out of scope at the end of that branch.\n\nalso as for the if-case statement, each case of a match goes as far as possible, but not past another case. to end a case early, the set of cases can be enclosed in a pair of curly braces. for example:\n\nmatch xs\ncase cons(_, ys) =>\n  match ys {\n    case cons(_, _) => 2\n    case nil => 1\n  }\ncase nil => 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that curly braces, not parentheses, are used in this way for both match statements and match expressions. one can, of course, also surround an entire match expression with parentheses, so the expression above can be written equivalently as:\n\nmatch xs\ncase cons(_, ys) =>\n  (match ys\n   case cons(_, _) => 2\n   case nil => 1)\ncase nil => 0\n\n\n1\n2\n3\n4\n5\n6\n\n\nin some situations, it may also be possible to simply reorder the cases for the same effect:\n\nmatch xs\ncase nil => 0\ncase cons(_, ys) =>\n  match ys\n  case nil => 1\n  case cons(_, _) => 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. local variables and let bindings\n\nthe statement that introduces a local variable has the form:\n\nvar x: int := 17;\n\n\n1\n\n\nthe type decoration \": int“ is needed only if dafny cannot infer the type, so it is typically omitted. the assignment of an initial value, here ”:= 17\", can also be omitted, if the initial value of the variable is irrelevant. (if the variable is used before the program explicitly assigns to it, dafny will initialize the variable to an arbitrary value of its type.) the variable introduced stays in scope until the current lexical scope ends (typically at the next close-curly-brace).\n\na var statement can introduce several variables. if so, any type decoration acts only on the variable it follows. that is, you can think of : as having higher binding power than the , that separates the variable names. if an initial assignment is used, it must give a value to all variables being declared. for example,\n\nvar a, b: bool, c := 13, true, 8.29;\n\n\n1\n\n\ndeclares an integer variable a, a boolean variable b, and a real-valued variable c.\n\nthe following example introduces three local variables, z, x, and y, and arranges in a complicated way to set z to 0 (where k is some integer variable in the enclosing scope):\n\nvar z;\nvar x, y := k, k;\nz := x - y;\n\n\n1\n2\n3\n\n\nthere is a form of the var statement in expressions: the let expression. the variables introduced by let expressions are usually called bound variables or let-bound variables. the syntax of the let expression is like the var statement, but followed by an expression. for example, the expression\n\nvar w := 5; w + w\n\n\n1\n\n\nreturns 10. if you're used to functional programming, you may choose to read this statement as “let” (var) w “be” (:=) 5 “in” (;) w + w.\n\nthe syntax intentionally mimics that of the var statement, to deemphasize the distinction between statements and expressions. for example, the statement that assigns to z above can be written with a let expression:\n\nvar z :=\n  var x, y := k, k;\n  x - y;\n\n\n1\n2\n3\n\n\nexcept that, here, the variables x and y are only in scope in the body of the let expression (which ends at the semi-colon); in the statement above, x and y are introduced as local variables, which remain in scope until the end of the lexical block. note that the first semi-colon is a separator in the let expression, whereas the second semi-colon terminates the var statement.\n\nlocal variables can be modified by assignment statements. in contrast, let-bound variables are immutable. in this light, we think of a let expression as binding a value to each of its let-bound variables. whereas the right-hand side of the := in a var statement gives initial values to the local variable, the right-hand side of the := in a let expression provides defining values for the let-bound variables. a syntactic difference between the var statement and let expression is that a let expression must always include the := and the accompanying defining expressions.\n\nthe relation between var statements and let expressions is analogous to the relation between a case in a match statement and a case in a match expression. recall, for the match constructs, each case takes the shape\n\ncase pattern => stmtlist;\n\n\n1\n\n\nor\n\ncase pattern => expr\n\n\n1\n\n\nrespectively. analogously, var statements and let expressions take the respective shapes\n\nvar x := expr; stmtlist;\n\n\n1\n\n\nor\n\nvar x := expr; expr\n\n\n1\n\n\n\n# 2.0. ghost variables\n\nmany constructs in dafny come in two manifestations: compiled or ghost. a ghost construct is used in specifications to reason about the correctness of the program, but is erased by the compiler and has no run-time cost. local variables and let expressions come in both manifestations. the ones we saw above were all compiled manifestations. to declare local variables or let-bound variables as ghost, simply precede the var keyword with ghost.\n\nfor example,\n\nvar m := 20;\nghost var n := m + 3;\n\n\n1\n2\n\n\nintroduces a compiled variable m and a ghost variable n.\n\ndafny makes sure that ghost variables (and other ghost constructs) really can be erased by the compiler without changing the meaning of the program. one of the checks it performs is that the values of compiled variables never depend on ghost variables. for example, the following declaration of n as a compiled variable is not legal, because the use the value of a ghost variable in an assignment to a compiled variable:\n\nghost var m := 20;\nvar n := m + 3;  // error: illegal to assign a ghost to a compiled variable\n\n\n1\n2\n\n\nwhen a var statement or let expression omits the ghost keyword, all variables the statement introduces are declared as compiled. and when the ghost keyword is present, all variables the statement introduces are declared as ghost. there is one exception to this rule. the exception applies when a var statement that omits the ghost keyword gives a method call as the right-hand side. then, any local variable that corresponds to a ghost out-parameter of the method called is implicitly declared as ghost, and if the method itself is ghost, then all of the local variables are implicitly declared as ghost.\n\nfor example, consider a method with two out-parameters, one compiled and one ghost:\n\nmethod m() returns (x: int, ghost y: int)\n\n\n1\n\n\nthe statement\n\nvar a, b := m();\n\n\n1\n\n\ndeclares a to be a compiled local variable and b to be a ghost local variable. if the statement explicitly uses the ghost keyword, as in\n\nghost var a, b := m();\n\n\n1\n\n\nthen both a and b are declared to be ghost local variables.\n\n\n# 2.1. patterns\n\nin a var statement and let expression, the left-hand side of := need not be a list of variables, but can be a list of patterns, just like the patterns in the cases of a match construct. this has the effect of deconstructing the right-hand side of := (that is, the initializing or defining expressions) and then assigning the new variables.\n\nfor example, using the datatype definition list from above, the var statement\n\nvar cons(a, cons(b, nil)) := e;\n\n\n1\n\n\nintroduces two variables, a and b, and sets these to the first two elements of the list e. the value denoted by the right-hand side must match the pattern in the left-hand side, and this is enforced by the verifier. in the example, e must denote a list whose length is exactly 2.\n\njust like in match patterns, any variable that is not needed can be replaced by an underscore. for example,\n\nvar cons(_, cons(b, _)) := e;\n\n\n1\n\n\nintroduces b and initializes it to the second element of the list e, where e is allowed to have more than two elements.\n\nto discard a result from the right-hand side, use an underscore as the corresponding actual out-parameter. for example, if p is a method with one out-parameter,\n\nvar _ := p();\n\n\n1\n\n\ncalls p() and then discards its result. this is also allowed if p is a function, but then there's not much point in making the function call at all.\n\n\n# 2.2. assign-such-that statements and let-such-that expressions\n\nthe var statements and let expressions we've seen so far are precise about what value to assign or bind to the new variables. there's is a cousin to these constructs that instead prescribes a set of values, any one of which may be picked at run-time as the value assigned. it is the assign-such-that statement (in statement form) and the let-such-that expression (in expression form).\n\nfor example, the assign-such-that statement\n\nvar x :| x in s;\n\n\n1\n\n\nintroduces local variable x and says to set it to any value that satisfies the predicate x in s. in other words, this statement sets x to some value in s. (the verifier will complain for this example statement if it cannot prove s to be nonempty.)\n\nsyntactically, the difference between an ordinary assignment and an assign-such-that construct is that the former uses := whereas the latter uses :|. also, in the ordinary assignment, the variables introduced are not in scope in the right-hand side, where the variables introduced are in scope in the right-hand side of the assign-such-that constructs. like the var statement and let expression, the such-that forms can introduce multiple variables, but the left-hand side is always a list of variables, never patterns.\n\nhere is an example var statement with an assign-such-that statement that introduces three new variables, b, s, and t. it requires that either s is nonempty or n is strictly positive.\n\nvar b, s, t :| (b ==> s in s) && (!b ==> 0 <= t < n);\n\n\n1\n\n\nthe assign-such-that constructs give rise to a proof obligation that there exists some value for each of the new variables that satisfies the right-hand side. for the example above, the proof obligation thus amounts to that s is nonempty. a dafny compiler may impose additional restrictions on the right-hand side, because it may not always be clever enough to generate executable code that is guaranteed to, in finite time, find values for the variables.\n\nthe assign-such-that statement and let-such-that expression are the same, but there is an additional restriction on compiled let-such-that expressions. the restriction stems from the fact that expressions in dafny are always deterministic, that is, if you evaluate an expression twice in the same state, you will get the same value. this is important in order to let the verifier reason about “obvious” properties like\n\ne == e\n\n\n1\n\n\nstatements, on the other hand, can be nondeterministic, so assign-such-that statements may return different values each time they are executed:\n\nvar x :| x in s;\nvar y :| y in s;\nassert x == y;  // this condition is not guaranteed, unless |s| == 1\n\n\n1\n2\n3\n\n\ndafny's guarantee that let-such-that expressions be deterministic (within each run of the program) is unproblematic for ghost expressions, but the same guarantee for compiled let-such-that expressions would incur too high of a run-time cost (see [0]). instead, dafny restricts compiled such-that-expressions to those that uniquely specify the values of its variables. for example, if s is a nonempty set of integers, the compiled expression\n\nvar x :| x in s && forall y :: y in s ==> x <= y;\nx\n\n\n1\n2\n\n\nis legal and evaluates to the smallest element in s. unfortunately, this restriction on compiled let-such-that expressions is sometimes more harsh than one would like.\n\n\n# 2.3. upates\n\nlet-bound variables get their value at the time of declaration, but local variables can be subsequently updated with assignment statements or assign-such-that statements. these are like the assignments that provide the initial value of the local variables, except that patterns in the left-hand side are allowed only when the local variables are introduced, not in subsequent assignments.0\n\n\n# 3. statement expressions\n\ngenerally, statements contain expressions, but not the other way around. with one exception: the statement expression. it has the form s; e, where s is one of several ghost statements and e is an expression. the expression s; e evaluates to e. that is, statement s does not affect the value of the expression. the role of s is to provide information that will help prove the well-formedness of e.\n\nfor example, suppose there is a function f and a lemma aboutf that tells us something about the value returned by f:\n\nfunction method f(x: int): int\nlemma aboutf(x: int)\n  requires 0 <= x\n  ensures 0 < f(x)\n\n\n1\n2\n3\n4\n\n\nin the example, the lemma aboutf, which can be used if x is non-negative, says that f(x) returns a positive value. now, consider the following statement:\n\nif 0 <= y && 10 / f(y) == 2 {  // error: possible division by zero\n  // ...\n}\n\n\n1\n2\n3\n\n\nwithout further information, dafny is unable to prove the absence of division-by-zero in the guard of this if statement. to help the verifier along, we can use the lemma. to do that, we might try calling the lemma just before the if statement:\n\naboutf(y);  // error: precondition violation\nif 0 <= y && 10 / f(y) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nbut that doesn't work, because in that context, it could be that y is negative. by using a statement expression, we can insert the lemma call just where we need it:\n\nif 0 <= y && 10 / (aboutf(y); f(y)) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n\n\na statement expression accepts five kinds of statements: lemma calls and assert, assume, reveal, and calc statements.\n\n\n# 3.0. lemmas with out-parameters\n\nthere's a restriction on the lemma calls in statement expressions: the lemma must not have any out-parameters.1 this may be frustrating when it occasionally pops up.\n\nas an example, consider the following declarations:\n\n// some property that integers may have\npredicate p(k: int)\n\n// a lemma that, for every x, shows---by returning a witness---the\n// existence of a k satisfying p(k) \nlemma mylemma(x: int) returns (k: int)\n  ensures p(k)\n\n// two functions that need the p property\nfunction method g(x: int, ghost k: int): int\n  requires p(k)\nfunction method h(x: int): int\n  requires exists k :: p(k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nit would be nice to be able to write an expression\n\nvar k := mylemma(x); g(x, k)\n\n\n1\n\n\nor to write an expression\n\nvar _ := mylemma(x); h(x)\n\n\n1\n\n\nwhen the out-parameter does not need to be named. but the restriction forbids these.\n\nthere are workarounds. they are rather clumsy, but they show how various expressions discussed in this note can be combined to produce the desired result.\n\nfor the latter case, a workaround is the expression\n\nassert exists k :: p(k) by {\n  var _ := mylemma(x);\n}\nh(x)\n\n\n1\n2\n3\n4\n\n\nthe former is similar, but also uses a let-such-that expression to obtain a name for the value whose existence is proved by the first assert:\n\nassert exists k :: p(k) by {\n  var _ := mylemma(x);\n}\nghost var k :| p(k);\ng(x, k)\n\n\n1\n2\n3\n4\n5\n\n\nnote that this let-such-that expression is ghost, so the restriction that k must be determined uniquely does not apply.\n\n\n# 4. putting it all together\n\ndafny makes a distinction between statements and expressions, but the syntactic similarities i've discussed in this note make it less of a burden to remember what to write where. as a final example, consider the following (rather contrived) method and function for computing the same thing:\n\nmethod doitbymethod(xs: list<int>) returns (r: nat)\n{\n  match xs\n  case nil =>\n    return 0;\n  case cons(x, _) =>\n    var square := x * x;\n    aboutf(square);\n    return f(square);\n}\n\nfunction method doitbyfunction(xs: list<int>): nat\n{\n  match xs\n  case nil =>\n    0\n  case cons(x, _) =>\n    var square := x * x;\n    aboutf(square);\n    f(square)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nto be technical about it, the method uses a match statement, a var statement with a local variable, a lemma call, and the final function call that computes the result, whereas the function uses a match expression, a let expression with a let-bound variable, a statement expression featuring a lemma call, and the final function call.\n\nbut when you're in the midst of it, there's no need to dwell on those fine distinctions!\n\n# acknowledgments\n\ni thank matthias schlaipfer for useful feedback on this note.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning — short presentations, volume 35 of epic series in computer science, pages 106–118. easychair, december 2015. 🔎\n\n----------------------------------------\n\n0.this restriction may be removed in some future version of the language. ↩\n\n1.this restriction may be removed in some future version of the language. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"The Parent Trick for proving termination and a function-by-method use case",frontmatter:{title:"The Parent Trick for proving termination and a function-by-method use case",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/5a4346/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/55.The%20Parent%20Trick%20for%20proving%20termination%20and%20a%20function-by-method%20use%20case.html",relativePath:"80.语言/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md",key:"v-76a9f96e",path:"/pages/5a4346/",headers:[{level:2,title:"0. Motivating example: sets of strings",slug:"_0-motivating-example-sets-of-strings",normalizedTitle:"0. motivating example: sets of strings",charIndex:427},{level:2,title:"1. Two mutually recursive functions",slug:"_1-two-mutually-recursive-functions",normalizedTitle:"1. two mutually recursive functions",charIndex:1546},{level:2,title:"2. Why the Parent Trick works",slug:"_2-why-the-parent-trick-works",normalizedTitle:"2. why the parent trick works",charIndex:5455},{level:2,title:"3. Two more remarks",slug:"_3-two-more-remarks",normalizedTitle:"3. two more remarks",charIndex:6687},{level:2,title:"4. Segue into an arduous journey",slug:"_4-segue-into-an-arduous-journey",normalizedTitle:"4. segue into an arduous journey",charIndex:7483},{level:2,title:"5. Making a unique choice",slug:"_5-making-a-unique-choice",normalizedTitle:"5. making a unique choice",charIndex:8698},{level:2,title:"6. Restructuring the recursion",slug:"_6-restructuring-the-recursion",normalizedTitle:"6. restructuring the recursion",charIndex:11804},{level:2,title:"7. A more efficient choice",slug:"_7-a-more-efficient-choice",normalizedTitle:"7. a more efficient choice",charIndex:13568},{level:2,title:"8. Function-by-method",slug:"_8-function-by-method",normalizedTitle:"8. function-by-method",charIndex:14058},{level:2,title:"9. Max as a function-by-method",slug:"_9-max-as-a-function-by-method",normalizedTitle:"9. max as a function-by-method",charIndex:15462},{level:2,title:"10. A more common situation",slug:"_10-a-more-common-situation",normalizedTitle:"10. a more common situation",charIndex:17568},{level:2,title:"11. Naming the choice",slug:"_11-naming-the-choice",normalizedTitle:"11. naming the choice",charIndex:18535},{level:2,title:"12. What you remove may differ from what you just added",slug:"_12-what-you-remove-may-differ-from-what-you-just-added",normalizedTitle:"12. what you remove may differ from what you just added",charIndex:19243},{level:2,title:"13. Termination",slug:"_13-termination",normalizedTitle:"13. termination",charIndex:21772},{level:2,title:"14. Summary",slug:"_14-summary",normalizedTitle:"14. summary",charIndex:22678},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:23301},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:23777}],headersStr:"0. Motivating example: sets of strings 1. Two mutually recursive functions 2. Why the Parent Trick works 3. Two more remarks 4. Segue into an arduous journey 5. Making a unique choice 6. Restructuring the recursion 7. A more efficient choice 8. Function-by-method 9. Max as a function-by-method 10. A more common situation 11. Naming the choice 12. What you remove may differ from what you just added 13. Termination 14. Summary Acknowledgments References",content:"Dafny Power User: The Parent Trick for proving termination, and a function-by-method use case\n\nK. Rustan M. Leino\n\nManuscript KRML 283, 11 February 2022\n\nAbstract. This note proves termination for a common situation of mutually recursive functions. After that, it takes an arduous journey to turn an aggregating set operation into compiled code, which gives an opportunity to showcase Dafny's function-by-method construct.\n\n\n# 0. Motivating example: sets of strings\n\nA nonempty prefix-closed set S of strings can be stored as a DAG where each edge is labeled with one character. The presence in S of a string L is represented by the presence of a path from the root of the DAG through edges whose labels, in order, spell out L. For example, a DAG that represents the set {\"\", \"a\", \"ab\", \"b\"} is\n\n            Node (root)\n            /  \\\n           a    b\n          /      \\\n        Node      |\n          \\       |\n           b      |\n            \\    /\n             Node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWe declare the data structure for storing such sets of strings as follows:\n\ndatatype StringSet = Node(children: map<char, StringSet>)\n\npredicate In(s: string, tree: StringSet) {\n   s == \"\" ||\n   var ch := s[0];\n      ch in tree.children.Keys &&\n      In(s[1..], tree.children[ch])\n}\n\nlemma Examples() {\n  var tree :=\n    var empty := Node(map[]);\n    var n := Node(map['b' := empty]);\n    Node(map['a' := n, 'b' := empty]);\n  assert In(\"\", tree);\n  assert In(\"ab\", tree);\n  assert !In(\"xyz\", tree);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1. Two mutually recursive functions\n\nLet's write a function that computes the length of the longest string in the set. We'll do it using two mutually recursive functions (and a helper function Maximum).\n\nfunction MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree.children.Values)\n}\n\nfunction MaxLenForest(trees: set<StringSet>): nat {\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(trees - {t});\n    Maximum(m, n)\n}\n\nfunction Maximum(x: int, y: int): int {\n  if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nBut herein lies a problem: proving termination. As it stands, the verifier complains that it cannot prove termination for the call from MaxLen to MaxLenForest or for the call from MaxLenForest to MaxLen. (But it is able to prove termination for the recursive call to MaxLenForest.)\n\nLet's remind ourselves of what the decreases clauses for the two functions are, since we didn't write them explicitly and thus get Dafny's defaults. If you hover over the functions in the IDE, you'll discover that the decreases clauses that Dafny used are the following:\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n\nfunction MaxLenForest(trees: set<StringSet>): nat\n  decreases trees\n\n\n1\n2\n3\n4\n5\n\n\nTermination for the recursive call of MaxLenForest verifies, because trees - {t} is smaller than tree. But for the other two calls, it's no wonder that termination cannot be proved, since Dafny's built-in well-founded order does not relate datatypes (here, StringSet) and sets.\n\nIf we could arrange for the decreases clauses to have the same type, or at least that the types of one is a prefix of the types of the other, we may be able to make progress. This can be done by thinking of MaxLenForest as operating in “the context of” an enclosing tree, that is, the “parent” tree of the forest. Adding such a parent parameter to MaxLenForest and, for the purpose of this presentation, showing the default decreases clauses explicitly, we get:\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction MaxLenForest(parent: StringSet, trees: set<StringSet>): nat\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is a little better, because now the verifier can prove the termination of the call from MaxLen to MaxLenForest. The reason it can do that is that Dafny's lexicographic ordering considers the 2-tuple tree, tree.children.Values to be smaller than the 1-tuple tree.\n\nBut we still need to prove termination of the call from MaxLenForest back to MaxLen. We'd like to argue that this call terminates because t is “smaller than”—that is, structurally included in—the enclosing parent. But this information is not spelled out in the program. To make the information available, we need to write a precondition for MaxLenForest that says that the forest in enclosed in parent. Dafny allows operator < to be used with datatypes, with the meaning of “structurally included in”.\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction MaxLenForest(parent: StringSet, trees: set<StringSet>): nat\n  requires forall t :: t in trees ==> t < parent\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nWith that precondition, the verifier completes the proof of the program.\n\n\n# 2. Why the Parent Trick works\n\nSo, although Dafny's well-founded order does not relate datatypes and sets, even for a set that is structurally included in a datatype value, the verifier does know that the elements of that set (assuming the type of the elements is a datatype) are structurally included in the parent. In symbols, the well-founded order does not let you prove\n\ntree.children < tree\n\n\n1\n\n\nbut it does let you prove\n\ntree.children[i] < tree\n\n\n1\n\n\nfor any i in range. This is why “the parent trick” is an idiom that lets you prove termination for these sorts of mutually recursive functions.\n\nIn summary, the need for the parent trick came about because we had two mutually recursive functions. This meant that we needed to “remember” the context in which the MaxLenForest function is called, which is done by passing the extra parameter. If MaxLenForest somehow were written as just one recursive function, then we would still use Dafny's knowledge that a datatype value d inside the set inside a datatype value D is structurally included in D (and thus d < D), but we wouldn't need to apply the parent trick to pass the context as a parameter. I will show such an example below (see function MaxLen in Section 6).\n\n\n# 3. Two more remarks\n\nFirst, in presenting the program above, I explicitly showed the decreases clauses. But if you list the parameters in the order that I did, then the explicit decreases clause will coincide with Dafny's defaults. So, you can omit the decreases clauses and the verifier will still be able to prove the program.\n\nSecond, as I wrote them, the functions are ghost, so they are erased by the compiler and not available at run time. If you want the functions to be available at run time, you might be bothered by having to pass the “parent” parameter along everywhere. This is easily solved by then marking the “parent” parameter as ghost. This is possible, because parent is not used by the function, other than for its proof, so it's fine if the compiler erases the parameter.\n\n\n# 4. Segue into an arduous journey\n\nIf you try doing what I just said in the two remarks, the functions will be declared as follows:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction method MaxLenForest(ghost parent: StringSet, trees: set<StringSet>): nat\n  requires forall t :: t in trees ==> t < parent\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nbut you'll notice an error:\n\nvar t :| t in trees;\n^ here\nError: to be compilable, the value of a let-such-that expression must be\nuniquely determined\n\n\n1\n2\n3\n4\n\n\nThis is a completely different problem than the termination problem we worked to solve above. The problem is that the choice of a t that satisfies t in trees is not unique, as is required for compiling the let-such-that expression. The reasons for this restriction are explained in a different paper [0]. If you don't care about compiling MaxLen, you can stop reading now. Otherwise, stretch your legs, get more coffee, and keep reading.\n\n\n# 5. Making a unique choice\n\nTo make the choice of t unique, we need to strengthen the constraint in the let-such-that expression. For example, we might want to pick the “smallest” of the values in trees. But what does “smallest” mean among a set of StringSet trees? An easier way out is to change the program to pass the whole map tree.children to MaxLenForest, rather than just the children trees themselves (tree.childre.Values). Then, we can pick the smallest among the labels, which—since our labels have type char—is easy to do. Here's what we get:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children)\n}\n\nfunction method MaxLenForest(ghost parent: StringSet,\n                             children: map<char, StringSet>): nat\n  requires forall lbl :: lbl in children.Keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    var lbl :|\n      lbl in children.Keys &&\n      forall lbl' :: lbl' in children.Keys ==> lbl <= lbl';\n    var m := MaxLen(children[lbl]);\n    var n := MaxLenForest(parent, children - {lbl});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nNote that the expression children - {lbl} is a map-domain subtraction. That is, it denotes the map that is like children, except it doesn't have the key lbl.\n\nThe additional constraint makes the choice unique. However, now that we've strengthened it, the verifier is no longer convinced there is any choice for lbl. To fix this problem, we need to demonstrate that every nonempty set of characters has a smallest element. The easiest way to conduct such a demonstration is to compute it:\n\nfunction PickSmallest(s: set<char>): (ch: char)\n  requires s != {}\n  ensures ch in s && forall ch' :: ch' in s ==> ch <= ch'\n{\n  var ch :| ch in s;\n  if ch' :| ch' in s && ch' < ch then\n    var s' := s - {ch};\n    assert s == s' + {ch};\n    PickSmallest(s')\n  else\n    ch\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n“But wait!”, you say. \"How come this function gets away with the weak let-such-that constraint that was a problem in MaxLenForest?\" It's because PickSmallest is a ghost function, so its let-such-that expression does not have the uniqueness requirement (see [0]). Alright, then, so our final step is to use function PickSmallest just before the let-such-that expression in MaxLenForest:\n\nfunction method MaxLenForest(ghost parent: StringSet,\n                             children: map<char, StringSet>): nat\n  requires forall lbl :: lbl in children.Keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    ghost var smallest := PickSmallest(children.Keys);\n    var lbl :|\n      lbl in children.Keys &&\n      forall lbl' :: lbl' in children.Keys ==> lbl <= lbl';\n    var m := MaxLen(children[lbl]);\n    var n := MaxLenForest(parent, children - {lbl});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nAfter putting the result of PickSmallest into a ghost variable, the verifier has all the evidence it needs for the existence of a value of lbl. So, this concludes our program.\n\n\n# 6. Restructuring the recursion\n\nThe running example has already showed several techniques and features in Dafny. But in our final program above, we still have a rather big and unsatisfying let-such-that constraint. The mandate that we have to pick a unique element from the set seems unnecessarily harsh, since all we're trying to do is compute the maximum of a set, and the maximum will be the same regardless of which order we consider the elements in. So, what we'd like to do is use nondeterminism inside MaxLenForest, as long as we can prove that the nondeterminism does not affect the result. And Dafny has just the feature for this: function-by-method declarations.\n\nTo make a reusable function, let's define a general function Max as follows:\n\nfunction method Max(s: set<int>): int\n  requires s != {}\n  ensures Max(s) in s\n  ensures forall z :: z in s ==> z <= Max(s)\n\n\n1\n2\n3\n4\n\n\nBy constructing the set of elements we want to take the maximum of, we can use Max in MaxLen:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    var s := set t | t in tree.children.Values :: MaxLen(t);\n    assert s != {} by {\n      assert forall lbl ::\n        lbl in tree.children.Keys ==> MaxLen(tree.children[lbl]) in s;\n    }\n    1 + Max(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAs you see here, the verifier needed help in proving that s is nonempty. This proof obligation is addressed by asserting that, for every label in (the known to be nonempty) tree.children, s contains the MaxLen of the corresponding value. (Since MaxLen is now recursive and doesn't go through a mutually recursive function like MaxLenForest, we don't need the parent trick. That is, there's no longer a need to pass any additional context parameter.)\n\n\n# 7. A more efficient choice\n\nFrom now on, we'll focus just on Max. It would be nice to write its body as\n\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := Max(s');\n    Maximum(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nAlas, this is not allowed, because the compiled let-such-that does not uniquely determine the value for x. This is the exactly the problem that we started with and want to steer around!\n\nFunction-by-method to the rescue.\n\n\n# 8. Function-by-method\n\nSay what?! A function-by-method is a combination of a function and method. The body of the function part of a function-by-method is a ghost expression, but this expression acts just as the specification for what value is to be returned. The body of the method part of the function-by-method then gives a compilable method body for computing the value.\n\nUsing a bit of program text, the basic idea is to declare a function-by-method like\n\nfunction F(x: X): (y: Y)\n  requires Pre(x)\n  ensures Post(x, y)\n{\n  Expr;\n} by method {\n  MBody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nwhere Expr is a ghost expression (the “function part”) and MBody is a compilable statement list (the “method part”).\n\nTo explain the meaning of this function-by-method, it's helpful to look at it as two declarations:\n\nfunction F(x: X): (y: Y)\n  requires Pre(x)\n  ensures Post(x, y)\n{\n  Expr;\n}\n\nmethod _F(x: X) returns (y: Y)\n  requires Pre(x)\n  ensures y == F(x)\n{\n  MBody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nNow, Dafny arranges that every use of the original function-by-method in a ghost context calls ghost function F, and that every use of the function-by-method is a non-ghost context calls the compiled method _F.\n\nNote that any ensures clause on the original function-by-method is a proof obligation of the function part. The postcondition of the method part is y == F(x). (I'll come back to this point later.)\n\n\n# 9. Max as a function-by-method\n\nUsing a function-by-method declaration, we write Max as follows:\n\nfunction Max(s: set<int>): (m: int)\n  requires s != {}\n  ensures m in s && forall z :: z in s ==> z <= m\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := Max(s');\n    Maximum(x, y)\n} by method {\n   m :| m in s;\n   var r := s - {m};\n   while r != {}\n     invariant r < s\n     invariant m in s && forall z :: z in s - r ==> z <= m\n   {\n     var x :| x in r;\n     assert forall z :: z in s - (r - {x}) ==> z in s - r || z == x;\n     r := r - {x};\n     if m < x {\n       m := x;\n     }\n   }\n   assert s - {} == s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nThis function-by-method verifies as given. However, the reason it verifies is subtle and may not be what you expect (especially if this is the first time you see a function-by-method). Let me explain the reason and then show a more typical proof of a function-by-method.\n\nThe point of the method part of a function-by-method is to provide a method implementation that returns exactly the same value as the given function body. For this reason, the postcondition that the method body has to satisfy is m == Max(s). This is a very precise postcondition. The ensures clause declared in the function-by-method applies to the function part. It is usually much less precise; in fact, for most functions, this ensures clause is omitted, since the body of the function transparently says what the result value is.\n\nIn general, just because the method part of a function-by-method happens to satisfy the ensures clause of the function-by-method does not mean the method part is correct. But in our Max example, the two coincide, because the ensures clause I gave for the function-by-method uniquely determines m. Thus, any method body that satisfies this ensures clause also satisfies m == Max(s). (You can confirm this by deleting m in s from the ensures clause. This will cause the method part to fail to verify, while the function part still verifies.)\n\n\n# 10. A more common situation\n\nA more generally applicable pattern for proving the method part of a recursive makes use of the function in the loop invariant. To illustrate this, I will remove the ensures clause of Max. Consequently, the iterative method body needs to establish that it computes exactly what the recursion function body does.\n\nThe idea is to use a body like this:\n\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == Max(r)\n  {\n    var x :| x in s - r;\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis loops maintains the invariant m == Max(r) while enlarging r until it becomes s. Doing this proof is tricky, because of two issues. Both of these issues have standard solutions, which are really good to know. The two issues and solutions are explained for a simpler example in another Dafny Power User note [1], but it seems worthwhile to show them here as well.\n\n\n# 11. Naming the choice\n\nThe first issue is that the let-such-that expression is like a function, but by Dafny semantics it may be a different function for each textual occurrence of :| (see [0]). It is easy to become confused and frustrated if, without realizing it, you're using more than one :| function. Therefore, let's make sure there is only one textual occurrence of this operator. We do that by putting it inside a named function:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nWith this function, we write the function part of the function-by-method Max as\n\n  var x := Pick(s);\n  if s == {x} then\n    x\n  else\n    Maximum(Max(s - {x}), x)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 12. What you remove may differ from what you just added\n\nThe second issue is that we will need to help the verifier along in the proof of invariance for the loop. The reason is that the next element that the loop adds to the growing set r may not be the same element that the Pick function would choose when going in the opposite direction. Specifically, if the loop adds x to r as it's computing Max(r + {x}), there's no reason to believe that the definition of Max(r + {x}) picks x and recurses on Max(r). (Again, for a simpler example and better motivation, see [1].)\n\nThis lemma is tricky to prove, even if you've written similar proofs several times. An additional complication for our function Max is that Max requires its argument to be nonempty. Here is the lemma and a proof:\n\nlemma MaxOfOneMore(t: set<int>, x: int)\n  requires t != {} && x !in t\n  ensures Max(t + {x}) == Maximum(Max(t), x)\n  decreases |t|\n{\n  var u := t + {x};\n  var z := Pick(u);\n  var u'x, u'z := u - {x}, u - {z};\n  assert Max(u) == Maximum(Max(u'z), z);\n\n  if z == x {\n    // Straight from the definition of Max\n  } else if t == {z} {\n    assert u'z == {x} && u'x == {z};\n    // This is known about Max on singletons:\n    assert Max(u'z) == x;\n    assert Max(u'x) == z;\n    // So, regardless of which of x and z gets picked first, the result is the same\n    assert Max(u) == Maximum(x, z) == Maximum(z, x);\n  } else {\n    var u'z'x := u'z - {x};\n    calc {\n      Maximum(Max(u'z), z);\n    ==  { assert u'z == (u'z'x) + {x}; }\n      Maximum(Max((u'z'x) + {x}), z);\n    ==  { MaxOfOneMore(u'z'x, x); }\n      Maximum(Maximum(Max(u'z'x), x), z);\n    ==  // Maximum is commutative and associative\n      Maximum(Maximum(Max(u'z'x), z), x);\n    ==  { MaxOfOneMore(u'z'x, z); }\n      Maximum(Max(u'z'x + {z}), x);\n    ==  { assert u'z'x + {z} == u'x == t; }\n      Maximum(Max(t), x);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nThat's a mouthful. But once you have the lemma, using it once in the loop body finishes the proof of our function-by-method:\n\nfunction Max(s: set<int>): (m: int)\n  requires s != {}\n{\n  var x := Pick(s);\n  if s == {x} then\n    x\n  else\n    Maximum(Max(s - {x}), x)\n} by method {\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == Max(r)\n  {\n    var x :| x in s - r;\n    MaxOfOneMore(r, x);\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 13. Termination\n\nA final remark. It looks as if Max uses the lemma MaxOfOneMore, and the lemma uses Max. Doesn't this mutual recursion mean we have to prove termination? No, because there's isn't actually any mutual recursion in this example. To understand why, remember that the two parts of a function-by-method are treated as if they were one function and one method (see Section 8). This function and method are different points in the call graph, where calls to Max from ghost contexts go to the function part and calls to Max from compiled contexts go to the method part. Therefore, we have that the following call-graph edges:\n\nMax (function) --\x3e Max (function)\nMaxOfOneMore   --\x3e MaxOfOneMore, Max (function)\nMax (method)   --\x3e MaxOfOneMore, Max (function)\n\n\n1\n2\n3\n\n\nAs you can see from these, the function part of Max is recursive and the lemma is recursive, but there is no mutual recursion.\n\n\n# 14. Summary\n\nI started this note with the innocent problem of how to prove the termination of two mutually recursive functions. As the solution, I showed the Parent Trick. I then changed the code to make it compilable, which introduced proof obligations to show certain choices to be deterministic. This can be better solved using a function-by-method, so I gave a brief introduction to Dafny's function-by-method declaration and used it to present two solutions. The more straightforward solution worked for the example at hand, whereas the second solution shows a more typical pattern for such method implementations.\n\n# Acknowledgments\n\nI'm grateful to Mikaël Mayer for asking a question about these mutually recursive functions, which propelled me to write this note, and for his helpful comments on the write-up. The function-by-method construct was designed as a direct outgrowth of some collaborative work with Daniel Matichuk, Olivier Savary Belanger, and Mike Dodds, where as a step toward verified compilation we were considering how to implement immutable things with mutable things.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations, volume 35 of EPiC Series in Computing, pages 106–118. EasyChair, 2015. https://easychair.org/publications/paper/dM. 🔎\n\n[1]K. Rustan M. Leino. Dafny power user: Functions over set elements. Manuscript KRML 274, February 2020. http://leino.science/papers/krml274.html. 🔎",normalizedContent:"dafny power user: the parent trick for proving termination, and a function-by-method use case\n\nk. rustan m. leino\n\nmanuscript krml 283, 11 february 2022\n\nabstract. this note proves termination for a common situation of mutually recursive functions. after that, it takes an arduous journey to turn an aggregating set operation into compiled code, which gives an opportunity to showcase dafny's function-by-method construct.\n\n\n# 0. motivating example: sets of strings\n\na nonempty prefix-closed set s of strings can be stored as a dag where each edge is labeled with one character. the presence in s of a string l is represented by the presence of a path from the root of the dag through edges whose labels, in order, spell out l. for example, a dag that represents the set {\"\", \"a\", \"ab\", \"b\"} is\n\n            node (root)\n            /  \\\n           a    b\n          /      \\\n        node      |\n          \\       |\n           b      |\n            \\    /\n             node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nwe declare the data structure for storing such sets of strings as follows:\n\ndatatype stringset = node(children: map<char, stringset>)\n\npredicate in(s: string, tree: stringset) {\n   s == \"\" ||\n   var ch := s[0];\n      ch in tree.children.keys &&\n      in(s[1..], tree.children[ch])\n}\n\nlemma examples() {\n  var tree :=\n    var empty := node(map[]);\n    var n := node(map['b' := empty]);\n    node(map['a' := n, 'b' := empty]);\n  assert in(\"\", tree);\n  assert in(\"ab\", tree);\n  assert !in(\"xyz\", tree);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1. two mutually recursive functions\n\nlet's write a function that computes the length of the longest string in the set. we'll do it using two mutually recursive functions (and a helper function maximum).\n\nfunction maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree.children.values)\n}\n\nfunction maxlenforest(trees: set<stringset>): nat {\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(trees - {t});\n    maximum(m, n)\n}\n\nfunction maximum(x: int, y: int): int {\n  if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nbut herein lies a problem: proving termination. as it stands, the verifier complains that it cannot prove termination for the call from maxlen to maxlenforest or for the call from maxlenforest to maxlen. (but it is able to prove termination for the recursive call to maxlenforest.)\n\nlet's remind ourselves of what the decreases clauses for the two functions are, since we didn't write them explicitly and thus get dafny's defaults. if you hover over the functions in the ide, you'll discover that the decreases clauses that dafny used are the following:\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n\nfunction maxlenforest(trees: set<stringset>): nat\n  decreases trees\n\n\n1\n2\n3\n4\n5\n\n\ntermination for the recursive call of maxlenforest verifies, because trees - {t} is smaller than tree. but for the other two calls, it's no wonder that termination cannot be proved, since dafny's built-in well-founded order does not relate datatypes (here, stringset) and sets.\n\nif we could arrange for the decreases clauses to have the same type, or at least that the types of one is a prefix of the types of the other, we may be able to make progress. this can be done by thinking of maxlenforest as operating in “the context of” an enclosing tree, that is, the “parent” tree of the forest. adding such a parent parameter to maxlenforest and, for the purpose of this presentation, showing the default decreases clauses explicitly, we get:\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction maxlenforest(parent: stringset, trees: set<stringset>): nat\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is a little better, because now the verifier can prove the termination of the call from maxlen to maxlenforest. the reason it can do that is that dafny's lexicographic ordering considers the 2-tuple tree, tree.children.values to be smaller than the 1-tuple tree.\n\nbut we still need to prove termination of the call from maxlenforest back to maxlen. we'd like to argue that this call terminates because t is “smaller than”—that is, structurally included in—the enclosing parent. but this information is not spelled out in the program. to make the information available, we need to write a precondition for maxlenforest that says that the forest in enclosed in parent. dafny allows operator < to be used with datatypes, with the meaning of “structurally included in”.\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction maxlenforest(parent: stringset, trees: set<stringset>): nat\n  requires forall t :: t in trees ==> t < parent\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nwith that precondition, the verifier completes the proof of the program.\n\n\n# 2. why the parent trick works\n\nso, although dafny's well-founded order does not relate datatypes and sets, even for a set that is structurally included in a datatype value, the verifier does know that the elements of that set (assuming the type of the elements is a datatype) are structurally included in the parent. in symbols, the well-founded order does not let you prove\n\ntree.children < tree\n\n\n1\n\n\nbut it does let you prove\n\ntree.children[i] < tree\n\n\n1\n\n\nfor any i in range. this is why “the parent trick” is an idiom that lets you prove termination for these sorts of mutually recursive functions.\n\nin summary, the need for the parent trick came about because we had two mutually recursive functions. this meant that we needed to “remember” the context in which the maxlenforest function is called, which is done by passing the extra parameter. if maxlenforest somehow were written as just one recursive function, then we would still use dafny's knowledge that a datatype value d inside the set inside a datatype value d is structurally included in d (and thus d < d), but we wouldn't need to apply the parent trick to pass the context as a parameter. i will show such an example below (see function maxlen in section 6).\n\n\n# 3. two more remarks\n\nfirst, in presenting the program above, i explicitly showed the decreases clauses. but if you list the parameters in the order that i did, then the explicit decreases clause will coincide with dafny's defaults. so, you can omit the decreases clauses and the verifier will still be able to prove the program.\n\nsecond, as i wrote them, the functions are ghost, so they are erased by the compiler and not available at run time. if you want the functions to be available at run time, you might be bothered by having to pass the “parent” parameter along everywhere. this is easily solved by then marking the “parent” parameter as ghost. this is possible, because parent is not used by the function, other than for its proof, so it's fine if the compiler erases the parameter.\n\n\n# 4. segue into an arduous journey\n\nif you try doing what i just said in the two remarks, the functions will be declared as follows:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction method maxlenforest(ghost parent: stringset, trees: set<stringset>): nat\n  requires forall t :: t in trees ==> t < parent\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nbut you'll notice an error:\n\nvar t :| t in trees;\n^ here\nerror: to be compilable, the value of a let-such-that expression must be\nuniquely determined\n\n\n1\n2\n3\n4\n\n\nthis is a completely different problem than the termination problem we worked to solve above. the problem is that the choice of a t that satisfies t in trees is not unique, as is required for compiling the let-such-that expression. the reasons for this restriction are explained in a different paper [0]. if you don't care about compiling maxlen, you can stop reading now. otherwise, stretch your legs, get more coffee, and keep reading.\n\n\n# 5. making a unique choice\n\nto make the choice of t unique, we need to strengthen the constraint in the let-such-that expression. for example, we might want to pick the “smallest” of the values in trees. but what does “smallest” mean among a set of stringset trees? an easier way out is to change the program to pass the whole map tree.children to maxlenforest, rather than just the children trees themselves (tree.childre.values). then, we can pick the smallest among the labels, which—since our labels have type char—is easy to do. here's what we get:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children)\n}\n\nfunction method maxlenforest(ghost parent: stringset,\n                             children: map<char, stringset>): nat\n  requires forall lbl :: lbl in children.keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    var lbl :|\n      lbl in children.keys &&\n      forall lbl' :: lbl' in children.keys ==> lbl <= lbl';\n    var m := maxlen(children[lbl]);\n    var n := maxlenforest(parent, children - {lbl});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nnote that the expression children - {lbl} is a map-domain subtraction. that is, it denotes the map that is like children, except it doesn't have the key lbl.\n\nthe additional constraint makes the choice unique. however, now that we've strengthened it, the verifier is no longer convinced there is any choice for lbl. to fix this problem, we need to demonstrate that every nonempty set of characters has a smallest element. the easiest way to conduct such a demonstration is to compute it:\n\nfunction picksmallest(s: set<char>): (ch: char)\n  requires s != {}\n  ensures ch in s && forall ch' :: ch' in s ==> ch <= ch'\n{\n  var ch :| ch in s;\n  if ch' :| ch' in s && ch' < ch then\n    var s' := s - {ch};\n    assert s == s' + {ch};\n    picksmallest(s')\n  else\n    ch\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n“but wait!”, you say. \"how come this function gets away with the weak let-such-that constraint that was a problem in maxlenforest?\" it's because picksmallest is a ghost function, so its let-such-that expression does not have the uniqueness requirement (see [0]). alright, then, so our final step is to use function picksmallest just before the let-such-that expression in maxlenforest:\n\nfunction method maxlenforest(ghost parent: stringset,\n                             children: map<char, stringset>): nat\n  requires forall lbl :: lbl in children.keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    ghost var smallest := picksmallest(children.keys);\n    var lbl :|\n      lbl in children.keys &&\n      forall lbl' :: lbl' in children.keys ==> lbl <= lbl';\n    var m := maxlen(children[lbl]);\n    var n := maxlenforest(parent, children - {lbl});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nafter putting the result of picksmallest into a ghost variable, the verifier has all the evidence it needs for the existence of a value of lbl. so, this concludes our program.\n\n\n# 6. restructuring the recursion\n\nthe running example has already showed several techniques and features in dafny. but in our final program above, we still have a rather big and unsatisfying let-such-that constraint. the mandate that we have to pick a unique element from the set seems unnecessarily harsh, since all we're trying to do is compute the maximum of a set, and the maximum will be the same regardless of which order we consider the elements in. so, what we'd like to do is use nondeterminism inside maxlenforest, as long as we can prove that the nondeterminism does not affect the result. and dafny has just the feature for this: function-by-method declarations.\n\nto make a reusable function, let's define a general function max as follows:\n\nfunction method max(s: set<int>): int\n  requires s != {}\n  ensures max(s) in s\n  ensures forall z :: z in s ==> z <= max(s)\n\n\n1\n2\n3\n4\n\n\nby constructing the set of elements we want to take the maximum of, we can use max in maxlen:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    var s := set t | t in tree.children.values :: maxlen(t);\n    assert s != {} by {\n      assert forall lbl ::\n        lbl in tree.children.keys ==> maxlen(tree.children[lbl]) in s;\n    }\n    1 + max(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nas you see here, the verifier needed help in proving that s is nonempty. this proof obligation is addressed by asserting that, for every label in (the known to be nonempty) tree.children, s contains the maxlen of the corresponding value. (since maxlen is now recursive and doesn't go through a mutually recursive function like maxlenforest, we don't need the parent trick. that is, there's no longer a need to pass any additional context parameter.)\n\n\n# 7. a more efficient choice\n\nfrom now on, we'll focus just on max. it would be nice to write its body as\n\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := max(s');\n    maximum(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nalas, this is not allowed, because the compiled let-such-that does not uniquely determine the value for x. this is the exactly the problem that we started with and want to steer around!\n\nfunction-by-method to the rescue.\n\n\n# 8. function-by-method\n\nsay what?! a function-by-method is a combination of a function and method. the body of the function part of a function-by-method is a ghost expression, but this expression acts just as the specification for what value is to be returned. the body of the method part of the function-by-method then gives a compilable method body for computing the value.\n\nusing a bit of program text, the basic idea is to declare a function-by-method like\n\nfunction f(x: x): (y: y)\n  requires pre(x)\n  ensures post(x, y)\n{\n  expr;\n} by method {\n  mbody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nwhere expr is a ghost expression (the “function part”) and mbody is a compilable statement list (the “method part”).\n\nto explain the meaning of this function-by-method, it's helpful to look at it as two declarations:\n\nfunction f(x: x): (y: y)\n  requires pre(x)\n  ensures post(x, y)\n{\n  expr;\n}\n\nmethod _f(x: x) returns (y: y)\n  requires pre(x)\n  ensures y == f(x)\n{\n  mbody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nnow, dafny arranges that every use of the original function-by-method in a ghost context calls ghost function f, and that every use of the function-by-method is a non-ghost context calls the compiled method _f.\n\nnote that any ensures clause on the original function-by-method is a proof obligation of the function part. the postcondition of the method part is y == f(x). (i'll come back to this point later.)\n\n\n# 9. max as a function-by-method\n\nusing a function-by-method declaration, we write max as follows:\n\nfunction max(s: set<int>): (m: int)\n  requires s != {}\n  ensures m in s && forall z :: z in s ==> z <= m\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := max(s');\n    maximum(x, y)\n} by method {\n   m :| m in s;\n   var r := s - {m};\n   while r != {}\n     invariant r < s\n     invariant m in s && forall z :: z in s - r ==> z <= m\n   {\n     var x :| x in r;\n     assert forall z :: z in s - (r - {x}) ==> z in s - r || z == x;\n     r := r - {x};\n     if m < x {\n       m := x;\n     }\n   }\n   assert s - {} == s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nthis function-by-method verifies as given. however, the reason it verifies is subtle and may not be what you expect (especially if this is the first time you see a function-by-method). let me explain the reason and then show a more typical proof of a function-by-method.\n\nthe point of the method part of a function-by-method is to provide a method implementation that returns exactly the same value as the given function body. for this reason, the postcondition that the method body has to satisfy is m == max(s). this is a very precise postcondition. the ensures clause declared in the function-by-method applies to the function part. it is usually much less precise; in fact, for most functions, this ensures clause is omitted, since the body of the function transparently says what the result value is.\n\nin general, just because the method part of a function-by-method happens to satisfy the ensures clause of the function-by-method does not mean the method part is correct. but in our max example, the two coincide, because the ensures clause i gave for the function-by-method uniquely determines m. thus, any method body that satisfies this ensures clause also satisfies m == max(s). (you can confirm this by deleting m in s from the ensures clause. this will cause the method part to fail to verify, while the function part still verifies.)\n\n\n# 10. a more common situation\n\na more generally applicable pattern for proving the method part of a recursive makes use of the function in the loop invariant. to illustrate this, i will remove the ensures clause of max. consequently, the iterative method body needs to establish that it computes exactly what the recursion function body does.\n\nthe idea is to use a body like this:\n\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == max(r)\n  {\n    var x :| x in s - r;\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nthis loops maintains the invariant m == max(r) while enlarging r until it becomes s. doing this proof is tricky, because of two issues. both of these issues have standard solutions, which are really good to know. the two issues and solutions are explained for a simpler example in another dafny power user note [1], but it seems worthwhile to show them here as well.\n\n\n# 11. naming the choice\n\nthe first issue is that the let-such-that expression is like a function, but by dafny semantics it may be a different function for each textual occurrence of :| (see [0]). it is easy to become confused and frustrated if, without realizing it, you're using more than one :| function. therefore, let's make sure there is only one textual occurrence of this operator. we do that by putting it inside a named function:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nwith this function, we write the function part of the function-by-method max as\n\n  var x := pick(s);\n  if s == {x} then\n    x\n  else\n    maximum(max(s - {x}), x)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 12. what you remove may differ from what you just added\n\nthe second issue is that we will need to help the verifier along in the proof of invariance for the loop. the reason is that the next element that the loop adds to the growing set r may not be the same element that the pick function would choose when going in the opposite direction. specifically, if the loop adds x to r as it's computing max(r + {x}), there's no reason to believe that the definition of max(r + {x}) picks x and recurses on max(r). (again, for a simpler example and better motivation, see [1].)\n\nthis lemma is tricky to prove, even if you've written similar proofs several times. an additional complication for our function max is that max requires its argument to be nonempty. here is the lemma and a proof:\n\nlemma maxofonemore(t: set<int>, x: int)\n  requires t != {} && x !in t\n  ensures max(t + {x}) == maximum(max(t), x)\n  decreases |t|\n{\n  var u := t + {x};\n  var z := pick(u);\n  var u'x, u'z := u - {x}, u - {z};\n  assert max(u) == maximum(max(u'z), z);\n\n  if z == x {\n    // straight from the definition of max\n  } else if t == {z} {\n    assert u'z == {x} && u'x == {z};\n    // this is known about max on singletons:\n    assert max(u'z) == x;\n    assert max(u'x) == z;\n    // so, regardless of which of x and z gets picked first, the result is the same\n    assert max(u) == maximum(x, z) == maximum(z, x);\n  } else {\n    var u'z'x := u'z - {x};\n    calc {\n      maximum(max(u'z), z);\n    ==  { assert u'z == (u'z'x) + {x}; }\n      maximum(max((u'z'x) + {x}), z);\n    ==  { maxofonemore(u'z'x, x); }\n      maximum(maximum(max(u'z'x), x), z);\n    ==  // maximum is commutative and associative\n      maximum(maximum(max(u'z'x), z), x);\n    ==  { maxofonemore(u'z'x, z); }\n      maximum(max(u'z'x + {z}), x);\n    ==  { assert u'z'x + {z} == u'x == t; }\n      maximum(max(t), x);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nthat's a mouthful. but once you have the lemma, using it once in the loop body finishes the proof of our function-by-method:\n\nfunction max(s: set<int>): (m: int)\n  requires s != {}\n{\n  var x := pick(s);\n  if s == {x} then\n    x\n  else\n    maximum(max(s - {x}), x)\n} by method {\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == max(r)\n  {\n    var x :| x in s - r;\n    maxofonemore(r, x);\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 13. termination\n\na final remark. it looks as if max uses the lemma maxofonemore, and the lemma uses max. doesn't this mutual recursion mean we have to prove termination? no, because there's isn't actually any mutual recursion in this example. to understand why, remember that the two parts of a function-by-method are treated as if they were one function and one method (see section 8). this function and method are different points in the call graph, where calls to max from ghost contexts go to the function part and calls to max from compiled contexts go to the method part. therefore, we have that the following call-graph edges:\n\nmax (function) --\x3e max (function)\nmaxofonemore   --\x3e maxofonemore, max (function)\nmax (method)   --\x3e maxofonemore, max (function)\n\n\n1\n2\n3\n\n\nas you can see from these, the function part of max is recursive and the lemma is recursive, but there is no mutual recursion.\n\n\n# 14. summary\n\ni started this note with the innocent problem of how to prove the termination of two mutually recursive functions. as the solution, i showed the parent trick. i then changed the code to make it compilable, which introduced proof obligations to show certain choices to be deterministic. this can be better solved using a function-by-method, so i gave a brief introduction to dafny's function-by-method declaration and used it to present two solutions. the more straightforward solution worked for the example at hand, whereas the second solution shows a more typical pattern for such method implementations.\n\n# acknowledgments\n\ni'm grateful to mikael mayer for asking a question about these mutually recursive functions, which propelled me to write this note, and for his helpful comments on the write-up. the function-by-method construct was designed as a direct outgrowth of some collaborative work with daniel matichuk, olivier savary belanger, and mike dodds, where as a step toward verified compilation we were considering how to implement immutable things with mutable things.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning — short presentations, volume 35 of epic series in computing, pages 106–118. easychair, 2015. https://easychair.org/publications/paper/dm. 🔎\n\n[1]k. rustan m. leino. dafny power user: functions over set elements. manuscript krml 274, february 2020. http://leino.science/papers/krml274.html. 🔎",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Type-Parameter Completion",frontmatter:{title:"Type-Parameter Completion",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c45b5a/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/60.Type-Parameter%20Completion.html",relativePath:"80.语言/30.publication-lecture/60.Type-Parameter Completion.md",key:"v-b98a2e5c",path:"/pages/c45b5a/",headers:[{level:2,title:"[#](http://leino.science/papers/krml270.html#sec-type-parameters)0. Type Parameters",slug:"_0-type-parameters",normalizedTitle:'<a href="http://leino.science/papers/krml270.html#sec-type-parameters" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>0. type parameters',charIndex:null},{level:2,title:"1. Examples",slug:"_1-examples",normalizedTitle:"1. examples",charIndex:1887},{level:2,title:"2. Filling in Missing Type Arguments",slug:"_2-filling-in-missing-type-arguments",normalizedTitle:"2. filling in missing type arguments",charIndex:3101},{level:3,title:"2.0. Example: One type parameter",slug:"_2-0-example-one-type-parameter",normalizedTitle:"2.0. example: one type parameter",charIndex:3524},{level:3,title:"2.1. Example: Two type parameters",slug:"_2-1-example-two-type-parameters",normalizedTitle:"2.1. example: two type parameters",charIndex:4223},{level:3,title:"2.2. Example: Nested type parameters",slug:"_2-2-example-nested-type-parameters",normalizedTitle:"2.2. example: nested type parameters",charIndex:6671},{level:3,title:"2.3. Example: Datatype",slug:"_2-3-example-datatype",normalizedTitle:"2.3. example: datatype",charIndex:7229},{level:2,title:"3. Auto-Declaring Type Parameters",slug:"_3-auto-declaring-type-parameters",normalizedTitle:"3. auto-declaring type parameters",charIndex:7431},{level:3,title:"3.0. Examples",slug:"_3-0-examples",normalizedTitle:"3.0. examples",charIndex:7956},{level:3,title:"3.1. Sometimes you need formal type parameters",slug:"_3-1-sometimes-you-need-formal-type-parameters",normalizedTitle:"3.1. sometimes you need formal type parameters",charIndex:9018},{level:2,title:"4. Final Notes",slug:"_4-final-notes",normalizedTitle:"4. final notes",charIndex:9820}],headersStr:"[#](http://leino.science/papers/krml270.html#sec-type-parameters)0. Type Parameters 1. Examples 2. Filling in Missing Type Arguments 2.0. Example: One type parameter 2.1. Example: Two type parameters 2.2. Example: Nested type parameters 2.3. Example: Datatype 3. Auto-Declaring Type Parameters 3.0. Examples 3.1. Sometimes you need formal type parameters 4. Final Notes",content:"Dafny Power User: Type-Parameter Completion\n\nK. Rustan M. Leino\n\nManuscript KRML 270, 22 June 2019\n\nAbstract. When type parameters don't need to be named, Dafny has a scheme for filling them in automatically. Omitting the type parameters reduces clutter in function signatures. This note describes how the type parameters get filled in.\n\n\n# #0. Type Parameters\n\nAs in many languages, types in Dafny can be parameterized by other types. For example, the type set<int> denotes finite sets of integers and is parameterized by int. As another example, if List is a type defined as\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\n\n1\n\n\nand Expr is a type denoting expressions, then List<Expr> is a type that is parameterized by Expr. In the declaration of List, A is a formal type parameter, and in the type List<Expr>, Expr is the actual type parameter (or, actual type argument).\n\nSince set and List each requires a type parameter, they are not themselves types. That is, it doesn't make sense for a variable to have type set. We say that set and List are type constructors. More precisely, they are unary type constructors, since they take one type parameter. Each type constructor has an arity, which says how many type parameters it needs. So, a unary type constructor has arity 1. (There are no type constructors with arity 0; such a thing is simply a type.)\n\nIn Dafny, type constructors are not first class. This means that every mention of a type constructor must always be fully instantiated. However, the instantiation need not be explicit in the program text.\n\nIn the signature declarations of datatypes, functions, and methods, Dafny allows type constructors to be used without explicit type parameters. In this note, I describe Dafny's scheme for filling in those missing type parameters.0\n\nLet's start by looking at two examples that show the advantages of having such a scheme.\n\n\n# 1. Examples\n\nHere are functions for computing the length of a list and for computing the set of elements in a list.\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Elements(list: List): set {\n  match list\n  case Nil => {}\n  case Cons(x, tail) => {x} + Elements(tail)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAt first glance, they look to be exactly what you expect. But if you think some more, you will notice that List and set have no given type parameters. This is delightful! Both Length and Elements have more to do with the structure of the list than with the types of the elements stored in the list, and therefore it's nice that the definitions of these functions don't need to be cluttered up with the declaration and uses of the type parameters.\n\nIf you wrote the type parameters explicitly, the signatures of the functions above would look like this:\n\nfunction method Length<A>(list: List<A>): nat\nfunction method Elements<A>(list: List<A>): set<A>\n\n\n1\n2\n\n\nYou'll agree this is rather heavy on the <A>'s.1\n\nSo that you can use these abridged signatures effectively, let's now look at how omitted type parameters are filled in.\n\n\n# 2. Filling in Missing Type Arguments\n\nIn the type signatures of functions and methods and in the right-hand side of (the \"=\" in) datatype definitions, type parameters can be omitted. The rule is that if the type signature or right-hand side mentions a type constructor without any type arguments, then Dafny will fill these in from a prefix of the formal type parameters of the enclosing function, method, or datatype.\n\n\n# 2.0. Example: One type parameter\n\nSuppose the program text includes the following function signature:\n\nfunction method ReverseAux<A>(list: List<A>, acc: List): List<A>\n\n<A>\n\n\n1\n2\n3\n\n\nNote that List in the type of acc does not have an explicit type argument. Dafny now fills in the type parameter of List using the type parameter of function ReverseAux, completing the type of acc List<A>, as illustrated by the arrow above.2\n\nThe type arguments to the other occurrences of List in the function's type signature can be filled in in the same manner. So, the same function ReverseAux can be declared simply as:\n\nfunction method ReverseAux<A>(list: List, acc: List): List\n\n\n<A>``<A>``<A>\n\n\n1\n2\n3\n4\n\n\n\n# 2.1. Example: Two type parameters\n\nConsider a datatype Path with two type parameters:\n\ndatatype Path<L,R> = Stop | Left(L, Path<L,R>) | Right(R, Path<L,R>)\n\n\n1\n\n\nA value of type Path<L,R> represents a finite path of left- and right-turns. Each left-step is accompanied by a value (call it a “breadcrumb”, if you wish) of type L and every right-step is accompanied by a breadcrumb of type R.\n\nHere are two functions on paths. Hansel picks up all the breadcrumbs encountered on left turns and Gretel picks up all the breadcrumbs encountered on right turns.\n\nfunction Hansel<L,R>(p: Path<L,R>): List<L> {\n  match p\n  case Stop => Nil\n  case Left(l, rest) => Cons(l, Hansel(rest))\n  case Right(_, rest) => Hansel(rest)\n}\n\nfunction Gretel<L,R>(p: Path<L,R>): List<R> {\n  match p\n  case Stop => Nil\n  case Left(_, rest) => Gretel(rest)\n  case Right(r, rest) => Cons(r, Gretel(rest))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nUsing Dafny's type-parameter completion, we can write these as:\n\ndatatype Path<L,R> = Stop | Left(L, Path) | Right(R, Path)\n\n\n\n\nfunction Hansel<L,R>(p: Path): List\n\n\n\nfunction Gretel<L,R>(p: Path): List<R>\n\n<L,R>``<L,R>\n<L,R>``<L>\n<L,R>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nNote that both occurrences of Path in the right-hand side of the declaration of type Path get both type arguments filled in with the type's type parameters <L,R> given in the left-hand side of the declaration. In both of the functions, Path also gets the arguments <L,R> as declared in the functions. Moreover, for Hansel, type List automatically gets the argument <L>, because List needs one argument and therefore it only picks up a prefix of the function's type parameters <L,R>. Function Gretel has result type List<R>. Here, it is not possible to elide the type argument list <R>, since <R> is not a prefix of <L,R>.\n\nThe example illustrates how type-parameter completion picks a prefix of the enclosing function's type parameters. This allows you to write just List instead of List<L>. However, since L and R otherwise play symmetric roles in this example, you can of course also choose to write out List<L> explicitly. You may argue that doing so more clearly highlights the difference between functions Hansel and Gretel. You would then write the following signatures:\n\ndatatype Path<L,R> = Stop | Left(L, Path) | Right(R, Path)\nfunction Hansel<L,R>(p: Path): List<L>\nfunction Gretel<L,R>(p: Path): List<R>\n\n\n1\n2\n3\n\n\nwhich still looks pretty clean.\n\n\n# 2.2. Example: Nested type parameters\n\nType-parameter completion applies not just to the outermost types. For example,\n\ndatatype Tree<A> = Node(children: List<Tree<A>>)\n\n\n1\n\n\ncan also be written as\n\ndatatype Tree<A> = Node(children: List<Tree>)\n  \n<A>\n\n\n1\n2\n3\n\n\nNote that if you supply any type parameters at all, then Dafny will not change or complete the list you have given. The completion rule supplies the parameters to a type constructor only if the type constructor is mentioned with no type arguments at all (that is, without any angle brackets).\n\n\n# 2.3. Example: Datatype\n\nType-parameter completion also applies in the right-hand side of datatypes. So, if you want to, you can declare List as follows:\n\ndatatype List<A> = Nil | Cons(A, List)\n\n\n1\n\n\n\n# 3. Auto-Declaring Type Parameters\n\nWhat I described so far pertains to the actual type arguments of type constructors in signatures. There's one more part to Dafny's type-parameter completion. For functions and methods, but not for datatypes, if the function or method is declared without explicit formal type parameters, then Dafny provides these as well. This list of formal type parameters in this completion will be made long enough to cover the length of any missing type-argument list described in Section 2 above.\n\n\n# 3.0. Examples\n\nAs we saw in Section 2.0 above, function ReverseAux can omit the uses of its type parameter A. Consequently, there is no need for the signature to mention A by name. Dafny's type-parameter auto-declaration rule allows us to omit A altogether. By doing so, we can declare ReverseAux simply as\n\nfunction method ReverseAux(list: List, acc: List): List\n\n\n1\n\n\n<A>``<A>``<A>\n\n\n1\n\n\nThis declaration says that ReverseAux takes two lists and returns a list. There's no need to explicitly mention the type of list elements, and it is tacitly understood that the three lists mentioned have the same type of elements.\n\nWe already saw two other examples in the motivational Section 3.0: Length and Elements. Function Elements relies on type-parameter completion in three ways: both the user-defined type constructor List and the built-in type constructor set are completed with the same type parameter and this (un-named) type parameter is added to the formal type parameters of the function.\n\nfunction method Elements(list: List): set\n\n\n1\n\n\n<A>``<A>\n\n\n1\n\n\n\n# 3.1. Sometimes you need formal type parameters\n\nNote that you cannot take advantage of the auto-declaration part of type-parameter completion if you have a need to mention the type parameter. For example, you can shorten the signature of Snoc to:\n\nfunction method Snoc<A>(list: List, a: A): List {\n  match list\n  case Nil => Cons(a, Nil)\n  case Cons(x, tail) => Cons(x, Snoc(tail, a))\n}\n\n\n1\n2\n3\n4\n5\n\n\nBut since a's type needs to be mentioned as A, you must declare A explicitly. That is, you cannot abbreviate Snoc's type signature more than this.\n\nActual type parameters are completed in the right-hand side of datatype declarations, but auto-declaration of formal type parameters does not apply to datatypes. For example, you cannot omit the <A> in the left-hand side of the declaration of List.\n\n\n# 4. Final Notes\n\nRecall that if you supply any type parameters at all, then Dafny will not extend the list you have given. The completion rule will supply type parameters to a function or method only if the function or method is declared with no type parameters at all (that is, without any angle brackets).\n\nFinally, remember that Dafny's type-parameter completion is a feature, not a requirement. If you don't want to make use of this completion, then by all means, feel free to write out all formal type parameters and actual type arguments explicitly in your own programs.\n\n----------------------------------------\n\n0.Dafny's scheme for filling in type parameters in signature declarations is one of two mechanisms that the language employs to reduce type clutter in the program text. The other mechanism is type inference, which tries to figure out types of variables and expressions based on how these are used. In this Power note, I will not talk about type inference. ↩\n\n1.The compiled function Elements makes use of one other thing that Dafny fills in automatically, namely the fact that the argument to set needs to be a type that supports equality in compiled contexts. If you wrote this explicitly, the function signature would be\n\nfunction method Elements<A(==)>(list: List<A>): set<A>\n\n\n1\n\n\nIn this note, I won't say more about equality-supporting types or how Dafny tries to infer these. ↩\n\n2.The Dafny IDE in Visual Studio displays type information in tool tips. If you hover the mouse over acc in this IDE, the tool tip that pops up will tell you the full type of acc, namely List<A>. In the future, the other Dafny IDEs may also show such type tool-tips. ↩",normalizedContent:"dafny power user: type-parameter completion\n\nk. rustan m. leino\n\nmanuscript krml 270, 22 june 2019\n\nabstract. when type parameters don't need to be named, dafny has a scheme for filling them in automatically. omitting the type parameters reduces clutter in function signatures. this note describes how the type parameters get filled in.\n\n\n# #0. type parameters\n\nas in many languages, types in dafny can be parameterized by other types. for example, the type set<int> denotes finite sets of integers and is parameterized by int. as another example, if list is a type defined as\n\ndatatype list<a> = nil | cons(a, list<a>)\n\n\n1\n\n\nand expr is a type denoting expressions, then list<expr> is a type that is parameterized by expr. in the declaration of list, a is a formal type parameter, and in the type list<expr>, expr is the actual type parameter (or, actual type argument).\n\nsince set and list each requires a type parameter, they are not themselves types. that is, it doesn't make sense for a variable to have type set. we say that set and list are type constructors. more precisely, they are unary type constructors, since they take one type parameter. each type constructor has an arity, which says how many type parameters it needs. so, a unary type constructor has arity 1. (there are no type constructors with arity 0; such a thing is simply a type.)\n\nin dafny, type constructors are not first class. this means that every mention of a type constructor must always be fully instantiated. however, the instantiation need not be explicit in the program text.\n\nin the signature declarations of datatypes, functions, and methods, dafny allows type constructors to be used without explicit type parameters. in this note, i describe dafny's scheme for filling in those missing type parameters.0\n\nlet's start by looking at two examples that show the advantages of having such a scheme.\n\n\n# 1. examples\n\nhere are functions for computing the length of a list and for computing the set of elements in a list.\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method elements(list: list): set {\n  match list\n  case nil => {}\n  case cons(x, tail) => {x} + elements(tail)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nat first glance, they look to be exactly what you expect. but if you think some more, you will notice that list and set have no given type parameters. this is delightful! both length and elements have more to do with the structure of the list than with the types of the elements stored in the list, and therefore it's nice that the definitions of these functions don't need to be cluttered up with the declaration and uses of the type parameters.\n\nif you wrote the type parameters explicitly, the signatures of the functions above would look like this:\n\nfunction method length<a>(list: list<a>): nat\nfunction method elements<a>(list: list<a>): set<a>\n\n\n1\n2\n\n\nyou'll agree this is rather heavy on the <a>'s.1\n\nso that you can use these abridged signatures effectively, let's now look at how omitted type parameters are filled in.\n\n\n# 2. filling in missing type arguments\n\nin the type signatures of functions and methods and in the right-hand side of (the \"=\" in) datatype definitions, type parameters can be omitted. the rule is that if the type signature or right-hand side mentions a type constructor without any type arguments, then dafny will fill these in from a prefix of the formal type parameters of the enclosing function, method, or datatype.\n\n\n# 2.0. example: one type parameter\n\nsuppose the program text includes the following function signature:\n\nfunction method reverseaux<a>(list: list<a>, acc: list): list<a>\n\n<a>\n\n\n1\n2\n3\n\n\nnote that list in the type of acc does not have an explicit type argument. dafny now fills in the type parameter of list using the type parameter of function reverseaux, completing the type of acc list<a>, as illustrated by the arrow above.2\n\nthe type arguments to the other occurrences of list in the function's type signature can be filled in in the same manner. so, the same function reverseaux can be declared simply as:\n\nfunction method reverseaux<a>(list: list, acc: list): list\n\n\n<a>``<a>``<a>\n\n\n1\n2\n3\n4\n\n\n\n# 2.1. example: two type parameters\n\nconsider a datatype path with two type parameters:\n\ndatatype path<l,r> = stop | left(l, path<l,r>) | right(r, path<l,r>)\n\n\n1\n\n\na value of type path<l,r> represents a finite path of left- and right-turns. each left-step is accompanied by a value (call it a “breadcrumb”, if you wish) of type l and every right-step is accompanied by a breadcrumb of type r.\n\nhere are two functions on paths. hansel picks up all the breadcrumbs encountered on left turns and gretel picks up all the breadcrumbs encountered on right turns.\n\nfunction hansel<l,r>(p: path<l,r>): list<l> {\n  match p\n  case stop => nil\n  case left(l, rest) => cons(l, hansel(rest))\n  case right(_, rest) => hansel(rest)\n}\n\nfunction gretel<l,r>(p: path<l,r>): list<r> {\n  match p\n  case stop => nil\n  case left(_, rest) => gretel(rest)\n  case right(r, rest) => cons(r, gretel(rest))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nusing dafny's type-parameter completion, we can write these as:\n\ndatatype path<l,r> = stop | left(l, path) | right(r, path)\n\n\n\n\nfunction hansel<l,r>(p: path): list\n\n\n\nfunction gretel<l,r>(p: path): list<r>\n\n<l,r>``<l,r>\n<l,r>``<l>\n<l,r>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nnote that both occurrences of path in the right-hand side of the declaration of type path get both type arguments filled in with the type's type parameters <l,r> given in the left-hand side of the declaration. in both of the functions, path also gets the arguments <l,r> as declared in the functions. moreover, for hansel, type list automatically gets the argument <l>, because list needs one argument and therefore it only picks up a prefix of the function's type parameters <l,r>. function gretel has result type list<r>. here, it is not possible to elide the type argument list <r>, since <r> is not a prefix of <l,r>.\n\nthe example illustrates how type-parameter completion picks a prefix of the enclosing function's type parameters. this allows you to write just list instead of list<l>. however, since l and r otherwise play symmetric roles in this example, you can of course also choose to write out list<l> explicitly. you may argue that doing so more clearly highlights the difference between functions hansel and gretel. you would then write the following signatures:\n\ndatatype path<l,r> = stop | left(l, path) | right(r, path)\nfunction hansel<l,r>(p: path): list<l>\nfunction gretel<l,r>(p: path): list<r>\n\n\n1\n2\n3\n\n\nwhich still looks pretty clean.\n\n\n# 2.2. example: nested type parameters\n\ntype-parameter completion applies not just to the outermost types. for example,\n\ndatatype tree<a> = node(children: list<tree<a>>)\n\n\n1\n\n\ncan also be written as\n\ndatatype tree<a> = node(children: list<tree>)\n  \n<a>\n\n\n1\n2\n3\n\n\nnote that if you supply any type parameters at all, then dafny will not change or complete the list you have given. the completion rule supplies the parameters to a type constructor only if the type constructor is mentioned with no type arguments at all (that is, without any angle brackets).\n\n\n# 2.3. example: datatype\n\ntype-parameter completion also applies in the right-hand side of datatypes. so, if you want to, you can declare list as follows:\n\ndatatype list<a> = nil | cons(a, list)\n\n\n1\n\n\n\n# 3. auto-declaring type parameters\n\nwhat i described so far pertains to the actual type arguments of type constructors in signatures. there's one more part to dafny's type-parameter completion. for functions and methods, but not for datatypes, if the function or method is declared without explicit formal type parameters, then dafny provides these as well. this list of formal type parameters in this completion will be made long enough to cover the length of any missing type-argument list described in section 2 above.\n\n\n# 3.0. examples\n\nas we saw in section 2.0 above, function reverseaux can omit the uses of its type parameter a. consequently, there is no need for the signature to mention a by name. dafny's type-parameter auto-declaration rule allows us to omit a altogether. by doing so, we can declare reverseaux simply as\n\nfunction method reverseaux(list: list, acc: list): list\n\n\n1\n\n\n<a>``<a>``<a>\n\n\n1\n\n\nthis declaration says that reverseaux takes two lists and returns a list. there's no need to explicitly mention the type of list elements, and it is tacitly understood that the three lists mentioned have the same type of elements.\n\nwe already saw two other examples in the motivational section 3.0: length and elements. function elements relies on type-parameter completion in three ways: both the user-defined type constructor list and the built-in type constructor set are completed with the same type parameter and this (un-named) type parameter is added to the formal type parameters of the function.\n\nfunction method elements(list: list): set\n\n\n1\n\n\n<a>``<a>\n\n\n1\n\n\n\n# 3.1. sometimes you need formal type parameters\n\nnote that you cannot take advantage of the auto-declaration part of type-parameter completion if you have a need to mention the type parameter. for example, you can shorten the signature of snoc to:\n\nfunction method snoc<a>(list: list, a: a): list {\n  match list\n  case nil => cons(a, nil)\n  case cons(x, tail) => cons(x, snoc(tail, a))\n}\n\n\n1\n2\n3\n4\n5\n\n\nbut since a's type needs to be mentioned as a, you must declare a explicitly. that is, you cannot abbreviate snoc's type signature more than this.\n\nactual type parameters are completed in the right-hand side of datatype declarations, but auto-declaration of formal type parameters does not apply to datatypes. for example, you cannot omit the <a> in the left-hand side of the declaration of list.\n\n\n# 4. final notes\n\nrecall that if you supply any type parameters at all, then dafny will not extend the list you have given. the completion rule will supply type parameters to a function or method only if the function or method is declared with no type parameters at all (that is, without any angle brackets).\n\nfinally, remember that dafny's type-parameter completion is a feature, not a requirement. if you don't want to make use of this completion, then by all means, feel free to write out all formal type parameters and actual type arguments explicitly in your own programs.\n\n----------------------------------------\n\n0.dafny's scheme for filling in type parameters in signature declarations is one of two mechanisms that the language employs to reduce type clutter in the program text. the other mechanism is type inference, which tries to figure out types of variables and expressions based on how these are used. in this power note, i will not talk about type inference. ↩\n\n1.the compiled function elements makes use of one other thing that dafny fills in automatically, namely the fact that the argument to set needs to be a type that supports equality in compiled contexts. if you wrote this explicitly, the function signature would be\n\nfunction method elements<a(==)>(list: list<a>): set<a>\n\n\n1\n\n\nin this note, i won't say more about equality-supporting types or how dafny tries to infer these. ↩\n\n2.the dafny ide in visual studio displays type information in tool tips. if you hover the mouse over acc in this ide, the tool tip that pops up will tell you the full type of acc, namely list<a>. in the future, the other dafny ides may also show such type tool-tips. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Type-parameter modes variance and cardinality preservation",frontmatter:{title:"Type-parameter modes variance and cardinality preservation",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/3c9a0b/",categories:["语言","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/65.Type-parameter%20modes%20variance%20and%20cardinality%20preservation.html",relativePath:"80.语言/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md",key:"v-1cf80342",path:"/pages/3c9a0b/",headers:[{level:2,title:"0. Subtypes",slug:"_0-subtypes",normalizedTitle:"0. subtypes",charIndex:1472},{level:2,title:"1. Type parameters",slug:"_1-type-parameters",normalizedTitle:"1. type parameters",charIndex:2816},{level:2,title:"2. Variance",slug:"_2-variance",normalizedTitle:"2. variance",charIndex:3929},{level:3,title:"2.0. Co-variance",slug:"_2-0-co-variance",normalizedTitle:"2.0. co-variance",charIndex:4213},{level:3,title:"2.1. Contra-variance",slug:"_2-1-contra-variance",normalizedTitle:"2.1. contra-variance",charIndex:5067},{level:3,title:"2.2. Non-variance",slug:"_2-2-non-variance",normalizedTitle:"2.2. non-variance",charIndex:6145},{level:2,title:"3. Declaring variance",slug:"_3-declaring-variance",normalizedTitle:"3. declaring variance",charIndex:6895},{level:2,title:"4. Positive and negative positions",slug:"_4-positive-and-negative-positions",normalizedTitle:"4. positive and negative positions",charIndex:10320},{level:2,title:"5. Five type-parameter modes",slug:"_5-five-type-parameter-modes",normalizedTitle:"5. five type-parameter modes",charIndex:13772},{level:2,title:"6. Injectivity",slug:"_6-injectivity",normalizedTitle:"6. injectivity",charIndex:14475},{level:2,title:"7. A logical contradiction",slug:"_7-a-logical-contradiction",normalizedTitle:"7. a logical contradiction",charIndex:16173},{level:2,title:"8. Cardinality requirement",slug:"_8-cardinality-requirement",normalizedTitle:"8. cardinality requirement",charIndex:18912},{level:2,title:"9. Type parameters and cardinality",slug:"_9-type-parameters-and-cardinality",normalizedTitle:"9. type parameters and cardinality",charIndex:22927},{level:2,title:"10. Combining variance and cardinality preservation",slug:"_10-combining-variance-and-cardinality-preservation",normalizedTitle:"10. combining variance and cardinality preservation",charIndex:25467},{level:2,title:"11. Built-in type constructors",slug:"_11-built-in-type-constructors",normalizedTitle:"11. built-in type constructors",charIndex:26311},{level:3,title:"11.0. iset and ->",slug:"_11-0-iset-and",normalizedTitle:"11.0. iset and -&gt;",charIndex:null},{level:3,title:"11.1. Two subtle consequences",slug:"_11-1-two-subtle-consequences",normalizedTitle:"11.1. two subtle consequences",charIndex:29634},{level:3,title:"11.2. set and iset",slug:"_11-2-set-and-iset",normalizedTitle:"11.2. set and iset",charIndex:33103},{level:3,title:"11.3. map and imap",slug:"_11-3-map-and-imap",normalizedTitle:"11.3. map and imap",charIndex:34183},{level:2,title:"12. Other sources",slug:"_12-other-sources",normalizedTitle:"12. other sources",charIndex:35104},{level:2,title:"13. Summary",slug:"_13-summary",normalizedTitle:"13. summary",charIndex:36961},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:37583},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:38469},{level:2,title:"A. Finite powerset preserves cardinality",slug:"a-finite-powerset-preserves-cardinality",normalizedTitle:"a. finite powerset preserves cardinality",charIndex:40182}],headersStr:"0. Subtypes 1. Type parameters 2. Variance 2.0. Co-variance 2.1. Contra-variance 2.2. Non-variance 3. Declaring variance 4. Positive and negative positions 5. Five type-parameter modes 6. Injectivity 7. A logical contradiction 8. Cardinality requirement 9. Type parameters and cardinality 10. Combining variance and cardinality preservation 11. Built-in type constructors 11.0. iset and -> 11.1. Two subtle consequences 11.2. set and iset 11.3. map and imap 12. Other sources 13. Summary Acknowledgments References A. Finite powerset preserves cardinality",content:"Dafny Power User: Type-parameter modes: variance and cardinality preservation\n\nK. Rustan M. Leino\n\nManuscript KRML 280, 9 August 2021\n\nAbstract. Dafny supports 5 type-parameter variance and cardinality-preservation modes. Variance is common in languages with types, and cardinality preservation is a concern that arises in the context of verification. This note explains these modes and motivates the need for cardinality preservation. Along the way, it explains some phrases like “strict positivity”.\n\nThis note is long, so here's a little reading guide:\n\n * If you're a beginner and want to learn about type-parameter variance, read the first 4 sections.\n * If you're using type-parameter modes and are wondering about the syntax of each mode, see the table in Section 10.\n * If you want to see which type-parameter modes are used with Dafny's built-in types, see Section 11.\n * If you wonder what trouble you'd be in without cardinality-preservation rules (or, as some would say it, without “strict positivity”), then Section 7 will give you the idea (and the first code snippet in Section 9 adds type parameters to that example).\n * If you're a language designer, you may find the rest of Section 11 to be food for thought.\n * There's a little proof about finite powersets and cardinalities in Appendix A.\n * Finally, I have come to think that “strict positivity” is not a good term to use. I think “cardinality preservation” is more to the point, see Section 12.\n\n\n# 0. Subtypes\n\nDafny defines a subtype relation on types. If A is a subtype of B, then every value of A is also a value of type B. For example, the subset type nat is a subtype of int. As another example, given\n\ntrait Tr {\n  // ...\n}\nclass Cl extends Tr {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype Cl is a subtype of Tr.\n\nNote. The definition of subtype above mentions “If”. This is not an “If and only if”, because it doesn't go the other way around. For example, the type\n\ntype Unreal = r: real | r == r + 1.0\n  witness *\n\n\n1\n2\n\n\ndefines a type Unreal that has no values. Thus, every value of Unreal is also a value of int. Still, Dafny does not consider Unreal to be a subtype of int.\n\nThe subtype relation is reflexive—that is, every type is (trivially) a subtype of itself—and transitive. Other than that, there are three sources of subtyping in Dafny. One is that a subset type (like the built-in nat and the type Unreal above) is a subtype of its base type (int for nat and real for Unreal). Another is that a class or trait is a subtype of each trait it extends. For example, as we saw above, Cl is a subtype of Tr, and every reference type is a subtype of the built-in trait object (which, e.g., every class implicitly extends). The third source of subtyping stems from variance of type parameters, as I will explain in the next few sections.\n\n\n# 1. Type parameters\n\nA type can be parameterized by other types. For example,\n\nclass Cell<Data> {\n  var data: Data\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nintroduces a class Cell parameterized by a type Data, and\n\ndatatype PS<X, Y> = PSCtor(x: X, ys: seq<Y>)\n\n\n1\n\n\nintroduces a datatype PS parameterized by two types, where the values are essentially pairs consisting of one value (x) of the first type and a sequence (ys) of values of the other type.\n\nSince Cell and PS have (1 and 2, respectively) type parameters, they sometimes known as (unary and binary) type constructors. This just means they are not types by themselves, but they need their parameters to be filled in to be types. For example, PS<int, real> and PS<bool, bool> are types, whereas PS<int> and PS are not.\n\nAside. In some cases, Dafny will fill in or infer the type arguments automatically. In those cases, you may be able to write just PS in your program. For example,\n\nvar p: PS := PSCtor(5, [3.14, 2.7]);\n\n\n1\n\n\nis a legal statement. This is just a syntactic shorthand, and the type arguments of PS are still there, even if the program text omits them.\n\n\n# 2. Variance\n\nWhether or not a parameterized type is a subtype of another may depend on the parameters. For example, it turns out that seq<nat> is a subtype of seq<int>, but seq<bool> is not a subtype of seq<real>. The reason behind this is that seq is co-variant in its argument.\n\n\n# 2.0. Co-variance\n\nWhen a (here, unary) type constructor M is co-variant in its argument, then\n\n> for any types A and B such that A is a subtype of B, M<A> is a subtype of M<B>.\n\nLet me write the subtype relation as <:. Then, what I just said about M can be written as\n\n> A, B :: A <: B ==> M<A> <: M<B>\n\nThis is really just saying that M is monotonic (with respect to the subtyping ordering) in its argument. For example, in math, a function f over the reals is monotonic (with respect to the less-or-equal ordering) when\n\n> x, y :: x y ==> f(x) f(y)\n\nA type constructor with many arguments may be co-variant in some of its type arguments and not others. For example, if Trois is a type constructor with three arguments and is co-variant in the first and third argument, then\n\n> A, B, H, X, Y :: A <: B && X <: Y ==> Trois<A, H, X> <: Trois<B, H, Y>\n\n\n# 2.1. Contra-variance\n\nSome type constructors are contra-variant in some of their type arguments. This means that the subtype of the argument has an opposite effect on the subtyping of the constructed type. More precisely, when a (here, unary) type constructor M is contra-variant in its argument, then\n\n> A, B :: A <: B ==> M<B> <: M<A>\n\nThis corresponds to the math notion of a function being anti-monotonic.\n\nFor illustration, consider the declarations\n\ndatatype Color = Blue | Green\ntype Coloring<X> = X -> Color\n\n\n1\n2\n\n\nwhich, for any type X, defines Coloring<X> to be the type whose values are functions that give each X value a Color. As it turns out, type constructor Coloring is contra-variant in its argument. Consequently, every value of Coloring<int> is a value of Coloring<nat>. This makes sense—each value of Coloring<int> is a function that gives every integer a color, and each value of Coloring<nat> is a function that gives every non-negative integer a color, and every function that gives all integers a color also gives the non-negative integers a color.\n\n\n# 2.2. Non-variance\n\nFor some type constructors, if you provide different type arguments, the resulting types have no relation to each other. For example, using class Cell from above, there is no subtype relation between Cell<nat> and Cell<int>. In this case, we say that the type constructor is non-variant in its argument.\n\nNote. Perversely, non-variance is sometimes called invariance. That's a terrible mistake. “Invariant” refers to something that does not change, which is very much the opposite of the effect of non-variant type parameters. When you change the argument given to a non-variant type parameter, the resulting type can be something completely different—not the same thing. So, please… don't refer to non-variant as “invariant”!\n\n\n# 3. Declaring variance\n\nDafny defines the type-parameter variance of the built-in type constructors. For example, seq is co-variant in its type argument. (I'll mention the other collection types in Section 11.) As another example, for any n, the n-ary arrow type constructor is contra-variant in each of its n input types and co-variant in its output type. Reference types (user-defined classes, built-in arrays, etc.) are required to be non-variant in each of their type parameters.\n\nFor datatype and codatatype declarations, subset types, opaque types, and type synonyms, there's some freedom in choosing the variance for each type parameter. To declare a type constructor to be co-variant in a type parameter, mark the type parameter with a prefix +. For contra-variance, mark the type parameter with a prefix -. The absence of any such mark declares the type constructor to be non-variant in that type parameter.\n\nFor example, the declaration\n\ntype Example<+A, -B, C, +D>\n\n\n1\n\n\nintroduces an opaque-type type constructor Example with four type arguments. The type constructor is co-variant in its first and fourth arguments, contra-variant in its second argument, and non-variant in its third argument.\n\nAs another example, the built-in tuple type constructors (which are datatypes) are co-variant in each of their arguments.\n\nNote. In Section 2.1, I said that Coloring<X> is contra-variant. That's not quite true. The right-hand side of the definition of Coloring<X> is contra-variant in X. If you want Coloring to have this property, you must explicitly mark the parameter as such. That is, Coloring<X> declared in 2.1 is non-variant in X, whereas declaring it as\n\ntype Coloring<-X> = X -> Color\n\n\n1\n\n\nmakes it contra-variant.\n\nThere are no restrictions on the type-parameter variance of opaque types. But for the other type declarations, the right-hand side definition of the type must be consistent with each type-parameter variance given on the left-hand side.\n\nFor example, consider the following attempt at defining a datatype:\n\ndatatype Record<-X> = Record(x: X)  // error: X is not used contra-variantly\n\n\n1\n\n\nThis declaration introduces X as a contra-variant type parameter of Record, but the right-hand side definition of Record does not use X according to that variance. If X is instead introduced as a co-variant or non-variant type parameter, the definition is legal.\n\nNote. Even if the right-hand side is consistent with declaring a type parameter as co-variant or as contra-variant, the declaration of a type constructor does not need to advertise that to its users. In other words, it's fine to declare\n\ndatatype Record<X> = Record(x: X)\n\n\n1\n\n\neven though\n\ndatatype Record<+X> = Record(x: X)\n\n\n1\n\n\nis also legal and would allow more uses of Record. As another example, the Section 2.1 declaration of Coloring makes it non-variant, whereas its right-hand side would be consistent with making Coloring contra-variant. This is the same kind of choice of abstraction that is available throughout a programming language. For example, a function can have an int result type even it returns only non-negative integers. This establishes a contract between the implementation of a function and its callers. In particular, it says that the caller must be prepared to receive any integer result, and it gives the implementation the freedom to in the future return negative integers without breaking any callers.\n\n\n# 4. Positive and negative positions\n\nWhen looking at the right-hand side of a type declaration to see if the type parameters are used in accordance with their variance, it is useful to think of positive and negative positions. The basic idea is that an occurrence of a type X in a type expression T is in a positive position if the occurrence is to the left of an even number of arrows in T, and it is in a negative position if it occurs to the left of an odd number of arrows.\n\nTo illustrate, consider the following type expression:\n\n(A, (B -> bool) -> C, seq<D -> (E -> F)>)\n\n\n1\n\n\nIn this type expression, A, B, C, and F are in positive positions and D and E are in negative positions.\n\nTo explain the origin of the names “positive” and “negative”, let me write T(X) to denote a type expression where I have singled out a particular occurrence of X. If the X in T(X) occurs in a positive position, then any subtype/supertype change in X will cause a change in the same direction in T(X). That is, it is as if T(X) “multiplies” X by a positive number. Conversely, if X is in a negative position, then any subtype/supertype change in X will cause a change in the opposite direction in T(X). That is, it is as if T(X) “multiplies” X by a negative number.\n\nIn more symbols, if X occurs in a positive position in T(X), then\n\n> X, Y :: X <: Y ==> T(X) <: T(Y)\n\nand if X occurs in a negative position in T(X), then\n\n> X, Y :: X <: Y ==> T(Y) <: T(X)\n\nIt's no accident that these formulas look like the ones that define co-variance and contra-variance in Section 2, because those concepts are tightly related to the concepts of positive and negative positions.\n\nConsider a type-constructor declaration with a type parameter X and a right-hand side RHS. If X is marked as co-variant, then it is used correctly if all its occurrences in RHS are in positive positions. If X is marked as contra-variant, then it is used correctly if all its occurrences in RHS are in negative positions.\n\nLet me tidy up a detail. In my above definitions of positive and negative positions, I only mentioned arrow type constructors. If for a moment we ignore syntax and write an arrow type like A -> B as Arrow<A, B>, then we can view the (built-in) definition of Arrow as\n\ntype Arrow<-X, +Y>\n\n\n1\n\n\nNow, the definition of positive/negative positions goes as follows. For any type T,\n\n * If T has the form X where X is a type parameter, then this occurrence of X is in a positive position.\n\n * \n\nIf\n\nT\n\n\n1\n\n\nhas the form\n\nTC<..., U, ...>\n\n\n1\n\n\nwhere type expression\n\nU\n\n\n1\n\n\nis passed in as the type parameter\n\nA\n\n\n1\n\n\nin type constructor\n\nTC\n\n\n1\n\n\n, then\n\n * if A is declared as co-variant, then all the positive positions in U are positive positions in T and all negative positions in U are negative positions in T\n * if A is declared as contra-variant, then all the positive positions in U are negative positions in T and all negative positions in U are positive positions in T\n * if A is declared as non-variant, then U contributes neither positive nor negative positions to T\n\nFor example, in the type\n\nseq<(A, Cell<B -> bool>, C -> D)> -> Example<int, E, F, G>\n\n\n1\n\n\nwhere Cell and Example are as defined above (and, recall, the built-in seq and the built-in tuple types are co-variant in their arguments, and the type constructor -> is like Arrow above), the type variables in positive positions are C and G, and the type variables in negative positions are A, D, and E.\n\n\n# 5. Five type-parameter modes\n\nIn most programming languages that support type-parameter variance, you will encounter only the 3 modes of variance I've discussed so far. If that's all you want to know, you can stop reading now. (Dafny's defaults are such that you rarely need to know about more than these 3 modes.)\n\nDafny, it turns out, has 5 type-parameter modes. The additional modes come about because Dafny is concerned with formal verification. To motivate and explain the additional modes, I will review a property about datatypes, show a subtle way that mere type declarations can cause a logical contradiction, introduce the concept of cardinality preservation, and then come back to Dafny.\n\n\n# 6. Injectivity\n\nThe constructors of a datatype or codatatype are injective in their arguments. This means that there is only one way to construct a particular datatype value.\n\nIn more detail, let's review four properties of datatypes. For illustration, let's consider a standard List definition (of integers—just to keep things simple).\n\ndatatype List = Nil | Cons(head: int, tail: List)\n\n\n1\n\n\nFirst, this definition says that there are two variants of lists: those that are constructed using Nil and those that are constructed using Cons. So, for any value xs of type List, the disjunction\n\nxs.Nil? || xs.Cons?\n\n\n1\n\n\nalways holds. Second, the two variants give rise to different values. So,\n\n!(xs.Nil? && xs.Cons?)\n\n\n1\n\n\nalways holds. Third, each constructor is a function, in the sense that its arguments (and nothing else!) determine the value they produce. So,\n\nx == y && xs == ys  ==>  Cons(x, xs) == Cons(y, ys)\n\n\n1\n\n\nalways holds. Fourth, two values of the same variant are equal only if the corresponding arguments are equal. So,\n\nCons(x, xs) == Cons(y, ys)  ==>  x == y && xs == ys\n\n\n1\n\n\nIt's this fourth property that is called injectivity. More precisely, a datatype constructor is injective in each argument. (An alternate name for “injective” is “one-to-one”.) When a function is injective (in an argument), there exists an inverse function (for that argument). For a datatype, those inverse functions are called destructors, and they can be given names by introducing names for the parameters of the constructors. In the List declaration above, the inverse functions for Cons were introduced as .head and .tail. So, we have\n\nCons(x, xs).head == x  &&  Cons(x, xs).tail == xs\n\n\n1\n\n\n\n# 7. A logical contradiction\n\nConsider the following type declarations:\n\ntype F = D -> bool\ndatatype D = Ctor(f: F)\n\n\n1\n2\n\n\nI'm now going to argue that there is an infinite number of values of type D. Regardless of how many D values there are, we can define a function f``0 of type F that always returns false. If we pass in f``0 to Ctor, we get a D value, call it d``0. (We just proved that the set of D values is nonempty!) From our definition of f``0, we have that f``0``(d``0``) == false. Next, let's define a function f``1 that is like f``0, except that it returns true for d``0. Define d``1 to be the value Ctor(f``1``). Because f``0 is different from f``1, the injectivity of Ctor tells us that d``0 is different from d``1. (We have now shown that there are at least 2 D values!) Next, define a function f``2 that is like f``1, except that it returns true for d``1. By passing f``2 to Ctor, we get yet another D value. We can continue this process forever, which shows that there is no finite bound on the number of D values. Hence, the set of D values is infinite.\n\nHow many F values are there? If D were finite, you would immediately answer 2``|D|, where |D| is the size of D—also known as the cardinality of D—because for each D value, F may return one of 2 values. This is called the powerset of D. But as we just concluded above, D is infinite. Well, it turns out that the answer is still the same: the cardinality of F is 2``|D|, where we're using cardinal numbers instead of natural numbers. This sounds mathematical, but all you need to know is that the inequality n < 2``n holds for cardinal numbers just like it holds for natural numbers (see, e.g., Theorem 22.10 of [3]). In other words, the number of F values is strictly larger than the number of D values.\n\nThis is trouble.\n\nFor every F value, we can construct a D value, and thus |F| <= |D|. But we concluded above that |D| < 2``|D| and 2``|D|`` == |F|. Putting these facts together by transitivity, we get |F| < |F|, which is just false.\n\nUsing a construction akin to Cantor's diagonalization argument [6] or Russell's paradox [5], we can exploit this contradiction in cardinalities and prove false:\n\nlemma False()\n  ensures false\n{\n  var g := (d: D) => !d.f(d);\n  var dd := Ctor(g);\n  calc {\n    g(dd);\n  ==  // def. g\n    !dd.f(dd);\n  ==  { assert dd.f == g; }\n    !g(dd);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWell, it's more accurate to say that this could be trouble, because it would let us prove false. Luckily, the type definitions for F and D are not accepted by Dafny. That is, to avoid this logical contradiction, Dafny does not allow a datatype (here, D) to be defined in terms of right-hand sides that would have larger cardinalities than D itself.\n\n\n# 8. Cardinality requirement\n\nTo avoid the contradiction in cardinalities when defining a type D as some type expression T(D), we must make sure the cardinalities of D and T(D) can be the same. That is, we need to be able to make D large enough that its cardinality equals that of T(D). The previous section showed an example where this is not possible, because no matter how big you make D, T(D) will be exponentially larger. I'll refer to this condition as the cardinality requirement.\n\nA contradiction in cardinalities can occur only if a type is defined in terms of itself. That is, suppose a type D is defined to be RHS. If RHS does not depend on D, then D will, without risk of any contradiction, have the same cardinality as RHS. A problem can occur only if RHS depends on D. For all cases of non-trivial dependencies, one can use an argument like in Section 7 to show that D has an infinite number of elements. Therefore, when designing a restriction to enforce the cardinality requirement, we only need to think about types of infinite cardinality.\n\nIn type theory, we can think of a fixed repertoire of type compositions. Types are either type names or sum-type, product-type, or arrow-type compositions. Type names include built-in types like bool and int, and also include user-defined types, like D from above. Sum types correspond to the variants of a datatype. Product types correspond to the list of arguments in each such variant. Finally, arrow types are the types of functions.\n\nUsing standard type-theory notation for these types and for the cardinality of the type named , the cardinality of types, denoted , is defined as follows:\n\nFrom this definition, we see that the cardinality is a polynomial of the cardinalities of the type names involved, except in the case of arrow types. For any polynomial and infinite cardinal number , equals . So, the only way to violate the cardinality requirement is if D occurs in the left-hand argument of an arrow type.\n\nNote. Just because D occurs in the left-hand argument to an arrow does not mean there is a problem with cardinalities. In particular, arrow types are harmless if the right-hand type has cardinality 0 or 1, and so are product types where an argument has cardinality 0. For example, Empty is an empty type (that is, a type with cardinality 0) and Singleton is a unit type (that is, a type with cardinality 1), then there is no cardinality concern with the type\n\ndatatype D = Done | More(D -> Empty, D -> Singleton, (D, Empty) -> int)\n\n\n1\n\n\nNevertheless, Dafny's rules forbid this type, too, because the rules do not look for the special cases with cardinality-0 or cardinality-1 types. That's alright. By forbidding these trivial types, the rules both eliminate actual cardinality problems and stay simple.\n\nThe crucial point is this: Except for cardinality-0 types that are used as arguments to product types or as left-hand arguments to arrow types,\n\n> a type expression T(D) that mentions D is always at least as big as D.\n\nThis leads us to a proposed way to enforce the cardinality requirement:\n\n> For any type D defined to be T(D), do not allow D to be mentioned in the left-hand argument of any arrow type in T(D).\n\nThe proposed rule talks about left-hand arguments of arrow types, which reminds us of the positive/negative positions we discussed in Section 4 as a way to enforce variance restrictions. Some people think of the cardinality requirement as taking a step beyond saying D must be in positive positions. That is, whereas a doubly negative position (like X in (X -> bool) -> bool) is a positive position, the cardinality requirement seems to call for a strictly positive positions, where a doubly negative position is still a negative position. For this reason, you sometimes hear that the cardinality requirement is enforced by strict positivity. (I'll have more to say about this in Section 12.)\n\nBut wait! Weren't we discussing type parameters? What does the cardinality requirement have to do with type parameters?\n\n\n# 9. Type parameters and cardinality\n\nA variation of the example logical contradiction we saw in Section 7 can be written using type parameters:\n\ntype G<X> = X -> bool\ndatatype E = Ctor(g: G<E>)\n\n\n1\n2\n\n\nOnce the type synonym G is expanded, we get the same example, and indeed the same contradiction.\n\nIn a modular setting, it is not realistic to rely on being able to expand all types before checking for cardinality problems. For example, suppose type G is declared in a different module that exports G as an opaque type. A client module might then see just\n\ntype G<X>\ndatatype E = Ctor(g: G<E>)\n\n\n1\n2\n\n\nfrom which it is not evident whether or not there may be problems with cardinality.\n\nTo solve this problem, Dafny lets every type constructor declare which of its type parameters are used in ways that preserve cardinality. The mark ! in the following example illustrates:\n\ntype Example<X, !Y>\n\n\n1\n\n\nThis declaration says that Example uses type parameter X in a way that adheres to the cardinality requirement, whereas it does not promise the same for Y. This means that\n\ndatatype Good = None | Some(Example<Good, int>)\n\n\n1\n\n\nis legal, whereas\n\ndatatype Bad = None | Some(Example<int, Bad>) // error: violates cardinality requirement\n\n\n1\n\n\nis not, because it may violate the cardinality requirement.\n\nWe can now state the enforcement of the cardinality requirement precisely. Ignoring syntax, like I did in Section 4, we can view all types as type constructors that take a list of type parameters, each of which is identified as cardinality preserving or possibly not cardinality preserving. For any type T,\n\n * If T has the form X where X is a type parameter, then this occurrence of X is a cardinality-preserving position iff X is marked as cardinality preserving.\n\n * \n\nIf\n\nT\n\n\n1\n\n\nhas the form\n\nTC<..., U, ...>\n\n\n1\n\n\nwhere type expression\n\nU\n\n\n1\n\n\nis passed in as the type parameter\n\nA\n\n\n1\n\n\nin type constructor\n\nTC\n\n\n1\n\n\n, then\n\n * if A is declared as cardinality preserving, then all the cardinality-preserving positions in U are cardinality-preserving positions in T\n * if A is not declared as cardinality preserving, then U does not contribute any cardinality-preserving positions to T\n\nThe cardinality requirement is now enforced by the following cardinality-preservation rule: for any type D<..., X, ...> defined as RHS,\n\n * In RHS, D is allowed to be used only in cardinality-preserving positions.\n * If X is marked as cardinality preserving, then, in RHS, X is allowed to be used only in cardinality-preserving positions.\n\n\n# 10. Combining variance and cardinality preservation\n\nWith 3 kinds of variance, each with cardinality preservation or not, you'd think we'd have 6 modes altogether. But there is no way to be contra-variant and cardinality preserving—in terms of arrow types, contra-variance says the type parameter is to the left of some arrow, and that makes it not preserve cardinality. Therefore, Dafny supports 5 modes. The default mode is non-variant, cardinality preserving. The other four modes can be indicated with the prefix marks +, *, -, and !, as shown by this table:\n\n                 CARDINALITY PRESERVING   \nvariance         yes                      not necessarily\n                                          \nco-variant       +                        *\ncontra-variant   N/A                      -\nnon-variant      (default)                !\n\n\n# 11. Built-in type constructors\n\nDafny has several built-in type constructors. Here are their type-parameter modes:\n\nset<+A>          // finite sets\niset<*A>         // possibly infinite sets\nseq<+A>          // sequences\nmultiset<+A>     // multisets\nmap<+A, +B>      // finite maps\nimap<*A, +B>     // possibly infinite maps\n(+A, +B, +C)     // tuple types\n-A -> +B         // arrow type for total functions\n-A --\x3e +B        // arrow type for partial functions\n-A ~> +B         // arrow type for general functions\narray<A>         // arrays\narray2<A>        // multi-dimensional arrays\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMost of these are probably what you'd expect. For example, as we have seen above in examples, sequences are co-variant in their type argument, and they are also cardinality preserving. Tuple types (a 3-tuple is shown above) are built-in datatypes and they are co-variant and cardinality-preserving in all their arguments. Array types of any dimension are reference types, which are restricted to be non-variant in their type parameters, and they are also cardinality preserving. Arrow types are co-variant and cardinality preserving in their last type parameter and, as we have discussed, contra-variant and not cardinality preserving in the other type parameters.\n\nSome of type modes among the built-in types are more subtle. If you're tired of considering subtleties and are happy to accept the type-parameter modes of the built-in types, you can skip the rest of this section. If you want understand the rationale behind these type-parameter modes, keep reading.\n\n\n# 11.0. iset and ->\n\nAn iset<X> is a possibly infinite set of X's. We can think of such a set as a function that for each X returns true or false, depending on whether or not the value is in the set. So, iset<X> is like the type X -> bool, which is not cardinality preserving in X.0 But why is iset<X> co-variant in X while X -> bool is contra-variant in X?\n\nWhat I'm about to say applies to any types Y and X where Y is a subtype of X, but I find it helpful to think of specific, familiar types, so I will instead use the types nat and int.\n\nSince nat is a subtype of int, co-variance would say that every iset<nat> value is also an iset<int> value. Indeed, a set containing only non-negative integers is also an iset<int>, so it makes sense that iset is co-variant in its type argument.\n\nIf -> were co-variant, then any nat -> bool function would have to be a int -> bool function, which isn't so. For example, consider the nat -> bool function\n\n(n: nat) => 1000 / (n+1) < 20\n\n\n1\n\n\nThis function evaluates to false for 3 and evaluates to true for 999. If we ignore the \": nat\" type of the function's argument and try to think of the function as having type int -> bool, we expect to get a bool value if we apply the function to any integer. But the function's body is undefined for -1, so clearly it's not like an int -> bool function. We conclude that -> is not co-variant in its first argument.\n\nInstead, it is contra-variant in its first argument. That is, every int -> bool function is also a nat -> bool function. Being the latter says you get a bool result whenever you apply it to a non-negative integer. Since that's also true for any int -> bool function, it makes sense to say -> is contra-variant in its first argument.\n\n\n# 11.1. Two subtle consequences\n\nThere are two subtle consequences of the decision to make iset co-variant and _ -> bool contra-variant. They have to do with expressing membership/domain. To talk about them, let me first be explicit about the following principle in the Dafny language design:\n\n * The Static Types Don't Alter Values principle.\n   \n   A static type says something about the value, but does not alter the value. If Y is a subtype of X, then you're allowed to assign a value of type Y to a variable of type X. In Dafny, such an assignment does not alter the value assigned. For example, given variables\n   \n   x: X    y: Y    originalY: Y\n   \n   \n   1\n   \n   \n   the following assignments are allowed and result in the assertion being verified:\n   \n   originalY := y; // save the value of y\n   x := y; // assign y to a variable of a different type (a supertype)\n   y := x; // assign x back to y\n   assert x == y == originalY;\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   The assignment from y to x is allowed, since Y is a subtype of X. The assignment from x to y is allowed by the type system, but generates a proof obligation that the value of x at the time of the assignment is indeed a value of type Y. Since neither assignment alters the value, the final assertion succeeds.\n\nNow, if s has type iset<int>, then the expression -7 in s evaluates to a boolean that tells us whether or not -7 is an element of set s. Suppose t has type iset<nat>. Is the expression -7 in t legal? Yes, because we could assign t to s (which, according to the language-design principle above, does not alter the value) and then ask -7 in s. Since there is a way to ask about -7's membership in t, it seems fine to allow the expression -7 in t directly, and that's what Dafny does.\n\nNote. One could try to imagine a different language design, where an iset<int> value would be allowed to masquerade as an iset<nat> value. In such a language, consider the following program snippet, where variables s and t have types iset<int> and iset<nat>, respectively:\n\nt := s;\nassert s == t;\nassert -7 in s <==> -7 in t;\n\n\n1\n2\n3\n\n\nBy the Static Types Don't Alter Values principle, the first assertion should hold. And if s and t are indeed equal, then the next assertion should also hold. But that's nonsense, since every element of an iset<nat> is non-negative. Perhaps the language could outlaw the expression -7 in t, since -7 is not a value in the element type (nat) of the static type of t—but this doesn't help, since (as we considered above) we can ask about -7's membership in t without writing -7 in t directly. The conclusion is that such an imagined language design goes against the Static Types Don't Alter Values principle.\n\nNext, if f is an int -> bool function, we can (by contra-variance) assign it to a variable g of type nat -> bool. Since f is defined on every integer, the expression f.requires(-7) is true. So what about g.requires(-7)? It would be strange for it to return true, since -7 is not a value of the first type parameter of g's type. But we also can't let it return false, because then g is not equal to f, which violates the Static Types Don't Alter Values principle. The only way out is to try to outlaw g.requires(-7).\n\nFor an expression e of static type A -> B, Dafny defines e.requires to have type A -> bool. So, f.requires has type int -> bool, which means one can pass -7 to it. But g.requires has type nat -> bool, so it is not legal to pass it -7.\n\n\n# 11.2. set and iset\n\nHaving looked at iset<X> in detail, our first thought might be that set<X> would be the same. After all, we can view both iset<X> and set<X> as having values of the form X -> bool. While co-variance applies to iset and set alike, the cardinality concern we had with X -> bool and iset<X> does not apply to set<X> (explained next). Therefore, set's type parameter is declared with +.\n\nFor any type X, the values of iset<X> are in one-to-one correspondence with the powerset of X—that is, all functions from X to bool, or, equivalently, all possible subsets of X—whose cardinality is 2``|X|. The values of set<X> correspond to the finite powerset of X—that is, the functions from X to bool that return true only for a finite number of elements, or, equivalently, all finite subsets of X. The cardinality of the finite powerset is far smaller. Specifically, if X has infinite cardinality (which is the case we are interested in, see Section 8), then the cardinality of the finite powerset of X equals the cardinality of X itself (see Appendix A for a proof).\n\n\n# 11.3. map and imap\n\nThe last point to explain about the type-parameter modes of the built-in type constructors regards finite maps (map<X, Y>) and possibly infinite maps (imap<X, Y>).\n\nYou can view map<X, Y> and imap<X, Y> as (finite and possibly infinite) sets of pairs (x, y), with x a value of X and y a value of Y. Thus, as you consider subtypes (or supertypes) of either X or Y, the possible pairs shrink (or grow, respectively). This justifies the map types as being co-variant in both arguments.\n\nValues of type imap<X, Y> are in one-to-one correspondence with the values of type X -> Y, so our concerns about cardinality preservation apply (hence, imap declares its first argument with the mark *). But the cardinality of map<X, Y>, which allows only a finite number of mappings from X to Y, is far smaller. So, analogously to set<X>, when X is infinite, map<X, Y> has no more elements than both |X| and |Y|.\n\n\n# 12. Other sources\n\nIt seems that every textbook or course on types would cover the topic of cardinality preservation (or “strict positivity” as it's often called), but I have had difficulty finding such coverage. When I was first learning about this, the most useful reference I found was a seminal paper by Elsa Gunter [1]. But even that paper left me puzzled as to what types a verification language can allow without the risk of a logical contradiction.\n\nI now think that what had muddled my mind was the phrase “strict positivity”. I don't know who invented or popularized that phrase, but given the syntactic enforcement of cardinality preservation, I understand that it's tempting to think of the restriction as a stricter version of the positive-position restriction for type-parameter variance (Section 4). But if you think of the requirement as barring a type name from occurring “to the left of any arrow”, then the motivation is not clear. “Positivity” has well established connotations with monotonicity, whereas “strict positivity” has nothing to do with monotonicity. Once you realize the salient point is how the cardinality of a type parameter affects the cardinality of the type generated by a type constructor, the light in your head comes on. If you—like I did—feel betrayed by the phrase “strict positivity”, you—like I do—will feel compelled to instead use the name cardinality preservation.\n\nMany other verification languages incorporate restrictions to avoid logic contradictions. Of these, I want to mention the F* language [4], which does not forbid types like those in Section 7; instead, to avoid logical contradictions, F* omits the injectivity property of constructors (see Section 6) for such types. In other words, the constructors of a datatype in F* are injective only if the type satisfies the cardinality requirement.\n\n\n# 13. Summary\n\nConsider a (here, unary) type constructor T. Variance is a set of type-parameter modes that tell you what you can conclude about the subtyping relationship between T(X) and T(Y) by knowing something about the subtyping relationship between X and Y. Cardinality preservation is a set of type-parameter modes that tell you what you can conclude about the relative cardinalities of T(X) and T(Y) by knowing something about the relative cardinalities of X and Y. Dafny supports 5 type-parameter modes that a type constructor can use to express the desired combination of variance and cardinality preservation.\n\n# Acknowledgments\n\nI first learned—years ago—about the logical contradiction in Section 7 from Jean-Christophe Filliâtre and Christine Paulin-Mohring.\n\nAndreas Lochbihler demonstrated to me that the contradiction is detectable in Dafny, even though Dafny has no concepts or types that deal with cardinal numbers directly.\n\nDiscussions with Nik Swamy caused me to introduce the 5, not 3, type-parameter modes in Dafny, but I realize now that I was then still confused by the phrase “strict positivity”.\n\nRecently, I had some illuminating discussions with Andrei Paskevich and Jatin Arora on this topic.\n\nRemy Willems asked me questions about the type-parameter mark ! in Dafny, which prompted me to write this note to explore the topic in more detail. Little did I know I would spend this many words!\n\nI'm grateful to all of these colleagues.\n\nDafny error message movie reference [0].\n\n\n# References\n\n[0]“Continuum Transfunctioner”. In Philip Stark, writer, and Danny Leiner, director, Dude, Where's My Car?, Twentieth Century Fox, Alcon Entertainment, 2000. 🔎\n\n[1]Elsa L. Gunter. Why we can't have SML-style datatype declarations in HOL. In Luc J. M. Claesen and Michael J. C. Gordon, editors, Higher Order Logic Theorem Proving and its Applications, Proceedings of the IFIP TC10/WG10.2 Workshop HOL'92., volume A-20 of IFIP Transactions, pages 561–568. North-Holland/Elsevier, September 1992. Preprint available at http://egunter.cs.illinois.edu/papers/HOL1992.pdf. 🔎\n\n[2]Arturo Magidin. The cardinality of the set of all finite subsets of an infinite set. Math StackExchange, March 2011. https://math.stackexchange.com/questions/27096/the-cardinality-of-the-set-of-all-finite-subsets-of-an-infinite-set/27098#27098. 🔎\n\n[3]J. Donald Monk. Introduction to Set Theory. McGraw-Hill, 1969. Electronic version available from http://euclid.colorado.edu/~monkd/monk11.pdf. 🔎\n\n[4]Nilhil Swamy, et al. F*: A higher-order effectful language designed for program verification. https://fstar-lang.org/. 🔎\n\n[5]Bertrand Russell. The Principles of Mathematics. W. W. Norton & Company, New York, 2d. ed. reprint edition, 1996. First published in 1903. 🔎\n\n[6]Keith Simmons. Universality and the Liar: An Essay on Truth and the Diagonal Argument. Cambridge University Press, 1993. ISBN 978-0-521-43069-2, https://www.google.com/books/edition/Universality_and_the_Liar/wEj3Spept0AC. 🔎\n\n[7]chelivery. Cardinality of the set of all finite subset of . Math StackExchange, December 2016. https://math.stackexchange.com/questions/2057826/cardinality-of-the-set-of-all-finite-subset-of-mathbbr/2057908#2057908. 🔎\n\n\n# A. Finite powerset preserves cardinality\n\nWhile I haven't found the result in a textbook or journal article, math.stackexchange.com contains at least two proofs that finite powersets preserve cardinality [2, 7]. Here's a version of [7], but for any infinite set (not just ).\n\nTheorem. Let be an infinite set and be the set of all finite subsets of . Then, .\n\nProof. To prove and to have the same cardinality, we need to show a bijection between the two. By the Schröder-Bernstein Theorem, it suffices to show an injective function from to and a (possibly different) surjective function from to . The function from each element in to the singleton set in is injective. So, it remains to show a surjective function from to .\n\nFor any natural number , let denote the -element subsets of . We then have that\n\nSince, for each , is a subset of , there exists a surjective function . We define a function by . Function is surjective, because for any value in , , so by the surjectivity of there is an such that , and thus .\n\nAlright, so we have a surjective function, , from to , but we need to show a surjective function from to . We have (see Section 8), and and (since is infinite), so by cardinal arithmetic, . Hence, there is a surjective function, call it , from to . We conclude that is a surjective function from to , which completes our proof.\n\n----------------------------------------\n\n0.This had been defined incorrectly in Dafny. The issue was reported by Travis Hance and fixed by Jatin Arora. ↩",normalizedContent:"dafny power user: type-parameter modes: variance and cardinality preservation\n\nk. rustan m. leino\n\nmanuscript krml 280, 9 august 2021\n\nabstract. dafny supports 5 type-parameter variance and cardinality-preservation modes. variance is common in languages with types, and cardinality preservation is a concern that arises in the context of verification. this note explains these modes and motivates the need for cardinality preservation. along the way, it explains some phrases like “strict positivity”.\n\nthis note is long, so here's a little reading guide:\n\n * if you're a beginner and want to learn about type-parameter variance, read the first 4 sections.\n * if you're using type-parameter modes and are wondering about the syntax of each mode, see the table in section 10.\n * if you want to see which type-parameter modes are used with dafny's built-in types, see section 11.\n * if you wonder what trouble you'd be in without cardinality-preservation rules (or, as some would say it, without “strict positivity”), then section 7 will give you the idea (and the first code snippet in section 9 adds type parameters to that example).\n * if you're a language designer, you may find the rest of section 11 to be food for thought.\n * there's a little proof about finite powersets and cardinalities in appendix a.\n * finally, i have come to think that “strict positivity” is not a good term to use. i think “cardinality preservation” is more to the point, see section 12.\n\n\n# 0. subtypes\n\ndafny defines a subtype relation on types. if a is a subtype of b, then every value of a is also a value of type b. for example, the subset type nat is a subtype of int. as another example, given\n\ntrait tr {\n  // ...\n}\nclass cl extends tr {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype cl is a subtype of tr.\n\nnote. the definition of subtype above mentions “if”. this is not an “if and only if”, because it doesn't go the other way around. for example, the type\n\ntype unreal = r: real | r == r + 1.0\n  witness *\n\n\n1\n2\n\n\ndefines a type unreal that has no values. thus, every value of unreal is also a value of int. still, dafny does not consider unreal to be a subtype of int.\n\nthe subtype relation is reflexive—that is, every type is (trivially) a subtype of itself—and transitive. other than that, there are three sources of subtyping in dafny. one is that a subset type (like the built-in nat and the type unreal above) is a subtype of its base type (int for nat and real for unreal). another is that a class or trait is a subtype of each trait it extends. for example, as we saw above, cl is a subtype of tr, and every reference type is a subtype of the built-in trait object (which, e.g., every class implicitly extends). the third source of subtyping stems from variance of type parameters, as i will explain in the next few sections.\n\n\n# 1. type parameters\n\na type can be parameterized by other types. for example,\n\nclass cell<data> {\n  var data: data\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nintroduces a class cell parameterized by a type data, and\n\ndatatype ps<x, y> = psctor(x: x, ys: seq<y>)\n\n\n1\n\n\nintroduces a datatype ps parameterized by two types, where the values are essentially pairs consisting of one value (x) of the first type and a sequence (ys) of values of the other type.\n\nsince cell and ps have (1 and 2, respectively) type parameters, they sometimes known as (unary and binary) type constructors. this just means they are not types by themselves, but they need their parameters to be filled in to be types. for example, ps<int, real> and ps<bool, bool> are types, whereas ps<int> and ps are not.\n\naside. in some cases, dafny will fill in or infer the type arguments automatically. in those cases, you may be able to write just ps in your program. for example,\n\nvar p: ps := psctor(5, [3.14, 2.7]);\n\n\n1\n\n\nis a legal statement. this is just a syntactic shorthand, and the type arguments of ps are still there, even if the program text omits them.\n\n\n# 2. variance\n\nwhether or not a parameterized type is a subtype of another may depend on the parameters. for example, it turns out that seq<nat> is a subtype of seq<int>, but seq<bool> is not a subtype of seq<real>. the reason behind this is that seq is co-variant in its argument.\n\n\n# 2.0. co-variance\n\nwhen a (here, unary) type constructor m is co-variant in its argument, then\n\n> for any types a and b such that a is a subtype of b, m<a> is a subtype of m<b>.\n\nlet me write the subtype relation as <:. then, what i just said about m can be written as\n\n> a, b :: a <: b ==> m<a> <: m<b>\n\nthis is really just saying that m is monotonic (with respect to the subtyping ordering) in its argument. for example, in math, a function f over the reals is monotonic (with respect to the less-or-equal ordering) when\n\n> x, y :: x y ==> f(x) f(y)\n\na type constructor with many arguments may be co-variant in some of its type arguments and not others. for example, if trois is a type constructor with three arguments and is co-variant in the first and third argument, then\n\n> a, b, h, x, y :: a <: b && x <: y ==> trois<a, h, x> <: trois<b, h, y>\n\n\n# 2.1. contra-variance\n\nsome type constructors are contra-variant in some of their type arguments. this means that the subtype of the argument has an opposite effect on the subtyping of the constructed type. more precisely, when a (here, unary) type constructor m is contra-variant in its argument, then\n\n> a, b :: a <: b ==> m<b> <: m<a>\n\nthis corresponds to the math notion of a function being anti-monotonic.\n\nfor illustration, consider the declarations\n\ndatatype color = blue | green\ntype coloring<x> = x -> color\n\n\n1\n2\n\n\nwhich, for any type x, defines coloring<x> to be the type whose values are functions that give each x value a color. as it turns out, type constructor coloring is contra-variant in its argument. consequently, every value of coloring<int> is a value of coloring<nat>. this makes sense—each value of coloring<int> is a function that gives every integer a color, and each value of coloring<nat> is a function that gives every non-negative integer a color, and every function that gives all integers a color also gives the non-negative integers a color.\n\n\n# 2.2. non-variance\n\nfor some type constructors, if you provide different type arguments, the resulting types have no relation to each other. for example, using class cell from above, there is no subtype relation between cell<nat> and cell<int>. in this case, we say that the type constructor is non-variant in its argument.\n\nnote. perversely, non-variance is sometimes called invariance. that's a terrible mistake. “invariant” refers to something that does not change, which is very much the opposite of the effect of non-variant type parameters. when you change the argument given to a non-variant type parameter, the resulting type can be something completely different—not the same thing. so, please… don't refer to non-variant as “invariant”!\n\n\n# 3. declaring variance\n\ndafny defines the type-parameter variance of the built-in type constructors. for example, seq is co-variant in its type argument. (i'll mention the other collection types in section 11.) as another example, for any n, the n-ary arrow type constructor is contra-variant in each of its n input types and co-variant in its output type. reference types (user-defined classes, built-in arrays, etc.) are required to be non-variant in each of their type parameters.\n\nfor datatype and codatatype declarations, subset types, opaque types, and type synonyms, there's some freedom in choosing the variance for each type parameter. to declare a type constructor to be co-variant in a type parameter, mark the type parameter with a prefix +. for contra-variance, mark the type parameter with a prefix -. the absence of any such mark declares the type constructor to be non-variant in that type parameter.\n\nfor example, the declaration\n\ntype example<+a, -b, c, +d>\n\n\n1\n\n\nintroduces an opaque-type type constructor example with four type arguments. the type constructor is co-variant in its first and fourth arguments, contra-variant in its second argument, and non-variant in its third argument.\n\nas another example, the built-in tuple type constructors (which are datatypes) are co-variant in each of their arguments.\n\nnote. in section 2.1, i said that coloring<x> is contra-variant. that's not quite true. the right-hand side of the definition of coloring<x> is contra-variant in x. if you want coloring to have this property, you must explicitly mark the parameter as such. that is, coloring<x> declared in 2.1 is non-variant in x, whereas declaring it as\n\ntype coloring<-x> = x -> color\n\n\n1\n\n\nmakes it contra-variant.\n\nthere are no restrictions on the type-parameter variance of opaque types. but for the other type declarations, the right-hand side definition of the type must be consistent with each type-parameter variance given on the left-hand side.\n\nfor example, consider the following attempt at defining a datatype:\n\ndatatype record<-x> = record(x: x)  // error: x is not used contra-variantly\n\n\n1\n\n\nthis declaration introduces x as a contra-variant type parameter of record, but the right-hand side definition of record does not use x according to that variance. if x is instead introduced as a co-variant or non-variant type parameter, the definition is legal.\n\nnote. even if the right-hand side is consistent with declaring a type parameter as co-variant or as contra-variant, the declaration of a type constructor does not need to advertise that to its users. in other words, it's fine to declare\n\ndatatype record<x> = record(x: x)\n\n\n1\n\n\neven though\n\ndatatype record<+x> = record(x: x)\n\n\n1\n\n\nis also legal and would allow more uses of record. as another example, the section 2.1 declaration of coloring makes it non-variant, whereas its right-hand side would be consistent with making coloring contra-variant. this is the same kind of choice of abstraction that is available throughout a programming language. for example, a function can have an int result type even it returns only non-negative integers. this establishes a contract between the implementation of a function and its callers. in particular, it says that the caller must be prepared to receive any integer result, and it gives the implementation the freedom to in the future return negative integers without breaking any callers.\n\n\n# 4. positive and negative positions\n\nwhen looking at the right-hand side of a type declaration to see if the type parameters are used in accordance with their variance, it is useful to think of positive and negative positions. the basic idea is that an occurrence of a type x in a type expression t is in a positive position if the occurrence is to the left of an even number of arrows in t, and it is in a negative position if it occurs to the left of an odd number of arrows.\n\nto illustrate, consider the following type expression:\n\n(a, (b -> bool) -> c, seq<d -> (e -> f)>)\n\n\n1\n\n\nin this type expression, a, b, c, and f are in positive positions and d and e are in negative positions.\n\nto explain the origin of the names “positive” and “negative”, let me write t(x) to denote a type expression where i have singled out a particular occurrence of x. if the x in t(x) occurs in a positive position, then any subtype/supertype change in x will cause a change in the same direction in t(x). that is, it is as if t(x) “multiplies” x by a positive number. conversely, if x is in a negative position, then any subtype/supertype change in x will cause a change in the opposite direction in t(x). that is, it is as if t(x) “multiplies” x by a negative number.\n\nin more symbols, if x occurs in a positive position in t(x), then\n\n> x, y :: x <: y ==> t(x) <: t(y)\n\nand if x occurs in a negative position in t(x), then\n\n> x, y :: x <: y ==> t(y) <: t(x)\n\nit's no accident that these formulas look like the ones that define co-variance and contra-variance in section 2, because those concepts are tightly related to the concepts of positive and negative positions.\n\nconsider a type-constructor declaration with a type parameter x and a right-hand side rhs. if x is marked as co-variant, then it is used correctly if all its occurrences in rhs are in positive positions. if x is marked as contra-variant, then it is used correctly if all its occurrences in rhs are in negative positions.\n\nlet me tidy up a detail. in my above definitions of positive and negative positions, i only mentioned arrow type constructors. if for a moment we ignore syntax and write an arrow type like a -> b as arrow<a, b>, then we can view the (built-in) definition of arrow as\n\ntype arrow<-x, +y>\n\n\n1\n\n\nnow, the definition of positive/negative positions goes as follows. for any type t,\n\n * if t has the form x where x is a type parameter, then this occurrence of x is in a positive position.\n\n * \n\nif\n\nt\n\n\n1\n\n\nhas the form\n\ntc<..., u, ...>\n\n\n1\n\n\nwhere type expression\n\nu\n\n\n1\n\n\nis passed in as the type parameter\n\na\n\n\n1\n\n\nin type constructor\n\ntc\n\n\n1\n\n\n, then\n\n * if a is declared as co-variant, then all the positive positions in u are positive positions in t and all negative positions in u are negative positions in t\n * if a is declared as contra-variant, then all the positive positions in u are negative positions in t and all negative positions in u are positive positions in t\n * if a is declared as non-variant, then u contributes neither positive nor negative positions to t\n\nfor example, in the type\n\nseq<(a, cell<b -> bool>, c -> d)> -> example<int, e, f, g>\n\n\n1\n\n\nwhere cell and example are as defined above (and, recall, the built-in seq and the built-in tuple types are co-variant in their arguments, and the type constructor -> is like arrow above), the type variables in positive positions are c and g, and the type variables in negative positions are a, d, and e.\n\n\n# 5. five type-parameter modes\n\nin most programming languages that support type-parameter variance, you will encounter only the 3 modes of variance i've discussed so far. if that's all you want to know, you can stop reading now. (dafny's defaults are such that you rarely need to know about more than these 3 modes.)\n\ndafny, it turns out, has 5 type-parameter modes. the additional modes come about because dafny is concerned with formal verification. to motivate and explain the additional modes, i will review a property about datatypes, show a subtle way that mere type declarations can cause a logical contradiction, introduce the concept of cardinality preservation, and then come back to dafny.\n\n\n# 6. injectivity\n\nthe constructors of a datatype or codatatype are injective in their arguments. this means that there is only one way to construct a particular datatype value.\n\nin more detail, let's review four properties of datatypes. for illustration, let's consider a standard list definition (of integers—just to keep things simple).\n\ndatatype list = nil | cons(head: int, tail: list)\n\n\n1\n\n\nfirst, this definition says that there are two variants of lists: those that are constructed using nil and those that are constructed using cons. so, for any value xs of type list, the disjunction\n\nxs.nil? || xs.cons?\n\n\n1\n\n\nalways holds. second, the two variants give rise to different values. so,\n\n!(xs.nil? && xs.cons?)\n\n\n1\n\n\nalways holds. third, each constructor is a function, in the sense that its arguments (and nothing else!) determine the value they produce. so,\n\nx == y && xs == ys  ==>  cons(x, xs) == cons(y, ys)\n\n\n1\n\n\nalways holds. fourth, two values of the same variant are equal only if the corresponding arguments are equal. so,\n\ncons(x, xs) == cons(y, ys)  ==>  x == y && xs == ys\n\n\n1\n\n\nit's this fourth property that is called injectivity. more precisely, a datatype constructor is injective in each argument. (an alternate name for “injective” is “one-to-one”.) when a function is injective (in an argument), there exists an inverse function (for that argument). for a datatype, those inverse functions are called destructors, and they can be given names by introducing names for the parameters of the constructors. in the list declaration above, the inverse functions for cons were introduced as .head and .tail. so, we have\n\ncons(x, xs).head == x  &&  cons(x, xs).tail == xs\n\n\n1\n\n\n\n# 7. a logical contradiction\n\nconsider the following type declarations:\n\ntype f = d -> bool\ndatatype d = ctor(f: f)\n\n\n1\n2\n\n\ni'm now going to argue that there is an infinite number of values of type d. regardless of how many d values there are, we can define a function f``0 of type f that always returns false. if we pass in f``0 to ctor, we get a d value, call it d``0. (we just proved that the set of d values is nonempty!) from our definition of f``0, we have that f``0``(d``0``) == false. next, let's define a function f``1 that is like f``0, except that it returns true for d``0. define d``1 to be the value ctor(f``1``). because f``0 is different from f``1, the injectivity of ctor tells us that d``0 is different from d``1. (we have now shown that there are at least 2 d values!) next, define a function f``2 that is like f``1, except that it returns true for d``1. by passing f``2 to ctor, we get yet another d value. we can continue this process forever, which shows that there is no finite bound on the number of d values. hence, the set of d values is infinite.\n\nhow many f values are there? if d were finite, you would immediately answer 2``|d|, where |d| is the size of d—also known as the cardinality of d—because for each d value, f may return one of 2 values. this is called the powerset of d. but as we just concluded above, d is infinite. well, it turns out that the answer is still the same: the cardinality of f is 2``|d|, where we're using cardinal numbers instead of natural numbers. this sounds mathematical, but all you need to know is that the inequality n < 2``n holds for cardinal numbers just like it holds for natural numbers (see, e.g., theorem 22.10 of [3]). in other words, the number of f values is strictly larger than the number of d values.\n\nthis is trouble.\n\nfor every f value, we can construct a d value, and thus |f| <= |d|. but we concluded above that |d| < 2``|d| and 2``|d|`` == |f|. putting these facts together by transitivity, we get |f| < |f|, which is just false.\n\nusing a construction akin to cantor's diagonalization argument [6] or russell's paradox [5], we can exploit this contradiction in cardinalities and prove false:\n\nlemma false()\n  ensures false\n{\n  var g := (d: d) => !d.f(d);\n  var dd := ctor(g);\n  calc {\n    g(dd);\n  ==  // def. g\n    !dd.f(dd);\n  ==  { assert dd.f == g; }\n    !g(dd);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwell, it's more accurate to say that this could be trouble, because it would let us prove false. luckily, the type definitions for f and d are not accepted by dafny. that is, to avoid this logical contradiction, dafny does not allow a datatype (here, d) to be defined in terms of right-hand sides that would have larger cardinalities than d itself.\n\n\n# 8. cardinality requirement\n\nto avoid the contradiction in cardinalities when defining a type d as some type expression t(d), we must make sure the cardinalities of d and t(d) can be the same. that is, we need to be able to make d large enough that its cardinality equals that of t(d). the previous section showed an example where this is not possible, because no matter how big you make d, t(d) will be exponentially larger. i'll refer to this condition as the cardinality requirement.\n\na contradiction in cardinalities can occur only if a type is defined in terms of itself. that is, suppose a type d is defined to be rhs. if rhs does not depend on d, then d will, without risk of any contradiction, have the same cardinality as rhs. a problem can occur only if rhs depends on d. for all cases of non-trivial dependencies, one can use an argument like in section 7 to show that d has an infinite number of elements. therefore, when designing a restriction to enforce the cardinality requirement, we only need to think about types of infinite cardinality.\n\nin type theory, we can think of a fixed repertoire of type compositions. types are either type names or sum-type, product-type, or arrow-type compositions. type names include built-in types like bool and int, and also include user-defined types, like d from above. sum types correspond to the variants of a datatype. product types correspond to the list of arguments in each such variant. finally, arrow types are the types of functions.\n\nusing standard type-theory notation for these types and for the cardinality of the type named , the cardinality of types, denoted , is defined as follows:\n\nfrom this definition, we see that the cardinality is a polynomial of the cardinalities of the type names involved, except in the case of arrow types. for any polynomial and infinite cardinal number , equals . so, the only way to violate the cardinality requirement is if d occurs in the left-hand argument of an arrow type.\n\nnote. just because d occurs in the left-hand argument to an arrow does not mean there is a problem with cardinalities. in particular, arrow types are harmless if the right-hand type has cardinality 0 or 1, and so are product types where an argument has cardinality 0. for example, empty is an empty type (that is, a type with cardinality 0) and singleton is a unit type (that is, a type with cardinality 1), then there is no cardinality concern with the type\n\ndatatype d = done | more(d -> empty, d -> singleton, (d, empty) -> int)\n\n\n1\n\n\nnevertheless, dafny's rules forbid this type, too, because the rules do not look for the special cases with cardinality-0 or cardinality-1 types. that's alright. by forbidding these trivial types, the rules both eliminate actual cardinality problems and stay simple.\n\nthe crucial point is this: except for cardinality-0 types that are used as arguments to product types or as left-hand arguments to arrow types,\n\n> a type expression t(d) that mentions d is always at least as big as d.\n\nthis leads us to a proposed way to enforce the cardinality requirement:\n\n> for any type d defined to be t(d), do not allow d to be mentioned in the left-hand argument of any arrow type in t(d).\n\nthe proposed rule talks about left-hand arguments of arrow types, which reminds us of the positive/negative positions we discussed in section 4 as a way to enforce variance restrictions. some people think of the cardinality requirement as taking a step beyond saying d must be in positive positions. that is, whereas a doubly negative position (like x in (x -> bool) -> bool) is a positive position, the cardinality requirement seems to call for a strictly positive positions, where a doubly negative position is still a negative position. for this reason, you sometimes hear that the cardinality requirement is enforced by strict positivity. (i'll have more to say about this in section 12.)\n\nbut wait! weren't we discussing type parameters? what does the cardinality requirement have to do with type parameters?\n\n\n# 9. type parameters and cardinality\n\na variation of the example logical contradiction we saw in section 7 can be written using type parameters:\n\ntype g<x> = x -> bool\ndatatype e = ctor(g: g<e>)\n\n\n1\n2\n\n\nonce the type synonym g is expanded, we get the same example, and indeed the same contradiction.\n\nin a modular setting, it is not realistic to rely on being able to expand all types before checking for cardinality problems. for example, suppose type g is declared in a different module that exports g as an opaque type. a client module might then see just\n\ntype g<x>\ndatatype e = ctor(g: g<e>)\n\n\n1\n2\n\n\nfrom which it is not evident whether or not there may be problems with cardinality.\n\nto solve this problem, dafny lets every type constructor declare which of its type parameters are used in ways that preserve cardinality. the mark ! in the following example illustrates:\n\ntype example<x, !y>\n\n\n1\n\n\nthis declaration says that example uses type parameter x in a way that adheres to the cardinality requirement, whereas it does not promise the same for y. this means that\n\ndatatype good = none | some(example<good, int>)\n\n\n1\n\n\nis legal, whereas\n\ndatatype bad = none | some(example<int, bad>) // error: violates cardinality requirement\n\n\n1\n\n\nis not, because it may violate the cardinality requirement.\n\nwe can now state the enforcement of the cardinality requirement precisely. ignoring syntax, like i did in section 4, we can view all types as type constructors that take a list of type parameters, each of which is identified as cardinality preserving or possibly not cardinality preserving. for any type t,\n\n * if t has the form x where x is a type parameter, then this occurrence of x is a cardinality-preserving position iff x is marked as cardinality preserving.\n\n * \n\nif\n\nt\n\n\n1\n\n\nhas the form\n\ntc<..., u, ...>\n\n\n1\n\n\nwhere type expression\n\nu\n\n\n1\n\n\nis passed in as the type parameter\n\na\n\n\n1\n\n\nin type constructor\n\ntc\n\n\n1\n\n\n, then\n\n * if a is declared as cardinality preserving, then all the cardinality-preserving positions in u are cardinality-preserving positions in t\n * if a is not declared as cardinality preserving, then u does not contribute any cardinality-preserving positions to t\n\nthe cardinality requirement is now enforced by the following cardinality-preservation rule: for any type d<..., x, ...> defined as rhs,\n\n * in rhs, d is allowed to be used only in cardinality-preserving positions.\n * if x is marked as cardinality preserving, then, in rhs, x is allowed to be used only in cardinality-preserving positions.\n\n\n# 10. combining variance and cardinality preservation\n\nwith 3 kinds of variance, each with cardinality preservation or not, you'd think we'd have 6 modes altogether. but there is no way to be contra-variant and cardinality preserving—in terms of arrow types, contra-variance says the type parameter is to the left of some arrow, and that makes it not preserve cardinality. therefore, dafny supports 5 modes. the default mode is non-variant, cardinality preserving. the other four modes can be indicated with the prefix marks +, *, -, and !, as shown by this table:\n\n                 cardinality preserving   \nvariance         yes                      not necessarily\n                                          \nco-variant       +                        *\ncontra-variant   n/a                      -\nnon-variant      (default)                !\n\n\n# 11. built-in type constructors\n\ndafny has several built-in type constructors. here are their type-parameter modes:\n\nset<+a>          // finite sets\niset<*a>         // possibly infinite sets\nseq<+a>          // sequences\nmultiset<+a>     // multisets\nmap<+a, +b>      // finite maps\nimap<*a, +b>     // possibly infinite maps\n(+a, +b, +c)     // tuple types\n-a -> +b         // arrow type for total functions\n-a --\x3e +b        // arrow type for partial functions\n-a ~> +b         // arrow type for general functions\narray<a>         // arrays\narray2<a>        // multi-dimensional arrays\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmost of these are probably what you'd expect. for example, as we have seen above in examples, sequences are co-variant in their type argument, and they are also cardinality preserving. tuple types (a 3-tuple is shown above) are built-in datatypes and they are co-variant and cardinality-preserving in all their arguments. array types of any dimension are reference types, which are restricted to be non-variant in their type parameters, and they are also cardinality preserving. arrow types are co-variant and cardinality preserving in their last type parameter and, as we have discussed, contra-variant and not cardinality preserving in the other type parameters.\n\nsome of type modes among the built-in types are more subtle. if you're tired of considering subtleties and are happy to accept the type-parameter modes of the built-in types, you can skip the rest of this section. if you want understand the rationale behind these type-parameter modes, keep reading.\n\n\n# 11.0. iset and ->\n\nan iset<x> is a possibly infinite set of x's. we can think of such a set as a function that for each x returns true or false, depending on whether or not the value is in the set. so, iset<x> is like the type x -> bool, which is not cardinality preserving in x.0 but why is iset<x> co-variant in x while x -> bool is contra-variant in x?\n\nwhat i'm about to say applies to any types y and x where y is a subtype of x, but i find it helpful to think of specific, familiar types, so i will instead use the types nat and int.\n\nsince nat is a subtype of int, co-variance would say that every iset<nat> value is also an iset<int> value. indeed, a set containing only non-negative integers is also an iset<int>, so it makes sense that iset is co-variant in its type argument.\n\nif -> were co-variant, then any nat -> bool function would have to be a int -> bool function, which isn't so. for example, consider the nat -> bool function\n\n(n: nat) => 1000 / (n+1) < 20\n\n\n1\n\n\nthis function evaluates to false for 3 and evaluates to true for 999. if we ignore the \": nat\" type of the function's argument and try to think of the function as having type int -> bool, we expect to get a bool value if we apply the function to any integer. but the function's body is undefined for -1, so clearly it's not like an int -> bool function. we conclude that -> is not co-variant in its first argument.\n\ninstead, it is contra-variant in its first argument. that is, every int -> bool function is also a nat -> bool function. being the latter says you get a bool result whenever you apply it to a non-negative integer. since that's also true for any int -> bool function, it makes sense to say -> is contra-variant in its first argument.\n\n\n# 11.1. two subtle consequences\n\nthere are two subtle consequences of the decision to make iset co-variant and _ -> bool contra-variant. they have to do with expressing membership/domain. to talk about them, let me first be explicit about the following principle in the dafny language design:\n\n * the static types don't alter values principle.\n   \n   a static type says something about the value, but does not alter the value. if y is a subtype of x, then you're allowed to assign a value of type y to a variable of type x. in dafny, such an assignment does not alter the value assigned. for example, given variables\n   \n   x: x    y: y    originaly: y\n   \n   \n   1\n   \n   \n   the following assignments are allowed and result in the assertion being verified:\n   \n   originaly := y; // save the value of y\n   x := y; // assign y to a variable of a different type (a supertype)\n   y := x; // assign x back to y\n   assert x == y == originaly;\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   the assignment from y to x is allowed, since y is a subtype of x. the assignment from x to y is allowed by the type system, but generates a proof obligation that the value of x at the time of the assignment is indeed a value of type y. since neither assignment alters the value, the final assertion succeeds.\n\nnow, if s has type iset<int>, then the expression -7 in s evaluates to a boolean that tells us whether or not -7 is an element of set s. suppose t has type iset<nat>. is the expression -7 in t legal? yes, because we could assign t to s (which, according to the language-design principle above, does not alter the value) and then ask -7 in s. since there is a way to ask about -7's membership in t, it seems fine to allow the expression -7 in t directly, and that's what dafny does.\n\nnote. one could try to imagine a different language design, where an iset<int> value would be allowed to masquerade as an iset<nat> value. in such a language, consider the following program snippet, where variables s and t have types iset<int> and iset<nat>, respectively:\n\nt := s;\nassert s == t;\nassert -7 in s <==> -7 in t;\n\n\n1\n2\n3\n\n\nby the static types don't alter values principle, the first assertion should hold. and if s and t are indeed equal, then the next assertion should also hold. but that's nonsense, since every element of an iset<nat> is non-negative. perhaps the language could outlaw the expression -7 in t, since -7 is not a value in the element type (nat) of the static type of t—but this doesn't help, since (as we considered above) we can ask about -7's membership in t without writing -7 in t directly. the conclusion is that such an imagined language design goes against the static types don't alter values principle.\n\nnext, if f is an int -> bool function, we can (by contra-variance) assign it to a variable g of type nat -> bool. since f is defined on every integer, the expression f.requires(-7) is true. so what about g.requires(-7)? it would be strange for it to return true, since -7 is not a value of the first type parameter of g's type. but we also can't let it return false, because then g is not equal to f, which violates the static types don't alter values principle. the only way out is to try to outlaw g.requires(-7).\n\nfor an expression e of static type a -> b, dafny defines e.requires to have type a -> bool. so, f.requires has type int -> bool, which means one can pass -7 to it. but g.requires has type nat -> bool, so it is not legal to pass it -7.\n\n\n# 11.2. set and iset\n\nhaving looked at iset<x> in detail, our first thought might be that set<x> would be the same. after all, we can view both iset<x> and set<x> as having values of the form x -> bool. while co-variance applies to iset and set alike, the cardinality concern we had with x -> bool and iset<x> does not apply to set<x> (explained next). therefore, set's type parameter is declared with +.\n\nfor any type x, the values of iset<x> are in one-to-one correspondence with the powerset of x—that is, all functions from x to bool, or, equivalently, all possible subsets of x—whose cardinality is 2``|x|. the values of set<x> correspond to the finite powerset of x—that is, the functions from x to bool that return true only for a finite number of elements, or, equivalently, all finite subsets of x. the cardinality of the finite powerset is far smaller. specifically, if x has infinite cardinality (which is the case we are interested in, see section 8), then the cardinality of the finite powerset of x equals the cardinality of x itself (see appendix a for a proof).\n\n\n# 11.3. map and imap\n\nthe last point to explain about the type-parameter modes of the built-in type constructors regards finite maps (map<x, y>) and possibly infinite maps (imap<x, y>).\n\nyou can view map<x, y> and imap<x, y> as (finite and possibly infinite) sets of pairs (x, y), with x a value of x and y a value of y. thus, as you consider subtypes (or supertypes) of either x or y, the possible pairs shrink (or grow, respectively). this justifies the map types as being co-variant in both arguments.\n\nvalues of type imap<x, y> are in one-to-one correspondence with the values of type x -> y, so our concerns about cardinality preservation apply (hence, imap declares its first argument with the mark *). but the cardinality of map<x, y>, which allows only a finite number of mappings from x to y, is far smaller. so, analogously to set<x>, when x is infinite, map<x, y> has no more elements than both |x| and |y|.\n\n\n# 12. other sources\n\nit seems that every textbook or course on types would cover the topic of cardinality preservation (or “strict positivity” as it's often called), but i have had difficulty finding such coverage. when i was first learning about this, the most useful reference i found was a seminal paper by elsa gunter [1]. but even that paper left me puzzled as to what types a verification language can allow without the risk of a logical contradiction.\n\ni now think that what had muddled my mind was the phrase “strict positivity”. i don't know who invented or popularized that phrase, but given the syntactic enforcement of cardinality preservation, i understand that it's tempting to think of the restriction as a stricter version of the positive-position restriction for type-parameter variance (section 4). but if you think of the requirement as barring a type name from occurring “to the left of any arrow”, then the motivation is not clear. “positivity” has well established connotations with monotonicity, whereas “strict positivity” has nothing to do with monotonicity. once you realize the salient point is how the cardinality of a type parameter affects the cardinality of the type generated by a type constructor, the light in your head comes on. if you—like i did—feel betrayed by the phrase “strict positivity”, you—like i do—will feel compelled to instead use the name cardinality preservation.\n\nmany other verification languages incorporate restrictions to avoid logic contradictions. of these, i want to mention the f* language [4], which does not forbid types like those in section 7; instead, to avoid logical contradictions, f* omits the injectivity property of constructors (see section 6) for such types. in other words, the constructors of a datatype in f* are injective only if the type satisfies the cardinality requirement.\n\n\n# 13. summary\n\nconsider a (here, unary) type constructor t. variance is a set of type-parameter modes that tell you what you can conclude about the subtyping relationship between t(x) and t(y) by knowing something about the subtyping relationship between x and y. cardinality preservation is a set of type-parameter modes that tell you what you can conclude about the relative cardinalities of t(x) and t(y) by knowing something about the relative cardinalities of x and y. dafny supports 5 type-parameter modes that a type constructor can use to express the desired combination of variance and cardinality preservation.\n\n# acknowledgments\n\ni first learned—years ago—about the logical contradiction in section 7 from jean-christophe filliatre and christine paulin-mohring.\n\nandreas lochbihler demonstrated to me that the contradiction is detectable in dafny, even though dafny has no concepts or types that deal with cardinal numbers directly.\n\ndiscussions with nik swamy caused me to introduce the 5, not 3, type-parameter modes in dafny, but i realize now that i was then still confused by the phrase “strict positivity”.\n\nrecently, i had some illuminating discussions with andrei paskevich and jatin arora on this topic.\n\nremy willems asked me questions about the type-parameter mark ! in dafny, which prompted me to write this note to explore the topic in more detail. little did i know i would spend this many words!\n\ni'm grateful to all of these colleagues.\n\ndafny error message movie reference [0].\n\n\n# references\n\n[0]“continuum transfunctioner”. in philip stark, writer, and danny leiner, director, dude, where's my car?, twentieth century fox, alcon entertainment, 2000. 🔎\n\n[1]elsa l. gunter. why we can't have sml-style datatype declarations in hol. in luc j. m. claesen and michael j. c. gordon, editors, higher order logic theorem proving and its applications, proceedings of the ifip tc10/wg10.2 workshop hol'92., volume a-20 of ifip transactions, pages 561–568. north-holland/elsevier, september 1992. preprint available at http://egunter.cs.illinois.edu/papers/hol1992.pdf. 🔎\n\n[2]arturo magidin. the cardinality of the set of all finite subsets of an infinite set. math stackexchange, march 2011. https://math.stackexchange.com/questions/27096/the-cardinality-of-the-set-of-all-finite-subsets-of-an-infinite-set/27098#27098. 🔎\n\n[3]j. donald monk. introduction to set theory. mcgraw-hill, 1969. electronic version available from http://euclid.colorado.edu/~monkd/monk11.pdf. 🔎\n\n[4]nilhil swamy, et al. f*: a higher-order effectful language designed for program verification. https://fstar-lang.org/. 🔎\n\n[5]bertrand russell. the principles of mathematics. w. w. norton & company, new york, 2d. ed. reprint edition, 1996. first published in 1903. 🔎\n\n[6]keith simmons. universality and the liar: an essay on truth and the diagonal argument. cambridge university press, 1993. isbn 978-0-521-43069-2, https://www.google.com/books/edition/universality_and_the_liar/wej3spept0ac. 🔎\n\n[7]chelivery. cardinality of the set of all finite subset of . math stackexchange, december 2016. https://math.stackexchange.com/questions/2057826/cardinality-of-the-set-of-all-finite-subset-of-mathbbr/2057908#2057908. 🔎\n\n\n# a. finite powerset preserves cardinality\n\nwhile i haven't found the result in a textbook or journal article, math.stackexchange.com contains at least two proofs that finite powersets preserve cardinality [2, 7]. here's a version of [7], but for any infinite set (not just ).\n\ntheorem. let be an infinite set and be the set of all finite subsets of . then, .\n\nproof. to prove and to have the same cardinality, we need to show a bijection between the two. by the schroder-bernstein theorem, it suffices to show an injective function from to and a (possibly different) surjective function from to . the function from each element in to the singleton set in is injective. so, it remains to show a surjective function from to .\n\nfor any natural number , let denote the -element subsets of . we then have that\n\nsince, for each , is a subset of , there exists a surjective function . we define a function by . function is surjective, because for any value in , , so by the surjectivity of there is an such that , and thus .\n\nalright, so we have a surjective function, , from to , but we need to show a surjective function from to . we have (see section 8), and and (since is infinite), so by cardinal arithmetic, . hence, there is a surjective function, call it , from to . we conclude that is a surjective function from to , which completes our proof.\n\n----------------------------------------\n\n0.this had been defined incorrectly in dafny. the issue was reported by travis hance and fixed by jatin arora. ↩",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-75b9d625",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-27678185",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-6ae3dba5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"tips",frontmatter:{title:"tips",date:"2022-04-01T15:09:44.000Z",permalink:"/pages/12f287/",sidebar:"auto",categories:["Tips"],tags:[null],readingShow:"top"},regularPath:"/_posts/tips/tips.html",relativePath:"_posts/tips/tips.md",key:"v-3e5a3109",path:"/pages/12f287/",headersStr:null,content:"# this is a tip",normalizedContent:"# this is a tip",charsets:{},lastUpdated:"2022/04/01, 15:25:10",lastUpdatedTimestamp:164879791e4},{title:"Home",frontmatter:{home:!0,heroText:"Dafny",tagline:"welcome",pageClass:"dafny-index-class",features:[{title:"入门",details:"Dafny入门资料，快速上手！🧸",link:"/peizhi/",imgUrl:"/img/rumen.png"},{title:"进阶",details:"进一步成为Dafny高阶玩家吧~😄",link:"/zhinan/",imgUrl:"/img/jinjie.png"},{title:"资源",details:"中文服务社区，集中学习资源📖",link:"/ziyuan/",imgUrl:"/img/ziyuan.png"}],readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-87a57784",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3}],themeConfig:{bodyBgImg:"https://s1.ax1x.com/2022/04/01/q4APj1.png",bodyBgImgOpacity:1,sidebar:{"/00.目录页/":[["01.前端.md","Dafny入门","/peizhi"],["02.指南.md","Dafny进阶","/zhinan"],["03.教程.md","Dafny教程","/jiaocheng"],["04.资源.md","更多","/ziyuan"],["05.收藏.md","收藏","/shoucang"],["07.tips.md","Dafny tips","/tips"],["08.语言.md","languages","/en-US"],["09.更多.md","Dafny more","/more"]],catalogue:{"前端":"/peizhi","指南":"/zhinan","教程":"/jiaocheng","资源":"/ziyuan","收藏":"/shoucang",tips:"/tips","语言":"/en-US","更多":"/more"},"/10.配置/":[{title:"入门介绍",collapsable:!0,children:[["00.入门介绍/00.什么是Dafny.md","语言介绍","/pages/56e571/"]]},{title:"用起来吧",collapsable:!0,children:[["10.用起来吧/00.安装.md","安装Dafny","/pages/4fa796/"],["10.用起来吧/05.快速入门.md","快速入门","/pages/085606/"],["10.用起来吧/10.简单上手.md","简单上手","/pages/39fb20/"]]}],"/20.指南/":[{title:"Dafny快速入门",collapsable:!0,children:[["00.Dafny快速入门/00.基础 Basic.md","基础 Basic","/pages/6e15a6/"],["00.Dafny快速入门/05.方法 Method.md","方法 Method","/pages/eba166/"],["00.Dafny快速入门/10.关键字 Keyword.md","关键字 Keyword","/pages/83cdf9/"],["00.Dafny快速入门/15.函数 Function.md","函数 Function","/pages/01d76e/"],["00.Dafny快速入门/20.类 Class.md","类 Class","/pages/0fadc1/"],["00.Dafny快速入门/30.泛型 Generics.md","泛型 Generics","/pages/a010ab/"],["00.Dafny快速入门/35.声明 Statement.md","声明 Statement","/pages/c4fda3/"],["00.Dafny快速入门/40.表达式 Expression.md","表达式 Expression","/pages/e8438e/"]]},{title:"简单例子",collapsable:!0,children:[["10.简单例子/00.寻找最大和最小数.md","寻找最大和最小数","/pages/0978ce/"],["10.简单例子/05.斐波那契数列.md","斐波那契数列","/pages/e3e481/"],["10.简单例子/10.线性查询.md","线性查询","/pages/02fdef/"],["10.简单例子/15. 引理-计算序列中非负元素的个数.md","引理-计算序列中非负元素的个数","/pages/9b332b/"],["10.简单例子/20.集合.md","集合","/pages/3d1110/"],["10.简单例子/25.终止.md","终止","/pages/2146d4/"]]}],"/30.教程/":[{title:"Dafny教程",collapsable:!0,children:[["00.Dafny教程/00.介绍.md","介绍","/pages/877eb3/"],["00.Dafny教程/05.方法.md","方法","/pages/bf40c0/"],["00.Dafny教程/10.前置和后置条件.md","前置和后置条件","/pages/2e0c73/"],["00.Dafny教程/15.断言.md","断言","/pages/36c1b4/"],["00.Dafny教程/20.函数.md","函数","/pages/a1d5a4/"],["00.Dafny教程/25.循环不变式.md","循环不变式","/pages/d89435/"],["00.Dafny教程/30.终止.md","终止","/pages/af29e4/"],["00.Dafny教程/35.数组.md","数组","/pages/828a83/"],["00.Dafny教程/40.量词.md","量词","/pages/17e8d1/"],["00.Dafny教程/45.谓词.md","谓词","/pages/cc01af/"],["00.Dafny教程/50.框架.md","框架","/pages/13bbcd/"],["00.Dafny教程/55.二分查找.md","二分查找","/pages/1319be/"],["00.Dafny教程/60.结论.md","结论","/pages/30a8c2/"]]},{title:"Dafny进阶语法",collapsable:!0,children:[["10.Dafny进阶语法/00.引理和归纳.md","引理和归纳","/pages/273cac/"],["10.Dafny进阶语法/05.模块.md","模块","/pages/9d19b8/"],["10.Dafny进阶语法/10.集合.md","集合","/pages/b9300a/"],["10.Dafny进阶语法/15.序列.md","序列","/pages/cb3d21/"],["10.Dafny进阶语法/20.终止.md","终止","/pages/fc6196/"],["10.Dafny进阶语法/25.值类型.md","值类型","/pages/a2a107/"]]}],"/40.资源/":[{title:"实践探索",collapsable:!0,children:[["00.实践探索/1.自动归纳.md","自动归纳","/pages/718207/"],["00.实践探索/2.自动调用引理.md","自动调用引理","/pages/1f579f/"],["00.实践探索/3.定义、证明、算法正确性的案例研究GCD.md","定义、证明、算法正确性的案例研究GCD","/pages/f6638c/"],["00.实践探索/4.各种推导式.md","各种推导式","/pages/1d2420/"],["00.实践探索/5.不同类型的证明.md","不同类型的证明","/pages/20c275/"],["00.实践探索/6.集合元素上的函数.md","集合元素上的函数","/pages/67167e/"],["00.实践探索/7.在集合上迭代.md","在集合上迭代","/pages/be298d/"]]},{title:"常用工具",collapsable:!0,children:[["10.常用工具/00.Dafny type system.md","Dafny type system","/pages/8065fd/"],["10.常用工具/05.Style Guide for Dafny programs.md","Style Guide for Dafny programs","/pages/0f17ab/"],["10.常用工具/10.Cheet Sheet.md","Cheet Sheet","/pages/a65c3f/"]]}],"/50.收藏/":[["01.收藏站.md","收藏站","/pages/1b94a4/"]],"/60.支持/":[["01.导航站.md","本站 - 导航站模块","/pages/30bf81/"]],"/80.语言/":[{title:"dafny-quick-start",collapsable:!0,children:[["00.dafny-quick-start/00.Dafny Quick Reference.md","Dafny Quick Reference","/pages/8fb957/"],["00.dafny-quick-start/10.Getting Started with Dafny A Guide.md","Getting Started with Dafny A Guide","/pages/8766fd/"],["00.dafny-quick-start/20.cheet.md","cheet","/pages/fe5721/"]]},{title:"dafny-tutorials",collapsable:!0,children:[["10.dafny-tutorials/00.Getting Started with Dafny A Guide.md","Getting Started with Dafny A Guide","/pages/c80a4c/"]]},{title:"detailed-document",collapsable:!0,children:[["20.detailed-document/00.Dafny type system.md","Dafny type system","/pages/a9c4a5/"],["20.detailed-document/10.Style Guide for Dafny programers.md","Style Guide for Dafny programs","/pages/c0c2c7/"]]},{title:"publication-lecture",collapsable:!0,children:[["30.publication-lecture/00.Automatic Induction.md","Automatic Induction","/pages/a9363c/"],["30.publication-lecture/05.Calling Lemmas Automatically.md","Calling Lemmas Automatically","/pages/30441e/"],["30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md","Case study of definitions, proofs, algorithm correctness GCD","/pages/746026/"],["30.publication-lecture/15.Comprehensions.md","Comprehensions","/pages/da6921/"],["30.publication-lecture/20.Different Styles of Proofs.md","Different Styles of Proofs","/pages/8d8607/"],["30.publication-lecture/30.Functions over Set Elements.md","Functions over Set Elements","/pages/097ba0/"],["30.publication-lecture/35.Iterating over a Collection.md","Iterating over a Collection","/pages/c4484e/"],["30.publication-lecture/40.old and unchanged.md","old and unchanged","/pages/7fe522/"],["30.publication-lecture/45.Short-Circuit Operators.md","Short-Circuit Operators","/pages/369e25/"],["30.publication-lecture/50.Statement versus Expression Syntax.md","Statement versus Expression Syntax","/pages/f8c1c5/"],["30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md","The Parent Trick for proving termination and a function-by-method use case","/pages/5a4346/"],["30.publication-lecture/60.Type-Parameter Completion.md","Type-Parameter Completion","/pages/c45b5a/"],["30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md","Type-parameter modes variance and cardinality preservation","/pages/3c9a0b/"]]}]},sidebarDepth:2,logo:"/img/logo-2.png",repo:"aaron-clou/dafnycommunity",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",author:{name:"lijiahai",link:"https://github.com/Aaron-clou"},blogger:{avatar:"https://s1.ax1x.com/2022/04/01/qh3tDe.png",name:"Dafny",slogan:"新一代验证语言"},social:{iconfontCssFile:"//at.alicdn.com/t/font_3282046_m07s574tfh.css",icons:[{iconClass:"icon-github-fill",title:"Github",link:"https://github.com/Aaron-clou/dafnycommunity"},{iconClass:"icon-gitee2",title:"Gitee",link:"https://gitee.com/leo214/dafnycommunity"},{iconClass:"icon-email-fill",title:"Email",link:"1374921025@qq.com"}]},footer:{createYear:2022,copyrightInfo:"Li Jiahai | Dafny Community | 2022"},nav:[{text:"首页",link:"/"},{text:"配置",link:"/peizhi/",items:[{text:"入门介绍",link:"",items:[{text:"什么是dafny?",link:"/pages/56e571/"}]},{text:"用起来吧！",link:"",items:[{text:"安装",link:"/pages/4fa796/"},{text:"快速上手",link:"/pages/085606/"},{text:"可能遇到的问题?",link:"/pages/39fb20/"}]}]},{text:"指南",link:"/zhinan/",items:[{text:"Dafny快速入门",items:[{text:"基础学习 Basic",link:"/pages/6e15a6/"},{text:"方法 Method",link:"/pages/eba166/"},{text:"关键字 Keyword",link:"/pages/83cdf9/"},{text:"函数 Function",link:"/pages/01d76e/"},{text:"类 Class ",link:"/pages/0fadc1/"},{text:"泛型 Generics",link:"/pages/a010ab/"},{text:"声明 Statement",link:"/pages/c4fda3/"},{text:"表达式 Expression",link:"/pages/e8438e/"}]},{text:"Dafny简单例子",link:"",items:[{text:"寻找最大最小数和",link:"/pages/0978ce/"},{text:"斐波那契数列",link:"/pages/e3e481/"},{text:"线性查询",link:"/pages/02fdef/"},{text:"引理-计算序列非负元素个数",link:"/pages/9b332b/"},{text:"集合",link:"/pages/3d1110/"},{text:"终止",link:"/pages/2146d4/"}]}]},{text:"教程",link:"/jiaocheng/",items:[{text:"Dafny指导",items:[{text:"介绍",link:"/pages/877eb3/"},{text:"方法 Methods",link:"/pages/bf40c0/"},{text:"前置/后置条件 Pre/Postconditions",link:"/pages/2e0c73/"},{text:"断言 Assertions",link:"/pages/36c1b4/"},{text:"函数 Functions",link:"/pages/a1d5a4/"},{text:"循环不变体 Loop Invariants",link:"/pages/d89435/"},{text:"数组 Arrays",link:"/pages/828a83/"},{text:"量词(函数) Quantifiers",link:"/pages/17e8d1/"},{text:"谓词(函数) Predicates",link:"/pages/cc01af/"},{text:"框架 Framing",link:"/pages/13bbcd/"},{text:"二分搜索 Binary Search",link:"/pages/1319be/"},{text:"总结",link:"/pages/30a8c2/"}]},{text:"Dafny进阶语法",items:[{text:"引理和归纳 Lemmas and Induction",link:"/pages/273cac/"},{text:"模块 Modules",link:"/pages/9d19b8/"},{text:"集合 sets",link:"/pages/b9300a/"},{text:"序列 sequence",link:"/pages/cb3d21/"},{text:"终止 Terminal",link:"/pages/fc6196/"},{text:"值类型 Values Types",link:"/pages/a2a107/"}]}]},{text:"资源",link:"/ziyuan/",items:[{text:"实践探索",items:[{text:"自动归纳",link:"/pages/718207/"},{text:"自动调用引理",link:"/pages/1f579f/"},{text:"定义、证明、算法正确性",link:"/pages/f6638c/"},{text:"各种推导式",link:"/pages/1d2420/"},{text:"不同类型的证明",link:"/pages/20c275/"},{text:"集合元素上的函数",link:"/pages/67167e/"},{text:"在集合上的迭代",link:"/pages/be298d/"}]},{text:"常用工具",items:[{text:"Type System",link:"/pages/8065fd/"},{text:"Style Guide",link:"/pages/0f17ab/"},{text:"Cheet Sheet",link:"/pages/fe5721/"}]}]},{text:"✨收藏",link:"/pages/1b94a4/"},{text:"🏷️语言",link:"",items:[{text:"简体中文",link:"/"},{text:"English",link:"/en-US/"}]},{text:"💬社区留言板",link:"/pages/caf1f9/"}],blogInfo:{blogCreate:"2022-2-1",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"前端",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/01.前端.md",wordsCount:40,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"10.配置",imgUrl:"/img/rumen.png",description:"语言入门资料"}},title:"Dafny入门",date:"2020-03-11T21:50:53.000Z",permalink:"/peizhi",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"指南",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/02.指南.md",wordsCount:39,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"20.指南",imgUrl:"/img/jinjie.png",description:"Dafny进阶教程"}},title:"Dafny进阶",date:"2020-03-11T21:50:54.000Z",permalink:"/zhinan",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"教程",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/03.教程.md",wordsCount:39,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"30.教程",imgUrl:"/img/jinjie.png",description:"Dafny教程集锦"}},title:"Dafny教程",date:"2020-03-11T21:50:55.000Z",permalink:"/jiaocheng",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"资源",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/04.资源.md",wordsCount:49,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"40.资源",imgUrl:"/img/ziyuan.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/ziyuan",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"收藏",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/05.收藏.md",wordsCount:42,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"50.收藏",imgUrl:"/img/ziyuan.png",description:"更多验证语言在这里"}},title:"收藏",date:"2020-03-11T21:50:53.000Z",permalink:"/shoucang",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"tips",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/07.tips.md",wordsCount:33,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"70.tips",imgUrl:"/img/ziyuan.png",description:"tips"}},title:"Dafny tips",date:"2020-03-11T21:50:53.000Z",permalink:"/tips",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"语言",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/08.语言.md",wordsCount:34,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"80.语言",imgUrl:"/img/ziyuan.png",description:"language"}},title:"languages",date:"2020-03-11T21:50:53.000Z",permalink:"/en-US",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"更多",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.目录页/09.更多.md",wordsCount:35,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"80.更多",imgUrl:"/img/ziyuan.png",description:"更多"}},title:"Dafny more",date:"2020-03-11T21:50:53.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"什么是Dafny",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.配置/00.入门介绍/00.什么是Dafny.md",wordsCount:455,readingTime:"1.6m",title:"语言介绍",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/56e571/",categories:["配置"],tags:[null]},{name:"安装",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.配置/10.用起来吧/00.安装.md",wordsCount:539,readingTime:"2.6m",title:"安装Dafny",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/4fa796/",comment:!0,categories:["配置"],tags:[null]},{name:"快速入门",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.配置/10.用起来吧/05.快速入门.md",wordsCount:"3.7k",readingTime:"14.5m",title:"快速入门",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/085606/",categories:["配置"],tags:[null]},{name:"简单上手",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.配置/10.用起来吧/10.简单上手.md",wordsCount:67,readingTime:"1",title:"简单上手",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/39fb20/",categories:["配置"],tags:[null]},{name:"留言板",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/100.社区留言板/留言板.md",wordsCount:355,readingTime:"2m",title:"留言板",date:"2022-03-24T12:22:23.000Z",permalink:"/pages/caf1f9/",categories:["社区留言板"],tags:null,article:!1,sidebar:!1,editLink:!1},{name:"基础 Basic",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/00.基础 Basic.md",wordsCount:405,readingTime:"1.5m",title:"基础 Basic",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/6e15a6/",categories:["指南"],tags:[null]},{name:"方法 Method",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/05.方法 Method.md",wordsCount:411,readingTime:"1.6m",title:"方法 Method",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/eba166/",categories:["指南"],tags:[null]},{name:"关键字 Keyword",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/10.关键字 Keyword.md",wordsCount:410,readingTime:"1.6m",title:"关键字 Keyword",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/83cdf9/",categories:["指南"],tags:[null]},{name:"函数 Function",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/15.函数 Function.md",wordsCount:463,readingTime:"1.8m",title:"函数 Function",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/01d76e/",categories:["指南"],tags:[null]},{name:"类 Class",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/20.类 Class.md",wordsCount:57,readingTime:"1",title:"类 Class",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/0fadc1/",categories:["指南"],tags:[null]},{name:"泛型 Generics",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/30.泛型 Generics.md",wordsCount:108,readingTime:"1",title:"泛型 Generics",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/a010ab/",categories:["指南"],tags:[null]},{name:"声明 Statement",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/35.声明 Statement.md",wordsCount:680,readingTime:"2.6m",title:"声明 Statement",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/c4fda3/",categories:["指南"],tags:[null]},{name:"表达式 Expression",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/00.Dafny快速入门/40.表达式 Expression.md",wordsCount:995,readingTime:"3.8m",title:"表达式 Expression",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/e8438e/",categories:["指南"],tags:[null]},{name:"寻找最大和最小数",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/00.寻找最大和最小数.md",wordsCount:258,readingTime:"1m",title:"寻找最大和最小数",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/0978ce/",categories:["指南","简单例子"],tags:["教学例子"]},{name:"斐波那契数列",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/05.斐波那契数列.md",wordsCount:266,readingTime:"1m",title:"斐波那契数列",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/e3e481/",categories:["指南","简单例子"],tags:["教学例子"]},{name:"线性查询",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/10.线性查询.md",wordsCount:412,readingTime:"1.6m",title:"线性查询",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/02fdef/",categories:["指南","简单例子"],tags:["教学例子"]},{name:" 引理-计算序列中非负元素的个数",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/15. 引理-计算序列中非负元素的个数.md",wordsCount:634,readingTime:"2.5m",title:"引理-计算序列中非负元素的个数",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/9b332b/",categories:["指南","简单例子"],tags:["教学例子"]},{name:"集合",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/20.集合.md",wordsCount:239,readingTime:"1m",title:"集合",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/3d1110/",categories:["指南","简单例子"],tags:["教学例子"]},{name:"终止",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.指南/10.简单例子/25.终止.md",wordsCount:199,readingTime:"1",title:"终止",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/2146d4/",categories:["指南","简单例子"],tags:["教学例子"]},{name:"介绍",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/00.介绍.md",wordsCount:433,readingTime:"1.5m",title:"介绍",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/877eb3/",categories:["教程"],tags:[null]},{name:"方法",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/05.方法.md",wordsCount:741,readingTime:"2.8m",title:"方法",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/bf40c0/",categories:["教程"],tags:[null]},{name:"前置和后置条件",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/10.前置和后置条件.md",wordsCount:"1.7k",readingTime:"6.2m",title:"前置和后置条件",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/2e0c73/",categories:["教程"],tags:[null]},{name:"断言",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/15.断言.md",wordsCount:"2.4k",readingTime:"9.7m",title:"断言",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/36c1b4/",categories:["教程"],tags:[null]},{name:"函数",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/20.函数.md",wordsCount:"1.3k",readingTime:"5.3m",title:"函数",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/a1d5a4/",categories:["教程"],tags:[null]},{name:"循环不变式",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/25.循环不变式.md",wordsCount:"2.6k",readingTime:"10.6m",title:"循环不变式",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/d89435/",categories:["教程"],tags:[null]},{name:"终止",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/30.终止.md",wordsCount:913,readingTime:"3.5m",title:"终止",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/af29e4/",categories:["教程"],tags:[null]},{name:"数组",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/35.数组.md",wordsCount:732,readingTime:"2.7m",title:"数组",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/828a83/",categories:["教程"],tags:[null]},{name:"量词",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/40.量词.md",wordsCount:"1.6k",readingTime:"6.4m",title:"量词",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/17e8d1/",categories:["教程"],tags:[null]},{name:"谓词",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/45.谓词.md",wordsCount:422,readingTime:"1.5m",title:"谓词",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/cc01af/",categories:["教程"],tags:[null]},{name:"框架",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/50.框架.md",wordsCount:960,readingTime:"3.5m",title:"框架",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/13bbcd/",categories:["教程"],tags:[null]},{name:"二分查找",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/55.二分查找.md",wordsCount:"1k",readingTime:"4.6m",title:"二分查找",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/1319be/",categories:["教程"],tags:[null]},{name:"结论",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/00.Dafny教程/60.结论.md",wordsCount:429,readingTime:"1.4m",title:"结论",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/30a8c2/",categories:["教程"],tags:[null]},{name:"引理和归纳",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/00.引理和归纳.md",wordsCount:"7.4k",readingTime:"32.8m",title:"引理和归纳",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/273cac/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"模块",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/05.模块.md",wordsCount:"4.1k",readingTime:"16.7m",title:"模块",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/9d19b8/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"集合",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/10.集合.md",wordsCount:"1.5k",readingTime:"6.5m",title:"集合",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/b9300a/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"序列",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/15.序列.md",wordsCount:"1.6k",readingTime:"7m",title:"序列",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/cb3d21/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"终止",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/20.终止.md",wordsCount:"1.8k",readingTime:"6.8m",title:"终止",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/fc6196/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"值类型",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.教程/10.Dafny进阶语法/25.值类型.md",wordsCount:"5.1k",readingTime:"20.6m",title:"值类型",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/a2a107/",categories:["教程","Dafny进阶语法"],tags:[null]},{name:"自动归纳",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/1.自动归纳.md",wordsCount:"5.2k",readingTime:"20.1m",title:"自动归纳",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/718207/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"自动调用引理",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/2.自动调用引理.md",wordsCount:"1.7k",readingTime:"6.5m",title:"自动调用引理",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1f579f/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"定义、证明、算法正确性的案例研究GCD",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/3.定义、证明、算法正确性的案例研究GCD.md",wordsCount:"5.2k",readingTime:"21.1m",title:"定义、证明、算法正确性的案例研究GCD",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/f6638c/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"各种推导式",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/4.各种推导式.md",wordsCount:"7k",readingTime:"28.5m",title:"各种推导式",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1d2420/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"不同类型的证明",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/5.不同类型的证明.md",wordsCount:"4.9k",readingTime:"19.5m",title:"不同类型的证明",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/20c275/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"集合元素上的函数",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/6.集合元素上的函数.md",wordsCount:"2.6k",readingTime:"10.2m",title:"集合元素上的函数",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/67167e/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"在集合上迭代",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/00.实践探索/7.在集合上迭代.md",wordsCount:"3.5k",readingTime:"14.3m",title:"在集合上迭代",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/be298d/",categories:["资源","Dafny实践探索"],tags:[null]},{name:"Dafny type system",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/10.常用工具/00.Dafny type system.md",wordsCount:"14.7k",readingTime:"57.9m",title:"Dafny type system",date:"2022-03-26T16:59:26.000Z",permalink:"/pages/8065fd/",categories:["资源","常用工具"],tags:[null]},{name:"Style Guide for Dafny programs",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/10.常用工具/05.Style Guide for Dafny programs.md",wordsCount:"1.6k",readingTime:"7m",title:"Style Guide for Dafny programs",date:"2022-03-26T17:01:15.000Z",permalink:"/pages/0f17ab/",categories:["资源","常用工具"],tags:"111 -"},{name:"Cheet Sheet",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.资源/10.常用工具/10.Cheet Sheet.md",wordsCount:449,readingTime:"2.7m",title:"Cheet Sheet",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/a65c3f/",categories:["资源","常用工具"],tags:[null]},{name:"收藏站",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/50.收藏/01.收藏站.md",wordsCount:489,readingTime:"2.5m",title:"收藏站",date:"2022-03-25T11:48:45.000Z",permalink:"/pages/1b94a4/",categories:["收藏"],tags:[null]},{name:"导航站",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/60.支持/01.导航站.md",wordsCount:382,readingTime:"1.9m",title:"本站 - 导航站模块",date:"2022-01-11T14:03:46.000Z",categories:[null],tags:[null],permalink:"/pages/30bf81/"},{name:"Dafny Quick Reference",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/00.dafny-quick-start/00.Dafny Quick Reference.md",wordsCount:"3.8k",readingTime:"14.6m",title:"Dafny Quick Reference",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8fb957/",categories:["语言","dafny-quick-start"],tags:[null]},{name:"Getting Started with Dafny A Guide",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/00.dafny-quick-start/10.Getting Started with Dafny A Guide.md",wordsCount:"11k",readingTime:"1h8m",title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8766fd/",categories:["语言","dafny-quick-start"],tags:[null]},{name:"cheet",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/00.dafny-quick-start/20.cheet.md",wordsCount:448,readingTime:"2.7m",title:"cheet",date:"2022-03-26T11:02:27.000Z",categories:["语言","dafny-quick-start"],tags:[null],permalink:"/pages/fe5721/"},{name:"Getting Started with Dafny A Guide",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/10.dafny-tutorials/00.Getting Started with Dafny A Guide.md",wordsCount:"11k",readingTime:"1h8m",title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:03:41.000Z",permalink:"/pages/c80a4c/",categories:["语言","dafny-tutorials"],tags:[null]},{name:"Dafny type system",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/20.detailed-document/00.Dafny type system.md",wordsCount:"10.8k",readingTime:"1h7m",title:"Dafny type system",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/a9c4a5/",categories:["语言","detailed-document"],tags:[null]},{name:"Style Guide for Dafny programers",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/20.detailed-document/10.Style Guide for Dafny programers.md",wordsCount:"1.2k",readingTime:"7.5m",title:"Style Guide for Dafny programs",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/c0c2c7/",categories:["语言","detailed-document"],tags:[null]},{name:"Automatic Induction",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/00.Automatic Induction.md",wordsCount:"3.9k",readingTime:"24.1m",title:"Automatic Induction",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/a9363c/",categories:["语言","publication-lecture"],tags:[null]},{name:"Calling Lemmas Automatically",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/05.Calling Lemmas Automatically.md",wordsCount:"1.2k",readingTime:"7.5m",title:"Calling Lemmas Automatically",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/30441e/",categories:["语言","publication-lecture"],tags:[null]},{name:"Case study of definitions, proofs, algorithm correctness GCD",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md",wordsCount:"3.9k",readingTime:"24.6m",title:"Case study of definitions, proofs, algorithm correctness GCD",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/746026/",categories:["语言","publication-lecture"],tags:[null]},{name:"Comprehensions",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/15.Comprehensions.md",wordsCount:"5.3k",readingTime:"32.8m",title:"Comprehensions",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/da6921/",categories:["语言","publication-lecture"],tags:[null]},{name:"Different Styles of Proofs",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/20.Different Styles of Proofs.md",wordsCount:"3.6k",readingTime:"22.6m",title:"Different Styles of Proofs",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/8d8607/",categories:["语言","publication-lecture"],tags:[null]},{name:"Functions over Set Elements",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/30.Functions over Set Elements.md",wordsCount:"1.9k",readingTime:"12m",title:"Functions over Set Elements",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/097ba0/",categories:["语言","publication-lecture"],tags:[null]},{name:"Iterating over a Collection",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/35.Iterating over a Collection.md",wordsCount:"2.6k",readingTime:"16.5m",title:"Iterating over a Collection",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c4484e/",categories:["语言","publication-lecture"],tags:[null]},{name:"old and unchanged",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/40.old and unchanged.md",wordsCount:"2.9k",readingTime:"18m",title:"old and unchanged",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/7fe522/",categories:["语言","publication-lecture"],tags:[null]},{name:"Short-Circuit Operators",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/45.Short-Circuit Operators.md",wordsCount:"1.1k",readingTime:"6.9m",title:"Short-Circuit Operators",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/369e25/",categories:["语言","publication-lecture"],tags:[null]},{name:"Statement versus Expression Syntax",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/50.Statement versus Expression Syntax.md",wordsCount:"4.7k",readingTime:"29.1m",title:"Statement versus Expression Syntax",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/f8c1c5/",categories:["语言","publication-lecture"],tags:[null]},{name:"The Parent Trick for proving termination and a function-by-method use case",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md",wordsCount:"4.1k",readingTime:"25.4m",title:"The Parent Trick for proving termination and a function-by-method use case",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/5a4346/",categories:["语言","publication-lecture"],tags:[null]},{name:"Type-Parameter Completion",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/60.Type-Parameter Completion.md",wordsCount:"2.1k",readingTime:"13.1m",title:"Type-Parameter Completion",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c45b5a/",categories:["语言","publication-lecture"],tags:[null]},{name:"Type-parameter modes variance and cardinality preservation",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.语言/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md",wordsCount:"7.9k",readingTime:"49.1m",title:"Type-parameter modes variance and cardinality preservation",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/3c9a0b/",categories:["语言","publication-lecture"],tags:[null]},{name:"tips",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/_posts/tips/tips.md",wordsCount:21,readingTime:"1",title:"tips",date:"2022-04-01T15:09:44.000Z",permalink:"/pages/12f287/",sidebar:"auto",categories:["Tips"],tags:[null]}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500},indexImg:{navColor:2,switchNavColor:!0,bgTimeColor:!0,bgTimeColorArray:["rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)"],descFade:!0,desc:["Dafny -- New Verification Language","Welcome to our Dafny community","Hello,explorer!"],descFontSize:"1.5rem",descFadeInTime:200,descFadeOutTime:!1,descNextTime:8e3,bubble:!0,bubblePosition:0,bubbleNum:10}},locales:{"/":{lang:"zh-CN",title:"Dafny",description:"Dafny中文社区",path:"/"}}};function Kr(n){var e=document.querySelector(n);e&&e.parentNode.removeChild(e)}function Jr(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".articleInfo-wrap > .articleInfo > .info",t=0,a=setInterval((function(){t++;var i=document.querySelector(e);i?Qr(n,i)||(i.appendChild(n),clearInterval(a)):t>10&&clearInterval(a)}),1e3)}function Qr(n,e){return n.parentNode==e}t(133),t(149),t(134);var nl=t(212),el=t(213),tl=(t(231),t(233),t(42));var al={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,a=e.article,i=e.home;return!(t||!1===a||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(tl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(tl.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(tl.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},a=function(a,i){var s=n[a].frontmatter,o=s.categories,r=s.tags;"array"===Object(tl.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[a]))})),"array"===Object(tl.n)(r)&&r.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[a]))}))},i=0,s=n.length;i<s;i++)a(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var a in n.categories)e.push({key:a,length:n.categories[a].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Li.component(nl.default),Li.component(el.default);function il(n){return n.toString().padStart(2,"0")}t(375);Li.component("BlockToggle",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,492))})),Li.component("Card",(function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,493))})),Li.component("IndexBigImg",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,494))})),Li.component("Twikoo",(function(){return Promise.all([t.e(0),t.e(7)]).then(t.bind(null,495))})),Li.component("WebInfo",(function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,488))})),Li.component("Badge",(function(){return Promise.all([t.e(0),t.e(8)]).then(t.bind(null,576))})),Li.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,212))})),Li.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,213))}));t(376),t(220);var sl={name:"ReadingProgress",data:function(){return{readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}},watch:{$readingShow:function(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted:function(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy:function(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base:function(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase:function(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:function(){return Math.max(document.body.scrollHeight,document.body.offsetHeight,0)},getScreenHeight:function(){return Math.max(window.innerHeight,document.documentElement.clientHeight,0)},getReadingTop:function(){return Math.max(window.pageYOffset,document.documentElement.scrollTop,0)},getTransform:function(){var n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find((function(e){return e in n.style}))||void 0},getProgressStyle:function(){var n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?"".concat(this.transform,": scaleX(").concat(n,")"):"width: ".concat(100*n,"%");case"left":case"right":return this.transform?"".concat(this.transform,": scaleY(").concat(n,")"):"height: ".concat(100*n,"%");default:return null}}}},ol=(t(377),Object(Hr.a)(sl,(function(){var n=this.$createElement,e=this._self._c||n;return e("ClientOnly",[this.$readingShow?e("div",{staticClass:"reading-progress",class:this.$readingShow},[e("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),rl=[function(n){n.Vue,n.options;var e=n.router,a=n.siteData;n.isServer||e.beforeEach((function(n,e,i){i(),"/"!==n.path&&n.path!==e.path&&a.themeConfig.blogInfo&&(Kr(".page-view-js"),Kr(".page-view"),Kr(".book-words"),Kr(".reading-time"),a.pages.forEach((function(e){if(e.path==n.path&&(null==e.frontmatter.article||e.frontmatter.article)){var i=a.themeConfig.blogInfo,s=i.eachFileWords,o=i.pageView,r=i.pageIteration,l=i.readingTime;return s&&s.forEach((function(n){var t,a;n.permalink==e.frontmatter.permalink&&(!function(n){if(n){var e=document.createElement("div");e.title="文章字数",e.className="book-words iconfont icon-book",e.style.float="left",e.style.marginLeft="20px",e.style.fontSize="0.8rem",e.innerHTML='<a href="javascript:;" style="margin-left: 3px; color: #888">'.concat(n,"</a>"),Jr(e)}}(n.wordsCount),(l||null==l)&&(t=n.readingTime,(a=document.createElement("div")).title="预阅读时长",a.className="reading-time iconfont icon-shijian",a.style.float="left",a.style.marginLeft="20px",a.style.fontSize="0.8rem",a.innerHTML='<a href="javascript:;" style="margin-left: 3px; color: #888">'.concat(t,"</a>"),Jr(a)))})),void((o||null==o)&&(!function(){var n=document.createElement("div");n.title="浏览量",n.className="page-view iconfont icon-view",n.style.float="left",n.style.marginLeft="20px",n.style.fontSize="0.8rem",n.innerHTML='<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>',Jr(n);var e=document.createElement("style");e.innerHTML="@keyframes turn {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  .loading {\n    display: inline-block;\n    animation: turn 1s linear infinite;\n    -webkit-animation: turn 1s linear infinite;\n  }",document.head.appendChild(e)}(),setTimeout((function(){!function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3e3;Yr?Yr.fetch():Yr=t(230);var e=0,a="9999";setTimeout((function(){var t=setInterval((function(){var i=document.querySelector(".view-data");i?((e+=n)>10*n&&(i.innerText=a,clearInterval(t)),""==i.innerText?Yr.fetch():clearInterval(t)):clearInterval(t)}),n)}),n)}(r)}),1500)))}})))}))},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,a=e.date,i=e.author;"string"==typeof a&&"Z"===a.charAt(a.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(il(n.getUTCMonth()+1),"-").concat(il(n.getUTCDate())," ").concat(il(n.getUTCHours()),":").concat(il(n.getUTCMinutes()),":").concat(il(n.getUTCSeconds()))}(a)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(al)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){var e=n.Vue;e.component(ol.name,ol),e.mixin({computed:{$readingShow:function(){return this.$page.frontmatter.readingShow}}})}],ll=["ReadingProgress","Twikoo","BlockToggle"];t(131);t(205);function hl(n,e){return(hl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(206),t(207);function cl(n){return(cl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function dl(n,e){if(e&&("object"===Ao(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function ul(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,a=cl(n);if(e){var i=cl(this).constructor;t=Reflect.construct(a,arguments,i)}else t=a.apply(this,arguments);return dl(this,t)}}var fl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&hl(n,e)}(t,n);var e=ul(t);function t(){return hr(this,t),e.apply(this,arguments)}return dr(t)}(function(){function n(){hr(this,n),this.store=new Li({data:{state:{}}})}return dr(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Li.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(fl.prototype,{getPageAsyncComponent:Wo,getLayoutAsyncComponent:Uo,getAsyncComponent:Go,getVueComponent:$o});var ml={install:function(n){var e=new fl;n.$vuepress=e,n.prototype.$vuepress=e}};function pl(n){n.beforeEach((function(e,t,a){if(yl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";yl(n,i)?a(i):a()}else a();else{var s=e.path+"/",o=e.path+".html";yl(n,o)?a(o):yl(n,s)?a(s):a()}}))}function yl(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var gl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Xo("pageKey",e),Li.component(e)||Li.component(e,Wo(e)),Li.component(e)?n(e):n("")}},bl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,a=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},a()[t.slotKey])}},vl={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},xl=(t(379),t(380),Object(Hr.a)(vl,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function wl(){return(wl=Object(a.a)(regeneratorRuntime.mark((function n(e){var t,a,i,s;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Vr.routerBase||Vr.base,pl(a=new qo({base:t,mode:"history",fallback:!1,routes:Zr,scrollBehavior:function(n,e,t){return t||(n.hash?!Li.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(rl.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Li,options:i,router:a,siteData:Vr,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return s=new Li(Object.assign(i,{router:a,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ll.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:s,router:a});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Li.config.productionTip=!1,Li.use(qo),Li.use(ml),Li.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Li;So(e),t.$vuepress.$set("siteData",e);var a=n(t.$vuepress.$get("siteData")),i=new a,s=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(s).reduce((function(n,e){return e.startsWith("$")&&(n[e]=s[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){hr(this,e)}return dr(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,a=void 0===t?{}:t;for(var i in a)"/"===i?e=a[i]:0===this.$page.path.indexOf(i)&&(n=a[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Vr)),Li.component("Content",gl),Li.component("ContentSlotsDistributor",bl),Li.component("OutboundLink",xl),Li.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,a=e.children;if(t._isMounted)return a;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Li.component("Layout",Uo("Layout")),Li.component("NotFound",Uo("NotFound")),Li.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"26f9de9"},function(n){return wl.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);