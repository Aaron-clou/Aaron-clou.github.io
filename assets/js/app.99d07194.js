(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,r=e[0],l=e[1],h=e[2],d=0,u=[];d<r.length;d++)o=r[d],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&u.push(i[o][0]),i[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(c&&c(e);u.length;)u.shift()();return s.push.apply(s,h||[]),t()}function t(){for(var n,e=0;e<s.length;e++){for(var t=s[e],a=!0,r=1;r<t.length;r++){var l=t[r];0!==i[l]&&(a=!1)}a&&(s.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},i={1:0},s=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var s,r=document.createElement("script");r.charset="utf-8",r.timeout=120,o.nc&&r.setAttribute("nonce",o.nc),r.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"ab4658c0",3:"ab8a97d8",4:"06497870",5:"b8548e7f",6:"349bf431",7:"5451cfed",8:"522ce892",9:"4d4f4bdb",10:"ac38cab7",11:"38d5ee16",12:"c434ce94",13:"4e922264",14:"db841cfa",15:"b9c227cc",16:"41dadc32",17:"48b5f1eb",18:"ec254833",19:"288ca382",20:"cfeb5fdb",21:"ce8ddc5a",22:"1b8c89f0",23:"cb062ace",24:"ff271672",25:"5541f3af",26:"a1bbc4cb",27:"522d7884",28:"9335c003",29:"3fc0b07a",30:"57708681",31:"8571b949",32:"f91be5de",33:"8089c59b",34:"874d0299",35:"aff8adfd",36:"ac78b86e",37:"3fae0334",38:"3db4a8d6",39:"e585cc70",40:"afcb8fbe",41:"01f314da",42:"8e4fe21d",43:"571fb232",44:"14aebad2",45:"32f18970",46:"ce0d522f",47:"0bd83351",48:"648f667a",49:"83709ae0",50:"060e0424",51:"a1291856",52:"45f73497",53:"525782ca",54:"45a04a86",55:"65a94ba0",56:"2d038113",57:"579db650",58:"832d4c89",59:"13befb53",60:"41227bb1",61:"1d1b92f4",62:"2cdbc236",63:"83de9482",64:"4ecd0d25",65:"25118b81",66:"cdab1b54",67:"655e6e84",68:"84effb44",69:"8f07f81a",70:"d9a299e6",71:"16ef2000",72:"8252acc5",73:"f53e39bc",74:"5ef910c4",75:"72174d00",76:"bebf75c9",77:"b85547c7",78:"a0a1f574",79:"a731d645",80:"6e5b64b0",81:"6e19e312",82:"9244e788",83:"f08c5aed",84:"085ef3f8",85:"c41e6e0e",86:"e3798708",87:"fdac1c1c",88:"665ac8c8",89:"78dc55eb",90:"4757b202",91:"a0746cf2"}[n]+".js"}(n);var l=new Error;s=function(e){r.onerror=r.onload=null,clearTimeout(h);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),s=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+s+")",l.name="ChunkLoadError",l.type=a,l.request=s,t[1](l)}i[n]=void 0}};var h=setTimeout((function(){s({type:"timeout",target:r})}),12e4);r.onerror=r.onload=s,document.head.appendChild(r)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/dafnycommunity/",o.oe=function(n){throw console.error(n),n};var r=window.webpackJsonp=window.webpackJsonp||[],l=r.push.bind(r);r.push=e,r=r.slice();for(var h=0;h<r.length;h++)e(r[h]);var c=l;s.push([234,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(59),i=Function.prototype,s=i.bind,o=i.call,r=a&&s.bind(o,o);n.exports=a?function(n){return n&&r(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e,t){var a=t(0),i=t(39).f,s=t(26),o=t(14),r=t(107),l=t(112),h=t(101);n.exports=function(n,e){var t,c,d,u,f,m=n.target,p=n.global,y=n.stat;if(t=p?a:y?a[m]||r(m,{}):(a[m]||{}).prototype)for(c in e){if(u=e[c],d=n.noTargetGet?(f=i(t,c))&&f.value:t[c],!h(p?c:m+(y?".":"#")+c,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&s(u,"sham",!0),o(t,c,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var a=t(115),i=t(14),s=t(250);a||i(Object.prototype,"toString",s,{unsafe:!0})},function(n,e,t){var a=t(0),i=t(77),s=t(10),o=t(78),r=t(108),l=t(150),h=i("wks"),c=a.Symbol,d=c&&c.for,u=l?c:c&&c.withoutSetter||o;n.exports=function(n){if(!s(h,n)||!r&&"string"!=typeof h[n]){var e="Symbol."+n;r&&s(c,n)?h[n]=c[n]:h[n]=l&&d?d(e):u(e)}return h[n]}},function(n,e,t){var a=t(0),i=t(8),s=a.String,o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not an object")}},function(n,e,t){var a=t(4);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(1),i=t(15),s=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return s(i(n),e)}},function(n,e,t){var a=t(59),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var a=t(0),i=t(73),s=a.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return s(n)}},function(n,e,t){var a=t(0),i=t(9),s=t(152),o=t(151),r=t(7),l=t(80),h=a.TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(r(n),e=l(e),r(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(r(n),e=l(e),r(t),s)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw h("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(0),i=t(4),s=t(10),o=t(26),r=t(107),l=t(85),h=t(38),c=t(72).CONFIGURABLE,d=h.get,u=h.enforce,f=String(String).split("String");(n.exports=function(n,e,t,l){var h,d=!!l&&!!l.unsafe,m=!!l&&!!l.enumerable,p=!!l&&!!l.noTargetGet,y=l&&void 0!==l.name?l.name:e;i(t)&&("Symbol("===String(y).slice(0,7)&&(y="["+String(y).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!s(t,"name")||c&&t.name!==y)&&o(t,"name",y),(h=u(t)).source||(h.source=f.join("string"==typeof y?y:""))),n!==a?(d?!p&&n[e]&&(m=!0):delete n[e],m?n[e]=t:o(n,e,t)):m?n[e]=t:r(e,t)})(Function.prototype,"toString",(function(){return i(this)&&d(this).source||l(this)}))},function(n,e,t){var a=t(0),i=t(17),s=a.Object;n.exports=function(n){return s(i(n))}},function(n,e,t){var a=t(0),i=t(4),s=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?s(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0).TypeError;n.exports=function(n){if(null==n)throw a("Can't call method on "+n);return n}},function(n,e,t){"use strict";function a(n,e,t,a,i,s,o,r){var l,h="function"==typeof n?n.options:n;if(e&&(h.render=e,h.staticRenderFns=t,h._compiled=!0),a&&(h.functional=!0),s&&(h._scopeId="data-v-"+s),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},h._ssrRegister=l):i&&(l=r?function(){i.call(this,(h.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(h.functional){h._injectStyles=l;var c=h.render;h.render=function(n,e){return l.call(e),c(n,e)}}else{var d=h.beforeCreate;h.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:h}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(58),i=t(17);n.exports=function(n){return a(i(n))}},function(n,e,t){"use strict";var a=t(2),i=t(91);a({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e,t){var a=t(50);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(169).charAt,i=t(12),s=t(38),o=t(156),r=s.set,l=s.getterFor("String Iterator");o(String,"String",(function(n){r(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,e=l(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=a(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var a=t(14),i=t(266),s=Error.prototype;s.toString!==i&&a(s,"toString",i)},function(n,e,t){var a=t(1),i=a({}.toString),s=a("".slice);n.exports=function(n){return s(i(n),8,-1)}},function(n,e){n.exports=!1},function(n,e,t){var a=t(9),i=t(13),s=t(46);n.exports=a?function(n,e,t){return i.f(n,e,s(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(16);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(183),i="object"==typeof self&&self&&self.Object===Object&&self,s=a||i||Function("return this")();n.exports=s},function(n,e,t){"use strict";var a=t(2),i=t(47).filter;a({target:"Array",proto:!0,forced:!t(89)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),i=t(170),s=t(171),o=t(137),r=t(26),l=t(6),h=l("iterator"),c=l("toStringTag"),d=o.values,u=function(n,e){if(n){if(n[h]!==d)try{r(n,h,d)}catch(e){n[h]=d}if(n[c]||r(n,c,e),i[e])for(var t in o)if(n[t]!==o[t])try{r(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var f in i)u(a[f]&&a[f].prototype,f);u(s,"DOMTokenList")},function(n,e,t){var a,i=t(7),s=t(138),o=t(110),r=t(60),l=t(155),h=t(79),c=t(84),d=c("IE_PROTO"),u=function(){},f=function(n){return"<script>"+n+"<\/script>"},m=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},p=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;p="undefined"!=typeof document?document.domain&&a?m(a):((e=h("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):m(a);for(var t=o.length;t--;)delete p.prototype[o[t]];return p()};r[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=i(n),t=new u,u.prototype=null,t[d]=n):t=p(),void 0===e?t:s.f(t,e)}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59),i=Function.prototype,s=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(s):function(){return o.apply(s,arguments)})},function(n,e,t){var a=t(0),i=t(4),s=t(82),o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(2),i=t(175);a({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var a=t(0),i=t(170),s=t(171),o=t(175),r=t(26),l=function(n){if(n&&n.forEach!==o)try{r(n,"forEach",o)}catch(e){n.forEach=o}};for(var h in i)i[h]&&l(a[h]&&a[h].prototype);l(s)},function(n,e,t){var a,i,s,o=t(236),r=t(0),l=t(1),h=t(8),c=t(26),d=t(10),u=t(106),f=t(84),m=t(60),p=r.TypeError,y=r.WeakMap;if(o||u.state){var g=u.state||(u.state=new y),b=l(g.get),v=l(g.has),x=l(g.set);a=function(n,e){if(v(g,n))throw new p("Object already initialized");return e.facade=n,x(g,n,e),e},i=function(n){return b(g,n)||{}},s=function(n){return v(g,n)}}else{var w=f("state");m[w]=!0,a=function(n,e){if(d(n,w))throw new p("Object already initialized");return e.facade=n,c(n,w,e),e},i=function(n){return d(n,w)?n[w]:{}},s=function(n){return d(n,w)}}n.exports={set:a,get:i,has:s,enforce:function(n){return s(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!h(e)||(t=i(e)).type!==n)throw p("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(9),i=t(11),s=t(111),o=t(46),r=t(19),l=t(80),h=t(10),c=t(152),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=r(n),e=l(e),c)try{return d(n,e)}catch(n){}if(h(n,e))return o(!i(s.f,n,e),n[e])}},function(n,e,t){var a=t(2),i=t(0),s=t(34),o=t(262),r=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,h=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,forced:l},t)},c=function(n,e){if(r&&r[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,forced:l},t)}};h("Error",(function(n){return function(e){return s(n,this,arguments)}})),h("EvalError",(function(n){return function(e){return s(n,this,arguments)}})),h("RangeError",(function(n){return function(e){return s(n,this,arguments)}})),h("ReferenceError",(function(n){return function(e){return s(n,this,arguments)}})),h("SyntaxError",(function(n){return function(e){return s(n,this,arguments)}})),h("TypeError",(function(n){return function(e){return s(n,this,arguments)}})),h("URIError",(function(n){return function(e){return s(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return s(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return s(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return s(n,this,arguments)}}))},function(n,e,t){var a=t(287),i=t(290);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return s})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return h})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return y})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(20),t(51),t(218),t(71),t(217),t(146),t(43),t(36),t(5),t(37),t(30),t(75),t(131),t(133),t(70),t(149),t(23),t(134);var a=/#.*$/,i=/\.(md|html)$/,s=/\/$/,o=/^[a-z]+:/i;function r(n){return decodeURI(n).replace(a,"").replace(i,"")}function l(n){return o.test(n)}function h(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(a),t=e?e[0]:"",i=r(n);return s.test(i)?n:i+".html"+t}function u(n,e){var t=n.hash,i=function(n){var e=n.match(a);if(e)return e[0]}(e);return(!i||t===i)&&r(n.path)===r(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var s=n.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var r=s[o];".."===r?i.pop():"."!==r&&i.push(r)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var a=r(e),i=0;i<n.length;i++)if(r(n[i].regularPath)===a)return Object.assign({},n[i],{type:"page",path:d(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function m(n,e,t,a){var i=t.pages,s=t.themeConfig,o=a&&s.locales&&s.locales[a]||s;if("auto"===(n.frontmatter.sidebar||o.sidebar||s.sidebar))return p(n);var r=o.sidebar||s.sidebar;if(r){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(a=n,/(\.html|\/)$/.test(a)?a:a+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var a;return{}}(e,r),h=l.base,c=l.config;return"auto"===c?p(n):c?c.map((function(n){return function n(e,t,a){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return f(t,e,a);if(Array.isArray(e))return Object.assign(f(t,e[0],a),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var s=e.children||[];return 0===s.length&&e.path?Object.assign(f(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:s.map((function(e){return n(e,t,a,i+1)})),collapsable:!1!==e.collapsable}}(n,i,h)})):[]}return[]}function p(n){var e=y(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function y(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var a=t(2),i=t(47).map;a({target:"Array",proto:!0,forced:!t(89)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(35);n.exports=function(n,e){var t=n[e];return null==t?void 0:a(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(53),i=t(1),s=t(58),o=t(15),r=t(21),l=t(141),h=i([].push),c=function(n){var e=1==n,t=2==n,i=3==n,c=4==n,d=6==n,u=7==n,f=5==n||d;return function(m,p,y,g){for(var b,v,x=o(m),w=s(x),k=a(p,y),T=r(w),q=0,S=g||l,A=e?S(m,T):t||u?S(m,0):void 0;T>q;q++)if((f||q in w)&&(v=k(b=w[q],q,x),n))if(e)A[q]=v;else if(v)switch(n){case 3:return!0;case 5:return b;case 6:return q;case 2:h(A,b)}else switch(n){case 4:return!1;case 7:h(A,b)}return d?-1:i||c?c:A}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterReject:c(7)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a,i,s=t(0),o=t(28),r=s.process,l=s.Deno,h=r&&r.versions||l&&l.version,c=h&&h.v8;c&&(i=(a=c.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){var a=t(52),i=Math.min;n.exports=function(n){return n>0?i(a(n),9007199254740991):0}},function(n,e,t){"use strict";var a=t(34),i=t(11),s=t(1),o=t(104),r=t(3),l=t(7),h=t(4),c=t(52),d=t(50),u=t(12),f=t(17),m=t(119),p=t(45),y=t(267),g=t(105),b=t(6)("replace"),v=Math.max,x=Math.min,w=s([].concat),k=s([].push),T=s("".indexOf),q=s("".slice),S="$0"==="a".replace(/./,"$0"),A=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var s=A?"$":"$0";return[function(n,t){var a=f(this),s=null==n?void 0:p(n,b);return s?i(s,n,a,t):i(e,u(a),n,t)},function(n,i){var o=l(this),r=u(n);if("string"==typeof i&&-1===T(i,s)&&-1===T(i,"$<")){var f=t(e,o,r,i);if(f.done)return f.value}var p=h(i);p||(i=u(i));var b=o.global;if(b){var S=o.unicode;o.lastIndex=0}for(var A=[];;){var D=g(o,r);if(null===D)break;if(k(A,D),!b)break;""===u(D[0])&&(o.lastIndex=m(r,d(o.lastIndex),S))}for(var I,E="",j=0,C=0;C<A.length;C++){for(var z=u((D=A[C])[0]),L=v(x(c(D.index),r.length),0),F=[],_=1;_<D.length;_++)k(F,void 0===(I=D[_])?I:String(I));var P=D.groups;if(p){var M=w([z],F,L,r);void 0!==P&&k(M,P);var R=u(a(i,void 0,M))}else R=y(z,r,L,F,P,i);L>=j&&(E+=q(r,j,L)+R,j=L+z.length)}return E+q(r,j)}]}),!!r((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!S||A)},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?a:t)(e)}},function(n,e,t){var a=t(1),i=t(35),s=t(59),o=a(a.bind);n.exports=function(n,e){return i(n),void 0===e?n:s?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var a=t(154),i=t(110).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){var a=t(13).f,i=t(10),s=t(6)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,s)&&a(n,s,{configurable:!0,value:e})}},function(n,e,t){var a=t(24);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e,t){var a=t(65),i=t(272),s=t(273),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):s(n)}},function(n,e,t){var a=t(0),i=t(1),s=t(3),o=t(24),r=a.Object,l=i("".split);n.exports=s((function(){return!r("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?l(n,""):r(n)}:r},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var a=t(1),i=t(7),s=t(237);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),s(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e,t){var a=t(1);n.exports=a([].slice)},function(n,e,t){"use strict";var a=t(80),i=t(13),s=t(46);n.exports=function(n,e,t){var o=a(e);o in n?i.f(n,o,s(0,t)):n[o]=t}},function(n,e,t){var a=t(29).Symbol;n.exports=a},function(n,e,t){"use strict";t.d(e,"a",(function(){return s}));t(75);var a=t(67);t(74),t(90),t(5),t(118),t(22),t(31),t(143);var i=t(97);t(40),t(23);function s(n){return function(n){if(Array.isArray(n))return Object(a.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,a=new Array(e);t<e;t++)a[t]=n[t];return a}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(56),o=t(86),r=t(8),l=t(100),h=t(21),c=t(19),d=t(64),u=t(6),f=t(89),m=t(63),p=f("slice"),y=u("species"),g=i.Array,b=Math.max;a({target:"Array",proto:!0,forced:!p},{slice:function(n,e){var t,a,i,u=c(this),f=h(u),p=l(n,f),v=l(void 0===e?f:e,f);if(s(u)&&(t=u.constructor,(o(t)&&(t===g||s(t.prototype))||r(t)&&null===(t=t[y]))&&(t=void 0),t===g||void 0===t))return m(u,p,v);for(a=new(void 0===t?g:t)(b(v-p,0)),i=0;p<v;p++,i++)p in u&&d(a,i,u[p]);return a.length=i,a}})},function(n,e,t){var a=t(2),i=t(0),s=t(34),o=t(4),r=t(28),l=t(63),h=t(140),c=/MSIE .\./.test(r),d=i.Function,u=function(n){return function(e,t){var a=h(arguments.length,1)>2,i=o(e)?e:d(e),r=a?l(arguments,2):void 0;return n(a?function(){s(i,this,r)}:i,t)}};a({global:!0,bind:!0,forced:c},{setTimeout:u(i.setTimeout),setInterval:u(i.setInterval)})},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(3),o=t(56),r=t(8),l=t(15),h=t(21),c=t(64),d=t(141),u=t(89),f=t(6),m=t(49),p=f("isConcatSpreadable"),y=i.TypeError,g=m>=51||!s((function(){var n=[];return n[p]=!1,n.concat()[0]!==n})),b=u("concat"),v=function(n){if(!r(n))return!1;var e=n[p];return void 0!==e?!!e:o(n)};a({target:"Array",proto:!0,forced:!g||!b},{concat:function(n){var e,t,a,i,s,o=l(this),r=d(o,0),u=0;for(e=-1,a=arguments.length;e<a;e++)if(v(s=-1===e?o:arguments[e])){if(u+(i=h(s))>9007199254740991)throw y("Maximum allowed index exceeded");for(t=0;t<i;t++,u++)t in s&&c(r,u,s[t])}else{if(u>=9007199254740991)throw y("Maximum allowed index exceeded");c(r,u++,s)}return r.length=u,r}})},function(n,e,t){"use strict";t(20);var a,i,s=t(2),o=t(0),r=t(11),l=t(1),h=t(4),c=t(8),d=(a=!1,(i=/[ac]/).exec=function(){return a=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&a),u=o.Error,f=l(/./.test);s({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!h(e))return f(this,n);var t=r(e,this,n);if(null!==t&&!c(t))throw new u("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var a=t(9),i=t(10),s=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,r=i(s,"name"),l=r&&"something"===function(){}.name,h=r&&(!a||a&&o(s,"name").configurable);n.exports={EXISTS:r,PROPER:l,CONFIGURABLE:h}},function(n,e,t){var a=t(0),i=t(115),s=t(4),o=t(24),r=t(6)("toStringTag"),l=a.Object,h="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),r))?t:h?o(e):"Object"==(a=o(e))&&s(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a=t(2),i=t(0),s=t(16),o=t(34),r=t(11),l=t(1),h=t(25),c=t(9),d=t(108),u=t(3),f=t(10),m=t(56),p=t(4),y=t(8),g=t(33),b=t(81),v=t(7),x=t(15),w=t(19),k=t(80),T=t(12),q=t(46),S=t(32),A=t(83),D=t(54),I=t(177),E=t(113),j=t(39),C=t(13),z=t(138),L=t(111),F=t(63),_=t(14),P=t(77),M=t(84),R=t(60),B=t(78),O=t(6),N=t(178),W=t(179),U=t(55),G=t(38),$=t(47).forEach,H=M("hidden"),X=O("toPrimitive"),Y=G.set,Z=G.getterFor("Symbol"),V=Object.prototype,K=i.Symbol,J=K&&K.prototype,Q=i.TypeError,nn=i.QObject,en=s("JSON","stringify"),tn=j.f,an=C.f,sn=I.f,on=L.f,rn=l([].push),ln=P("symbols"),hn=P("op-symbols"),cn=P("string-to-symbol-registry"),dn=P("symbol-to-string-registry"),un=P("wks"),fn=!nn||!nn.prototype||!nn.prototype.findChild,mn=c&&u((function(){return 7!=S(an({},"a",{get:function(){return an(this,"a",{value:7}).a}})).a}))?function(n,e,t){var a=tn(V,e);a&&delete V[e],an(n,e,t),a&&n!==V&&an(V,e,a)}:an,pn=function(n,e){var t=ln[n]=S(J);return Y(t,{type:"Symbol",tag:n,description:e}),c||(t.description=e),t},yn=function(n,e,t){n===V&&yn(hn,e,t),v(n);var a=k(e);return v(t),f(ln,a)?(t.enumerable?(f(n,H)&&n[H][a]&&(n[H][a]=!1),t=S(t,{enumerable:q(0,!1)})):(f(n,H)||an(n,H,q(1,{})),n[H][a]=!0),mn(n,a,t)):an(n,a,t)},gn=function(n,e){v(n);var t=w(e),a=A(t).concat(wn(t));return $(a,(function(e){c&&!r(bn,t,e)||yn(n,e,t[e])})),n},bn=function(n){var e=k(n),t=r(on,this,e);return!(this===V&&f(ln,e)&&!f(hn,e))&&(!(t||!f(this,e)||!f(ln,e)||f(this,H)&&this[H][e])||t)},vn=function(n,e){var t=w(n),a=k(e);if(t!==V||!f(ln,a)||f(hn,a)){var i=tn(t,a);return!i||!f(ln,a)||f(t,H)&&t[H][a]||(i.enumerable=!0),i}},xn=function(n){var e=sn(w(n)),t=[];return $(e,(function(n){f(ln,n)||f(R,n)||rn(t,n)})),t},wn=function(n){var e=n===V,t=sn(e?hn:w(n)),a=[];return $(t,(function(n){!f(ln,n)||e&&!f(V,n)||rn(a,ln[n])})),a};(d||(_(J=(K=function(){if(g(J,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?T(arguments[0]):void 0,e=B(n),t=function(n){this===V&&r(t,hn,n),f(this,H)&&f(this[H],e)&&(this[H][e]=!1),mn(this,e,q(1,n))};return c&&fn&&mn(V,e,{configurable:!0,set:t}),pn(e,n)}).prototype,"toString",(function(){return Z(this).tag})),_(K,"withoutSetter",(function(n){return pn(B(n),n)})),L.f=bn,C.f=yn,z.f=gn,j.f=vn,D.f=I.f=xn,E.f=wn,N.f=function(n){return pn(O(n),n)},c&&(an(J,"description",{configurable:!0,get:function(){return Z(this).description}}),h||_(V,"propertyIsEnumerable",bn,{unsafe:!0}))),a({global:!0,wrap:!0,forced:!d,sham:!d},{Symbol:K}),$(A(un),(function(n){W(n)})),a({target:"Symbol",stat:!0,forced:!d},{for:function(n){var e=T(n);if(f(cn,e))return cn[e];var t=K(e);return cn[e]=t,dn[t]=e,t},keyFor:function(n){if(!b(n))throw Q(n+" is not a symbol");if(f(dn,n))return dn[n]},useSetter:function(){fn=!0},useSimple:function(){fn=!1}}),a({target:"Object",stat:!0,forced:!d,sham:!c},{create:function(n,e){return void 0===e?S(n):gn(S(n),e)},defineProperty:yn,defineProperties:gn,getOwnPropertyDescriptor:vn}),a({target:"Object",stat:!0,forced:!d},{getOwnPropertyNames:xn,getOwnPropertySymbols:wn}),a({target:"Object",stat:!0,forced:u((function(){E.f(1)}))},{getOwnPropertySymbols:function(n){return E.f(x(n))}}),en)&&a({target:"JSON",stat:!0,forced:!d||u((function(){var n=K();return"[null]"!=en([n])||"{}"!=en({a:n})||"{}"!=en(Object(n))}))},{stringify:function(n,e,t){var a=F(arguments),i=e;if((y(e)||void 0!==n)&&!b(n))return m(e)||(e=function(n,e){if(p(i)&&(e=r(i,this,n,e)),!b(e))return e}),a[1]=e,o(en,null,a)}});if(!J[X]){var kn=J.valueOf;_(J,X,(function(n){return r(kn,this)}))}U(K,"Symbol"),R[H]=!0},function(n,e,t){t(2)({target:"Array",stat:!0},{isArray:t(56)})},function(n,e,t){var a=t(9),i=t(72).EXISTS,s=t(1),o=t(13).f,r=Function.prototype,l=s(r.toString),h=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,c=s(h.exec);a&&!i&&o(r,"name",{configurable:!0,get:function(){try{return c(h,l(this))[1]}catch(n){return""}}})},function(n,e,t){var a=t(25),i=t(106);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:a?"pure":"global",copyright:"Â© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var a=t(1),i=0,s=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+s,36)}},function(n,e,t){var a=t(0),i=t(8),s=a.document,o=i(s)&&i(s.createElement);n.exports=function(n){return o?s.createElement(n):{}}},function(n,e,t){var a=t(153),i=t(81);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e,t){var a=t(0),i=t(16),s=t(4),o=t(33),r=t(150),l=a.Object;n.exports=r?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return s(e)&&o(e.prototype,l(n))}},function(n,e,t){var a=t(0).String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(154),i=t(110);n.exports=Object.keys||function(n){return a(n,i)}},function(n,e,t){var a=t(77),i=t(78),s=a("keys");n.exports=function(n){return s[n]||(s[n]=i(n))}},function(n,e,t){var a=t(1),i=t(4),s=t(106),o=a(Function.toString);i(s.inspectSource)||(s.inspectSource=function(n){return o(n)}),n.exports=s.inspectSource},function(n,e,t){var a=t(1),i=t(3),s=t(4),o=t(73),r=t(16),l=t(85),h=function(){},c=[],d=r("Reflect","construct"),u=/^\s*(?:class|function)\b/,f=a(u.exec),m=!u.exec(h),p=function(n){if(!s(n))return!1;try{return d(h,c,n),!0}catch(n){return!1}},y=function(n){if(!s(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return m||!!f(u,l(n))}catch(n){return!0}};y.sham=!0,n.exports=!d||i((function(){var n;return p(p.call)||!p(Object)||!p((function(){n=!0}))||n}))?y:p},function(n,e,t){var a=t(24),i=t(0);n.exports="process"==a(i.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(5);function a(n,e,t,a,i,s,o){try{var r=n[s](o),l=r.value}catch(n){return void t(n)}r.done?e(l):Promise.resolve(l).then(a,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,s){var o=n.apply(e,t);function r(n){a(o,i,s,r,l,"next",n)}function l(n){a(o,i,s,r,l,"throw",n)}r(void 0)}))}}},function(n,e,t){var a=t(3),i=t(6),s=t(49),o=i("species");n.exports=function(n){return s>=51||!a((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var a=t(2),i=t(9),s=t(0),o=t(1),r=t(10),l=t(4),h=t(33),c=t(12),d=t(13).f,u=t(112),f=s.Symbol,m=f&&f.prototype;if(i&&l(f)&&(!("description"in m)||void 0!==f().description)){var p={},y=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:c(arguments[0]),e=h(m,this)?new f(n):void 0===n?f():f(n);return""===n&&(p[e]=!0),e};u(y,f),y.prototype=m,m.constructor=y;var g="Symbol(test)"==String(f("test")),b=o(m.toString),v=o(m.valueOf),x=/^Symbol\((.*)\)[^)]+$/,w=o("".replace),k=o("".slice);d(m,"description",{configurable:!0,get:function(){var n=v(this),e=b(n);if(r(p,n))return"";var t=g?k(e,7,-1):w(e,x,"$1");return""===t?void 0:t}}),a({global:!0,forced:!0},{Symbol:y})}},function(n,e,t){"use strict";var a,i,s=t(11),o=t(1),r=t(12),l=t(144),h=t(103),c=t(77),d=t(32),u=t(38).get,f=t(219),m=t(226),p=c("native-string-replace",String.prototype.replace),y=RegExp.prototype.exec,g=y,b=o("".charAt),v=o("".indexOf),x=o("".replace),w=o("".slice),k=(i=/b*/g,s(y,a=/a/,"a"),s(y,i,"a"),0!==a.lastIndex||0!==i.lastIndex),T=h.BROKEN_CARET,q=void 0!==/()??/.exec("")[1];(k||q||T||f||m)&&(g=function(n){var e,t,a,i,o,h,c,f=this,m=u(f),S=r(n),A=m.raw;if(A)return A.lastIndex=f.lastIndex,e=s(g,A,S),f.lastIndex=A.lastIndex,e;var D=m.groups,I=T&&f.sticky,E=s(l,f),j=f.source,C=0,z=S;if(I&&(E=x(E,"y",""),-1===v(E,"g")&&(E+="g"),z=w(S,f.lastIndex),f.lastIndex>0&&(!f.multiline||f.multiline&&"\n"!==b(S,f.lastIndex-1))&&(j="(?: "+j+")",z=" "+z,C++),t=new RegExp("^(?:"+j+")",E)),q&&(t=new RegExp("^"+j+"$(?!\\s)",E)),k&&(a=f.lastIndex),i=s(y,I?t:f,z),I?i?(i.input=w(i.input,C),i[0]=w(i[0],C),i.index=f.lastIndex,f.lastIndex+=i[0].length):f.lastIndex=0:k&&i&&(f.lastIndex=f.global?i.index+i[0].length:a),q&&i&&i.length>1&&s(p,i[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&D)for(i.groups=h=d(null),o=0;o<D.length;o++)h[(c=D[o])[0]]=i[c[1]];return i}),n.exports=g},function(n,e,t){var a=t(277),i=t(278),s=t(279),o=t(280),r=t(281);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e,t){var a=t(185);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(41)(Object,"create");n.exports=a},function(n,e,t){var a=t(299);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(127);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(68),t(5),t(76),t(143),t(22),t(20),t(71);var a=t(67);function i(n,e){if(n){if("string"==typeof n)return Object(a.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(a.a)(n,e):void 0}}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function s(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),h=l.querySelector(a.barSelector),c=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),r(h,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+s(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+s(n)+"%,0)"}:{"margin-left":s(n)+"%"}).transition="all "+e+"ms "+t,i}(n,c,d)),1===n?(r(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){r(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");h(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,o=e.querySelector(a.barSelector),l=n?"-100":s(t.status||0),c=document.querySelector(a.parent);return r(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&u(i),c!=document.body&&h(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),r=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,s=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+s)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,s=arguments;if(2==s.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,s[1],s[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function h(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function c(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n,e,t){var a=t(6),i=t(32),s=t(13),o=a("unscopables"),r=Array.prototype;null==r[o]&&s.f(r,o,{configurable:!0,value:i(null)}),n.exports=function(n){r[o][n]=!0}},function(n,e,t){var a=t(52),i=Math.max,s=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):s(t,e)}},function(n,e,t){var a=t(3),i=t(4),s=/#|\.prototype\./,o=function(n,e){var t=l[r(n)];return t==c||t!=h&&(i(e)?a(e):!!e)},r=o.normalize=function(n){return String(n).replace(s,".").toLowerCase()},l=o.data={},h=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(73),i=t(45),s=t(61),o=t(6)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||s[a(n)]}},function(n,e,t){var a=t(3),i=t(0).RegExp,s=a((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=s||a((function(){return!i("a","y").sticky})),r=s||a((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:r,MISSED_STICKY:o,UNSUPPORTED_Y:s}},function(n,e,t){"use strict";t(20);var a=t(1),i=t(14),s=t(91),o=t(3),r=t(6),l=t(26),h=r("species"),c=RegExp.prototype;n.exports=function(n,e,t,d){var u=r(n),f=!o((function(){var e={};return e[u]=function(){return 7},7!=""[n](e)})),m=f&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[h]=function(){return t},t.flags="",t[u]=/./[u]),t.exec=function(){return e=!0,null},t[u](""),!e}));if(!f||!m||t){var p=a(/./[u]),y=e(u,""[n],(function(n,e,t,i,o){var r=a(n),l=e.exec;return l===s||l===c.exec?f&&!o?{done:!0,value:p(e,t,i)}:{done:!0,value:r(t,e,i)}:{done:!1}}));i(String.prototype,n,y[0]),i(c,u,y[1])}d&&l(c[u],"sham",!0)}},function(n,e,t){var a=t(0),i=t(11),s=t(7),o=t(4),r=t(24),l=t(91),h=a.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var a=i(t,n,e);return null!==a&&s(a),a}if("RegExp"===r(n))return i(l,n,e);throw h("RegExp#exec called on incompatible receiver")}},function(n,e,t){var a=t(0),i=t(107),s=a["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=s},function(n,e,t){var a=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(49),i=t(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a=t(19),i=t(100),s=t(21),o=function(n){return function(e,t,o){var r,l=a(e),h=s(l),c=i(o,h);if(n&&t!=t){for(;h>c;)if((r=l[c++])!=r)return!0}else for(;h>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,s=i&&!a.call({1:2},1);e.f=s?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(10),i=t(157),s=t(39),o=t(13);n.exports=function(n,e,t){for(var r=i(e),l=o.f,h=s.f,c=0;c<r.length;c++){var d=r[c];a(n,d)||t&&a(t,d)||l(n,d,h(e,d))}}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(0),i=t(10),s=t(4),o=t(15),r=t(84),l=t(159),h=r("IE_PROTO"),c=a.Object,d=c.prototype;n.exports=l?c.getPrototypeOf:function(n){var e=o(n);if(i(e,h))return e[h];var t=e.constructor;return s(t)&&e instanceof t?t.prototype:e instanceof c?d:null}},function(n,e,t){var a={};a[t(6)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(7),i=t(164),s=t(6)("species");n.exports=function(n,e){var t,o=a(n).constructor;return void 0===o||null==(t=a(o)[s])?e:i(t)}},function(n,e,t){var a=t(0),i=t(100),s=t(21),o=t(64),r=a.Array,l=Math.max;n.exports=function(n,e,t){for(var a=s(n),h=i(e,a),c=i(void 0===t?a:t,a),d=r(l(c-h,0)),u=0;h<c;h++,u++)o(d,u,n[h]);return d.length=u,d}},function(n,e,t){t(179)("iterator")},function(n,e,t){"use strict";var a=t(169).charAt;n.exports=function(n,e,t){return e+(t?a(n,e).length:1)}},function(n,e,t){var a=t(271),i=t(48),s=Object.prototype,o=s.hasOwnProperty,r=s.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return i(n)&&o.call(n,"callee")&&!r.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(41)(t(29),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(291),i=t(298),s=t(300),o=t(301),r=t(302);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(27),i=t(127),s=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!s.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(57),i=t(48);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(75);t(74),t(90),t(5),t(118),t(22),t(31);var a=t(97);t(40),t(23);function i(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var a,i,s=[],o=!0,r=!1;try{for(t=t.call(n);!(o=(a=t.next()).done)&&(s.push(a.value),!e||s.length!==e);o=!0);}catch(n){r=!0,i=n}finally{try{o||null==t.return||t.return()}finally{if(r)throw i}}return s}}(n,e)||Object(a.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){var a=t(2),i=t(15),s=t(83);a({target:"Object",stat:!0,forced:t(3)((function(){s(1)}))},{keys:function(n){return s(i(n))}})},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(109).indexOf,o=t(44),r=i([].indexOf),l=!!r&&1/r([1],1,-0)<0,h=o("indexOf");a({target:"Array",proto:!0,forced:l||!h},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?r(this,n,e)||0:s(this,n,e)}})},function(n,e,t){"use strict";var a=t(2),i=t(47).some;a({target:"Array",proto:!0,forced:!t(44)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(1),i=t(14),s=Date.prototype,o=a(s.toString),r=a(s.getTime);"Invalid Date"!=String(new Date(NaN))&&i(s,"toString",(function(){var n=r(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){"use strict";var a=t(1),i=t(72).PROPER,s=t(14),o=t(7),r=t(33),l=t(12),h=t(3),c=t(144),d=RegExp.prototype,u=d.toString,f=a(c),m=h((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),p=i&&"toString"!=u.name;(m||p)&&s(RegExp.prototype,"toString",(function(){var n=o(this),e=l(n.source),t=n.flags;return"/"+e+"/"+l(void 0===t&&r(d,n)&&!("flags"in d)?f(n):t)}),{unsafe:!0})},function(n,e,t){var a=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",o=a.toStringTag||"@@toStringTag";function r(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{r({},"")}catch(n){r=function(n,e,t){return n[e]=t}}function l(n,e,t,a){var i=e&&e.prototype instanceof d?e:d,s=Object.create(i.prototype),o=new T(a||[]);return s._invoke=function(n,e,t){var a="suspendedStart";return function(i,s){if("executing"===a)throw new Error("Generator is already running");if("completed"===a){if("throw"===i)throw s;return S()}for(t.method=i,t.arg=s;;){var o=t.delegate;if(o){var r=x(o,t);if(r){if(r===c)continue;return r}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===a)throw a="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);a="executing";var l=h(n,e,t);if("normal"===l.type){if(a=t.done?"completed":"suspendedYield",l.arg===c)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(a="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),s}function h(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var c={};function d(){}function u(){}function f(){}var m={};r(m,i,(function(){return this}));var p=Object.getPrototypeOf,y=p&&p(p(q([])));y&&y!==e&&t.call(y,i)&&(m=y);var g=f.prototype=d.prototype=Object.create(m);function b(n){["next","throw","return"].forEach((function(e){r(n,e,(function(n){return this._invoke(e,n)}))}))}function v(n,e){var a;this._invoke=function(i,s){function o(){return new e((function(a,o){!function a(i,s,o,r){var l=h(n[i],n,s);if("throw"!==l.type){var c=l.arg,d=c.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){a("next",n,o,r)}),(function(n){a("throw",n,o,r)})):e.resolve(d).then((function(n){c.value=n,o(c)}),(function(n){return a("throw",n,o,r)}))}r(l.arg)}(i,s,a,o)}))}return a=a?a.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return c;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return c}var a=h(t,n.iterator,e.arg);if("throw"===a.type)return e.method="throw",e.arg=a.arg,e.delegate=null,c;var i=a.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,c):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,c)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function T(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function q(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var a=-1,s=function e(){for(;++a<n.length;)if(t.call(n,a))return e.value=n[a],e.done=!1,e;return e.value=void 0,e.done=!0,e};return s.next=s}}return{next:S}}function S(){return{value:void 0,done:!0}}return u.prototype=f,r(g,"constructor",f),r(f,"constructor",u),u.displayName=r(f,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,f):(n.__proto__=f,r(n,o,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},b(v.prototype),r(v.prototype,s,(function(){return this})),n.AsyncIterator=v,n.async=function(e,t,a,i,s){void 0===s&&(s=Promise);var o=new v(l(e,t,a,i),s);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(g),r(g,o,"Generator"),r(g,i,(function(){return this})),r(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var a=e.pop();if(a in n)return t.value=a,t.done=!1,t}return t.done=!0,t}},n.values=q,T.prototype={constructor:T,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function a(t,a){return o.type="throw",o.arg=n,e.next=t,a&&(e.method="next",e.arg=void 0),!!a}for(var i=this.tryEntries.length-1;i>=0;--i){var s=this.tryEntries[i],o=s.completion;if("root"===s.tryLoc)return a("end");if(s.tryLoc<=this.prev){var r=t.call(s,"catchLoc"),l=t.call(s,"finallyLoc");if(r&&l){if(this.prev<s.catchLoc)return a(s.catchLoc,!0);if(this.prev<s.finallyLoc)return a(s.finallyLoc)}else if(r){if(this.prev<s.catchLoc)return a(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return a(s.finallyLoc)}}}},abrupt:function(n,e){for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var s=i;break}}s&&("break"===n||"continue"===n)&&s.tryLoc<=e&&e<=s.finallyLoc&&(s=null);var o=s?s.completion:{};return o.type=n,o.arg=e,s?(this.method="next",this.next=s.finallyLoc,c):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),c},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),c}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var a=t.completion;if("throw"===a.type){var i=a.arg;k(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:q(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),c}},n}(n.exports);try{regeneratorRuntime=a}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=a:Function("r","regeneratorRuntime = r")(a)}},function(n,e,t){var a=t(2),i=t(9),s=t(13).f;a({target:"Object",stat:!0,forced:Object.defineProperty!==s,sham:!i},{defineProperty:s})},function(n,e,t){"use strict";var a=t(19),i=t(99),s=t(61),o=t(38),r=t(13).f,l=t(156),h=t(25),c=t(9),d=o.set,u=o.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:a(n),index:0,kind:e})}),(function(){var n=u(this),e=n.target,t=n.kind,a=n.index++;return!e||a>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:a,done:!1}:"values"==t?{value:e[a],done:!1}:{value:[a,e[a]],done:!1}}),"values");var f=s.Arguments=s.Array;if(i("keys"),i("values"),i("entries"),!h&&c&&"values"!==f.name)try{r(f,"name",{value:"values"})}catch(n){}},function(n,e,t){var a=t(9),i=t(151),s=t(13),o=t(7),r=t(19),l=t(83);e.f=a&&!i?Object.defineProperties:function(n,e){o(n);for(var t,a=r(e),i=l(e),h=i.length,c=0;h>c;)s.f(n,t=i[c++],a[t]);return n}},function(n,e,t){var a=t(0),i=t(11),s=t(35),o=t(7),r=t(82),l=t(102),h=a.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(s(t))return o(i(t,n));throw h(r(n)+" is not iterable")}},function(n,e,t){var a=t(0).TypeError;n.exports=function(n,e){if(n<e)throw a("Not enough arguments");return n}},function(n,e,t){var a=t(251);n.exports=function(n,e){return new(a(n))(0===e?0:e)}},function(n,e,t){var a=t(8),i=t(24),s=t(6)("match");n.exports=function(n){var e;return a(n)&&(void 0!==(e=n[s])?!!e:"RegExp"==i(n))}},function(n,e,t){var a=t(2),i=t(260);a({target:"Array",stat:!0,forced:!t(163)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){"use strict";var a=t(7);n.exports=function(){var n=a(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var a=t(4),i=t(8),s=t(62);n.exports=function(n,e,t){var o,r;return s&&a(o=e.constructor)&&o!==t&&i(r=o.prototype)&&r!==t.prototype&&s(n,r),n}},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(58),o=t(19),r=t(44),l=i([].join),h=s!=Object,c=r("join",",");a({target:"Array",proto:!0,forced:h||!c},{join:function(n){return l(o(this),void 0===n?",":n)}})},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,s=/^0o[0-7]+$/i,o=parseInt,r="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,h=r||l||Function("return this")(),c=Object.prototype.toString,d=Math.max,u=Math.min,f=function(){return h.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function p(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var r=i.test(n);return r||s.test(n)?o(n.slice(2),r?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,s,o,r,l,h=0,c=!1,y=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,s=i;return a=i=void 0,h=e,o=n.apply(s,t)}function v(n){return h=n,r=setTimeout(w,e),c?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||y&&n-h>=s}function w(){var n=f();if(x(n))return k(n);r=setTimeout(w,function(n){var t=e-(n-l);return y?u(t,s-(n-h)):t}(n))}function k(n){return r=void 0,g&&a?b(n):(a=i=void 0,o)}function T(){var n=f(),t=x(n);if(a=arguments,i=this,l=n,t){if(void 0===r)return v(l);if(y)return r=setTimeout(w,e),b(l)}return void 0===r&&(r=setTimeout(w,e)),o}return e=p(e)||0,m(t)&&(c=!!t.leading,s=(y="maxWait"in t)?d(p(t.maxWait)||0,e):s,g="trailing"in t?!!t.trailing:g),T.cancel=function(){void 0!==r&&clearTimeout(r),h=0,a=l=i=r=void 0},T.flush=function(){return void 0===r?o:k(f())},T}},function(n,e,t){"use strict";var a=t(2),i=t(367).start;a({target:"String",proto:!0,forced:t(369)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(108);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(9),i=t(3);n.exports=a&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(9),i=t(3),s=t(79);n.exports=!a&&!i((function(){return 7!=Object.defineProperty(s("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(0),i=t(11),s=t(8),o=t(81),r=t(45),l=t(235),h=t(6),c=a.TypeError,d=h("toPrimitive");n.exports=function(n,e){if(!s(n)||o(n))return n;var t,a=r(n,d);if(a){if(void 0===e&&(e="default"),t=i(a,n,e),!s(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var a=t(1),i=t(10),s=t(19),o=t(109).indexOf,r=t(60),l=a([].push);n.exports=function(n,e){var t,a=s(n),h=0,c=[];for(t in a)!i(r,t)&&i(a,t)&&l(c,t);for(;e.length>h;)i(a,t=e[h++])&&(~o(c,t)||l(c,t));return c}},function(n,e,t){var a=t(16);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(2),i=t(11),s=t(25),o=t(72),r=t(4),l=t(221),h=t(114),c=t(62),d=t(55),u=t(26),f=t(14),m=t(6),p=t(61),y=t(158),g=o.PROPER,b=o.CONFIGURABLE,v=y.IteratorPrototype,x=y.BUGGY_SAFARI_ITERATORS,w=m("iterator"),k=function(){return this};n.exports=function(n,e,t,o,m,y,T){l(t,e,o);var q,S,A,D=function(n){if(n===m&&z)return z;if(!x&&n in j)return j[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},I=e+" Iterator",E=!1,j=n.prototype,C=j[w]||j["@@iterator"]||m&&j[m],z=!x&&C||D(m),L="Array"==e&&j.entries||C;if(L&&(q=h(L.call(new n)))!==Object.prototype&&q.next&&(s||h(q)===v||(c?c(q,v):r(q[w])||f(q,w,k)),d(q,I,!0,!0),s&&(p[I]=k)),g&&"values"==m&&C&&"values"!==C.name&&(!s&&b?u(j,"name","values"):(E=!0,z=function(){return i(C,this)})),m)if(S={values:D("values"),keys:y?z:D("keys"),entries:D("entries")},T)for(A in S)(x||E||!(A in j))&&f(j,A,S[A]);else a({target:e,proto:!0,forced:x||E},S);return s&&!T||j[w]===z||f(j,w,z,{name:m}),p[e]=z,S}},function(n,e,t){var a=t(16),i=t(1),s=t(54),o=t(113),r=t(7),l=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=s.f(r(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var a,i,s,o=t(3),r=t(4),l=t(32),h=t(114),c=t(14),d=t(6),u=t(25),f=d("iterator"),m=!1;[].keys&&("next"in(s=[].keys())?(i=h(h(s)))!==Object.prototype&&(a=i):m=!0),null==a||o((function(){var n={};return a[f].call(n)!==n}))?a={}:u&&(a=l(a)),r(a[f])||c(a,f,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){var a=t(3);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var a=t(0);n.exports=a.Promise},function(n,e,t){var a=t(6),i=t(61),s=a("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[s]===n)}},function(n,e,t){var a=t(11),i=t(7),s=t(45);n.exports=function(n,e,t){var o,r;i(n);try{if(!(o=s(n,"return"))){if("throw"===e)throw t;return t}o=a(o,n)}catch(n){r=!0,o=n}if("throw"===e)throw t;if(r)throw o;return i(o),t}},function(n,e,t){var a=t(6)("iterator"),i=!1;try{var s=0,o={next:function(){return{done:!!s++}},return:function(){i=!0}};o[a]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var s={};s[a]=function(){return{next:function(){return{done:t=!0}}}},n(s)}catch(n){}return t}},function(n,e,t){var a=t(0),i=t(86),s=t(82),o=a.TypeError;n.exports=function(n){if(i(n))return n;throw o(s(n)+" is not a constructor")}},function(n,e,t){var a,i,s,o,r=t(0),l=t(34),h=t(53),c=t(4),d=t(10),u=t(3),f=t(155),m=t(63),p=t(79),y=t(140),g=t(166),b=t(87),v=r.setImmediate,x=r.clearImmediate,w=r.process,k=r.Dispatch,T=r.Function,q=r.MessageChannel,S=r.String,A=0,D={};try{a=r.location}catch(n){}var I=function(n){if(d(D,n)){var e=D[n];delete D[n],e()}},E=function(n){return function(){I(n)}},j=function(n){I(n.data)},C=function(n){r.postMessage(S(n),a.protocol+"//"+a.host)};v&&x||(v=function(n){y(arguments.length,1);var e=c(n)?n:T(n),t=m(arguments,1);return D[++A]=function(){l(e,void 0,t)},i(A),A},x=function(n){delete D[n]},b?i=function(n){w.nextTick(E(n))}:k&&k.now?i=function(n){k.now(E(n))}:q&&!g?(o=(s=new q).port2,s.port1.onmessage=j,i=h(o.postMessage,o)):r.addEventListener&&c(r.postMessage)&&!r.importScripts&&a&&"file:"!==a.protocol&&!u(C)?(i=C,r.addEventListener("message",j,!1)):i="onreadystatechange"in p("script")?function(n){f.appendChild(p("script")).onreadystatechange=function(){f.removeChild(this),I(n)}}:function(n){setTimeout(E(n),0)}),n.exports={set:v,clear:x}},function(n,e,t){var a=t(28);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(a)},function(n,e,t){var a=t(7),i=t(8),s=t(168);n.exports=function(n,e){if(a(n),i(e)&&e.constructor===n)return e;var t=s.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var a=t(35),i=function(n){var e,t;this.promise=new n((function(n,a){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=a})),this.resolve=a(e),this.reject=a(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){var a=t(1),i=t(52),s=t(12),o=t(17),r=a("".charAt),l=a("".charCodeAt),h=a("".slice),c=function(n){return function(e,t){var a,c,d=s(o(e)),u=i(t),f=d.length;return u<0||u>=f?n?"":void 0:(a=l(d,u))<55296||a>56319||u+1===f||(c=l(d,u+1))<56320||c>57343?n?r(d,u):a:n?h(d,u,u+2):c-56320+(a-55296<<10)+65536}};n.exports={codeAt:c(!1),charAt:c(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var a=t(79)("span").classList,i=a&&a.constructor&&a.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,e,t){var a=t(2),i=t(3),s=t(15),o=t(114),r=t(159);a({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!r},{getPrototypeOf:function(n){return o(s(n))}})},function(n,e,t){var a=t(0),i=t(142),s=a.TypeError;n.exports=function(n){if(i(n))throw s("The method doesn't accept regular expressions");return n}},function(n,e,t){var a=t(6)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[a]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var a=t(47).forEach,i=t(44)("forEach");n.exports=i?[].forEach:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var a=t(24),i=t(19),s=t(54).f,o=t(117),r="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return r&&"Window"==a(n)?function(n){try{return s(n)}catch(n){return o(r)}}(n):s(i(n))}},function(n,e,t){var a=t(6);e.f=a},function(n,e,t){var a=t(259),i=t(10),s=t(178),o=t(13).f;n.exports=function(n){var e=a.Symbol||(a.Symbol={});i(e,n)||o(e,n,{value:s.f(n)})}},function(n,e,t){var a=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){t(2)({target:"Object",stat:!0,sham:!t(9)},{create:t(32)})},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(92),i=t(282),s=t(283),o=t(284),r=t(285),l=t(286);function h(n){var e=this.__data__=new a(n);this.size=e.size}h.prototype.clear=i,h.prototype.delete=s,h.prototype.get=o,h.prototype.has=r,h.prototype.set=l,n.exports=h},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(57),i=t(122);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(303),i=t(48);n.exports=function n(e,t,s,o,r){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,s,o,n,r))}},function(n,e,t){var a=t(190),i=t(306),s=t(191);n.exports=function(n,e,t,o,r,l){var h=1&t,c=n.length,d=e.length;if(c!=d&&!(h&&d>c))return!1;var u=l.get(n),f=l.get(e);if(u&&f)return u==e&&f==n;var m=-1,p=!0,y=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++m<c;){var g=n[m],b=e[m];if(o)var v=h?o(b,g,m,e,n,l):o(g,b,m,n,e,l);if(void 0!==v){if(v)continue;p=!1;break}if(y){if(!i(e,(function(n,e){if(!s(y,e)&&(g===n||r(g,n,t,o,l)))return y.push(e)}))){p=!1;break}}else if(g!==b&&!r(g,b,t,o,l)){p=!1;break}}return l.delete(n),l.delete(e),p}},function(n,e,t){var a=t(123),i=t(304),s=t(305);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=s,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(316),i=t(322),s=t(196);n.exports=function(n){return s(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(29),i=t(318),s=e&&!e.nodeType&&e,o=s&&"object"==typeof n&&n&&!n.nodeType&&n,r=o&&o.exports===s?a.Buffer:void 0,l=(r?r.isBuffer:void 0)||i;n.exports=l}).call(this,t(147)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(319),i=t(320),s=t(321),o=s&&s.isTypedArray,r=o?i(o):a;n.exports=r},function(n,e,t){var a=t(186),i=t(125);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(41)(t(29),"Set");n.exports=a},function(n,e,t){var a=t(122);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(201),i=t(96);n.exports=function(n,e){for(var t=0,s=(e=a(e,n)).length;null!=n&&t<s;)n=n[i(e[t++])];return t&&t==s?n:void 0}},function(n,e,t){var a=t(27),i=t(126),s=t(333),o=t(336);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:s(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){t(2)({target:"Object",stat:!0},{setPrototypeOf:t(62)})},function(n,e,t){var a=t(2),i=t(16),s=t(34),o=t(378),r=t(164),l=t(7),h=t(8),c=t(32),d=t(3),u=i("Reflect","construct"),f=Object.prototype,m=[].push,p=d((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),y=!d((function(){u((function(){}))})),g=p||y;a({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,e){r(n),l(e);var t=arguments.length<3?n:r(arguments[2]);if(y&&!p)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var a=[null];return s(m,a,e),new(s(o,n,a))}var i=t.prototype,d=c(h(i)?i:f),g=s(n,d,e);return h(g)?g:d}})},function(n,e,t){var a=t(2),i=t(0),s=t(55);a({global:!0},{Reflect:{}}),s(i.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(269),i=t(274),s=t(345),o=t(353),r=t(362),l=t(229),h=s((function(n){var e=l(n);return r(e)&&(e=void 0),o(a(n,1,r,!0),i(e,2))}));n.exports=h},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var s="",o=0,r=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}r!==o&&(s+=t.substring(r,o)),r=o+1,s+=e}return r!==o?s+t.substring(r,o):s}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(370),t(18)),s=Object(i.a)(a,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);t(36),t(5),t(37),t(43),t(30);var a={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(t(371),t(18)),s=Object(i.a)(a,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,a){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=s.exports},function(n,e,t){"use strict";var a=t(9),i=t(0),s=t(1),o=t(101),r=t(14),l=t(10),h=t(145),c=t(33),d=t(81),u=t(153),f=t(3),m=t(54).f,p=t(39).f,y=t(13).f,g=t(365),b=t(215).trim,v=i.Number,x=v.prototype,w=i.TypeError,k=s("".slice),T=s("".charCodeAt),q=function(n){var e=u(n,"number");return"bigint"==typeof e?e:S(e)},S=function(n){var e,t,a,i,s,o,r,l,h=u(n,"number");if(d(h))throw w("Cannot convert a Symbol value to a number");if("string"==typeof h&&h.length>2)if(h=b(h),43===(e=T(h,0))||45===e){if(88===(t=T(h,2))||120===t)return NaN}else if(48===e){switch(T(h,1)){case 66:case 98:a=2,i=49;break;case 79:case 111:a=8,i=55;break;default:return+h}for(o=(s=k(h,2)).length,r=0;r<o;r++)if((l=T(s,r))<48||l>i)return NaN;return parseInt(s,a)}return+h};if(o("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var A,D=function(n){var e=arguments.length<1?0:v(q(n)),t=this;return c(x,t)&&f((function(){g(t)}))?h(Object(e),t,D):e},I=a?m(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),E=0;I.length>E;E++)l(v,A=I[E])&&!l(D,A)&&y(D,A,p(v,A));D.prototype=x,x.constructor=D,r(i,"Number",D)}},function(n,e,t){var a=t(1),i=t(17),s=t(12),o=t(216),r=a("".replace),l="["+o+"]",h=RegExp("^"+l+l+"*"),c=RegExp(l+l+"*$"),d=function(n){return function(e){var t=s(i(e));return 1&n&&(t=r(t,h,"")),2&n&&(t=r(t,c,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff"},function(n,e,t){"use strict";var a=t(34),i=t(11),s=t(1),o=t(104),r=t(142),l=t(7),h=t(17),c=t(116),d=t(119),u=t(50),f=t(12),m=t(45),p=t(117),y=t(105),g=t(91),b=t(103),v=t(3),x=b.UNSUPPORTED_Y,w=Math.min,k=[].push,T=s(/./.exec),q=s(k),S=s("".slice);o("split",(function(n,e,t){var s;return s="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var s=f(h(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[s];if(!r(n))return i(e,s,n,o);for(var l,c,d,u=[],m=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),y=0,b=new RegExp(n.source,m+"g");(l=i(g,b,s))&&!((c=b.lastIndex)>y&&(q(u,S(s,y,l.index)),l.length>1&&l.index<s.length&&a(k,u,p(l,1)),d=l[0].length,y=c,u.length>=o));)b.lastIndex===l.index&&b.lastIndex++;return y===s.length?!d&&T(b,"")||q(u,""):q(u,S(s,y)),u.length>o?p(u,0,o):u}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:i(e,this,n,t)}:e,[function(e,t){var a=h(this),o=null==e?void 0:m(e,n);return o?i(o,e,a,t):i(s,f(a),e,t)},function(n,a){var i=l(this),o=f(n),r=t(s,i,o,a,s!==e);if(r.done)return r.value;var h=c(i,RegExp),m=i.unicode,p=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),g=new h(x?"^(?:"+i.source+")":i,p),b=void 0===a?4294967295:a>>>0;if(0===b)return[];if(0===o.length)return null===y(g,o)?[o]:[];for(var v=0,k=0,T=[];k<o.length;){g.lastIndex=x?0:k;var A,D=y(g,x?S(o,k):o);if(null===D||(A=w(u(g.lastIndex+(x?k:0)),o.length))===v)k=d(o,k,m);else{if(q(T,S(o,v,k)),T.length===b)return T;for(var I=1;I<=D.length-1;I++)if(q(T,D[I]),T.length===b)return T;k=v=A}}return q(T,S(o,v)),T}]}),!!v((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var a=t(11),i=t(104),s=t(7),o=t(50),r=t(12),l=t(17),h=t(45),c=t(119),d=t(105);i("match",(function(n,e,t){return[function(e){var t=l(this),i=null==e?void 0:h(e,n);return i?a(i,e,t):new RegExp(e)[n](r(t))},function(n){var a=s(this),i=r(n),l=t(e,a,i);if(l.done)return l.value;if(!a.global)return d(a,i);var h=a.unicode;a.lastIndex=0;for(var u,f=[],m=0;null!==(u=d(a,i));){var p=r(u[0]);f[m]=p,""===p&&(a.lastIndex=c(i,o(a.lastIndex),h)),m++}return 0===m?null:f}]}))},function(n,e,t){var a=t(3),i=t(0).RegExp;n.exports=a((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var a=t(2),i=t(47).find,s=t(99),o=!0;"find"in[]&&Array(1).find((function(){o=!1})),a({target:"Array",proto:!0,forced:o},{find:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),s("find")},function(n,e,t){"use strict";var a=t(158).IteratorPrototype,i=t(32),s=t(46),o=t(55),r=t(61),l=function(){return this};n.exports=function(n,e,t,h){var c=e+" Iterator";return n.prototype=i(a,{next:s(+!h,t)}),o(n,c,!1,!0),r[c]=l,n}},function(n,e,t){var a=t(14);n.exports=function(n,e,t){for(var i in e)a(n,i,e[i],t);return n}},function(n,e,t){"use strict";var a=t(16),i=t(13),s=t(6),o=t(9),r=s("species");n.exports=function(n){var e=a(n),t=i.f;o&&e&&!e[r]&&t(e,r,{configurable:!0,get:function(){return this}})}},function(n,e,t){var a=t(0),i=t(33),s=a.TypeError;n.exports=function(n,e){if(i(e,n))return n;throw s("Incorrect invocation")}},function(n,e,t){var a=t(2),i=t(9),s=t(157),o=t(19),r=t(39),l=t(64);a({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,a=o(n),i=r.f,h=s(a),c={},d=0;h.length>d;)void 0!==(t=i(a,e=h[d++]))&&l(c,e,t);return c}})},function(n,e,t){var a=t(3),i=t(0).RegExp;n.exports=a((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var a=t(2),i=t(109).includes,s=t(99);a({target:"Array",proto:!0},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),s("includes")},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(173),o=t(17),r=t(12),l=t(174),h=i("".indexOf);a({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~h(r(o(this)),r(s(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(366)},function(n,e,t){"use strict";var a=t(2),i=t(1),s=t(35),o=t(15),r=t(21),l=t(12),h=t(3),c=t(232),d=t(44),u=t(372),f=t(373),m=t(49),p=t(374),y=[],g=i(y.sort),b=i(y.push),v=h((function(){y.sort(void 0)})),x=h((function(){y.sort(null)})),w=d("sort"),k=!h((function(){if(m)return m<70;if(!(u&&u>3)){if(f)return!0;if(p)return p<603;var n,e,t,a,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(a=0;a<47;a++)y.push({k:e+a,v:t})}for(y.sort((function(n,e){return e.v-n.v})),a=0;a<y.length;a++)e=y[a].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));a({target:"Array",proto:!0,forced:v||!x||!w||!k},{sort:function(n){void 0!==n&&s(n);var e=o(this);if(k)return void 0===n?g(e):g(e,n);var t,a,i=[],h=r(e);for(a=0;a<h;a++)a in e&&b(i,e[a]);for(c(i,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=i.length,a=0;a<t;)e[a]=i[a++];for(;a<h;)delete e[a++];return e}})},function(n,e,t){var a=t(117),i=Math.floor,s=function(n,e){var t=n.length,l=i(t/2);return t<8?o(n,e):r(n,s(a(n,0,l),e),s(a(n,l),e),e)},o=function(n,e){for(var t,a,i=n.length,s=1;s<i;){for(a=s,t=n[s];a&&e(n[a-1],t)>0;)n[a]=n[--a];a!==s++&&(n[a]=t)}return n},r=function(n,e,t,a){for(var i=e.length,s=t.length,o=0,r=0;o<i||r<s;)n[o+r]=o<i&&r<s?a(e[o],t[r])<=0?e[o++]:t[r++]:o<i?e[o++]:t[r++];return n};n.exports=s},function(n,e,t){var a=t(0),i=t(9),s=t(103).MISSED_STICKY,o=t(24),r=t(13).f,l=t(38).get,h=RegExp.prototype,c=a.TypeError;i&&s&&r(h,"sticky",{configurable:!0,get:function(){if(this!==h){if("RegExp"===o(this))return!!l(this).sticky;throw c("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(381)},function(n,e,t){var a=t(0),i=t(11),s=t(4),o=t(8),r=a.TypeError;n.exports=function(n,e){var t,a;if("string"===e&&s(t=n.toString)&&!o(a=i(t,n)))return a;if(s(t=n.valueOf)&&!o(a=i(t,n)))return a;if("string"!==e&&s(t=n.toString)&&!o(a=i(t,n)))return a;throw r("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),i=t(4),s=t(85),o=a.WeakMap;n.exports=i(o)&&/native code/.test(s(o))},function(n,e,t){var a=t(0),i=t(4),s=a.String,o=a.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+s(n)+" as a prototype")}},function(n,e,t){"use strict";var a,i,s,o,r=t(2),l=t(25),h=t(0),c=t(16),d=t(11),u=t(160),f=t(14),m=t(222),p=t(62),y=t(55),g=t(223),b=t(35),v=t(4),x=t(8),w=t(224),k=t(85),T=t(239),q=t(163),S=t(116),A=t(165).set,D=t(240),I=t(167),E=t(243),j=t(168),C=t(244),z=t(245),L=t(38),F=t(101),_=t(6),P=t(246),M=t(87),R=t(49),B=_("species"),O="Promise",N=L.getterFor(O),W=L.set,U=L.getterFor(O),G=u&&u.prototype,$=u,H=G,X=h.TypeError,Y=h.document,Z=h.process,V=j.f,K=V,J=!!(Y&&Y.createEvent&&h.dispatchEvent),Q=v(h.PromiseRejectionEvent),nn=!1,en=F(O,(function(){var n=k($),e=n!==String($);if(!e&&66===R)return!0;if(l&&!H.finally)return!0;if(R>=51&&/native code/.test(n))return!1;var t=new $((function(n){n(1)})),a=function(n){n((function(){}),(function(){}))};return(t.constructor={})[B]=a,!(nn=t.then((function(){}))instanceof a)||!e&&P&&!Q})),tn=en||!q((function(n){$.all(n).catch((function(){}))})),an=function(n){var e;return!(!x(n)||!v(e=n.then))&&e},sn=function(n,e){var t,a,i,s=e.value,o=1==e.state,r=o?n.ok:n.fail,l=n.resolve,h=n.reject,c=n.domain;try{r?(o||(2===e.rejection&&cn(e),e.rejection=1),!0===r?t=s:(c&&c.enter(),t=r(s),c&&(c.exit(),i=!0)),t===n.promise?h(X("Promise-chain cycle")):(a=an(t))?d(a,t,l,h):l(t)):h(s)}catch(n){c&&!i&&c.exit(),h(n)}},on=function(n,e){n.notified||(n.notified=!0,D((function(){for(var t,a=n.reactions;t=a.get();)sn(t,n);n.notified=!1,e&&!n.rejection&&ln(n)})))},rn=function(n,e,t){var a,i;J?((a=Y.createEvent("Event")).promise=e,a.reason=t,a.initEvent(n,!1,!0),h.dispatchEvent(a)):a={promise:e,reason:t},!Q&&(i=h["on"+n])?i(a):"unhandledrejection"===n&&E("Unhandled promise rejection",t)},ln=function(n){d(A,h,(function(){var e,t=n.facade,a=n.value;if(hn(n)&&(e=C((function(){M?Z.emit("unhandledRejection",a,t):rn("unhandledrejection",t,a)})),n.rejection=M||hn(n)?2:1,e.error))throw e.value}))},hn=function(n){return 1!==n.rejection&&!n.parent},cn=function(n){d(A,h,(function(){var e=n.facade;M?Z.emit("rejectionHandled",e):rn("rejectionhandled",e,n.value)}))},dn=function(n,e,t){return function(a){n(e,a,t)}},un=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,on(n,!0))},fn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw X("Promise can't be resolved itself");var a=an(e);a?D((function(){var t={done:!1};try{d(a,e,dn(fn,t,n),dn(un,t,n))}catch(e){un(t,e,n)}})):(n.value=e,n.state=1,on(n,!1))}catch(e){un({done:!1},e,n)}}};if(en&&(H=($=function(n){w(this,H),b(n),d(a,this);var e=N(this);try{n(dn(fn,e),dn(un,e))}catch(n){un(e,n)}}).prototype,(a=function(n){W(this,{type:O,done:!1,notified:!1,parent:!1,reactions:new z,rejection:!1,state:0,value:void 0})}).prototype=m(H,{then:function(n,e){var t=U(this),a=V(S(this,$));return t.parent=!0,a.ok=!v(n)||n,a.fail=v(e)&&e,a.domain=M?Z.domain:void 0,0==t.state?t.reactions.add(a):D((function(){sn(a,t)})),a.promise},catch:function(n){return this.then(void 0,n)}}),i=function(){var n=new a,e=N(n);this.promise=n,this.resolve=dn(fn,e),this.reject=dn(un,e)},j.f=V=function(n){return n===$||n===s?new i(n):K(n)},!l&&v(u)&&G!==Object.prototype)){o=G.then,nn||(f(G,"then",(function(n,e){var t=this;return new $((function(n,e){d(o,t,n,e)})).then(n,e)}),{unsafe:!0}),f(G,"catch",H.catch,{unsafe:!0}));try{delete G.constructor}catch(n){}p&&p(G,H)}r({global:!0,wrap:!0,forced:en},{Promise:$}),y($,O,!1,!0),g(O),s=c(O),r({target:O,stat:!0,forced:en},{reject:function(n){var e=V(this);return d(e.reject,void 0,n),e.promise}}),r({target:O,stat:!0,forced:l||en},{resolve:function(n){return I(l&&this===s?$:this,n)}}),r({target:O,stat:!0,forced:tn},{all:function(n){var e=this,t=V(e),a=t.resolve,i=t.reject,s=C((function(){var t=b(e.resolve),s=[],o=0,r=1;T(n,(function(n){var l=o++,h=!1;r++,d(t,e,n).then((function(n){h||(h=!0,s[l]=n,--r||a(s))}),i)})),--r||a(s)}));return s.error&&i(s.value),t.promise},race:function(n){var e=this,t=V(e),a=t.reject,i=C((function(){var i=b(e.resolve);T(n,(function(n){d(i,e,n).then(t.resolve,a)}))}));return i.error&&a(i.value),t.promise}})},function(n,e,t){var a=t(0),i=t(53),s=t(11),o=t(7),r=t(82),l=t(161),h=t(21),c=t(33),d=t(139),u=t(102),f=t(162),m=a.TypeError,p=function(n,e){this.stopped=n,this.result=e},y=p.prototype;n.exports=function(n,e,t){var a,g,b,v,x,w,k,T=t&&t.that,q=!(!t||!t.AS_ENTRIES),S=!(!t||!t.IS_ITERATOR),A=!(!t||!t.INTERRUPTED),D=i(e,T),I=function(n){return a&&f(a,"normal",n),new p(!0,n)},E=function(n){return q?(o(n),A?D(n[0],n[1],I):D(n[0],n[1])):A?D(n,I):D(n)};if(S)a=n;else{if(!(g=u(n)))throw m(r(n)+" is not iterable");if(l(g)){for(b=0,v=h(n);v>b;b++)if((x=E(n[b]))&&c(y,x))return x;return new p(!1)}a=d(n,g)}for(w=a.next;!(k=s(w,a)).done;){try{x=E(k.value)}catch(n){f(a,"throw",n)}if("object"==typeof x&&x&&c(y,x))return x}return new p(!1)}},function(n,e,t){var a,i,s,o,r,l,h,c,d=t(0),u=t(53),f=t(39).f,m=t(165).set,p=t(166),y=t(241),g=t(242),b=t(87),v=d.MutationObserver||d.WebKitMutationObserver,x=d.document,w=d.process,k=d.Promise,T=f(d,"queueMicrotask"),q=T&&T.value;q||(a=function(){var n,e;for(b&&(n=w.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?o():s=void 0,n}}s=void 0,n&&n.enter()},p||b||g||!v||!x?!y&&k&&k.resolve?((h=k.resolve(void 0)).constructor=k,c=u(h.then,h),o=function(){c(a)}):b?o=function(){w.nextTick(a)}:(m=u(m,d),o=function(){m(a)}):(r=!0,l=x.createTextNode(""),new v(a).observe(l,{characterData:!0}),o=function(){l.data=r=!r})),n.exports=q||function(n){var e={fn:n,next:void 0};s&&(s.next=e),i||(i=e,o()),s=e}},function(n,e,t){var a=t(28),i=t(0);n.exports=/ipad|iphone|ipod/i.test(a)&&void 0!==i.Pebble},function(n,e,t){var a=t(28);n.exports=/web0s(?!.*chrome)/i.test(a)},function(n,e,t){var a=t(0);n.exports=function(n,e){var t=a.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window},function(n,e,t){var a=t(2),i=t(248);a({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var a=t(9),i=t(1),s=t(11),o=t(3),r=t(83),l=t(113),h=t(111),c=t(15),d=t(58),u=Object.assign,f=Object.defineProperty,m=i([].concat);n.exports=!u||o((function(){if(a&&1!==u({b:1},u(f({},"a",{enumerable:!0,get:function(){f(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=u({},n)[t]||"abcdefghijklmnopqrst"!=r(u({},e)).join("")}))?function(n,e){for(var t=c(n),i=arguments.length,o=1,u=l.f,f=h.f;i>o;)for(var p,y=d(arguments[o++]),g=u?m(r(y),u(y)):r(y),b=g.length,v=0;b>v;)p=g[v++],a&&!s(f,y,p)||(t[p]=y[p]);return t}:u},function(n,e,t){"use strict";var a=t(2),i=t(25),s=t(160),o=t(3),r=t(16),l=t(4),h=t(116),c=t(167),d=t(14);if(a({target:"Promise",proto:!0,real:!0,forced:!!s&&o((function(){s.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=h(this,r("Promise")),t=l(n);return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),!i&&l(s)){var u=r("Promise").prototype.finally;s.prototype.finally!==u&&d(s.prototype,"finally",u,{unsafe:!0})}},function(n,e,t){"use strict";var a=t(115),i=t(73);n.exports=a?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){var a=t(0),i=t(56),s=t(86),o=t(8),r=t(6)("species"),l=a.Array;n.exports=function(n){var e;return i(n)&&(e=n.constructor,(s(e)&&(e===l||i(e.prototype))||o(e)&&null===(e=e[r]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var a=t(2),i=t(253).left,s=t(44),o=t(49),r=t(87);a({target:"Array",proto:!0,forced:!s("reduce")||!r&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),i=t(35),s=t(15),o=t(58),r=t(21),l=a.TypeError,h=function(n){return function(e,t,a,h){i(t);var c=s(e),d=o(c),u=r(c),f=n?u-1:0,m=n?-1:1;if(a<2)for(;;){if(f in d){h=d[f],f+=m;break}if(f+=m,n?f<0:u<=f)throw l("Reduce of empty array with no initial value")}for(;n?f>=0:u>f;f+=m)f in d&&(h=t(h,d[f],f,c));return h}};n.exports={left:h(!1),right:h(!0)}},function(n,e,t){"use strict";var a,i=t(2),s=t(1),o=t(39).f,r=t(50),l=t(12),h=t(173),c=t(17),d=t(174),u=t(25),f=s("".startsWith),m=s("".slice),p=Math.min,y=d("startsWith");i({target:"String",proto:!0,forced:!!(u||y||(a=o(String.prototype,"startsWith"),!a||a.writable))&&!y},{startsWith:function(n){var e=l(c(this));h(n);var t=r(p(arguments.length>1?arguments[1]:void 0,e.length)),a=l(n);return f?f(e,a,t):m(e,t,t+a.length)===a}})},function(n,e,t){var a=t(2),i=t(176),s=t(3),o=t(8),r=t(256).onFreeze,l=Object.freeze;a({target:"Object",stat:!0,forced:s((function(){l(1)})),sham:!i},{freeze:function(n){return l&&o(n)?l(r(n)):n}})},function(n,e,t){var a=t(2),i=t(1),s=t(60),o=t(8),r=t(10),l=t(13).f,h=t(54),c=t(177),d=t(257),u=t(78),f=t(176),m=!1,p=u("meta"),y=0,g=function(n){l(n,p,{value:{objectID:"O"+y++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},m=!0;var n=h.f,e=i([].splice),t={};t[p]=1,n(t).length&&(h.f=function(t){for(var a=n(t),i=0,s=a.length;i<s;i++)if(a[i]===p){e(a,i,1);break}return a},a({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:c.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!r(n,p)){if(!d(n))return"F";if(!e)return"E";g(n)}return n[p].objectID},getWeakData:function(n,e){if(!r(n,p)){if(!d(n))return!0;if(!e)return!1;g(n)}return n[p].weakData},onFreeze:function(n){return f&&m&&d(n)&&!r(n,p)&&g(n),n}};s[p]=!0},function(n,e,t){var a=t(3),i=t(8),s=t(24),o=t(258),r=Object.isExtensible,l=a((function(){r(1)}));n.exports=l||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=s(n))&&(!r||r(n)))}:r},function(n,e,t){var a=t(3);n.exports=a((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){var a=t(0);n.exports=a},function(n,e,t){"use strict";var a=t(0),i=t(53),s=t(11),o=t(15),r=t(261),l=t(161),h=t(86),c=t(21),d=t(64),u=t(139),f=t(102),m=a.Array;n.exports=function(n){var e=o(n),t=h(this),a=arguments.length,p=a>1?arguments[1]:void 0,y=void 0!==p;y&&(p=i(p,a>2?arguments[2]:void 0));var g,b,v,x,w,k,T=f(e),q=0;if(!T||this==m&&l(T))for(g=c(e),b=t?new this(g):m(g);g>q;q++)k=y?p(e[q],q):e[q],d(b,q,k);else for(w=(x=u(e,T)).next,b=t?new this:[];!(v=s(w,x)).done;q++)k=y?r(x,p,[v.value,q],!0):v.value,d(b,q,k);return b.length=q,b}},function(n,e,t){var a=t(7),i=t(162);n.exports=function(n,e,t,s){try{return s?e(a(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";var a=t(16),i=t(10),s=t(26),o=t(33),r=t(62),l=t(112),h=t(145),c=t(180),d=t(263),u=t(264),f=t(265),m=t(25);n.exports=function(n,e,t,p){var y=p?2:1,g=n.split("."),b=g[g.length-1],v=a.apply(null,g);if(v){var x=v.prototype;if(!m&&i(x,"cause")&&delete x.cause,!t)return v;var w=a("Error"),k=e((function(n,e){var t=c(p?e:n,void 0),a=p?new v(n):new v;return void 0!==t&&s(a,"message",t),f&&s(a,"stack",u(a.stack,2)),this&&o(x,this)&&h(a,this,k),arguments.length>y&&d(a,arguments[y]),a}));if(k.prototype=x,"Error"!==b&&(r?r(k,w):l(k,w,{name:!0})),l(k,v),!m)try{x.name!==b&&s(x,"name",b),x.constructor=k}catch(n){}return k}}},function(n,e,t){var a=t(8),i=t(26);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var a=t(1)("".replace),i=String(Error("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,o=s.test(i);n.exports=function(n,e){if(o&&"string"==typeof n)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var a=t(3),i=t(46);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(9),i=t(3),s=t(7),o=t(32),r=t(180),l=Error.prototype.toString,h=i((function(){if(a){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=h?function(){var n=s(this),e=r(n.name,"Error"),t=r(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var a=t(1),i=t(15),s=Math.floor,o=a("".charAt),r=a("".replace),l=a("".slice),h=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,c=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,a,d,u){var f=t+n.length,m=a.length,p=c;return void 0!==d&&(d=i(d),p=h),r(u,p,(function(i,r){var h;switch(o(r,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,f);case"<":h=d[l(r,1,-1)];break;default:var c=+r;if(0===c)return i;if(c>m){var u=s(c/10);return 0===u?i:u<=m?void 0===a[u-1]?o(r,1):a[u-1]+o(r,1):i}h=a[c-1]}return void 0===h?"":h}))}},function(n,e,t){var a=t(2),i=t(0),s=t(16),o=t(34),r=t(1),l=t(3),h=i.Array,c=s("JSON","stringify"),d=r(/./.exec),u=r("".charAt),f=r("".charCodeAt),m=r("".replace),p=r(1..toString),y=/[\uD800-\uDFFF]/g,g=/^[\uD800-\uDBFF]$/,b=/^[\uDC00-\uDFFF]$/,v=function(n,e,t){var a=u(t,e-1),i=u(t,e+1);return d(g,n)&&!d(b,i)||d(b,n)&&!d(g,a)?"\\u"+p(f(n,0),16):n},x=l((function(){return'"\\udf06\\ud834"'!==c("\udf06\ud834")||'"\\udead"'!==c("\udead")}));c&&a({target:"JSON",stat:!0,forced:x},{stringify:function(n,e,t){for(var a=0,i=arguments.length,s=h(i);a<i;a++)s[a]=arguments[a];var r=o(c,null,s);return"string"==typeof r?m(r,y,v):r}})},function(n,e,t){var a=t(182),i=t(270);n.exports=function n(e,t,s,o,r){var l=-1,h=e.length;for(s||(s=i),r||(r=[]);++l<h;){var c=e[l];t>0&&s(c)?t>1?n(c,t-1,s,o,r):a(r,c):o||(r[r.length]=c)}return r}},function(n,e,t){var a=t(65),i=t(120),s=t(27),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return s(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(57),i=t(48);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(65),i=Object.prototype,s=i.hasOwnProperty,o=i.toString,r=a?a.toStringTag:void 0;n.exports=function(n){var e=s.call(n,r),t=n[r];try{n[r]=void 0;var a=!0}catch(n){}var i=o.call(n);return a&&(e?n[r]=t:delete n[r]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(275),i=t(331),s=t(128),o=t(27),r=t(342);n.exports=function(n){return"function"==typeof n?n:null==n?s:"object"==typeof n?o(n)?i(n[0],n[1]):a(n):r(n)}},function(n,e,t){var a=t(276),i=t(330),s=t(199);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?s(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(184),i=t(188);n.exports=function(n,e,t,s){var o=t.length,r=o,l=!s;if(null==n)return!r;for(n=Object(n);o--;){var h=t[o];if(l&&h[2]?h[1]!==n[h[0]]:!(h[0]in n))return!1}for(;++o<r;){var c=(h=t[o])[0],d=n[c],u=h[1];if(l&&h[2]){if(void 0===d&&!(c in n))return!1}else{var f=new a;if(s)var m=s(d,u,c,n,e,f);if(!(void 0===m?i(u,d,3,s,f):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(93),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(93);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(93);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(93);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(92);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(92),i=t(121),s=t(123);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new s(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(186),i=t(288),s=t(122),o=t(187),r=/^\[object .+?Constructor\]$/,l=Function.prototype,h=Object.prototype,c=l.toString,d=h.hasOwnProperty,u=RegExp("^"+c.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!s(n)||i(n))&&(a(n)?u:r).test(o(n))}},function(n,e,t){var a,i=t(289),s=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!s&&s in n}},function(n,e,t){var a=t(29)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(292),i=t(92),s=t(121);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(s||i),string:new a}}},function(n,e,t){var a=t(293),i=t(294),s=t(295),o=t(296),r=t(297);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=s,l.prototype.has=o,l.prototype.set=r,n.exports=l},function(n,e,t){var a=t(94);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(94),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(94),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(94);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(95);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(95);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(95);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(95);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(184),i=t(189),s=t(307),o=t(310),r=t(326),l=t(27),h=t(193),c=t(195),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,m,p){var y=l(n),g=l(e),b=y?"[object Array]":r(n),v=g?"[object Array]":r(e),x=(b="[object Arguments]"==b?d:b)==d,w=(v="[object Arguments]"==v?d:v)==d,k=b==v;if(k&&h(n)){if(!h(e))return!1;y=!0,x=!1}if(k&&!x)return p||(p=new a),y||c(n)?i(n,e,t,f,m,p):s(n,e,b,t,f,m,p);if(!(1&t)){var T=x&&u.call(n,"__wrapped__"),q=w&&u.call(e,"__wrapped__");if(T||q){var S=T?n.value():n,A=q?e.value():e;return p||(p=new a),m(S,A,t,f,p)}}return!!k&&(p||(p=new a),o(n,e,t,f,m,p))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(65),i=t(308),s=t(185),o=t(189),r=t(309),l=t(124),h=a?a.prototype:void 0,c=h?h.valueOf:void 0;n.exports=function(n,e,t,a,h,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return s(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=r;case"[object Set]":var m=1&a;if(f||(f=l),n.size!=e.size&&!m)return!1;var p=u.get(n);if(p)return p==e;a|=2,u.set(n,e);var y=o(f(n),f(e),a,h,d,u);return u.delete(n),y;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var a=t(29).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(311),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,s,o,r){var l=1&t,h=a(n),c=h.length;if(c!=a(e).length&&!l)return!1;for(var d=c;d--;){var u=h[d];if(!(l?u in e:i.call(e,u)))return!1}var f=r.get(n),m=r.get(e);if(f&&m)return f==e&&m==n;var p=!0;r.set(n,e),r.set(e,n);for(var y=l;++d<c;){var g=n[u=h[d]],b=e[u];if(s)var v=l?s(b,g,u,e,n,r):s(g,b,u,n,e,r);if(!(void 0===v?g===b||o(g,b,t,s,r):v)){p=!1;break}y||(y="constructor"==u)}if(p&&!y){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(p=!1)}return r.delete(n),r.delete(e),p}},function(n,e,t){var a=t(312),i=t(313),s=t(192);n.exports=function(n){return a(n,s,i)}},function(n,e,t){var a=t(182),i=t(27);n.exports=function(n,e,t){var s=e(n);return i(n)?s:a(s,t(n))}},function(n,e,t){var a=t(314),i=t(315),s=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,r=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return s.call(n,e)})))}:i;n.exports=r},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,s=[];++t<a;){var o=n[t];e(o,t,n)&&(s[i++]=o)}return s}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(317),i=t(120),s=t(27),o=t(193),r=t(194),l=t(195),h=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=s(n),c=!t&&i(n),d=!t&&!c&&o(n),u=!t&&!c&&!d&&l(n),f=t||c||d||u,m=f?a(n.length,String):[],p=m.length;for(var y in n)!e&&!h.call(n,y)||f&&("length"==y||d&&("offset"==y||"parent"==y)||u&&("buffer"==y||"byteLength"==y||"byteOffset"==y)||r(y,p))||m.push(y);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(57),i=t(125),s=t(48),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return s(n)&&i(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(183),i=e&&!e.nodeType&&e,s=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===i&&a.process,r=function(){try{var n=s&&s.require&&s.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=r}).call(this,t(147)(n))},function(n,e,t){var a=t(323),i=t(324),s=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))s.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(325)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(327),i=t(121),s=t(328),o=t(197),r=t(329),l=t(57),h=t(187),c=h(a),d=h(i),u=h(s),f=h(o),m=h(r),p=l;(a&&"[object DataView]"!=p(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=p(new i)||s&&"[object Promise]"!=p(s.resolve())||o&&"[object Set]"!=p(new o)||r&&"[object WeakMap]"!=p(new r))&&(p=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?h(t):"";if(a)switch(a){case c:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case f:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=p},function(n,e,t){var a=t(41)(t(29),"DataView");n.exports=a},function(n,e,t){var a=t(41)(t(29),"Promise");n.exports=a},function(n,e,t){var a=t(41)(t(29),"WeakMap");n.exports=a},function(n,e,t){var a=t(198),i=t(192);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var s=e[t],o=n[s];e[t]=[s,o,a(o)]}return e}},function(n,e,t){var a=t(188),i=t(332),s=t(339),o=t(126),r=t(198),l=t(199),h=t(96);n.exports=function(n,e){return o(n)&&r(e)?l(h(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?s(t,n):a(e,o,3)}}},function(n,e,t){var a=t(200);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(334),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,s=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(s,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(335);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(123);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],s=t.cache;if(s.has(i))return s.get(i);var o=n.apply(this,a);return t.cache=s.set(i,o)||s,o};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(337);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(65),i=t(338),s=t(27),o=t(127),r=a?a.prototype:void 0,l=r?r.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(s(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(340),i=t(341);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(201),i=t(120),s=t(27),o=t(194),r=t(125),l=t(96);n.exports=function(n,e,t){for(var h=-1,c=(e=a(e,n)).length,d=!1;++h<c;){var u=l(e[h]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++h!=c?d:!!(c=null==n?0:n.length)&&r(c)&&o(u,c)&&(s(n)||i(n))}},function(n,e,t){var a=t(343),i=t(344),s=t(126),o=t(96);n.exports=function(n){return s(n)?a(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(200);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(128),i=t(346),s=t(348);n.exports=function(n,e){return s(i(n,e,a),n+"")}},function(n,e,t){var a=t(347),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var s=arguments,o=-1,r=i(s.length-e,0),l=Array(r);++o<r;)l[o]=s[e+o];o=-1;for(var h=Array(e+1);++o<e;)h[o]=s[o];return h[e]=t(l),a(n,this,h)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(349),i=t(352)(a);n.exports=i},function(n,e,t){var a=t(350),i=t(351),s=t(128),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:s;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(41),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),s=16-(i-a);if(a=i,s>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(190),i=t(354),s=t(359),o=t(191),r=t(360),l=t(124);n.exports=function(n,e,t){var h=-1,c=i,d=n.length,u=!0,f=[],m=f;if(t)u=!1,c=s;else if(d>=200){var p=e?null:r(n);if(p)return l(p);u=!1,c=o,m=new a}else m=e?[]:f;n:for(;++h<d;){var y=n[h],g=e?e(y):y;if(y=t||0!==y?y:0,u&&g==g){for(var b=m.length;b--;)if(m[b]===g)continue n;e&&m.push(g),f.push(y)}else c(m,g,t)||(m!==f&&m.push(g),f.push(y))}return f}},function(n,e,t){var a=t(355);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(356),i=t(357),s=t(358);n.exports=function(n,e,t){return e==e?s(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,s=t+(a?1:-1);a?s--:++s<i;)if(e(n[s],s,n))return s;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(197),i=t(361),s=t(124),o=a&&1/s(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(196),i=t(48);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(1);n.exports=a(1..valueOf)},function(n,e){var t,a,i,s,o,r,l,h=!1,c=[];"undefined"!=typeof document&&(s=function(n){return h||"interactive"===document.readyState||"complete"===document.readyState?n.call(document):c.push((function(){return n.call(this)})),this},r=function(){for(var n=0,e=c.length;n<e;n++)c[n].apply(document);c=[]},l=function(){h||(h=!0,r.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",l),window==window.top&&(clearInterval(o),o=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",l,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",(function(){/loaded|complete/.test(document.readyState)&&l()})),window==window.top&&(o=setInterval((function(){try{h||document.documentElement.doScroll("left")}catch(n){return}l()}),5)))),t={fetch:function(n,e){var t="BusuanziCallback_"+Math.floor(1099511627776*Math.random());n=n.replace("=BusuanziCallback","="+t),(i=document.createElement("SCRIPT")).type="text/javascript",i.defer=!0,i.src=n,document.getElementsByTagName("HEAD")[0].appendChild(i),window[t]=this.evalCall(e)},evalCall:function(n){return function(e){s((function(){try{n(e),i&&i.parentElement&&i.parentElement.removeChild&&i.parentElement.removeChild(i)}catch(n){console.log(n),a.hides()}}))}}};const d=()=>{a&&a.hides(),t.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",(function(n){a.texts(n),a.shows()}))};a={bszs:["site_pv","page_pv","site_uv"],texts:function(n){this.bszs.map((function(e){var t=document.getElementById("busuanzi_value_"+e);t&&(t.innerHTML=n[e])}))},hides:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="none")}))},shows:function(){this.bszs.map((function(n){var e=document.getElementById("busuanzi_container_"+n);e&&(e.style.display="inline")}))}},"undefined"!=typeof document&&d(),n.exports={fetch:d}},function(n,e,t){var a=t(1),i=t(50),s=t(12),o=t(368),r=t(17),l=a(o),h=a("".slice),c=Math.ceil,d=function(n){return function(e,t,a){var o,d,u=s(r(e)),f=i(t),m=u.length,p=void 0===a?" ":s(a);return f<=m||""==p?u:((d=l(p,c((o=f-m)/p.length))).length>o&&(d=h(d,0,o)),n?u+d:d+u)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var a=t(0),i=t(52),s=t(12),o=t(17),r=a.RangeError;n.exports=function(n){var e=s(o(this)),t="",a=i(n);if(a<0||a==1/0)throw r("Wrong number of repetitions");for(;a>0;(a>>>=1)&&(e+=e))1&a&&(t+=e);return t}},function(n,e,t){var a=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(a)},function(n,e,t){"use strict";t(202)},function(n,e,t){"use strict";t(203)},function(n,e,t){var a=t(28).match(/firefox\/(\d+)/i);n.exports=!!a&&+a[1]},function(n,e,t){var a=t(28);n.exports=/MSIE|Trident/.test(a)},function(n,e,t){var a=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!a&&+a[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(204)},function(n,e,t){"use strict";var a=t(0),i=t(1),s=t(35),o=t(8),r=t(10),l=t(63),h=t(59),c=a.Function,d=i([].concat),u=i([].join),f={},m=function(n,e,t){if(!r(f,e)){for(var a=[],i=0;i<e;i++)a[i]="a["+i+"]";f[e]=c("C,a","return new C("+u(a,",")+")")}return f[e](n,t)};n.exports=h?c.bind:function(n){var e=s(this),t=e.prototype,a=l(arguments,1),i=function(){var t=d(a,l(arguments));return this instanceof i?m(e,t.length,t):e.apply(n,t)};return o(t)&&(i.prototype=t),i}},function(n,e,t){"use strict";t(208)},function(n,e,t){"use strict";t(209)},function(n,e,t){"use strict";t.r(e);t(137),t(238),t(247),t(249);var a=t(88),i=(t(135),t(68),t(5),t(22),t(31),t(43),t(30),Object.freeze({}));function s(n){return null==n}function o(n){return null!=n}function r(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function h(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function d(n){return"[object Object]"===c.call(n)}function u(n){return"[object RegExp]"===c.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function p(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var b=g("key,ref,slot,slot-scope,is");function v(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,q=k((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),S=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,D=k((function(n){return n.replace(A,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function E(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function j(n,e){for(var t in e)n[t]=e[t];return n}function C(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function z(n,e,t){}var L=function(n,e,t){return!1},F=function(n){return n};function _(n,e){if(n===e)return!0;var t=h(n),a=h(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),s=Array.isArray(e);if(i&&s)return n.length===e.length&&n.every((function(n,t){return _(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||s)return!1;var o=Object.keys(n),r=Object.keys(e);return o.length===r.length&&o.every((function(t){return _(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(_(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],B=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],O={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:z,parsePlatformTagName:F,mustUseProp:L,async:!0,_lifecycleHooks:B},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var U=new RegExp("[^"+N.source+".$_\\d]");var G,$="__proto__"in{},H="undefined"!=typeof window,X="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Y=X&&WXEnvironment.platform.toLowerCase(),Z=H&&window.navigator.userAgent.toLowerCase(),V=Z&&/msie|trident/.test(Z),K=Z&&Z.indexOf("msie 9.0")>0,J=Z&&Z.indexOf("edge/")>0,Q=(Z&&Z.indexOf("android"),Z&&/iphone|ipad|ipod|ios/.test(Z)||"ios"===Y),nn=(Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z),Z&&Z.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(H)try{var an={};Object.defineProperty(an,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===G&&(G=!H&&!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),G},on=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function rn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,hn="undefined"!=typeof Symbol&&rn(Symbol)&&"undefined"!=typeof Reflect&&rn(Reflect.ownKeys);ln="undefined"!=typeof Set&&rn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=z,dn=0,un=function(){this.id=dn++,this.subs=[]};un.prototype.addSub=function(n){this.subs.push(n)},un.prototype.removeSub=function(n){v(this.subs,n)},un.prototype.depend=function(){un.target&&un.target.addDep(this)},un.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},un.target=null;var fn=[];function mn(n){fn.push(n),un.target=n}function pn(){fn.pop(),un.target=fn[fn.length-1]}var yn=function(n,e,t,a,i,s,o,r){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=r,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(yn.prototype,gn);var bn=function(n){void 0===n&&(n="");var e=new yn;return e.text=n,e.isComment=!0,e};function vn(n){return new yn(void 0,void 0,void 0,String(n))}function xn(n){var e=new yn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];W(kn,n,(function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];var i,s=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),s}))}));var Tn=Object.getOwnPropertyNames(kn),qn=!0;function Sn(n){qn=n}var An=function(n){this.value=n,this.dep=new un,this.vmCount=0,W(n,"__ob__",this),Array.isArray(n)?($?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var a=0,i=t.length;a<i;a++){var s=t[a];W(n,s,e[s])}}(n,kn,Tn),this.observeArray(n)):this.walk(n)};function Dn(n,e){var t;if(h(n)&&!(n instanceof yn))return w(n,"__ob__")&&n.__ob__ instanceof An?t=n.__ob__:qn&&!sn()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new An(n)),e&&t&&t.vmCount++,t}function In(n,e,t,a,i){var s=new un,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var r=o&&o.get,l=o&&o.set;r&&!l||2!==arguments.length||(t=n[e]);var h=!i&&Dn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=r?r.call(n):t;return un.target&&(s.depend(),h&&(h.dep.depend(),Array.isArray(e)&&Cn(e))),e},set:function(e){var a=r?r.call(n):t;e===a||e!=e&&a!=a||r&&!l||(l?l.call(n,e):t=e,h=!i&&Dn(e),s.notify())}})}}function En(n,e,t){if(Array.isArray(n)&&f(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var a=n.__ob__;return n._isVue||a&&a.vmCount?t:a?(In(a.value,e,t),a.dep.notify(),t):(n[e]=t,t)}function jn(n,e){if(Array.isArray(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Cn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Cn(e)}An.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)In(n,e[t])},An.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Dn(n[e])};var zn=O.optionMergeStrategies;function Ln(n,e){if(!e)return n;for(var t,a,i,s=hn?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(t=s[o])&&(a=n[t],i=e[t],w(n,t)?a!==i&&d(a)&&d(i)&&Ln(a,i):En(n,t,i));return n}function Fn(n,e,t){return t?function(){var a="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return a?Ln(a,i):i}:e?n?function(){return Ln("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function _n(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pn(n,e,t,a){var i=Object.create(n||null);return e?j(i,e):i}zn.data=function(n,e,t){return t?Fn(n,e,t):e&&"function"!=typeof e?n:Fn(n,e)},B.forEach((function(n){zn[n]=_n})),R.forEach((function(n){zn[n+"s"]=Pn})),zn.watch=function(n,e,t,a){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var s in j(i,n),e){var o=i[s],r=e[s];o&&!Array.isArray(o)&&(o=[o]),i[s]=o?o.concat(r):Array.isArray(r)?r:[r]}return i},zn.props=zn.methods=zn.inject=zn.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return j(i,n),e&&j(i,e),i},zn.provide=Fn;var Mn=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,s={};if(Array.isArray(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(s[q(i)]={type:null});else if(d(t))for(var o in t)i=t[o],s[q(o)]=d(i)?i:{type:i};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(d(t))for(var s in t){var o=t[s];a[s]=d(o)?j({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];"function"==typeof a&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Rn(n,e.mixins[a],t);var s,o={};for(s in n)r(s);for(s in e)w(n,s)||r(s);function r(a){var i=zn[a]||Mn;o[a]=i(n[a],e[a],t,a)}return o}function Bn(n,e,t,a){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var s=q(t);if(w(i,s))return i[s];var o=S(s);return w(i,o)?i[o]:i[t]||i[s]||i[o]}}function On(n,e,t,a){var i=e[n],s=!w(t,n),o=t[n],r=Gn(Boolean,i.type);if(r>-1)if(s&&!w(i,"default"))o=!1;else if(""===o||o===D(n)){var l=Gn(String,i.type);(l<0||r<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof a&&"Function"!==Wn(e.type)?a.call(n):a}(a,i,n);var h=qn;Sn(!0),Dn(o),Sn(h)}return o}var Nn=/^\s*function (\w+)/;function Wn(n){var e=n&&n.toString().match(Nn);return e?e[1]:""}function Un(n,e){return Wn(n)===Wn(e)}function Gn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Un(e[t],n))return t;return-1}function $n(n,e,t){mn();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,n,e,t))return}catch(n){Xn(n,a,"errorCaptured hook")}}Xn(n,e,t)}finally{pn()}}function Hn(n,e,t,a,i){var s;try{(s=t?n.apply(e,t):n.call(e))&&!s._isVue&&m(s)&&!s._handled&&(s.catch((function(n){return $n(n,a,i+" (Promise/async)")})),s._handled=!0)}catch(n){$n(n,a,i)}return s}function Xn(n,e,t){if(O.errorHandler)try{return O.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Yn(e,null,"config.errorHandler")}Yn(n,e,t)}function Yn(n,e,t){if(!H&&!X||"undefined"==typeof console)throw n;console.error(n)}var Zn,Vn=!1,Kn=[],Jn=!1;function Qn(){Jn=!1;var n=Kn.slice(0);Kn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&rn(Promise)){var ne=Promise.resolve();Zn=function(){ne.then(Qn),Q&&setTimeout(z)},Vn=!0}else if(V||"undefined"==typeof MutationObserver||!rn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Zn="undefined"!=typeof setImmediate&&rn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),ae=document.createTextNode(String(ee));te.observe(ae,{characterData:!0}),Zn=function(){ee=(ee+1)%2,ae.data=String(ee)},Vn=!0}function ie(n,e){var t;if(Kn.push((function(){if(n)try{n.call(e)}catch(n){$n(n,e,"nextTick")}else t&&t(e)})),Jn||(Jn=!0,Zn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var se=new ln;function oe(n){!function n(e,t){var a,i,s=Array.isArray(e);if(!s&&!h(e)||Object.isFrozen(e)||e instanceof yn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(a=e.length;a--;)n(e[a],t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,se),se.clear()}var re=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function le(n,e){function t(){var n=arguments,a=t.fns;if(!Array.isArray(a))return Hn(a,null,arguments,e,"v-on handler");for(var i=a.slice(),s=0;s<i.length;s++)Hn(i[s],null,n,e,"v-on handler")}return t.fns=n,t}function he(n,e,t,a,i,o){var l,h,c,d;for(l in n)h=n[l],c=e[l],d=re(l),s(h)||(s(c)?(s(h.fns)&&(h=n[l]=le(h,o)),r(d.once)&&(h=n[l]=i(d.name,h,d.capture)),t(d.name,h,d.capture,d.passive,d.params)):h!==c&&(c.fns=h,n[l]=c));for(l in e)s(n[l])&&a((d=re(l)).name,e[l],d.capture)}function ce(n,e,t){var a;n instanceof yn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),v(a.fns,l)}s(i)?a=le([l]):o(i.fns)&&r(i.merged)?(a=i).fns.push(l):a=le([i,l]),a.merged=!0,n[e]=a}function de(n,e,t,a,i){if(o(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function ue(n){return l(n)?[vn(n)]:Array.isArray(n)?function n(e,t){var a,i,h,c,d=[];for(a=0;a<e.length;a++)s(i=e[a])||"boolean"==typeof i||(h=d.length-1,c=d[h],Array.isArray(i)?i.length>0&&(fe((i=n(i,(t||"")+"_"+a))[0])&&fe(c)&&(d[h]=vn(c.text+i[0].text),i.shift()),d.push.apply(d,i)):l(i)?fe(c)?d[h]=vn(c.text+i):""!==i&&d.push(vn(i)):fe(i)&&fe(c)?d[h]=vn(c.text+i.text):(r(e._isVList)&&o(i.tag)&&s(i.key)&&o(t)&&(i.key="__vlist"+t+"_"+a+"__"),d.push(i)));return d}(n):void 0}function fe(n){return o(n)&&o(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),a=hn?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){for(var o=n[s].from,r=e;r;){if(r._provided&&w(r._provided,o)){t[s]=r._provided[o];break}r=r.$parent}if(!r)if("default"in n[s]){var l=n[s].default;t[s]="function"==typeof l?l.call(e):l}else 0}}return t}}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var s=n[a],o=s.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,s.context!==e&&s.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(s);else{var r=o.slot,l=t[r]||(t[r]=[]);"template"===s.tag?l.push.apply(l,s.children||[]):l.push(s)}}for(var h in t)t[h].every(ye)&&delete t[h];return t}function ye(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var a,s=Object.keys(e).length>0,o=n?!!n.$stable:!s,r=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&r===t.$key&&!s&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=ve(e,l,n[l]))}else a={};for(var h in e)h in a||(a[h]=xe(e,h));return n&&Object.isExtensible(n)&&(n._normalized=a),W(a,"$stable",o),W(a,"$key",r),W(a,"$hasNormal",s),a}function ve(n,e,t){var a=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ge(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:a,enumerable:!0,configurable:!0}),a}function xe(n,e){return function(){return n[e]}}function we(n,e){var t,a,i,s,r;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),a=0,i=n.length;a<i;a++)t[a]=e(n[a],a);else if("number"==typeof n)for(t=new Array(n),a=0;a<n;a++)t[a]=e(a+1,a);else if(h(n))if(hn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),c=l.next();!c.done;)t.push(e(c.value,t.length)),c=l.next()}else for(s=Object.keys(n),t=new Array(s.length),a=0,i=s.length;a<i;a++)r=s[a],t[a]=e(n[r],r,a);return o(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,a){var i,s=this.$scopedSlots[n];s?(t=t||{},a&&(t=j(j({},a),t)),i=s(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Te(n){return Bn(this.$options,"filters",n)||F}function qe(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,a,i){var s=O.keyCodes[e]||t;return i&&a&&!O.keyCodes[e]?qe(i,a):s?qe(s,n):a?D(a)!==e:void 0===n}function Ae(n,e,t,a,i){if(t)if(h(t)){var s;Array.isArray(t)&&(t=C(t));var o=function(o){if("class"===o||"style"===o||b(o))s=n;else{var r=n.attrs&&n.attrs.type;s=a||O.mustUseProp(e,r,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=q(o),h=D(o);l in s||h in s||(s[o]=t[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var r in t)o(r)}else;return n}function De(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||Ee(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),a}function Ie(n,e,t){return Ee(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ee(n,e,t){if(Array.isArray(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&je(n[a],e+"_"+a,t);else je(n,e,t)}function je(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(d(e)){var t=n.on=n.on?j({},n.on):{};for(var a in e){var i=t[a],s=e[a];t[a]=i?[].concat(i,s):s}}else;return n}function ze(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var s=n[i];Array.isArray(s)?ze(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function Le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function Fe(n,e){return"string"==typeof n?e+n:n}function _e(n){n._o=Ie,n._n=y,n._s=p,n._l=we,n._t=ke,n._q=_,n._i=P,n._m=De,n._f=Te,n._k=Se,n._b=Ae,n._v=vn,n._e=bn,n._u=ze,n._g=Ce,n._d=Le,n._p=Fe}function Pe(n,e,t,a,s){var o,l=this,h=s.options;w(a,"_uid")?(o=Object.create(a))._original=a:(o=a,a=a._original);var c=r(h._compiled),d=!c;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||i,this.injections=me(h.inject,a),this.slots=function(){return l.$slots||be(n.scopedSlots,l.$slots=pe(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),c&&(this.$options=h,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),h._scopeId?this._c=function(n,e,t,i){var s=Ue(o,n,e,t,i,d);return s&&!Array.isArray(s)&&(s.fnScopeId=h._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,a){return Ue(o,n,e,t,a,d)}}function Me(n,e,t,a,i){var s=xn(n);return s.fnContext=t,s.fnOptions=a,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function Re(n,e){for(var t in e)n[q(t)]=e[t]}_e(Pe.prototype);var Be={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Be.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Je)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,s){0;var o=a.data.scopedSlots,r=n.$scopedSlots,l=!!(o&&!o.$stable||r!==i&&!r.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),h=!!(s||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=s,n.$attrs=a.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){Sn(!1);for(var c=n._props,d=n.$options._propKeys||[],u=0;u<d.length;u++){var f=d[u],m=n.$options.props;c[f]=On(f,m,e,n)}Sn(!0),n.$options.propsData=e}t=t||i;var p=n.$options._parentListeners;n.$options._parentListeners=t,Ke(n,t,p),h&&(n.$slots=pe(s,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,tt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,it.push(e)):et(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Oe=Object.keys(Be);function Ne(n,e,t,a,l){if(!s(n)){var c=t.$options._base;if(h(n)&&(n=c.extend(n)),"function"==typeof n){var d;if(s(n.cid)&&void 0===(n=function(n,e){if(r(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=$e;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(r(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return v(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=M((function(t){n.resolved=He(t,e),i?a.length=0:d(!0)})),f=M((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),p=n(u,f);return h(p)&&(m(p)?s(n.resolved)&&p.then(u,f):m(p.component)&&(p.component.then(u,f),o(p.error)&&(n.errorComp=He(p.error,e)),o(p.loading)&&(n.loadingComp=He(p.loading,e),0===p.delay?n.loading=!0:l=setTimeout((function(){l=null,s(n.resolved)&&s(n.error)&&(n.loading=!0,d(!1))}),p.delay||200)),o(p.timeout)&&(c=setTimeout((function(){c=null,s(n.resolved)&&f(null)}),p.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,c)))return function(n,e,t,a,i){var s=bn();return s.asyncFactory=n,s.asyncMeta={data:e,context:t,children:a,tag:i},s}(d,e,t,a,l);e=e||{},qt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],r=e.model.callback;o(s)?(Array.isArray(s)?-1===s.indexOf(r):s!==r)&&(i[a]=[r].concat(s)):i[a]=r}(n.options,e);var u=function(n,e,t){var a=e.options.props;if(!s(a)){var i={},r=n.attrs,l=n.props;if(o(r)||o(l))for(var h in a){var c=D(h);de(i,l,h,c,!0)||de(i,r,h,c,!1)}return i}}(e,n);if(r(n.options.functional))return function(n,e,t,a,s){var r=n.options,l={},h=r.props;if(o(h))for(var c in h)l[c]=On(c,h,e||i);else o(t.attrs)&&Re(l,t.attrs),o(t.props)&&Re(l,t.props);var d=new Pe(t,l,s,a,n),u=r.render.call(null,d._c,d);if(u instanceof yn)return Me(u,t,d.parent,r,d);if(Array.isArray(u)){for(var f=ue(u)||[],m=new Array(f.length),p=0;p<f.length;p++)m[p]=Me(f[p],t,d.parent,r,d);return m}}(n,u,e,t,a);var f=e.on;if(e.on=e.nativeOn,r(n.options.abstract)){var p=e.slot;e={},p&&(e.slot=p)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Oe.length;t++){var a=Oe[t],i=e[a],s=Be[a];i===s||i&&i._merged||(e[a]=i?We(s,i):s)}}(e);var y=n.options.name||l;return new yn("vue-component-"+n.cid+(y?"-"+y:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:f,tag:l,children:a},d)}}}function We(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}function Ue(n,e,t,a,i,c){return(Array.isArray(t)||l(t))&&(i=a,a=t,t=void 0),r(c)&&(i=2),function(n,e,t,a,i){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(a)&&"function"==typeof a[0]&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===i?a=ue(a):1===i&&(a=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var l,c;if("string"==typeof e){var d;c=n.$vnode&&n.$vnode.ns||O.getTagNamespace(e),l=O.isReservedTag(e)?new yn(O.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(d=Bn(n.$options,"components",e))?new yn(e,t,a,void 0,void 0,n):Ne(d,t,n,a,e)}else l=Ne(e,t,n,a);return Array.isArray(l)?l:o(l)?(o(c)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var h=e.children[i];o(h.tag)&&(s(h.ns)||r(a)&&"svg"!==h.tag)&&n(h,t,a)}}(l,c),o(t)&&function(n){h(n.style)&&oe(n.style);h(n.class)&&oe(n.class)}(t),l):bn()}(n,e,t,a,i)}var Ge,$e=null;function He(n,e){return(n.__esModule||hn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),h(n)?e.extend(n):n}function Xe(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ge(t)))return t}}function Ye(n,e){Ge.$on(n,e)}function Ze(n,e){Ge.$off(n,e)}function Ve(n,e){var t=Ge;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Ke(n,e,t){Ge=n,he(e,t||{},Ye,Ze,Ve,n),Ge=void 0}var Je=null;function Qe(n){var e=Je;return Je=n,function(){Je=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){mn();var t=n.$options[e],a=e+" hook";if(t)for(var i=0,s=t.length;i<s;i++)Hn(t[i],n,null,n,a);n._hasHookEvent&&n.$emit("hook:"+e),pn()}var at=[],it=[],st={},ot=!1,rt=!1,lt=0;var ht=0,ct=Date.now;if(H&&!V){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}function ut(){var n,e;for(ht=ct(),rt=!0,at.sort((function(n,e){return n.id-e.id})),lt=0;lt<at.length;lt++)(n=at[lt]).before&&n.before(),e=n.id,st[e]=null,n.run();var t=it.slice(),a=at.slice();lt=at.length=it.length=0,st={},ot=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a._watcher===t&&a._isMounted&&!a._isDestroyed&&tt(a,"updated")}}(a),on&&O.devtools&&on.emit("flush")}var ft=0,mt=function(n,e,t,a,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ft,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$n(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),pn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==st[e]){if(st[e]=!0,rt){for(var t=at.length-1;t>lt&&at[t].id>n.id;)t--;at.splice(t+1,0,n)}else at.push(n);ot||(ot=!0,ie(ut))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||h(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Hn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var pt={enumerable:!0,configurable:!0,get:z,set:z};function yt(n,e,t){pt.get=function(){return this[e][t]},pt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,pt)}function gt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props={},i=n.$options._propKeys=[];n.$parent&&Sn(!1);var s=function(s){i.push(s);var o=On(s,e,t,n);In(a,s,o),s in n||yt(n,"_props",s)};for(var o in e)s(o);Sn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:I(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return $n(n,e,"data()"),{}}finally{pn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var s=t[i];0,a&&w(a,s)||(o=void 0,36!==(o=(s+"").charCodeAt(0))&&95!==o&&yt(n,"_data",s))}var o;Dn(e,!0)}(n):Dn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var i in e){var s=e[i],o="function"==typeof s?s:s.get;0,a||(t[i]=new mt(n,o||z,z,bt)),i in n||vt(n,i,s)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var a=e[t];if(Array.isArray(a))for(var i=0;i<a.length;i++)kt(n,t,a[i]);else kt(n,t,a)}}(n,e.watch)}var bt={lazy:!0};function vt(n,e,t){var a=!sn();"function"==typeof t?(pt.get=a?xt(e):wt(t),pt.set=z):(pt.get=t.get?a&&!1!==t.cache?xt(e):wt(t.get):z,pt.set=t.set||z),Object.defineProperty(n,e,pt)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),un.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Tt=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&j(n.extendOptions,a),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function St(n){this._init(n)}function At(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var s=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)yt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)vt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),s&&(o.options.components[s]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=j({},o.options),i[a]=o,o}}function Dt(n){return n&&(n.Ctor.options.name||n.tag)}function It(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Et(n,e){var t=n.cache,a=n.keys,i=n._vnode;for(var s in t){var o=t[s];if(o){var r=o.name;r&&!e(r)&&jt(t,s,a,i)}}}function jt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,v(t,e)}St.prototype._init=function(n){var e=this;e._uid=Tt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=pe(e._renderChildren,a),n.$scopedSlots=i,n._c=function(e,t,a,i){return Ue(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return Ue(n,e,t,a,i,!0)};var s=t&&t.data;In(n,"$attrs",s&&s.attrs||i,null,!0),In(n,"$listeners",e._parentListeners||i,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){In(n,t,e[t])})),Sn(!0))}(e),gt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=En,n.prototype.$delete=jn,n.prototype.$watch=function(n,e,t){if(d(e))return kt(this,n,e,t);(t=t||{}).user=!0;var a=new mt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+a.expression+'"';mn(),Hn(e,this,[a.value],this,i),pn()}return function(){a.teardown()}}}(St),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var r=o.length;r--;)if((s=o[r])===e||s.fn===e){o.splice(r,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?E(t):t;for(var a=E(arguments,1),i='event handler for "'+n+'"',s=0,o=t.length;s<o;s++)Hn(t[s],e,a,e,i)}return e}}(St),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,s=Qe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),s(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||v(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(St),function(n){_e(n.prototype),n.prototype.$nextTick=function(n){return ie(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&(e.$scopedSlots=be(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{$e=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){$n(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof yn||(n=bn()),n.parent=i,n}}(St);var Ct=[String,RegExp,Array],zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,s=t.componentInstance,o=t.componentOptions;n[a]={name:Dt(o),tag:i,componentInstance:s},e.push(a),this.max&&e.length>parseInt(this.max)&&jt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)jt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Et(n,(function(n){return It(e,n)}))})),this.$watch("exclude",(function(e){Et(n,(function(n){return!It(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Xe(n),t=e&&e.componentOptions;if(t){var a=Dt(t),i=this.include,s=this.exclude;if(i&&(!a||!It(i,a))||s&&a&&It(s,a))return e;var o=this.cache,r=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,v(r,l),r.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return O}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:j,mergeOptions:Rn,defineReactive:In},n.set=En,n.delete=jn,n.nextTick=ie,n.observable=function(n){return Dn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=E(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),At(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(St),Object.defineProperty(St.prototype,"$isServer",{get:sn}),Object.defineProperty(St.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(St,"FunctionalRenderContext",{value:Pe}),St.version="2.6.14";var Lt=g("style,class"),Ft=g("input,textarea,option,select,progress"),_t=g("contenteditable,draggable,spellcheck"),Pt=g("events,caret,typing,plaintext-only"),Mt=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Bt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ot=function(n){return Bt(n)?n.slice(6,n.length):""},Nt=function(n){return null==n||!1===n};function Wt(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=Ut(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(o(n)||o(e))return Gt(n,$t(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:Gt(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Gt(n,e){return n?e?n+" "+e:n:e||""}function $t(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)o(e=$t(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):h(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Xt=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Yt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Zt=function(n){return Xt(n)||Yt(n)};var Vt=Object.create(null);var Kt=g("text,number,password,search,email,tel,url");var Jt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){na(e)},update:function(n,e){n.data.ref!==e.data.ref&&(na(n,!0),na(e))},destroy:function(n){na(n,!0)}};function na(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=a.$refs;e?Array.isArray(s[t])?v(s[t],i):s[t]===i&&(s[t]=void 0):n.data.refInFor?Array.isArray(s[t])?s[t].indexOf(i)<0&&s[t].push(i):s[t]=[i]:s[t]=i}}var ea=new yn("",{},[]),ta=["create","activate","update","remove","destroy"];function aa(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===i||Kt(a)&&Kt(i)}(n,e)||r(n.isAsyncPlaceholder)&&s(e.asyncFactory.error))}function ia(n,e,t){var a,i,s={};for(a=e;a<=t;++a)o(i=n[a].key)&&(s[i]=a);return s}var sa={create:oa,update:oa,destroy:function(n){oa(n,ea)}};function oa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,s=n===ea,o=e===ea,r=la(n.data.directives,n.context),l=la(e.data.directives,e.context),h=[],c=[];for(t in l)a=r[t],i=l[t],a?(i.oldValue=a.value,i.oldArg=a.arg,ca(i,"update",e,n),i.def&&i.def.componentUpdated&&c.push(i)):(ca(i,"bind",e,n),i.def&&i.def.inserted&&h.push(i));if(h.length){var d=function(){for(var t=0;t<h.length;t++)ca(h[t],"inserted",e,n)};s?ce(e,"insert",d):d()}c.length&&ce(e,"postpatch",(function(){for(var t=0;t<c.length;t++)ca(c[t],"componentUpdated",e,n)}));if(!s)for(t in r)l[t]||ca(r[t],"unbind",n,n,o)}(n,e)}var ra=Object.create(null);function la(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(a=n[t]).modifiers||(a.modifiers=ra),i[ha(a)]=a,a.def=Bn(e.$options,"directives",a.name);return i}function ha(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ca(n,e,t,a,i){var s=n.def&&n.def[e];if(s)try{s(t.elm,n,t,a,i)}catch(a){$n(a,t.context,"directive "+n.name+" "+e+" hook")}}var da=[Qt,sa];function ua(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||s(n.data.attrs)&&s(e.data.attrs))){var a,i,r=e.elm,l=n.data.attrs||{},h=e.data.attrs||{};for(a in o(h.__ob__)&&(h=e.data.attrs=j({},h)),h)i=h[a],l[a]!==i&&fa(r,a,i,e.data.pre);for(a in(V||J)&&h.value!==l.value&&fa(r,"value",h.value),l)s(h[a])&&(Bt(a)?r.removeAttributeNS(Rt,Ot(a)):_t(a)||r.removeAttribute(a))}}function fa(n,e,t,a){a||n.tagName.indexOf("-")>-1?ma(n,e,t):Mt(e)?Nt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):_t(e)?n.setAttribute(e,function(n,e){return Nt(e)||"false"===e?"false":"contenteditable"===n&&Pt(e)?e:"true"}(e,t)):Bt(e)?Nt(t)?n.removeAttributeNS(Rt,Ot(e)):n.setAttributeNS(Rt,e,t):ma(n,e,t)}function ma(n,e,t){if(Nt(t))n.removeAttribute(e);else{if(V&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var pa={create:ua,update:ua};function ya(n,e){var t=e.elm,a=e.data,i=n.data;if(!(s(a.staticClass)&&s(a.class)&&(s(i)||s(i.staticClass)&&s(i.class)))){var r=Wt(e),l=t._transitionClasses;o(l)&&(r=Gt(r,$t(l))),r!==t._prevClass&&(t.setAttribute("class",r),t._prevClass=r)}}var ga,ba={create:ya,update:ya};function va(n,e,t){var a=ga;return function i(){var s=e.apply(null,arguments);null!==s&&ka(n,i,t,a)}}var xa=Vn&&!(nn&&Number(nn[1])<=53);function wa(n,e,t,a){if(xa){var i=ht,s=e;e=s._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return s.apply(this,arguments)}}ga.addEventListener(n,e,tn?{capture:t,passive:a}:t)}function ka(n,e,t,a){(a||ga).removeEventListener(n,e._wrapper||e,t)}function Ta(n,e){if(!s(n.data.on)||!s(e.data.on)){var t=e.data.on||{},a=n.data.on||{};ga=e.elm,function(n){if(o(n.__r)){var e=V?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),he(t,a,wa,ka,va,e.context),ga=void 0}}var qa,Sa={create:Ta,update:Ta};function Aa(n,e){if(!s(n.data.domProps)||!s(e.data.domProps)){var t,a,i=e.elm,r=n.data.domProps||{},l=e.data.domProps||{};for(t in o(l.__ob__)&&(l=e.data.domProps=j({},l)),r)t in l||(i[t]="");for(t in l){if(a=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===r[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var h=s(a)?"":String(a);Da(i,h)&&(i.value=h)}else if("innerHTML"===t&&Yt(i.tagName)&&s(i.innerHTML)){(qa=qa||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var c=qa.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;c.firstChild;)i.appendChild(c.firstChild)}else if(a!==r[t])try{i[t]=a}catch(n){}}}}function Da(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return y(t)!==y(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ia={create:Aa,update:Aa},Ea=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function ja(n){var e=Ca(n.style);return n.staticStyle?j(n.staticStyle,e):e}function Ca(n){return Array.isArray(n)?C(n):"string"==typeof n?Ea(n):n}var za,La=/^--/,Fa=/\s*!important$/,_a=function(n,e,t){if(La.test(e))n.style.setProperty(e,t);else if(Fa.test(t))n.style.setProperty(D(e),t.replace(Fa,""),"important");else{var a=Ma(e);if(Array.isArray(t))for(var i=0,s=t.length;i<s;i++)n.style[a]=t[i];else n.style[a]=t}},Pa=["Webkit","Moz","ms"],Ma=k((function(n){if(za=za||document.createElement("div").style,"filter"!==(n=q(n))&&n in za)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Pa.length;t++){var a=Pa[t]+e;if(a in za)return a}}));function Ra(n,e){var t=e.data,a=n.data;if(!(s(t.staticStyle)&&s(t.style)&&s(a.staticStyle)&&s(a.style))){var i,r,l=e.elm,h=a.staticStyle,c=a.normalizedStyle||a.style||{},d=h||c,u=Ca(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?j({},u):u;var f=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=ja(i.data))&&j(a,t);(t=ja(n.data))&&j(a,t);for(var s=n;s=s.parent;)s.data&&(t=ja(s.data))&&j(a,t);return a}(e,!0);for(r in d)s(f[r])&&_a(l,r,"");for(r in f)(i=f[r])!==d[r]&&_a(l,r,null==i?"":i)}}var Ba={create:Ra,update:Ra},Oa=/\s+/;function Na(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Wa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,Ga(n.name||"v")),j(e,n),e}return"string"==typeof n?Ga(n):void 0}}var Ga=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),$a=H&&!K,Ha="transition",Xa="transitionend",Ya="animation",Za="animationend";$a&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ha="WebkitTransition",Xa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ya="WebkitAnimation",Za="webkitAnimationEnd"));var Va=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ka(n){Va((function(){Va(n)}))}function Ja(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Na(n,e))}function Qa(n,e){n._transitionClasses&&v(n._transitionClasses,e),Wa(n,e)}function ni(n,e,t){var a=ti(n,e),i=a.type,s=a.timeout,o=a.propCount;if(!i)return t();var r="transition"===i?Xa:Za,l=0,h=function(){n.removeEventListener(r,c),t()},c=function(e){e.target===n&&++l>=o&&h()};setTimeout((function(){l<o&&h()}),s+1),n.addEventListener(r,c)}var ei=/\b(transform|all)(,|$)/;function ti(n,e){var t,a=window.getComputedStyle(n),i=(a[Ha+"Delay"]||"").split(", "),s=(a[Ha+"Duration"]||"").split(", "),o=ai(i,s),r=(a[Ya+"Delay"]||"").split(", "),l=(a[Ya+"Duration"]||"").split(", "),h=ai(r,l),c=0,d=0;return"transition"===e?o>0&&(t="transition",c=o,d=s.length):"animation"===e?h>0&&(t="animation",c=h,d=l.length):d=(t=(c=Math.max(o,h))>0?o>h?"transition":"animation":null)?"transition"===t?s.length:l.length:0,{type:t,timeout:c,propCount:d,hasTransform:"transition"===t&&ei.test(a[Ha+"Property"])}}function ai(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ii(e)+ii(n[t])})))}function ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function si(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=Ua(n.data.transition);if(!s(a)&&!o(t._enterCb)&&1===t.nodeType){for(var i=a.css,r=a.type,l=a.enterClass,c=a.enterToClass,d=a.enterActiveClass,u=a.appearClass,f=a.appearToClass,m=a.appearActiveClass,p=a.beforeEnter,g=a.enter,b=a.afterEnter,v=a.enterCancelled,x=a.beforeAppear,w=a.appear,k=a.afterAppear,T=a.appearCancelled,q=a.duration,S=Je,A=Je.$vnode;A&&A.parent;)S=A.context,A=A.parent;var D=!S._isMounted||!n.isRootInsert;if(!D||w||""===w){var I=D&&u?u:l,E=D&&m?m:d,j=D&&f?f:c,C=D&&x||p,z=D&&"function"==typeof w?w:g,L=D&&k||b,F=D&&T||v,_=y(h(q)?q.enter:q);0;var P=!1!==i&&!K,R=li(z),B=t._enterCb=M((function(){P&&(Qa(t,j),Qa(t,E)),B.cancelled?(P&&Qa(t,I),F&&F(t)):L&&L(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,B)})),C&&C(t),P&&(Ja(t,I),Ja(t,E),Ka((function(){Qa(t,I),B.cancelled||(Ja(t,j),R||(ri(_)?setTimeout(B,_):ni(t,r,B)))}))),n.data.show&&(e&&e(),z&&z(t,B)),P||R||B()}}}function oi(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=Ua(n.data.transition);if(s(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=a.css,r=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,f=a.leave,m=a.afterLeave,p=a.leaveCancelled,g=a.delayLeave,b=a.duration,v=!1!==i&&!K,x=li(f),w=y(h(b)?b.leave:b);0;var k=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(Qa(t,c),Qa(t,d)),k.cancelled?(v&&Qa(t,l),p&&p(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(T):T()}function T(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),v&&(Ja(t,l),Ja(t,d),Ka((function(){Qa(t,l),k.cancelled||(Ja(t,c),x||(ri(w)?setTimeout(k,w):ni(t,r,k)))}))),f&&f(t,k),v||x||k())}}function ri(n){return"number"==typeof n&&!isNaN(n)}function li(n){if(s(n))return!1;var e=n.fns;return o(e)?li(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function hi(n,e){!0!==e.data.show&&si(e)}var ci=function(n){var e,t,a={},i=n.modules,h=n.nodeOps;for(e=0;e<ta.length;++e)for(a[ta[e]]=[],t=0;t<i.length;++t)o(i[t][ta[e]])&&a[ta[e]].push(i[t][ta[e]]);function c(n){var e=h.parentNode(n);o(e)&&h.removeChild(e,n)}function d(n,e,t,i,s,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=xn(n)),n.isRootInsert=!s,!function(n,e,t,i){var s=n.data;if(o(s)){var l=o(n.componentInstance)&&s.keepAlive;if(o(s=s.hook)&&o(s=s.init)&&s(n,!1),o(n.componentInstance))return u(n,e),f(t,n.elm,i),r(l)&&function(n,e,t,i){var s,r=n;for(;r.componentInstance;)if(r=r.componentInstance._vnode,o(s=r.data)&&o(s=s.transition)){for(s=0;s<a.activate.length;++s)a.activate[s](ea,r);e.push(r);break}f(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?h.createElementNS(n.ns,g):h.createElement(g,n),b(n),m(n,p,e),o(d)&&y(n,e),f(t,n.elm,i)):r(n.isComment)?(n.elm=h.createComment(n.text),f(t,n.elm,i)):(n.elm=h.createTextNode(n.text),f(t,n.elm,i))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,p(n)?(y(n,e),b(n)):(na(n),e.push(n))}function f(n,e,t){o(n)&&(o(t)?h.parentNode(t)===n&&h.insertBefore(n,e,t):h.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var a=0;a<e.length;++a)d(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&h.appendChild(n.elm,h.createTextNode(String(n.text)))}function p(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function y(n,t){for(var i=0;i<a.create.length;++i)a.create[i](ea,n);o(e=n.data.hook)&&(o(e.create)&&e.create(ea,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))h.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e),t=t.parent;o(e=Je)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e)}function v(n,e,t,a,i,s){for(;a<=i;++a)d(t[a],s,n,e,!1,t,a)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(k(a),x(a)):c(a.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=a.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&c(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else c(n.elm)}function T(n,e,t,a){for(var i=t;i<a;i++){var s=e[i];if(o(s)&&aa(n,s))return i}}function q(n,e,t,i,l,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=xn(e));var u=e.elm=n.elm;if(r(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?D(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(r(e.isStatic)&&r(n.isStatic)&&e.key===n.key&&(r(e.isCloned)||r(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,m=e.data;o(m)&&o(f=m.hook)&&o(f=f.prepatch)&&f(n,e);var y=n.children,g=e.children;if(o(m)&&p(e)){for(f=0;f<a.update.length;++f)a.update[f](n,e);o(f=m.hook)&&o(f=f.update)&&f(n,e)}s(e.text)?o(y)&&o(g)?y!==g&&function(n,e,t,a,i){var r,l,c,u=0,f=0,m=e.length-1,p=e[0],y=e[m],g=t.length-1,b=t[0],x=t[g],k=!i;for(0;u<=m&&f<=g;)s(p)?p=e[++u]:s(y)?y=e[--m]:aa(p,b)?(q(p,b,a,t,f),p=e[++u],b=t[++f]):aa(y,x)?(q(y,x,a,t,g),y=e[--m],x=t[--g]):aa(p,x)?(q(p,x,a,t,g),k&&h.insertBefore(n,p.elm,h.nextSibling(y.elm)),p=e[++u],x=t[--g]):aa(y,b)?(q(y,b,a,t,f),k&&h.insertBefore(n,y.elm,p.elm),y=e[--m],b=t[++f]):(s(r)&&(r=ia(e,u,m)),s(l=o(b.key)?r[b.key]:T(b,e,u,m))?d(b,a,n,p.elm,!1,t,f):aa(c=e[l],b)?(q(c,b,a,t,f),e[l]=void 0,k&&h.insertBefore(n,c.elm,p.elm)):d(b,a,n,p.elm,!1,t,f),b=t[++f]);u>m?v(n,s(t[g+1])?null:t[g+1].elm,t,f,g,a):f>g&&w(e,u,m)}(u,y,g,t,c):o(g)?(o(n.text)&&h.setTextContent(u,""),v(u,null,g,0,g.length-1,t)):o(y)?w(y,0,y.length-1):o(n.text)&&h.setTextContent(u,""):n.text!==e.text&&h.setTextContent(u,e.text),o(m)&&o(f=m.hook)&&o(f=f.postpatch)&&f(n,e)}}}function S(n,e,t){if(r(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var A=g("attrs,class,staticClass,staticStyle,key");function D(n,e,t,a){var i,s=e.tag,l=e.data,h=e.children;if(a=a||l&&l.pre,e.elm=n,r(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return u(e,t),!0;if(o(s)){if(o(h))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var c=!0,d=n.firstChild,f=0;f<h.length;f++){if(!d||!D(d,h[f],t,a)){c=!1;break}d=d.nextSibling}if(!c||d)return!1}else m(e,h,t);if(o(l)){var p=!1;for(var g in l)if(!A(g)){p=!0,y(e,t);break}!p&&l.class&&oe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!s(e)){var l,c=!1,u=[];if(s(n))c=!0,d(e,u);else{var f=o(n.nodeType);if(!f&&aa(n,e))q(n,e,u,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),r(t)&&D(n,e,u))return S(e,u,!0),n;l=n,n=new yn(h.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,y=h.parentNode(m);if(d(e,u,m._leaveCb?null:y,h.nextSibling(m)),o(e.parent))for(var g=e.parent,b=p(e);g;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](g);if(g.elm=e.elm,b){for(var k=0;k<a.create.length;++k)a.create[k](ea,g);var T=g.data.hook.insert;if(T.merged)for(var A=1;A<T.fns.length;A++)T.fns[A]()}else na(g);g=g.parent}o(y)?w([n],0,0):o(n.tag)&&x(n)}}return S(e,u,c),e.elm}o(n)&&x(n)}}({nodeOps:Jt,modules:[pa,ba,Sa,Ia,Ba,H?{create:hi,activate:hi,remove:function(n,e){!0!==n.data.show?oi(n,e):e()}}:{}].concat(da)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var di={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?ce(t,"postpatch",(function(){di.componentUpdated(n,e,t)})):ui(n,e,t.context),n._vOptions=[].map.call(n.options,pi)):("textarea"===t.tag||Kt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",yi),n.addEventListener("compositionend",gi),n.addEventListener("change",gi),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ui(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,pi);if(i.some((function(n,e){return!_(n,a[e])})))(n.multiple?e.value.some((function(n){return mi(n,i)})):e.value!==e.oldValue&&mi(e.value,i))&&bi(n,"change")}}};function ui(n,e,t){fi(n,e,t),(V||J)&&setTimeout((function(){fi(n,e,t)}),0)}function fi(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var s,o,r=0,l=n.options.length;r<l;r++)if(o=n.options[r],i)s=P(a,pi(o))>-1,o.selected!==s&&(o.selected=s);else if(_(pi(o),a))return void(n.selectedIndex!==r&&(n.selectedIndex=r));i||(n.selectedIndex=-1)}}function mi(n,e){return e.every((function(e){return!_(e,n)}))}function pi(n){return"_value"in n?n._value:n.value}function yi(n){n.target.composing=!0}function gi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function vi(n){return!n.componentInstance||n.data&&n.data.transition?n:vi(n.componentInstance._vnode)}var xi={model:di,show:{bind:function(n,e,t){var a=e.value,i=(t=vi(t)).data&&t.data.transition,s=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,si(t,(function(){n.style.display=s}))):n.style.display=a?s:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=vi(t)).data&&t.data.transition?(t.data.show=!0,a?si(t,(function(){n.style.display=n.__vOriginalDisplay})):oi(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},wi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ki(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ki(Xe(e.children)):n}function Ti(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var s in i)e[q(s)]=i[s];return e}function qi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Si=function(n){return n.tag||ge(n)},Ai=function(n){return"show"===n.name},Di={name:"transition",props:wi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Si)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var s=ki(i);if(!s)return i;if(this._leaving)return qi(n,i);var o="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?o+"comment":o+s.tag:l(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var r=(s.data||(s.data={})).transition=Ti(this),h=this._vnode,c=ki(h);if(s.data.directives&&s.data.directives.some(Ai)&&(s.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(s,c)&&!ge(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var d=c.data.transition=j({},r);if("out-in"===a)return this._leaving=!0,ce(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),qi(n,i);if("in-out"===a){if(ge(s))return h;var u,f=function(){u()};ce(r,"afterEnter",f),ce(r,"enterCancelled",f),ce(d,"delayLeave",(function(n){u=n}))}}return i}}},Ii=j({tag:String,moveClass:String},wi);function Ei(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function ji(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ci(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var s=n.elm.style;s.transform=s.WebkitTransform="translate("+a+"px,"+i+"px)",s.transitionDuration="0s"}}delete Ii.mode;var zi={Transition:Di,TransitionGroup:{props:Ii,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],o=Ti(this),r=0;r<i.length;r++){var l=i[r];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))s.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(a){for(var h=[],c=[],d=0;d<a.length;d++){var u=a[d];u.data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?h.push(u):c.push(u)}this.kept=n(e,null,h),this.removed=c}return n(e,null,s)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ei),n.forEach(ji),n.forEach(Ci),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Ja(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(Xa,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(Xa,n),t._moveCb=null,Qa(t,e))})}})))},methods:{hasMove:function(n,e){if(!$a)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Wa(t,n)})),Na(t,e),t.style.display="none",this.$el.appendChild(t);var a=ti(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};St.config.mustUseProp=function(n,e,t){return"value"===t&&Ft(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},St.config.isReservedTag=Zt,St.config.isReservedAttr=Lt,St.config.getTagNamespace=function(n){return Yt(n)?"svg":"math"===n?"math":void 0},St.config.isUnknownElement=function(n){if(!H)return!0;if(Zt(n))return!1;if(n=n.toLowerCase(),null!=Vt[n])return Vt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Vt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Vt[n]=/HTMLUnknownElement/.test(e.toString())},j(St.options.directives,xi),j(St.options.components,zi),St.prototype.__patch__=H?ci:z,St.prototype.$mount=function(n,e){return function(n,e,t){var a;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new mt(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){O.devtools&&on&&on.emit("init",St)}),0);var Li=St;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Fi(n,e){for(var t in e)n[t]=e[t];return n}var _i=/[!'()*]/g,Pi=function(n){return"%"+n.charCodeAt(0).toString(16)},Mi=/%2C/g,Ri=function(n){return encodeURIComponent(n).replace(_i,Pi).replace(Mi,",")};function Bi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Oi=function(n){return null==n||"object"==typeof n?n:String(n)};function Ni(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=Bi(t.shift()),i=t.length>0?Bi(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function Wi(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Ri(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(Ri(e)):a.push(Ri(e)+"="+Ri(n)))})),a.join("&")}return Ri(e)+"="+Ri(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ui=/\/?$/;function Gi(n,e,t,a){var i=a&&a.options.stringifyQuery,s=e.query||{};try{s=$i(s)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:s,params:e.params||{},fullPath:Yi(e,i),matched:n?Xi(n):[]};return t&&(o.redirectedFrom=Yi(t,i)),Object.freeze(o)}function $i(n){if(Array.isArray(n))return n.map($i);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=$i(n[t]);return e}return n}var Hi=Gi(null,{path:"/"});function Xi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Yi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Wi)(a)+i}function Zi(n,e,t){return e===Hi?n===e:!!e&&(n.path&&e.path?n.path.replace(Ui,"")===e.path.replace(Ui,"")&&(t||n.hash===e.hash&&Vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Vi(n.query,e.query)&&Vi(n.params,e.params))))}function Vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var s=n[t];if(a[i]!==t)return!1;var o=e[t];return null==s||null==o?s===o:"object"==typeof s&&"object"==typeof o?Vi(s,o):String(s)===String(o)}))}function Ki(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],s=t.enteredCbs[a];if(i&&s){delete t.enteredCbs[a];for(var o=0;o<s.length;o++)i._isBeingDestroyed||s[o](i)}}}}var Ji={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,s=e.data;s.routerView=!0;for(var o=i.$createElement,r=t.name,l=i.$route,h=i._routerViewCache||(i._routerViewCache={}),c=0,d=!1;i&&i._routerRoot!==i;){var u=i.$vnode?i.$vnode.data:{};u.routerView&&c++,u.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(s.routerViewDepth=c,d){var f=h[r],m=f&&f.component;return m?(f.configProps&&Qi(m,s,f.route,f.configProps),o(m,s,a)):o()}var p=l.matched[c],y=p&&p.components[r];if(!p||!y)return h[r]=null,o();h[r]={component:y},s.registerRouteInstance=function(n,e){var t=p.instances[r];(e&&t!==n||!e&&t===n)&&(p.instances[r]=e)},(s.hook||(s.hook={})).prepatch=function(n,e){p.instances[r]=e.componentInstance},s.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==p.instances[r]&&(p.instances[r]=n.componentInstance),Ki(l)};var g=p.props&&p.props[r];return g&&(Fi(h[r],{route:l,configProps:g}),Qi(y,s,l,g)),o(y,s,a)}};function Qi(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=Fi({},i);var s=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(s[o]=i[o],delete i[o])}}function ns(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var s=n.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var r=s[o];".."===r?i.pop():"."!==r&&i.push(r)}return""!==i[0]&&i.unshift(""),i.join("/")}function es(n){return n.replace(/\/+/g,"/")}var ts=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},as=gs,is=hs,ss=function(n,e){return ds(hs(n,e),e)},os=ds,rs=ys,ls=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function hs(n,e){for(var t,a=[],i=0,s=0,o="",r=e&&e.delimiter||"/";null!=(t=ls.exec(n));){var l=t[0],h=t[1],c=t.index;if(o+=n.slice(s,c),s=c+l.length,h)o+=h[1];else{var d=n[s],u=t[2],f=t[3],m=t[4],p=t[5],y=t[6],g=t[7];o&&(a.push(o),o="");var b=null!=u&&null!=d&&d!==u,v="+"===y||"*"===y,x="?"===y||"*"===y,w=t[2]||r,k=m||p;a.push({name:f||i++,prefix:u||"",delimiter:w,optional:x,repeat:v,partial:b,asterisk:!!g,pattern:k?fs(k):g?".*":"[^"+us(w)+"]+?"})}}return s<n.length&&(o+=n.substr(s)),o&&a.push(o),a}function cs(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ds(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",ps(e)));return function(e,a){for(var i="",s=e||{},o=(a||{}).pretty?cs:encodeURIComponent,r=0;r<n.length;r++){var l=n[r];if("string"!=typeof l){var h,c=s[l.name];if(null==c){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ts(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<c.length;d++){if(h=o(c[d]),!t[r].test(h))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(h)+"`");i+=(0===d?l.prefix:l.delimiter)+h}}else{if(h=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[r].test(h))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+h+'"');i+=l.prefix+h}}else i+=l}return i}}function us(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function fs(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ms(n,e){return n.keys=e,n}function ps(n){return n&&n.sensitive?"":"i"}function ys(n,e,t){ts(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,s="",o=0;o<n.length;o++){var r=n[o];if("string"==typeof r)s+=us(r);else{var l=us(r.prefix),h="(?:"+r.pattern+")";e.push(r),r.repeat&&(h+="(?:"+l+h+")*"),s+=h=r.optional?r.partial?l+"("+h+")?":"(?:"+l+"("+h+"))?":l+"("+h+")"}}var c=us(t.delimiter||"/"),d=s.slice(-c.length)===c;return a||(s=(d?s.slice(0,-c.length):s)+"(?:"+c+"(?=$))?"),s+=i?"$":a&&d?"":"(?="+c+"|$)",ms(new RegExp("^"+s,ps(t)),e)}function gs(n,e,t){return ts(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ms(n,e)}(n,e):ts(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(gs(n[i],e,t).source);return ms(new RegExp("(?:"+a.join("|")+")",ps(t)),e)}(n,e,t):function(n,e,t){return ys(hs(n,t),e,t)}(n,e,t)}as.parse=is,as.compile=ss,as.tokensToFunction=os,as.tokensToRegExp=rs;var bs=Object.create(null);function vs(n,e,t){e=e||{};try{var a=bs[n]||(bs[n]=as.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xs(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var s=(i=Fi({},n)).params;return s&&"object"==typeof s&&(i.params=Fi({},s)),i}if(!i.path&&i.params&&e){(i=Fi({},i))._normalized=!0;var o=Fi(Fi({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var r=e.matched[e.matched.length-1].path;i.path=vs(r,o,e.path)}else 0;return i}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),h=e&&e.path||"/",c=l.path?ns(l.path,h,t||i.append):h,d=function(n,e,t){void 0===e&&(e={});var a,i=t||Ni;try{a=i(n||"")}catch(n){a={}}for(var s in e){var o=e[s];a[s]=Array.isArray(o)?o.map(Oi):Oi(o)}return a}(l.query,i.query,a&&a.options.parseQuery),u=i.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:c,query:d,hash:u}}var ws,ks=function(){},Ts={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),s=i.location,o=i.route,r=i.href,l={},h=t.options.linkActiveClass,c=t.options.linkExactActiveClass,d=null==h?"router-link-active":h,u=null==c?"router-link-exact-active":c,f=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?u:this.exactActiveClass,p=o.redirectedFrom?Gi(null,xs(o.redirectedFrom),null,t):o;l[m]=Zi(a,p,this.exactPath),l[f]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(Ui,"/").indexOf(e.path.replace(Ui,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,p);var y=l[m]?this.ariaCurrentValue:null,g=function(n){qs(n)&&(e.replace?t.replace(s,ks):t.push(s,ks))},b={click:qs};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var v={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:r,route:o,navigate:g,isActive:l[f],isExactActive:l[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)v.on=b,v.attrs={href:r,"aria-current":y};else{var w=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=Fi({},w.data);for(var T in k.on=k.on||{},k.on){var q=k.on[T];T in b&&(k.on[T]=Array.isArray(q)?q:[q])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=g;var A=w.data.attrs=Fi({},w.data.attrs);A.href=r,A["aria-current"]=y}else v.on=b}return n(this.tag,v,this.$slots.default)}};function qs(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ss="undefined"!=typeof window;function As(n,e,t,a,i){var s=e||[],o=t||Object.create(null),r=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,s,o){var r=i.path,l=i.name;0;var h=i.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return es(e.path+"/"+n)}(r,s,h.strict);"boolean"==typeof i.caseSensitive&&(h.sensitive=i.caseSensitive);var d={path:c,regex:Ds(c,h),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:s,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var s=o?es(o+"/"+i.path):void 0;n(e,t,a,i,d,s)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var u=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<u.length;++f){0;var m={path:u[f],children:i.children};n(e,t,a,m,s,d.path||"/")}l&&(a[l]||(a[l]=d))}(s,o,r,n,i)}));for(var l=0,h=s.length;l<h;l++)"*"===s[l]&&(s.push(s.splice(l,1)[0]),h--,l--);return{pathList:s,pathMap:o,nameMap:r}}function Ds(n,e){return as(n,[],e)}function Is(n,e){var t=As(n),a=t.pathList,i=t.pathMap,s=t.nameMap;function o(n,t,o){var r=xs(n,t,!1,e),h=r.name;if(h){var c=s[h];if(!c)return l(null,r);var d=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof r.params&&(r.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in r.params)&&d.indexOf(u)>-1&&(r.params[u]=t.params[u]);return r.path=vs(c.path,r.params),l(c,r,o)}if(r.path){r.params={};for(var f=0;f<a.length;f++){var m=a[f],p=i[m];if(Es(p.regex,r.path,r.params))return l(p,r,o)}}return l(null,r)}function r(n,t){var a=n.redirect,i="function"==typeof a?a(Gi(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var r=i,h=r.name,c=r.path,d=t.query,u=t.hash,f=t.params;if(d=r.hasOwnProperty("query")?r.query:d,u=r.hasOwnProperty("hash")?r.hash:u,f=r.hasOwnProperty("params")?r.params:f,h){s[h];return o({_normalized:!0,name:h,query:d,hash:u,params:f},void 0,t)}if(c){var m=function(n,e){return ns(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:vs(m,f),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?r(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:vs(t,e.params)});if(a){var i=a.matched,s=i[i.length-1];return e.params=a.params,l(s,e)}return l(null,e)}(0,t,n.matchAs):Gi(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?s[n]:void 0;As([e||n],a,i,s,t),t&&t.alias.length&&As(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,s,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){As(n,a,i,s)}}}function Es(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,s=a.length;i<s;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[i]?Bi(a[i]):a[i])}return!0}var js=Ss&&window.performance&&window.performance.now?window.performance:Date;function Cs(){return js.now().toFixed(3)}var zs=Cs();function Ls(){return zs}function Fs(n){return zs=n}var _s=Object.create(null);function Ps(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Fi({},window.history.state);return t.key=Ls(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Bs),function(){window.removeEventListener("popstate",Bs)}}function Ms(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var s=function(){var n=Ls();if(n)return _s[n]}(),o=i.call(n,e,t,a?s:null);o&&("function"==typeof o.then?o.then((function(n){Gs(n,s)})).catch((function(n){0})):Gs(o,s))}))}}function Rs(){var n=Ls();n&&(_s[n]={x:window.pageXOffset,y:window.pageYOffset})}function Bs(n){Rs(),n.state&&n.state.key&&Fs(n.state.key)}function Os(n){return Ws(n.x)||Ws(n.y)}function Ns(n){return{x:Ws(n.x)?n.x:window.pageXOffset,y:Ws(n.y)?n.y:window.pageYOffset}}function Ws(n){return"number"==typeof n}var Us=/^#\d/;function Gs(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=Us.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var s=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,s={x:Ws((t=s).x)?t.x:0,y:Ws(t.y)?t.y:0})}else Os(n)&&(e=Ns(n))}else a&&Os(n)&&(e=Ns(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var $s,Hs=Ss&&((-1===($s=window.navigator.userAgent).indexOf("Android 2.")&&-1===$s.indexOf("Android 4.0")||-1===$s.indexOf("Mobile Safari")||-1!==$s.indexOf("Chrome")||-1!==$s.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Xs(n,e){Rs();var t=window.history;try{if(e){var a=Fi({},t.state);a.key=Ls(),t.replaceState(a,"",n)}else t.pushState({key:Fs(Cs())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ys(n){Xs(n,!0)}function Zs(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}var Vs={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ks(n,e){return Qs(n,e,Vs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Js(n,e){return Qs(n,e,Vs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Qs(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ao(n){return function(e,t,a){var i=!1,s=0,o=null;io(n,(function(n,e,t,r){if("function"==typeof n&&void 0===n.cid){i=!0,s++;var l,h=ro((function(e){var i;((i=e).__esModule||oo&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ws.extend(e),t.components[r]=e,--s<=0&&a()})),c=ro((function(n){var e="Failed to resolve async component "+r+": "+n;o||(o=eo(n)?n:new Error(e),a(o))}));try{l=n(h,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(h,c);else{var d=l.component;d&&"function"==typeof d.then&&d.then(h,c)}}})),i||a()}}function io(n,e){return so(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function so(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ro(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var lo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ss){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Hi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ho(n,e,t,a){var i=io(n,(function(n,a,i,s){var o=function(n,e){"function"!=typeof n&&(n=ws.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,i,s)})):t(o,a,i,s)}));return so(a?i.reverse():i)}function co(n,e){if(e)return function(){return n.apply(e,arguments)}}lo.prototype.listen=function(n){this.cb=n},lo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},lo.prototype.onError=function(n){this.errorCbs.push(n)},lo.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(to(n,Vs.redirected)&&s===Hi||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},lo.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var s,o,r=function(n){!to(n)&&eo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,h=i.matched.length-1;if(Zi(n,i)&&l===h&&n.matched[l]===i.matched[h])return this.ensureURL(),n.hash&&Ms(this.router,i,n,!1),r(((o=Qs(s=i,n,Vs.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=c.updated,u=c.deactivated,f=c.activated,m=[].concat(function(n){return ho(n,"beforeRouteLeave",co,!0)}(u),this.router.beforeHooks,function(n){return ho(n,"beforeRouteUpdate",co)}(d),f.map((function(n){return n.beforeEnter})),ao(f)),p=function(e,t){if(a.pending!==n)return r(Js(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),r(function(n,e){return Qs(n,e,Vs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):eo(e)?(a.ensureURL(!0),r(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(r(Ks(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){r(n)}};Zs(m,p,(function(){Zs(function(n){return ho(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,s){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),s(n)}))}}(n,t,a)}))}(f).concat(a.router.resolveHooks),p,(function(){if(a.pending!==n)return r(Js(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){Ki(n)}))}))}))},lo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},lo.prototype.setupListeners=function(){},lo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Hi,this.pending=null};var uo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=fo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=Hs&&t;a&&this.listeners.push(Ps());var i=function(){var t=n.current,i=fo(n.base);n.current===Hi&&i===n._startLocation||n.transitionTo(i,(function(n){a&&Ms(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Xs(es(a.base+n.fullPath)),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Ys(es(a.base+n.fullPath)),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(fo(this.base)!==this.current.fullPath){var e=es(this.base+this.current.fullPath);n?Xs(e):Ys(e)}},e.prototype.getCurrentLocation=function(){return fo(this.base)},e}(lo);function fo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(es(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var mo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=fo(n);if(!/^\/#/.test(e))return window.location.replace(es(n+"/#"+e)),!0}(this.base)||po()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Hs&&e;t&&this.listeners.push(Ps());var a=function(){var e=n.current;po()&&n.transitionTo(yo(),(function(a){t&&Ms(n.router,a,e,!0),Hs||vo(a.fullPath)}))},i=Hs?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){vo(n.fullPath),Ms(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;yo()!==e&&(n?bo(e):vo(e))},e.prototype.getCurrentLocation=function(){return yo()},e}(lo);function po(){var n=yo();return"/"===n.charAt(0)||(vo("/"+n),!1)}function yo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function go(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Hs?Xs(go(n)):window.location.hash=n}function vo(n){Hs?Ys(go(n)):window.location.replace(go(n))}var xo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){to(n,Vs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(lo),wo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Is(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Hs&&!1!==n.fallback,this.fallback&&(e="hash"),Ss||(e="abstract"),this.mode=e,e){case"history":this.history=new uo(this,n.base);break;case"hash":this.history=new mo(this,n.base,this.fallback);break;case"abstract":this.history=new xo(this,n.base);break;default:0}},ko={currentRoute:{configurable:!0}};function To(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ko.currentRoute.get=function(){return this.history&&this.history.current},wo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof uo||t instanceof mo){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;Hs&&i&&"fullPath"in n&&Ms(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wo.prototype.beforeEach=function(n){return To(this.beforeHooks,n)},wo.prototype.beforeResolve=function(n){return To(this.resolveHooks,n)},wo.prototype.afterEach=function(n){return To(this.afterHooks,n)},wo.prototype.onReady=function(n,e){this.history.onReady(n,e)},wo.prototype.onError=function(n){this.history.onError(n)},wo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},wo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},wo.prototype.go=function(n){this.history.go(n)},wo.prototype.back=function(){this.go(-1)},wo.prototype.forward=function(){this.go(1)},wo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wo.prototype.resolve=function(n,e,t){var a=xs(n,e=e||this.history.current,t,this),i=this.match(a,e),s=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?es(n+"/"+a):a}(this.history.base,s,this.mode),normalizedTo:a,resolved:i}},wo.prototype.getRoutes=function(){return this.matcher.getRoutes()},wo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Hi&&this.history.transitionTo(this.history.getCurrentLocation())},wo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Hi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wo.prototype,ko),wo.install=function n(e){if(!n.installed||ws!==e){n.installed=!0,ws=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ji),e.component("RouterLink",Ts);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},wo.version="3.5.3",wo.isNavigationFailure=to,wo.NavigationFailureType=Vs,wo.START_LOCATION=Hi,Ss&&window.Vue&&window.Vue.use(wo);var qo=wo;t(225),t(172),t(252),t(130),t(254),t(36),t(37),t(255);function So(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(74),t(90),t(118);function Ao(n){return(Ao="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Do=t(66),Io=(t(181),t(20),t(51),t(227),t(228),t(40),t(23),{NotFound:function(){return Promise.all([t.e(0),t.e(9)]).then(t.bind(null,489))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,487))}}),Eo={"v-77a2df87":function(){return t.e(11).then(t.bind(null,496))},"v-c81280ce":function(){return t.e(12).then(t.bind(null,497))},"v-44fa5406":function(){return t.e(13).then(t.bind(null,498))},"v-eaf3e45e":function(){return t.e(14).then(t.bind(null,499))},"v-8274608c":function(){return t.e(15).then(t.bind(null,500))},"v-9356a500":function(){return t.e(16).then(t.bind(null,501))},"v-69ba53dc":function(){return t.e(17).then(t.bind(null,502))},"v-53783a7a":function(){return t.e(18).then(t.bind(null,503))},"v-4bb54d5a":function(){return t.e(19).then(t.bind(null,504))},"v-665d2ff5":function(){return Promise.all([t.e(0),t.e(10)]).then(t.bind(null,505))},"v-714308ff":function(){return t.e(20).then(t.bind(null,506))},"v-4ac269ee":function(){return t.e(21).then(t.bind(null,507))},"v-135bff0e":function(){return t.e(22).then(t.bind(null,508))},"v-240065b4":function(){return t.e(23).then(t.bind(null,509))},"v-4fafc755":function(){return t.e(24).then(t.bind(null,510))},"v-350b180b":function(){return t.e(25).then(t.bind(null,511))},"v-e0d76c86":function(){return t.e(26).then(t.bind(null,512))},"v-a626afce":function(){return t.e(27).then(t.bind(null,513))},"v-57bdc255":function(){return t.e(28).then(t.bind(null,514))},"v-96b41596":function(){return t.e(29).then(t.bind(null,515))},"v-6de99164":function(){return t.e(30).then(t.bind(null,516))},"v-fb6a0bc6":function(){return t.e(31).then(t.bind(null,517))},"v-022af798":function(){return t.e(32).then(t.bind(null,518))},"v-9ec8b0e0":function(){return t.e(33).then(t.bind(null,519))},"v-78a1ec51":function(){return t.e(34).then(t.bind(null,520))},"v-0c0b0a3c":function(){return t.e(35).then(t.bind(null,521))},"v-af1f7912":function(){return t.e(36).then(t.bind(null,522))},"v-3dbdb6b8":function(){return t.e(37).then(t.bind(null,523))},"v-5e14a608":function(){return t.e(38).then(t.bind(null,524))},"v-4f011ddc":function(){return t.e(39).then(t.bind(null,525))},"v-8af21fba":function(){return t.e(40).then(t.bind(null,526))},"v-305b9b44":function(){return t.e(41).then(t.bind(null,527))},"v-2b81695b":function(){return t.e(42).then(t.bind(null,528))},"v-d588bd04":function(){return t.e(43).then(t.bind(null,529))},"v-2cd59290":function(){return t.e(44).then(t.bind(null,530))},"v-380fb48e":function(){return t.e(45).then(t.bind(null,531))},"v-a6041e50":function(){return t.e(46).then(t.bind(null,532))},"v-56398717":function(){return t.e(47).then(t.bind(null,533))},"v-29984e8a":function(){return t.e(48).then(t.bind(null,534))},"v-3a5a84d4":function(){return t.e(49).then(t.bind(null,535))},"v-5546a966":function(){return t.e(50).then(t.bind(null,536))},"v-2472a78b":function(){return t.e(51).then(t.bind(null,537))},"v-51317608":function(){return t.e(52).then(t.bind(null,538))},"v-3957ebbe":function(){return t.e(53).then(t.bind(null,539))},"v-d1f85536":function(){return t.e(54).then(t.bind(null,540))},"v-5b4bcfa3":function(){return t.e(55).then(t.bind(null,541))},"v-7a49265a":function(){return t.e(56).then(t.bind(null,542))},"v-1b6b0b30":function(){return t.e(57).then(t.bind(null,543))},"v-ad783cd0":function(){return t.e(58).then(t.bind(null,544))},"v-fbc707cc":function(){return t.e(59).then(t.bind(null,545))},"v-93595222":function(){return t.e(60).then(t.bind(null,546))},"v-523d0d4e":function(){return t.e(61).then(t.bind(null,547))},"v-5ca082b2":function(){return t.e(62).then(t.bind(null,548))},"v-3c7b36da":function(){return t.e(63).then(t.bind(null,549))},"v-03378743":function(){return t.e(64).then(t.bind(null,550))},"v-7bba5a2e":function(){return t.e(65).then(t.bind(null,551))},"v-99fc7970":function(){return t.e(66).then(t.bind(null,490))},"v-18848ef1":function(){return t.e(67).then(t.bind(null,491))},"v-77d4d05b":function(){return t.e(68).then(t.bind(null,552))},"v-618eaefe":function(){return t.e(69).then(t.bind(null,553))},"v-e10e4096":function(){return t.e(70).then(t.bind(null,554))},"v-6f2fc85c":function(){return t.e(71).then(t.bind(null,555))},"v-508d0816":function(){return t.e(72).then(t.bind(null,556))},"v-0789c349":function(){return t.e(73).then(t.bind(null,557))},"v-4069c5f8":function(){return t.e(74).then(t.bind(null,558))},"v-4d8171d5":function(){return t.e(75).then(t.bind(null,559))},"v-0c0b63a6":function(){return t.e(76).then(t.bind(null,560))},"v-4470a5a9":function(){return t.e(77).then(t.bind(null,561))},"v-111c7b94":function(){return t.e(78).then(t.bind(null,562))},"v-57bcc112":function(){return t.e(79).then(t.bind(null,563))},"v-6754fb32":function(){return t.e(80).then(t.bind(null,564))},"v-6cd0ba1b":function(){return t.e(81).then(t.bind(null,565))},"v-62c9c110":function(){return t.e(82).then(t.bind(null,566))},"v-75eb6ec4":function(){return t.e(83).then(t.bind(null,567))},"v-76a9f96e":function(){return t.e(84).then(t.bind(null,568))},"v-b98a2e5c":function(){return t.e(85).then(t.bind(null,569))},"v-1cf80342":function(){return t.e(86).then(t.bind(null,570))},"v-75b9d625":function(){return t.e(87).then(t.bind(null,571))},"v-27678185":function(){return t.e(88).then(t.bind(null,572))},"v-6ae3dba5":function(){return t.e(89).then(t.bind(null,573))},"v-3e5a3109":function(){return t.e(90).then(t.bind(null,574))},"v-87a57784":function(){return t.e(91).then(t.bind(null,575))}};function jo(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Co=/-(\w)/g,zo=jo((function(n){return n.replace(Co,(function(n,e){return e?e.toUpperCase():""}))})),Lo=/\B([A-Z])/g,Fo=jo((function(n){return n.replace(Lo,"-$1").toLowerCase()})),_o=jo((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Po(n,e){if(e)return n(e)?n(e):e.includes("-")?n(_o(zo(e))):n(_o(e))||n(Fo(e))}var Mo=Object.assign({},Io,Eo),Ro=function(n){return Mo[n]},Bo=function(n){return Eo[n]},Oo=function(n){return Io[n]},No=function(n){return Li.component(n)};function Wo(n){return Po(Bo,n)}function Uo(n){return Po(Oo,n)}function Go(n){return Po(Ro,n)}function $o(n){return Po(No,n)}function Ho(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(a.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if($o(e)||!Go(e)){n.next=5;break}return n.next=3,Go(e)();case 3:t=n.sent,Li.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Xo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Yo=t(129),Zo=(t(268),t(146),t(70),t(210)),Vo=t.n(Zo),Ko=t(211),Jo=t.n(Ko),Qo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Yo.a)(n,1)[0]})).map((function(n){var e=Object(Yo.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Jo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=er(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Do.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tr(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Vo()([{name:"description",content:this.$description}],n,this.siteMeta,ar)},updateCanonicalLink:function(){nr(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",er(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tr(null,this.currentMetaTags),nr()}};function nr(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function er(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tr(n,e){if(e&&Object(Do.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ar(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var a=t[e];if(n.hasOwnProperty(a))return n[a]+a}return JSON.stringify(n)}t(132);var ir=t(148),sr={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ir)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),a=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),s=window.innerHeight+a,o=0;o<t.length;o++){var r=t[o],l=t[o+1],h=0===o&&0===a||a>=r.parentElement.offsetTop+10&&(!l||a<l.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(h&&c!==decodeURIComponent(r.hash)){var d=r;if(s===i)for(var u=o+1;u<t.length;u++)if(c===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},or=(t(76),t(98)),rr=t.n(or),lr={mounted:function(){var n=this;rr.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Li.component(n.name)||rr.a.start(),t()})),this.$router.afterEach((function(){rr.a.done(),n.isSidebarOpen=!1}))}};t(71),t(69),t(75),t(363);function hr(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(136);function cr(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function dr(n,e,t){return e&&cr(n.prototype,e),t&&cr(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(364);var ur=function(){function n(){hr(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return dr(n,[{key:"show",value:function(n){var e=this,t=n.text,a=void 0===t?"":t,i=n.duration,s=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(a,"</div>\n    "),this.containerEl.appendChild(o),s>0&&setTimeout((function(){e.close(o)}),s)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),fr={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ur).show({text:"å¤å¶æå",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},mr=(t(214),"auto"),pr="zoom-in",yr="zoom-out",gr="grab",br="move";function vr(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function xr(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function wr(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function kr(n,e,t){!function(n){var e=Tr,t=qr;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var s in e)t&&(i[s]=a[s]||""),a[s]=e[s];return i}var Tr="transition",qr="transform",Sr="transform",Ar="transitionend";var Dr=function(){},Ir={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Dr,onClose:Dr,onGrab:Dr,onMove:Dr,onRelease:Dr,onBeforeOpen:Dr,onBeforeClose:Dr,onBeforeGrab:Dr,onBeforeRelease:Dr,onImageLoading:Dr,onImageLoaded:Dr},Er={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Cr(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,s=this.options.scrollThreshold;(Math.abs(i)>=s||Math.abs(a)>=s)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(jr(n)&&!Cr(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){jr(n)&&!Cr(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function jr(n){return 0===n.button}function Cr(n){return n.metaKey||n.ctrlKey}var zr={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,kr(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),vr(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){kr(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Fr=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),_r=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},Pr={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=wr(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?gr:yr,transition:Sr+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=kr(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,kr(this.el,{transform:"none"})},grab:function(n,e,t){var a=Mr(),i=a.x-n,s=a.y-e;kr(this.el,{cursor:br,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=Mr(),i=a.x-n,s=a.y-e;kr(this.el,{transition:Sr,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){kr(this.el,this.styleClose)},restoreOpenStyle:function(){kr(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Mr(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,s=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Lr(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,r=this.rect.height/2,l=Mr(),h={x:l.x-o,y:l.y-r},c=h.x/o,d=h.y/r,u=s+Math.min(c,d);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,m=e||this.el.naturalHeight,p=parseFloat(i)*f/(100*this.rect.width),y=parseFloat(i)*m/(100*this.rect.height);if(u>p||u>y)return{x:p,y:y}}return{x:u,y:u}}};function Mr(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Rr(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){vr(n,a,e[a],t)}))}var Br=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Pr),this.overlay=Object.create(zr),this.handler=Object.create(Er),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=_r({},Ir,e),this.overlay.init(this),this.handler.init(this)}return Fr(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=pr,vr(n,"click",this.handler.click),this.options.preloadImage&&xr(wr(n)));return this}},{key:"config",value:function(n){return n?(_r(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),xr(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),vr(document,"scroll",this.handler.scroll),vr(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&vr(window,"resize",this.handler.resizeWindow);var s=function n(){vr(a,Ar,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Rr(document,e.handler,!0),t(a)};return vr(a,Ar,s),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=mr,this.overlay.fadeOut(),this.target.zoomOut(),vr(document,"scroll",this.handler.scroll,!1),vr(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&vr(window,"resize",this.handler.resizeWindow,!1);var a=function a(){vr(t,Ar,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Rr(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return vr(t,Ar,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var s=function n(){vr(i,Ar,n,!1),a(i)};return vr(i,Ar,s),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=br,this.target.move(n,e,t);var i=this.target.el,s=function n(){vr(i,Ar,n,!1),a(i)};return vr(i,Ar,s),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=mr,this.target.restoreOpenStyle();var a=function a(){vr(t,Ar,a,!1),n.lock=!1,n.released=!0,e(t)};return vr(t,Ar,a),this}}}]),n}(),Or=".theme-vdoing-content img:not(.no-zoom)",Nr=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Wr=Number("500"),Ur=function(){function n(){hr(this,n),this.instance=new Br(Nr)}return dr(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Wr;setTimeout((function(){return n.update(e)}),t)}}]),n}(),Gr=[Qo,sr,lr,fr,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new Ur,this.$vuepress.zooming.updateDelay()}}],$r={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Xo("layout",n),Li.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Hr=t(18),Xr=Object(Hr.a)($r,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var a;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(a=n[e]).push.apply(a,Object(Do.a)(t));break;default:throw new Error("Unknown option name.")}}(Xr,"mixins",Gr);var Yr,Zr=[{name:"v-77a2df87",path:"/peizhi/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-77a2df87").then(t)}},{path:"/peizhi/index.html",redirect:"/peizhi/"},{path:"/00.ç®å½é¡µ/01.åç«¯.html",redirect:"/peizhi/"},{name:"v-c81280ce",path:"/zhinan/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-c81280ce").then(t)}},{path:"/zhinan/index.html",redirect:"/zhinan/"},{path:"/00.ç®å½é¡µ/02.æå.html",redirect:"/zhinan/"},{name:"v-44fa5406",path:"/jiaocheng/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-44fa5406").then(t)}},{path:"/jiaocheng/index.html",redirect:"/jiaocheng/"},{path:"/00.ç®å½é¡µ/03.æç¨.html",redirect:"/jiaocheng/"},{name:"v-eaf3e45e",path:"/ziyuan/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-eaf3e45e").then(t)}},{path:"/ziyuan/index.html",redirect:"/ziyuan/"},{path:"/00.ç®å½é¡µ/04.èµæº.html",redirect:"/ziyuan/"},{name:"v-8274608c",path:"/shoucang/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-8274608c").then(t)}},{path:"/shoucang/index.html",redirect:"/shoucang/"},{path:"/00.ç®å½é¡µ/05.æ¶è.html",redirect:"/shoucang/"},{name:"v-9356a500",path:"/tips/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-9356a500").then(t)}},{path:"/tips/index.html",redirect:"/tips/"},{path:"/00.ç®å½é¡µ/07.tips.html",redirect:"/tips/"},{name:"v-69ba53dc",path:"/en-US/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-69ba53dc").then(t)}},{path:"/en-US/index.html",redirect:"/en-US/"},{path:"/00.ç®å½é¡µ/08.è¯­è¨.html",redirect:"/en-US/"},{name:"v-53783a7a",path:"/more/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-53783a7a").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.ç®å½é¡µ/09.æ´å¤.html",redirect:"/more/"},{name:"v-4bb54d5a",path:"/pages/56e571/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4bb54d5a").then(t)}},{path:"/pages/56e571/index.html",redirect:"/pages/56e571/"},{path:"/10.éç½®/00.å¥é¨ä»ç»/00.ä»ä¹æ¯Dafny.html",redirect:"/pages/56e571/"},{name:"v-665d2ff5",path:"/pages/4fa796/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-665d2ff5").then(t)}},{path:"/pages/4fa796/index.html",redirect:"/pages/4fa796/"},{path:"/10.éç½®/10.ç¨èµ·æ¥å§/00.å®è£.html",redirect:"/pages/4fa796/"},{name:"v-714308ff",path:"/pages/085606/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-714308ff").then(t)}},{path:"/pages/085606/index.html",redirect:"/pages/085606/"},{path:"/10.éç½®/10.ç¨èµ·æ¥å§/05.å¿«éå¥é¨.html",redirect:"/pages/085606/"},{name:"v-4ac269ee",path:"/pages/39fb20/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4ac269ee").then(t)}},{path:"/pages/39fb20/index.html",redirect:"/pages/39fb20/"},{path:"/10.éç½®/10.ç¨èµ·æ¥å§/10.ç®åä¸æ.html",redirect:"/pages/39fb20/"},{name:"v-135bff0e",path:"/pages/caf1f9/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-135bff0e").then(t)}},{path:"/pages/caf1f9/index.html",redirect:"/pages/caf1f9/"},{path:"/100.ç¤¾åºçè¨æ¿/çè¨æ¿.html",redirect:"/pages/caf1f9/"},{name:"v-240065b4",path:"/pages/6e15a6/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-240065b4").then(t)}},{path:"/pages/6e15a6/index.html",redirect:"/pages/6e15a6/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/00.åºç¡ Basic.html",redirect:"/pages/6e15a6/"},{name:"v-4fafc755",path:"/pages/eba166/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4fafc755").then(t)}},{path:"/pages/eba166/index.html",redirect:"/pages/eba166/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/05.æ¹æ³ Method.html",redirect:"/pages/eba166/"},{name:"v-350b180b",path:"/pages/83cdf9/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-350b180b").then(t)}},{path:"/pages/83cdf9/index.html",redirect:"/pages/83cdf9/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/10.å³é®å­ Keyword.html",redirect:"/pages/83cdf9/"},{name:"v-e0d76c86",path:"/pages/01d76e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-e0d76c86").then(t)}},{path:"/pages/01d76e/index.html",redirect:"/pages/01d76e/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/15.å½æ° Function.html",redirect:"/pages/01d76e/"},{name:"v-a626afce",path:"/pages/0fadc1/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-a626afce").then(t)}},{path:"/pages/0fadc1/index.html",redirect:"/pages/0fadc1/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/20.ç±» Class.html",redirect:"/pages/0fadc1/"},{name:"v-57bdc255",path:"/pages/a010ab/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-57bdc255").then(t)}},{path:"/pages/a010ab/index.html",redirect:"/pages/a010ab/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/30.æ³å Generics.html",redirect:"/pages/a010ab/"},{name:"v-96b41596",path:"/pages/c4fda3/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-96b41596").then(t)}},{path:"/pages/c4fda3/index.html",redirect:"/pages/c4fda3/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/35.å£°æ Statement.html",redirect:"/pages/c4fda3/"},{name:"v-6de99164",path:"/pages/e8438e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6de99164").then(t)}},{path:"/pages/e8438e/index.html",redirect:"/pages/e8438e/"},{path:"/20.æå/00.Dafnyå¿«éå¥é¨/40.è¡¨è¾¾å¼ Expression.html",redirect:"/pages/e8438e/"},{name:"v-fb6a0bc6",path:"/pages/0978ce/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-fb6a0bc6").then(t)}},{path:"/pages/0978ce/index.html",redirect:"/pages/0978ce/"},{path:"/20.æå/10.ç®åä¾å­/00.å¯»æ¾æå¤§åæå°æ°.html",redirect:"/pages/0978ce/"},{name:"v-022af798",path:"/pages/e3e481/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-022af798").then(t)}},{path:"/pages/e3e481/index.html",redirect:"/pages/e3e481/"},{path:"/20.æå/10.ç®åä¾å­/05.ææ³¢é£å¥æ°å.html",redirect:"/pages/e3e481/"},{name:"v-9ec8b0e0",path:"/pages/02fdef/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-9ec8b0e0").then(t)}},{path:"/pages/02fdef/index.html",redirect:"/pages/02fdef/"},{path:"/20.æå/10.ç®åä¾å­/10.çº¿æ§æ¥è¯¢.html",redirect:"/pages/02fdef/"},{name:"v-78a1ec51",path:"/pages/9b332b/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-78a1ec51").then(t)}},{path:"/pages/9b332b/index.html",redirect:"/pages/9b332b/"},{path:"/20.æå/10.ç®åä¾å­/15. å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°.html",redirect:"/pages/9b332b/"},{name:"v-0c0b0a3c",path:"/pages/3d1110/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0c0b0a3c").then(t)}},{path:"/pages/3d1110/index.html",redirect:"/pages/3d1110/"},{path:"/20.æå/10.ç®åä¾å­/20.éå.html",redirect:"/pages/3d1110/"},{name:"v-af1f7912",path:"/pages/2146d4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-af1f7912").then(t)}},{path:"/pages/2146d4/index.html",redirect:"/pages/2146d4/"},{path:"/20.æå/10.ç®åä¾å­/25.ç»æ­¢.html",redirect:"/pages/2146d4/"},{name:"v-3dbdb6b8",path:"/pages/877eb3/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3dbdb6b8").then(t)}},{path:"/pages/877eb3/index.html",redirect:"/pages/877eb3/"},{path:"/30.æç¨/00.Dafnyæç¨/00.ä»ç».html",redirect:"/pages/877eb3/"},{name:"v-5e14a608",path:"/pages/bf40c0/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5e14a608").then(t)}},{path:"/pages/bf40c0/index.html",redirect:"/pages/bf40c0/"},{path:"/30.æç¨/00.Dafnyæç¨/05.æ¹æ³.html",redirect:"/pages/bf40c0/"},{name:"v-4f011ddc",path:"/pages/2e0c73/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4f011ddc").then(t)}},{path:"/pages/2e0c73/index.html",redirect:"/pages/2e0c73/"},{path:"/30.æç¨/00.Dafnyæç¨/10.åç½®ååç½®æ¡ä»¶.html",redirect:"/pages/2e0c73/"},{name:"v-8af21fba",path:"/pages/36c1b4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-8af21fba").then(t)}},{path:"/pages/36c1b4/index.html",redirect:"/pages/36c1b4/"},{path:"/30.æç¨/00.Dafnyæç¨/15.æ­è¨.html",redirect:"/pages/36c1b4/"},{name:"v-305b9b44",path:"/pages/a1d5a4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-305b9b44").then(t)}},{path:"/pages/a1d5a4/index.html",redirect:"/pages/a1d5a4/"},{path:"/30.æç¨/00.Dafnyæç¨/20.å½æ°.html",redirect:"/pages/a1d5a4/"},{name:"v-2b81695b",path:"/pages/d89435/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2b81695b").then(t)}},{path:"/pages/d89435/index.html",redirect:"/pages/d89435/"},{path:"/30.æç¨/00.Dafnyæç¨/25.å¾ªç¯ä¸åå¼.html",redirect:"/pages/d89435/"},{name:"v-d588bd04",path:"/pages/af29e4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-d588bd04").then(t)}},{path:"/pages/af29e4/index.html",redirect:"/pages/af29e4/"},{path:"/30.æç¨/00.Dafnyæç¨/30.ç»æ­¢.html",redirect:"/pages/af29e4/"},{name:"v-2cd59290",path:"/pages/828a83/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2cd59290").then(t)}},{path:"/pages/828a83/index.html",redirect:"/pages/828a83/"},{path:"/30.æç¨/00.Dafnyæç¨/35.æ°ç».html",redirect:"/pages/828a83/"},{name:"v-380fb48e",path:"/pages/17e8d1/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-380fb48e").then(t)}},{path:"/pages/17e8d1/index.html",redirect:"/pages/17e8d1/"},{path:"/30.æç¨/00.Dafnyæç¨/40.éè¯.html",redirect:"/pages/17e8d1/"},{name:"v-a6041e50",path:"/pages/cc01af/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-a6041e50").then(t)}},{path:"/pages/cc01af/index.html",redirect:"/pages/cc01af/"},{path:"/30.æç¨/00.Dafnyæç¨/45.è°è¯.html",redirect:"/pages/cc01af/"},{name:"v-56398717",path:"/pages/13bbcd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-56398717").then(t)}},{path:"/pages/13bbcd/index.html",redirect:"/pages/13bbcd/"},{path:"/30.æç¨/00.Dafnyæç¨/50.æ¡æ¶.html",redirect:"/pages/13bbcd/"},{name:"v-29984e8a",path:"/pages/1319be/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-29984e8a").then(t)}},{path:"/pages/1319be/index.html",redirect:"/pages/1319be/"},{path:"/30.æç¨/00.Dafnyæç¨/55.äºåæ¥æ¾.html",redirect:"/pages/1319be/"},{name:"v-3a5a84d4",path:"/pages/30a8c2/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3a5a84d4").then(t)}},{path:"/pages/30a8c2/index.html",redirect:"/pages/30a8c2/"},{path:"/30.æç¨/00.Dafnyæç¨/60.ç»è®º.html",redirect:"/pages/30a8c2/"},{name:"v-5546a966",path:"/pages/273cac/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5546a966").then(t)}},{path:"/pages/273cac/index.html",redirect:"/pages/273cac/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/00.å¼çåå½çº³.html",redirect:"/pages/273cac/"},{name:"v-2472a78b",path:"/pages/9d19b8/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-2472a78b").then(t)}},{path:"/pages/9d19b8/index.html",redirect:"/pages/9d19b8/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/05.æ¨¡å.html",redirect:"/pages/9d19b8/"},{name:"v-51317608",path:"/pages/b9300a/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-51317608").then(t)}},{path:"/pages/b9300a/index.html",redirect:"/pages/b9300a/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/10.éå.html",redirect:"/pages/b9300a/"},{name:"v-3957ebbe",path:"/pages/cb3d21/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3957ebbe").then(t)}},{path:"/pages/cb3d21/index.html",redirect:"/pages/cb3d21/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/15.åºå.html",redirect:"/pages/cb3d21/"},{name:"v-d1f85536",path:"/pages/fc6196/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-d1f85536").then(t)}},{path:"/pages/fc6196/index.html",redirect:"/pages/fc6196/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/20.ç»æ­¢.html",redirect:"/pages/fc6196/"},{name:"v-5b4bcfa3",path:"/pages/a2a107/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5b4bcfa3").then(t)}},{path:"/pages/a2a107/index.html",redirect:"/pages/a2a107/"},{path:"/30.æç¨/10.Dafnyè¿é¶è¯­æ³/25.å¼ç±»å.html",redirect:"/pages/a2a107/"},{name:"v-7a49265a",path:"/pages/718207/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-7a49265a").then(t)}},{path:"/pages/718207/index.html",redirect:"/pages/718207/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/1.èªå¨å½çº³.html",redirect:"/pages/718207/"},{name:"v-1b6b0b30",path:"/pages/1f579f/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-1b6b0b30").then(t)}},{path:"/pages/1f579f/index.html",redirect:"/pages/1f579f/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/2.èªå¨è°ç¨å¼ç.html",redirect:"/pages/1f579f/"},{name:"v-ad783cd0",path:"/pages/f6638c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-ad783cd0").then(t)}},{path:"/pages/f6638c/index.html",redirect:"/pages/f6638c/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/3.å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD.html",redirect:"/pages/f6638c/"},{name:"v-fbc707cc",path:"/pages/1d2420/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-fbc707cc").then(t)}},{path:"/pages/1d2420/index.html",redirect:"/pages/1d2420/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/4.åç§æ¨å¯¼å¼.html",redirect:"/pages/1d2420/"},{name:"v-93595222",path:"/pages/20c275/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-93595222").then(t)}},{path:"/pages/20c275/index.html",redirect:"/pages/20c275/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/5.ä¸åç±»åçè¯æ.html",redirect:"/pages/20c275/"},{name:"v-523d0d4e",path:"/pages/67167e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-523d0d4e").then(t)}},{path:"/pages/67167e/index.html",redirect:"/pages/67167e/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/6.éååç´ ä¸çå½æ°.html",redirect:"/pages/67167e/"},{name:"v-5ca082b2",path:"/pages/be298d/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-5ca082b2").then(t)}},{path:"/pages/be298d/index.html",redirect:"/pages/be298d/"},{path:"/40.èµæº/00.å®è·µæ¢ç´¢/7.å¨éåä¸è¿­ä»£.html",redirect:"/pages/be298d/"},{name:"v-3c7b36da",path:"/pages/8065fd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3c7b36da").then(t)}},{path:"/pages/8065fd/index.html",redirect:"/pages/8065fd/"},{path:"/40.èµæº/10.å¸¸ç¨å·¥å·/00.Dafny type system.html",redirect:"/pages/8065fd/"},{name:"v-03378743",path:"/pages/0f17ab/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-03378743").then(t)}},{path:"/pages/0f17ab/index.html",redirect:"/pages/0f17ab/"},{path:"/40.èµæº/10.å¸¸ç¨å·¥å·/05.Style Guide for Dafny programs.html",redirect:"/pages/0f17ab/"},{name:"v-7bba5a2e",path:"/pages/a65c3f/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-7bba5a2e").then(t)}},{path:"/pages/a65c3f/index.html",redirect:"/pages/a65c3f/"},{path:"/40.èµæº/10.å¸¸ç¨å·¥å·/10.Cheet Sheet.html",redirect:"/pages/a65c3f/"},{name:"v-99fc7970",path:"/pages/1b94a4/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-99fc7970").then(t)}},{path:"/pages/1b94a4/index.html",redirect:"/pages/1b94a4/"},{path:"/50.æ¶è/01.æ¶èç«.html",redirect:"/pages/1b94a4/"},{name:"v-18848ef1",path:"/pages/30bf81/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-18848ef1").then(t)}},{path:"/pages/30bf81/index.html",redirect:"/pages/30bf81/"},{path:"/60.æ¯æ/01.å¯¼èªç«.html",redirect:"/pages/30bf81/"},{name:"v-77d4d05b",path:"/pages/8fb957/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-77d4d05b").then(t)}},{path:"/pages/8fb957/index.html",redirect:"/pages/8fb957/"},{path:"/80.è¯­è¨/00.dafny-quick-start/00.Dafny Quick Reference.html",redirect:"/pages/8fb957/"},{name:"v-618eaefe",path:"/pages/8766fd/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-618eaefe").then(t)}},{path:"/pages/8766fd/index.html",redirect:"/pages/8766fd/"},{path:"/80.è¯­è¨/00.dafny-quick-start/10.Getting Started with Dafny A Guide.html",redirect:"/pages/8766fd/"},{name:"v-e10e4096",path:"/pages/fe5721/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-e10e4096").then(t)}},{path:"/pages/fe5721/index.html",redirect:"/pages/fe5721/"},{path:"/80.è¯­è¨/00.dafny-quick-start/20.cheet.html",redirect:"/pages/fe5721/"},{name:"v-6f2fc85c",path:"/pages/c80a4c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6f2fc85c").then(t)}},{path:"/pages/c80a4c/index.html",redirect:"/pages/c80a4c/"},{path:"/80.è¯­è¨/10.dafny-tutorials/00.Getting Started with Dafny A Guide.html",redirect:"/pages/c80a4c/"},{name:"v-508d0816",path:"/pages/a9c4a5/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-508d0816").then(t)}},{path:"/pages/a9c4a5/index.html",redirect:"/pages/a9c4a5/"},{path:"/80.è¯­è¨/20.detailed-document/00.Dafny type system.html",redirect:"/pages/a9c4a5/"},{name:"v-0789c349",path:"/pages/c0c2c7/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0789c349").then(t)}},{path:"/pages/c0c2c7/index.html",redirect:"/pages/c0c2c7/"},{path:"/80.è¯­è¨/20.detailed-document/10.Style Guide for Dafny programers.html",redirect:"/pages/c0c2c7/"},{name:"v-4069c5f8",path:"/pages/a9363c/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4069c5f8").then(t)}},{path:"/pages/a9363c/index.html",redirect:"/pages/a9363c/"},{path:"/80.è¯­è¨/30.publication-lecture/00.Automatic Induction.html",redirect:"/pages/a9363c/"},{name:"v-4d8171d5",path:"/pages/30441e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4d8171d5").then(t)}},{path:"/pages/30441e/index.html",redirect:"/pages/30441e/"},{path:"/80.è¯­è¨/30.publication-lecture/05.Calling Lemmas Automatically.html",redirect:"/pages/30441e/"},{name:"v-0c0b63a6",path:"/pages/746026/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-0c0b63a6").then(t)}},{path:"/pages/746026/index.html",redirect:"/pages/746026/"},{path:"/80.è¯­è¨/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.html",redirect:"/pages/746026/"},{name:"v-4470a5a9",path:"/pages/da6921/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-4470a5a9").then(t)}},{path:"/pages/da6921/index.html",redirect:"/pages/da6921/"},{path:"/80.è¯­è¨/30.publication-lecture/15.Comprehensions.html",redirect:"/pages/da6921/"},{name:"v-111c7b94",path:"/pages/8d8607/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-111c7b94").then(t)}},{path:"/pages/8d8607/index.html",redirect:"/pages/8d8607/"},{path:"/80.è¯­è¨/30.publication-lecture/20.Different Styles of Proofs.html",redirect:"/pages/8d8607/"},{name:"v-57bcc112",path:"/pages/097ba0/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-57bcc112").then(t)}},{path:"/pages/097ba0/index.html",redirect:"/pages/097ba0/"},{path:"/80.è¯­è¨/30.publication-lecture/30.Functions over Set Elements.html",redirect:"/pages/097ba0/"},{name:"v-6754fb32",path:"/pages/c4484e/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6754fb32").then(t)}},{path:"/pages/c4484e/index.html",redirect:"/pages/c4484e/"},{path:"/80.è¯­è¨/30.publication-lecture/35.Iterating over a Collection.html",redirect:"/pages/c4484e/"},{name:"v-6cd0ba1b",path:"/pages/7fe522/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6cd0ba1b").then(t)}},{path:"/pages/7fe522/index.html",redirect:"/pages/7fe522/"},{path:"/80.è¯­è¨/30.publication-lecture/40.old and unchanged.html",redirect:"/pages/7fe522/"},{name:"v-62c9c110",path:"/pages/369e25/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-62c9c110").then(t)}},{path:"/pages/369e25/index.html",redirect:"/pages/369e25/"},{path:"/80.è¯­è¨/30.publication-lecture/45.Short-Circuit Operators.html",redirect:"/pages/369e25/"},{name:"v-75eb6ec4",path:"/pages/f8c1c5/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-75eb6ec4").then(t)}},{path:"/pages/f8c1c5/index.html",redirect:"/pages/f8c1c5/"},{path:"/80.è¯­è¨/30.publication-lecture/50.Statement versus Expression Syntax.html",redirect:"/pages/f8c1c5/"},{name:"v-76a9f96e",path:"/pages/5a4346/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-76a9f96e").then(t)}},{path:"/pages/5a4346/index.html",redirect:"/pages/5a4346/"},{path:"/80.è¯­è¨/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.html",redirect:"/pages/5a4346/"},{name:"v-b98a2e5c",path:"/pages/c45b5a/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-b98a2e5c").then(t)}},{path:"/pages/c45b5a/index.html",redirect:"/pages/c45b5a/"},{path:"/80.è¯­è¨/30.publication-lecture/60.Type-Parameter Completion.html",redirect:"/pages/c45b5a/"},{name:"v-1cf80342",path:"/pages/3c9a0b/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-1cf80342").then(t)}},{path:"/pages/3c9a0b/index.html",redirect:"/pages/3c9a0b/"},{path:"/80.è¯­è¨/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.html",redirect:"/pages/3c9a0b/"},{name:"v-75b9d625",path:"/archives/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-75b9d625").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-27678185",path:"/categories/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-27678185").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-6ae3dba5",path:"/tags/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-6ae3dba5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-3e5a3109",path:"/pages/12f287/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-3e5a3109").then(t)}},{path:"/pages/12f287/index.html",redirect:"/pages/12f287/"},{path:"/_posts/tips/tips.html",redirect:"/pages/12f287/"},{name:"v-87a57784",path:"/",component:Xr,beforeEnter:function(n,e,t){Ho("Layout","v-87a57784").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:Xr}],Vr={title:"",description:"",base:"/dafnycommunity/",headTags:[["link",{rel:"icon",href:"/dafnycommunity/img/bgico2.ico"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["link",{rel:"stylesheet",href:"https://at.alicdn.com/t/font_3282046_1qux519eoim.css"}],["script",{src:"https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"}]],pages:[{title:"Dafnyå¥é¨",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"10.éç½®",imgUrl:"/img/rumen.png",description:"è¯­è¨å¥é¨èµæ"}},title:"Dafnyå¥é¨",date:"2020-03-11T21:50:53.000Z",permalink:"/peizhi",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.ç®å½é¡µ/01.åç«¯.md",key:"v-77a2df87",path:"/peizhi/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafnyè¿é¶",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.æå",imgUrl:"/img/jinjie.png",description:"Dafnyè¿é¶æç¨"}},title:"Dafnyè¿é¶",date:"2020-03-11T21:50:54.000Z",permalink:"/zhinan",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E6%8C%87%E5%8D%97.html",relativePath:"00.ç®å½é¡µ/02.æå.md",key:"v-c81280ce",path:"/zhinan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafnyæç¨",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.æç¨",imgUrl:"/img/jinjie.png",description:"Dafnyæç¨éé¦"}},title:"Dafnyæç¨",date:"2020-03-11T21:50:55.000Z",permalink:"/jiaocheng",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%95%99%E7%A8%8B.html",relativePath:"00.ç®å½é¡µ/03.æç¨.md",key:"v-44fa5406",path:"/jiaocheng/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"æ´å¤",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"40.èµæº",imgUrl:"/img/ziyuan.png",description:"å­¦ä¹ ãé¢è¯ãå¨çº¿å·¥å·ç­æ´å¤æç« åé¡µé¢"}},title:"æ´å¤",date:"2020-03-11T21:50:56.000Z",permalink:"/ziyuan",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E8%B5%84%E6%BA%90.html",relativePath:"00.ç®å½é¡µ/04.èµæº.md",key:"v-eaf3e45e",path:"/ziyuan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"æ¶è",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.æ¶è",imgUrl:"/img/ziyuan.png",description:"æ´å¤éªè¯è¯­è¨å¨è¿é"}},title:"æ¶è",date:"2020-03-11T21:50:53.000Z",permalink:"/shoucang",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E6%94%B6%E8%97%8F.html",relativePath:"00.ç®å½é¡µ/05.æ¶è.md",key:"v-8274608c",path:"/shoucang/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny tips",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"70.tips",imgUrl:"/img/ziyuan.png",description:"tips"}},title:"Dafny tips",date:"2020-03-11T21:50:53.000Z",permalink:"/tips",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/07.tips.html",relativePath:"00.ç®å½é¡µ/07.tips.md",key:"v-9356a500",path:"/tips/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"languages",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"80.è¯­è¨",imgUrl:"/img/ziyuan.png",description:"language"}},title:"languages",date:"2020-03-11T21:50:53.000Z",permalink:"/en-US",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/08.%E8%AF%AD%E8%A8%80.html",relativePath:"00.ç®å½é¡µ/08.è¯­è¨.md",key:"v-69ba53dc",path:"/en-US/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"Dafny more",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"80.æ´å¤",imgUrl:"/img/ziyuan.png",description:"æ´å¤"}},title:"Dafny more",date:"2020-03-11T21:50:53.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/09.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.ç®å½é¡µ/09.æ´å¤.md",key:"v-53783a7a",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/01, 15:33:45",lastUpdatedTimestamp:1648798425e3},{title:"è¯­è¨ä»ç»",frontmatter:{title:"è¯­è¨ä»ç»",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/56e571/",categories:["éç½®"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/00.%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/00.%E4%BB%80%E4%B9%88%E6%98%AFDafny.html",relativePath:"10.éç½®/00.å¥é¨ä»ç»/00.ä»ä¹æ¯Dafny.md",key:"v-4bb54d5a",path:"/pages/56e571/",headersStr:null,content:"# ä»ç»\n\nDafny æ¯ä¸ç§æ¨å¨ä½¿ç¼åæ­£ç¡®ä»£ç åå¾å®¹æçè¯­è¨ãæä¹æ´å®¹æçéªè¯æ­£ç¡®æ§å¢ï¼Dafnyä¾é é«çº§æ³¨éæ¥å®ç°ãéè¿é«çº§æ³¨éï¼high-level annotationsï¼çæ¨çåéªè¯ï¼ä¸æ®µä»£ç çé»è¾å¯ä»¥ç¨é«çº§æ³¨éæ´èªç¶æ½è±¡çè¡¨è¾¾åºæ¥ï¼å½ç¶è¿æ ·æ´å å®¹æç¼ååéªè¯ï¼ä¸ä¸æåéã\n\nç¼è¯dafnyç¨åºåï¼dafnyä¼çæä¸é«çº§æ³¨éå¹éçé»è¾è¯æï¼æ¥åè¯ç¨åºåè¿ä¸ªç¨åºé»è¾æ­£ä¸æ­£ç¡®ï¼éäºä¹ä¼ææ¥éãDafnyè¿æ ·å®éä¸æ¯æç¼åæ éè¯¯ä»£ç åè½»ä¸ºç¼åæ éè¯¯æ³¨éï¼è¿æ ·åèµ·æ¥å½ç¶æ´å®¹æï¼å ä¸ºæ³¨éæ´ç­æ´ç´æ¥ãä¸é¢ä¸¾ä¸ªä¾å­ï¼\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nè¿ä¸ªä¾å­æ¯è¯´ï¼å¯¹äºæææ°ç»ä¸æ ç´¢å¼kï¼å¶ç´¢å¼å¯¹åºçæ°ç»å¼a[k]>0ãéè¿ç¼åè¿æ®µæ³¨éï¼å¯ä»¥éªè¯è¿ä¸ªæ¯æ­£ç¡®çã\n\né¤äºè¯æç¨åºååçé«çº§æ³¨éæ¯å¦æ­£ç¡®å¤ï¼Dafnyè¿è½å®æ¶éªè¯é»è¾ãå®è½è¾¹åç¨åºè¾¹éªè¯ï¼æ¯å¦æ°ç»è¶çãç©ºå¼ç¨ãé¤ä»¥é¶ç­ï¼è¿å¯ä»¥è¯æå¾ªç¯ä¸­ä»£ç æ¯å¦ç»æ­¢ï¼æ»ä¹åè½éå¸¸å¼ºå¤§ã\n\né£ä¹å¨ä½å¤ç¼åDafnyå¢ï¼å¯ä»¥ä¸githubä¸è½½Dafnyè¯­è¨åï¼ç¨å½ä»¤è¡æå¼Dafny.exeæä»¶è¾å¥ç¨åºå°±å¯ä»¥éªè¯ï¼ä¹å¯ä»¥å¨æµè§å¨webä¸æå¼rise4funç½ç«ï¼è¿ç½ç«ä¸è½å®æ¶ç¼åå¹¶ä¸ææç¨ãå¦ææ³ææ´å¥½çä½éªæ¯å¦é«äº®æ³¨éå®æ¶æ¥éè¿ç§åè½çè¯ï¼å¯ä»¥ç¨VScodeä¸è½½ç¸åº éç¨å¹¿æ³çåºç¡åé\n\nmarkdown content",normalizedContent:"# ä»ç»\n\ndafny æ¯ä¸ç§æ¨å¨ä½¿ç¼åæ­£ç¡®ä»£ç åå¾å®¹æçè¯­è¨ãæä¹æ´å®¹æçéªè¯æ­£ç¡®æ§å¢ï¼dafnyä¾é é«çº§æ³¨éæ¥å®ç°ãéè¿é«çº§æ³¨éï¼high-level annotationsï¼çæ¨çåéªè¯ï¼ä¸æ®µä»£ç çé»è¾å¯ä»¥ç¨é«çº§æ³¨éæ´èªç¶æ½è±¡çè¡¨è¾¾åºæ¥ï¼å½ç¶è¿æ ·æ´å å®¹æç¼ååéªè¯ï¼ä¸ä¸æåéã\n\nç¼è¯dafnyç¨åºåï¼dafnyä¼çæä¸é«çº§æ³¨éå¹éçé»è¾è¯æï¼æ¥åè¯ç¨åºåè¿ä¸ªç¨åºé»è¾æ­£ä¸æ­£ç¡®ï¼éäºä¹ä¼ææ¥éãdafnyè¿æ ·å®éä¸æ¯æç¼åæ éè¯¯ä»£ç åè½»ä¸ºç¼åæ éè¯¯æ³¨éï¼è¿æ ·åèµ·æ¥å½ç¶æ´å®¹æï¼å ä¸ºæ³¨éæ´ç­æ´ç´æ¥ãä¸é¢ä¸¾ä¸ªä¾å­ï¼\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nè¿ä¸ªä¾å­æ¯è¯´ï¼å¯¹äºæææ°ç»ä¸æ ç´¢å¼kï¼å¶ç´¢å¼å¯¹åºçæ°ç»å¼a[k]>0ãéè¿ç¼åè¿æ®µæ³¨éï¼å¯ä»¥éªè¯è¿ä¸ªæ¯æ­£ç¡®çã\n\né¤äºè¯æç¨åºååçé«çº§æ³¨éæ¯å¦æ­£ç¡®å¤ï¼dafnyè¿è½å®æ¶éªè¯é»è¾ãå®è½è¾¹åç¨åºè¾¹éªè¯ï¼æ¯å¦æ°ç»è¶çãç©ºå¼ç¨ãé¤ä»¥é¶ç­ï¼è¿å¯ä»¥è¯æå¾ªç¯ä¸­ä»£ç æ¯å¦ç»æ­¢ï¼æ»ä¹åè½éå¸¸å¼ºå¤§ã\n\né£ä¹å¨ä½å¤ç¼ådafnyå¢ï¼å¯ä»¥ä¸githubä¸è½½dafnyè¯­è¨åï¼ç¨å½ä»¤è¡æå¼dafny.exeæä»¶è¾å¥ç¨åºå°±å¯ä»¥éªè¯ï¼ä¹å¯ä»¥å¨æµè§å¨webä¸æå¼rise4funç½ç«ï¼è¿ç½ç«ä¸è½å®æ¶ç¼åå¹¶ä¸ææç¨ãå¦ææ³ææ´å¥½çä½éªæ¯å¦é«äº®æ³¨éå®æ¶æ¥éè¿ç§åè½çè¯ï¼å¯ä»¥ç¨vscodeä¸è½½ç¸åº éç¨å¹¿æ³çåºç¡åé\n\nmarkdown content",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å®è£Dafny",frontmatter:{title:"å®è£Dafny",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/4fa796/",comment:!0,categories:["éç½®"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/00.%E5%AE%89%E8%A3%85.html",relativePath:"10.éç½®/10.ç¨èµ·æ¥å§/00.å®è£.md",key:"v-665d2ff5",path:"/pages/4fa796/",headers:[{level:2,title:"å®è£",slug:"å®è£",normalizedTitle:"å®è£",charIndex:11},{level:2,title:"Vscode",slug:"vscode",normalizedTitle:"vscode",charIndex:45},{level:3,title:"ä¸è½½Dafnyæ©å±å",slug:"ä¸è½½dafnyæ©å±å",normalizedTitle:"ä¸è½½dafnyæ©å±å",charIndex:264},{level:3,title:"ä¸è½½NetCore5.0",slug:"ä¸è½½netcore5-0",normalizedTitle:"ä¸è½½netcore5.0",charIndex:281},{level:3,title:"èªå¨ä¸è½½language server",slug:"èªå¨ä¸è½½language-server",normalizedTitle:"èªå¨ä¸è½½language server",charIndex:416},{level:3,title:"æå¨éç½®language server",slug:"æå¨éç½®language-server",normalizedTitle:"æå¨éç½®language server",charIndex:666},{level:4,title:"GitHubä¸è½½dafny",slug:"githubä¸è½½dafny",normalizedTitle:"githubä¸è½½dafny",charIndex:689},{level:4,title:"ç¸å³éç½®æä»¶",slug:"ç¸å³éç½®æä»¶",normalizedTitle:"ç¸å³éç½®æä»¶",charIndex:747},{level:4,title:"æ´æ¹ç¸å³è·¯å¾",slug:"æ´æ¹ç¸å³è·¯å¾",normalizedTitle:"æ´æ¹ç¸å³è·¯å¾",charIndex:805}],headersStr:"å®è£ Vscode ä¸è½½Dafnyæ©å±å ä¸è½½NetCore5.0 èªå¨ä¸è½½language server æå¨éç½®language server GitHubä¸è½½dafny ç¸å³éç½®æä»¶ æ´æ¹ç¸å³è·¯å¾",content:"# å¿«éä¸æ\n\n\n# å®è£\n\nå¯ä»¥è®¿é®Dafny-langæ¥çææ°Dafnyçæ¬\n\n\n# Vscode\n\nå·ä½ä¸è½½æ¹æ³å¯æ¥çDafny wikiï¼è¿æ¯è¯­è¨å¢éæ¨åºå¹¶ç»´æ¤çwikiåå®¢ã\n\nå¦æä½ æ³å¿«éä¸æä½¿ç¨ï¼å¯ä»¥è§çInstall Dafny on Windowsï¼äºè§£å¦ä½å¨vscodeä¸åå»ºå¹¶ç¼è¯Dafnyæä»¶ã\n\næ­¥éª¤å¦ä¸ï¼\n\n * ä¸è½½vscode,å®è£Dafny(v1.6.0)æ©å±å\n * ä¸è½½Netcore5.0\n * åå»º.dfyæä»¶ï¼ç­å¾language serverèªå¨ä¸è½½å®æã\n * ç¼è¯è¿è¡\n\n\n# ä¸è½½Dafnyæ©å±å\n\n\n\n\n# ä¸è½½NetCore5.0\n\nè¿å¥vscodeæ°å»ºææå¼ä¸ä¸ªdafnyï¼.dfyï¼æä»¶ï¼æ­¤æ¶vscodeä¼æç¤ºéè¦ä¸è½½[NETCore5.0](Download .NET (Linux, macOS, and Windows) (microsoft.com))ã\n\n\n# èªå¨ä¸è½½language server\n\næ³¨ææ©å±åä¸­æå¦ä¸æç¤ºï¼\n\n> This VSCode plugin requires the Dafny language server (shipped with the Dafny release since v3.1.0).\n> \n> The plugin will install it automatically upon first use.\n\nDafnyæ©å±æä»¶ä¼èªå¨ä¸è½½language server,ä½å®ééåº¦åæåçä¸å°½äººæã\n\n\n# æå¨éç½®language server\n\n# GitHubä¸è½½dafny\n\nä»¥dafny(v3.2.0)ä¸ºä¾ï¼è¿å¥Dafny-langä¸è½½å¯¹åºçæ¬è¯­è¨åã\n\n# ç¸å³éç½®æä»¶\n\næ¾å°Dafny.dllä¸DafnyLanguageServer.dllæä»¶ï¼è®°ä½å¶æä»¶è·¯å¾ã\n\n# æ´æ¹ç¸å³è·¯å¾\n\nå¨vscodeå·¥ä½åº--æ©å±--Dafny extensionä¸­ä¿®æ¹Compiler Runtime PathãLanguage Server Runtime Pathä¸ºä»¥ä¸ä¸¤ä¸ªæä»¶çå¯¹åºè·¯å¾ã\n\n----------------------------------------\n\n\n# ç¬¬ä¸ä¸ªDafnyç¨åº\n\néç½®å®æï¼è®©æä»¬æ¥åå»ºä¸ªç®åçdafnyæä»¶æ¥ä½éªä¸ä¸å§ï¼\n\n * å®æ¶éªè¯\n\n * hello,Dafny\n\n> ç¸å³é¾æ¥ï¼\n> \n> github wiki\n> \n> vscode dafny-extension\n> \n> youtube Install Dafny on Windows",normalizedContent:"# å¿«éä¸æ\n\n\n# å®è£\n\nå¯ä»¥è®¿é®dafny-langæ¥çææ°dafnyçæ¬\n\n\n# vscode\n\nå·ä½ä¸è½½æ¹æ³å¯æ¥çdafny wikiï¼è¿æ¯è¯­è¨å¢éæ¨åºå¹¶ç»´æ¤çwikiåå®¢ã\n\nå¦æä½ æ³å¿«éä¸æä½¿ç¨ï¼å¯ä»¥è§çinstall dafny on windowsï¼äºè§£å¦ä½å¨vscodeä¸åå»ºå¹¶ç¼è¯dafnyæä»¶ã\n\næ­¥éª¤å¦ä¸ï¼\n\n * ä¸è½½vscode,å®è£dafny(v1.6.0)æ©å±å\n * ä¸è½½netcore5.0\n * åå»º.dfyæä»¶ï¼ç­å¾language serverèªå¨ä¸è½½å®æã\n * ç¼è¯è¿è¡\n\n\n# ä¸è½½dafnyæ©å±å\n\n\n\n\n# ä¸è½½netcore5.0\n\nè¿å¥vscodeæ°å»ºææå¼ä¸ä¸ªdafnyï¼.dfyï¼æä»¶ï¼æ­¤æ¶vscodeä¼æç¤ºéè¦ä¸è½½[netcore5.0](download .net (linux, macos, and windows) (microsoft.com))ã\n\n\n# èªå¨ä¸è½½language server\n\næ³¨ææ©å±åä¸­æå¦ä¸æç¤ºï¼\n\n> this vscode plugin requires the dafny language server (shipped with the dafny release since v3.1.0).\n> \n> the plugin will install it automatically upon first use.\n\ndafnyæ©å±æä»¶ä¼èªå¨ä¸è½½language server,ä½å®ééåº¦åæåçä¸å°½äººæã\n\n\n# æå¨éç½®language server\n\n# githubä¸è½½dafny\n\nä»¥dafny(v3.2.0)ä¸ºä¾ï¼è¿å¥dafny-langä¸è½½å¯¹åºçæ¬è¯­è¨åã\n\n# ç¸å³éç½®æä»¶\n\næ¾å°dafny.dllä¸dafnylanguageserver.dllæä»¶ï¼è®°ä½å¶æä»¶è·¯å¾ã\n\n# æ´æ¹ç¸å³è·¯å¾\n\nå¨vscodeå·¥ä½åº--æ©å±--dafny extensionä¸­ä¿®æ¹compiler runtime pathãlanguage server runtime pathä¸ºä»¥ä¸ä¸¤ä¸ªæä»¶çå¯¹åºè·¯å¾ã\n\n----------------------------------------\n\n\n# ç¬¬ä¸ä¸ªdafnyç¨åº\n\néç½®å®æï¼è®©æä»¬æ¥åå»ºä¸ªç®åçdafnyæä»¶æ¥ä½éªä¸ä¸å§ï¼\n\n * å®æ¶éªè¯\n\n * hello,dafny\n\n> ç¸å³é¾æ¥ï¼\n> \n> github wiki\n> \n> vscode dafny-extension\n> \n> youtube install dafny on windows",charsets:{cjk:!0},lastUpdated:"2022/03/26, 22:28:20",lastUpdatedTimestamp:16483049e5},{title:"å¿«éå¥é¨",frontmatter:{title:"å¿«éå¥é¨",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/085606/",categories:["éç½®"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/05.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"10.éç½®/10.ç¨èµ·æ¥å§/05.å¿«éå¥é¨.md",key:"v-714308ff",path:"/pages/085606/",headers:[{level:2,title:"åºæ¬å®ä¹",slug:"åºæ¬å®ä¹",normalizedTitle:"åºæ¬å®ä¹",charIndex:448},{level:2,title:"æ¹æ³ methods",slug:"æ¹æ³-methods",normalizedTitle:"æ¹æ³ methods",charIndex:787},{level:3,title:"æ¡æ¶Frame",slug:"æ¡æ¶frame",normalizedTitle:"æ¡æ¶frame",charIndex:1306},{level:3,title:"åä½å½æ° variant function",slug:"åä½å½æ°-variant-function",normalizedTitle:"åä½å½æ° variant function",charIndex:1545},{level:3,title:"ghost å³é®å­",slug:"ghost-å³é®å­",normalizedTitle:"ghost å³é®å­",charIndex:1691},{level:3,title:"this å³é®å­",slug:"this-å³é®å­",normalizedTitle:"this å³é®å­",charIndex:1754},{level:3,title:"æé å½æ°/æé ä½ constructor",slug:"æé å½æ°-æé ä½-constructor",normalizedTitle:"æé å½æ°/æé ä½ constructor",charIndex:1858},{level:3,title:"lemma å³é®å­",slug:"lemma-å³é®å­",normalizedTitle:"lemma å³é®å­",charIndex:2181},{level:2,title:"å½æ° function",slug:"å½æ°-function",normalizedTitle:"å½æ° function",charIndex:2581},{level:3,title:"ç±» class",slug:"ç±»-class",normalizedTitle:"ç±» class",charIndex:3516},{level:3,title:"æ°æ®ç±»å datatypes",slug:"æ°æ®ç±»å-datatypes",normalizedTitle:"æ°æ®ç±»å datatypes",charIndex:3624},{level:3,title:"æ³å Generics",slug:"æ³å-generics",normalizedTitle:"æ³å generics",charIndex:4278},{level:3,title:"å£°æ Statement",slug:"å£°æ-statement",normalizedTitle:"å£°æ statement",charIndex:4606},{level:4,title:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",slug:"å½æ°-æ¹æ³çè¿åå¼èµå¼ç»åé",normalizedTitle:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",charIndex:5043},{level:4,title:"assert å£°æ",slug:"assert-å£°æ",normalizedTitle:"assert å£°æ",charIndex:5476},{level:4,title:"print æå°è¯­å¥",slug:"print-æå°è¯­å¥",normalizedTitle:"print æå°è¯­å¥",charIndex:5523},{level:4,title:"if éæ©è¯­å¥",slug:"if-éæ©è¯­å¥",normalizedTitle:"if éæ©è¯­å¥",charIndex:5606},{level:4,title:"while å¾ªç¯è¯­å¥",slug:"while-å¾ªç¯è¯­å¥",normalizedTitle:"while å¾ªç¯è¯­å¥",charIndex:5676},{level:4,title:"matchè¯­å¥(é¿å·´é¿å·´)",slug:"matchè¯­å¥-é¿å·´é¿å·´",normalizedTitle:"matchè¯­å¥(é¿å·´é¿å·´)",charIndex:5969},{level:4,title:"breakè¯­å¥",slug:"breakè¯­å¥",normalizedTitle:"breakè¯­å¥",charIndex:6109},{level:2,title:"è¡¨è¾¾å¼ Expressions",slug:"è¡¨è¾¾å¼-expressions",normalizedTitle:"è¡¨è¾¾å¼ expressions",charIndex:6158},{level:3,title:"åºæ¬è¿ç®ç¬¦",slug:"åºæ¬è¿ç®ç¬¦",normalizedTitle:"åºæ¬è¿ç®ç¬¦",charIndex:6224},{level:4,title:"æ´æ°è¿ç®",slug:"æ´æ°è¿ç®",normalizedTitle:"æ´æ°è¿ç®",charIndex:6679},{level:4,title:"ç¦» æ£ æ° å­¦",slug:"ç¦»-æ£-æ°-å­¦",normalizedTitle:"ç¦» æ£ æ° å­¦",charIndex:6846},{level:4,title:"éåè¿ç®",slug:"éåè¿ç®",normalizedTitle:"éåè¿ç®",charIndex:6966},{level:4,title:"åºåè¿ç®",slug:"åºåè¿ç®",normalizedTitle:"åºåè¿ç®",charIndex:7187},{level:4,title:"if-then-elseå¤æ­è¯­å¥",slug:"if-then-elseå¤æ­è¯­å¥",normalizedTitle:"if-then-elseå¤æ­è¯­å¥",charIndex:7733},{level:4,title:"matchå¹éè¡¨è¾¾å¼",slug:"matchå¹éè¡¨è¾¾å¼",normalizedTitle:"matchå¹éè¡¨è¾¾å¼",charIndex:7896}],headersStr:"åºæ¬å®ä¹ æ¹æ³ methods æ¡æ¶Frame åä½å½æ° variant function ghost å³é®å­ this å³é®å­ æé å½æ°/æé ä½ constructor lemma å³é®å­ å½æ° function ç±» class æ°æ®ç±»å datatypes æ³å Generics å£°æ Statement å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé assert å£°æ print æå°è¯­å¥ if éæ©è¯­å¥ while å¾ªç¯è¯­å¥ matchè¯­å¥(é¿å·´é¿å·´) breakè¯­å¥ è¡¨è¾¾å¼ Expressions åºæ¬è¿ç®ç¬¦ æ´æ°è¿ç® ç¦» æ£ æ° å­¦ éåè¿ç® åºåè¿ç® if-then-elseå¤æ­è¯­å¥ matchå¹éè¡¨è¾¾å¼",content:"# åºç¡å­¦ä¹ \n\né¡µé¢è¯´æ\n\næ­¤é¡µé¢è¯´æäº Dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ Dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\nDafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼Dafnyæä»¶æ¯ä»¥dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼main`ä¸æ¯å¿é¡»çã\n\n> æ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)Tï¼\n\nvar x: T\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\nDafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<T>ï¼ä¸å¯åçæ åºéå\n * seq<T>ï¼ä¸å¯åçæåºéå\n * array<T>ãarray2<T>ãarray3<T>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã\n\n\n# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //è¾å¥è¾åºåæ°\nrequires Pre\t//åç½®æ¡ä»¶\nmodifies Frame  //æ¡æ¶\nensures Post\t//åç½®æ¡ä»¶\ndecreases TerminationMetric //åä½å½æ°\n{\nBody //å½æ°ä½`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * Pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * Frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°(Frame denotes a set of objects whose fields may be updated by the method)\n * Post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * TerminationMetric: æ¯æ¹æ³çåä½å½æ°(TerminationMetric is the methodâs variant function)\n * Body: æ¯å®ç°æ¹æ³çè¯­å¥ã\n\n\n# æ¡æ¶Frame\n\næ¡æ¶Frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶Frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»Cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çâtopâåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼Dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\nDafny IDE å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéææ¹æ³ M å¯ä»¥ç± C.M(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨` \nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼`\n\n{\n  Body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³(method)å³é®å­ä¼è¢«å¼ç(lemmas)åä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶`\n{\nx, y, z := a, b, c;\nif z < y {\ny, z := z, y;\n}\nif y < x {\n    x, y := y, x;\n  }\nif z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction F(a: A, b: B, c: C): T\nrequires Pre  //åç½®æ¡ä»¶pre\nreads Frame\t//æ¡æ¶frame\nensures Post //åç½®æ¡ä»¶post\ndecreases TerminationMetric //åä½å½æ°\n{\n  Body\t//å½æ°ä½\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : è¾å¥çå½¢åï¼\n * T : è¿åç»æçç±»åï¼\n * Pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * Frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * Post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * TerminationMetric: åä½å½æ°\n * Body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ Dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦Factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction Factorial(n: int): int\nrequires 0 <= n //åç½®æ¡ä»¶pre\nensures 1 <= Factorial(n) //åç½®æ¡ä»¶post\n{\n if n == 0 then 1 else Factorial(n-1) * n //å½æ°ä½body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­staticæ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéæå½æ° F å¯ä»¥è¢« C.F(...) è°ç¨ã\n\n\n# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass C {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã\n\n\n# æ°æ®ç±»å datatypes\n\nå½çº³æ°æ®ç±»åï¼inductive datatypeï¼æ¯ä¸ç§ç±»åï¼å¶å¼æ¯ç¨ä¸ç»åºå®çæé å½æ°åå»ºçã\n\næ°æ®ç±»å ä¸ºTreeå¸¦ææé å½æ° Leaf å Node çå½æ°å£°æå¦ä¸ï¼\n\ndatatype Tree = Leaf | Node(Tree, int, Tree)//Leafä¸ºæ åæé å½æ° Nodeä¸ºæå\n\næé å½æ°ç±ç«çº¿åéã æ åæ°æé å½æ°ä¸éè¦ä½¿ç¨æ¬å·ï¼å¦ Leaf æç¤ºã\n\nå¯¹äºæ¯ä¸ªæé å½æ° Ctï¼æ°æ®ç±»åéå¼å£°æäºä¸ä¸ªå¸å°æå Ct?ï¼å¯¹äºå·²ç»ä½¿ç¨ Ct æé å½æ°èµçå¼çæåï¼å®è¿å trueã ä¾å¦ï¼å¨ä»£ç çæ®µä¹åï¼\n\nvar t0 := Leaf; var t1 := Node(t0, 5, t0);\n\nè¡¨è¾¾å¼ t1.Nodeç»æä¸º true, t0.Nodeç»æä¸ºfalseã\n\nå¦æä¸¤ä¸ªæ°æ®ç±»åå¼æ¯ä½¿ç¨ç¸åçæé å½æ°åè¯¥æé å½æ°çç¸ååæ°åå»ºçï¼åå®ä»¬æ¯ç¸ç­çãå æ­¤ï¼å¯¹äºå Leafãt.Leaf è¿æ ·çæ åæ°æé å½æ°ï¼Dafnyä¼ç»åºä¸ t == Leaf ç¸åçç»æã(æ²¡çæï¼ä¸ç®¡äº)\n\næé å½æ°å¯ä»¥éæ©ä¸ºå¶ä»»ä½åæ°å£°æææå½æ°ï¼è¿æ¯éè¿ä¸ºåæ°å¼å¥åç§°æ¥å®æçã ä¾å¦ï¼å¦æ Tree è¢«å£°æä¸ºï¼\n\ndatatype Tree = Leaf | Node(left: Tree, data: int, right: Tree)\n\né£ä¹t1.data == 5åt1.left == t0å¨ä¸é¢çä»£ç çæ®µä¹åä¿æä¸åã(è¿æ¯æ²¡æ)\n\n\n# æ³å Generics\n\nDafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åT\n\nclass MyMultiset<T> {\n /*...*/\n}\t\t//ç±»æ³å\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //èªå®ä¹æ°æ®æ³å\nmethod Find<T>(key: T, collection: Tree<T>) { //æ¹æ³æ³å`\n /*...*/\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T {\t//å½æ°æ³å\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# å£°æ Statement\n\nä»¥ä¸æ¯ Dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar LocalVariables := ExprList;\nLvalues := ExprList;\nassert BoolExpr;\nprint ExprList;\n\nif BoolExpr0 {\n  Stmts0\n} else if BoolExpr1 {\n  Stmts1\n} else {\n  Stmts2\n}\n\n  while BoolExpr\n  invariant Inv\n  modifies Frame\n  decreases Rank\n{\n  Stmts\n}\n match Expr {\n  case Empty => Stmts0\n  case Node(l, d, r) => Stmts1\n}\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ªå±é¨åéèå·²ï¼ var LocalVariables := ExprList; var è¯­å¥å¼å¥äºå±é¨åéã Lvalues := ExprList;\n\nèµå¼è¯­å¥å° ExprListåéèµç»Lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç L å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º T çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºTæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifiesè¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reductionè¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã(çæ²¡çæï¼\n\nwhile BoolExpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶`\n  invariant Inv\n  modifies Frame\n  decreases Rank\n\n{\n  Statements\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# matchè¯­å¥(é¿å·´é¿å·´)\n\nmatch è¯­å¥è®¡ç®æº Exprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã\n\n\n# è¡¨è¾¾å¼ Expressions\n\nDafny ä¸­çè¡¨è¾¾å¼ä¸ç±» Java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼Dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==>ä½çç»å®åï¼èåèåæ¯ && å ||å·ææ´ä½çç»å®åã\n\nDafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çç¸åæ¹åçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.Length == N\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.Length && a.Length == N\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ == å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å %ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç % æ»æ¯å¯¼è´éè´æ°ã ï¼å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ CãJava æ C# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/Modulo_operationãï¼\n\n# ç¦» æ£ æ° å­¦\n\nDafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: Expr åexists x :: Exprï¼å¶ä¸­xæ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: T ä¸­æç¤ºï¼ï¼èExpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã S ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå S çæåï¼è x !in S æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in S)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in S å x !in Sãåºå S çé¿åº¦è¡¨ç¤ºä¸º |S|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |S| çç´¢å¼ãè¡¨è¾¾å¼ S[j] è¡¨ç¤ºåºå S çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ S[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |S|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯S ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» S[m]ãS[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ S[n]ï¼ãè¡¨è¾¾å¼ S[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâ)ä¸ S[m..|S|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ S çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ S[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ S[0..n] ç¸åï¼å³å®è¿åç± S çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå S çææç´¢å¼ï¼åè¡¨è¾¾å¼ S[j := x];æ¯ç±»ä¼¼äº S çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾ [x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if BoolExpr then Expr0 else Expr1\n\nå¶ä¸­ Expr0 å Expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",normalizedContent:"# åºç¡å­¦ä¹ \n\né¡µé¢è¯´æ\n\næ­¤é¡µé¢è¯´æäº dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\ndafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼dafnyæä»¶æ¯ä»¥dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼main`ä¸æ¯å¿é¡»çã\n\n> æ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)tï¼\n\nvar x: t\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\ndafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<t>ï¼ä¸å¯åçæ åºéå\n * seq<t>ï¼ä¸å¯åçæåºéå\n * array<t>ãarray2<t>ãarray3<t>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã\n\n\n# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //è¾å¥è¾åºåæ°\nrequires pre\t//åç½®æ¡ä»¶\nmodifies frame  //æ¡æ¶\nensures post\t//åç½®æ¡ä»¶\ndecreases terminationmetric //åä½å½æ°\n{\nbody //å½æ°ä½`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°(frame denotes a set of objects whose fields may be updated by the method)\n * post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * terminationmetric: æ¯æ¹æ³çåä½å½æ°(terminationmetric is the methodâs variant function)\n * body: æ¯å®ç°æ¹æ³çè¯­å¥ã\n\n\n# æ¡æ¶frame\n\næ¡æ¶frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çâtopâåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\ndafny ide å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéææ¹æ³ m å¯ä»¥ç± c.m(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨` \nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼`\n\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³(method)å³é®å­ä¼è¢«å¼ç(lemmas)åä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶`\n{\nx, y, z := a, b, c;\nif z < y {\ny, z := z, y;\n}\nif y < x {\n    x, y := y, x;\n  }\nif z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction f(a: a, b: b, c: c): t\nrequires pre  //åç½®æ¡ä»¶pre\nreads frame\t//æ¡æ¶frame\nensures post //åç½®æ¡ä»¶post\ndecreases terminationmetric //åä½å½æ°\n{\n  body\t//å½æ°ä½\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : è¾å¥çå½¢åï¼\n * t : è¿åç»æçç±»åï¼\n * pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * terminationmetric: åä½å½æ°\n * body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction factorial(n: int): int\nrequires 0 <= n //åç½®æ¡ä»¶pre\nensures 1 <= factorial(n) //åç½®æ¡ä»¶post\n{\n if n == 0 then 1 else factorial(n-1) * n //å½æ°ä½body\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­staticæ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéæå½æ° f å¯ä»¥è¢« c.f(...) è°ç¨ã\n\n\n# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass c {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã\n\n\n# æ°æ®ç±»å datatypes\n\nå½çº³æ°æ®ç±»åï¼inductive datatypeï¼æ¯ä¸ç§ç±»åï¼å¶å¼æ¯ç¨ä¸ç»åºå®çæé å½æ°åå»ºçã\n\næ°æ®ç±»å ä¸ºtreeå¸¦ææé å½æ° leaf å node çå½æ°å£°æå¦ä¸ï¼\n\ndatatype tree = leaf | node(tree, int, tree)//leafä¸ºæ åæé å½æ° nodeä¸ºæå\n\næé å½æ°ç±ç«çº¿åéã æ åæ°æé å½æ°ä¸éè¦ä½¿ç¨æ¬å·ï¼å¦ leaf æç¤ºã\n\nå¯¹äºæ¯ä¸ªæé å½æ° ctï¼æ°æ®ç±»åéå¼å£°æäºä¸ä¸ªå¸å°æå ct?ï¼å¯¹äºå·²ç»ä½¿ç¨ ct æé å½æ°èµçå¼çæåï¼å®è¿å trueã ä¾å¦ï¼å¨ä»£ç çæ®µä¹åï¼\n\nvar t0 := leaf; var t1 := node(t0, 5, t0);\n\nè¡¨è¾¾å¼ t1.nodeç»æä¸º true, t0.nodeç»æä¸ºfalseã\n\nå¦æä¸¤ä¸ªæ°æ®ç±»åå¼æ¯ä½¿ç¨ç¸åçæé å½æ°åè¯¥æé å½æ°çç¸ååæ°åå»ºçï¼åå®ä»¬æ¯ç¸ç­çãå æ­¤ï¼å¯¹äºå leafãt.leaf è¿æ ·çæ åæ°æé å½æ°ï¼dafnyä¼ç»åºä¸ t == leaf ç¸åçç»æã(æ²¡çæï¼ä¸ç®¡äº)\n\næé å½æ°å¯ä»¥éæ©ä¸ºå¶ä»»ä½åæ°å£°æææå½æ°ï¼è¿æ¯éè¿ä¸ºåæ°å¼å¥åç§°æ¥å®æçã ä¾å¦ï¼å¦æ tree è¢«å£°æä¸ºï¼\n\ndatatype tree = leaf | node(left: tree, data: int, right: tree)\n\né£ä¹t1.data == 5åt1.left == t0å¨ä¸é¢çä»£ç çæ®µä¹åä¿æä¸åã(è¿æ¯æ²¡æ)\n\n\n# æ³å generics\n\ndafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åt\n\nclass mymultiset<t> {\n /*...*/\n}\t\t//ç±»æ³å\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //èªå®ä¹æ°æ®æ³å\nmethod find<t>(key: t, collection: tree<t>) { //æ¹æ³æ³å`\n /*...*/\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t {\t//å½æ°æ³å\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# å£°æ statement\n\nä»¥ä¸æ¯ dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar localvariables := exprlist;\nlvalues := exprlist;\nassert boolexpr;\nprint exprlist;\n\nif boolexpr0 {\n  stmts0\n} else if boolexpr1 {\n  stmts1\n} else {\n  stmts2\n}\n\n  while boolexpr\n  invariant inv\n  modifies frame\n  decreases rank\n{\n  stmts\n}\n match expr {\n  case empty => stmts0\n  case node(l, d, r) => stmts1\n}\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ªå±é¨åéèå·²ï¼ var localvariables := exprlist; var è¯­å¥å¼å¥äºå±é¨åéã lvalues := exprlist;\n\nèµå¼è¯­å¥å° exprliståéèµç»lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç l å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º t çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºtæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifiesè¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reductionè¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã(çæ²¡çæï¼\n\nwhile boolexpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶`\n  invariant inv\n  modifies frame\n  decreases rank\n\n{\n  statements\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# matchè¯­å¥(é¿å·´é¿å·´)\n\nmatch è¯­å¥è®¡ç®æº exprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã\n\n\n# è¡¨è¾¾å¼ expressions\n\ndafny ä¸­çè¡¨è¾¾å¼ä¸ç±» java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==>ä½çç»å®åï¼èåèåæ¯ && å ||å·ææ´ä½çç»å®åã\n\ndafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çç¸åæ¹åçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.length == n\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.length && a.length == n\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ == å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å %ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç % æ»æ¯å¯¼è´éè´æ°ã ï¼å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ cãjava æ c# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/modulo_operationãï¼\n\n# ç¦» æ£ æ° å­¦\n\ndafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: expr åexists x :: exprï¼å¶ä¸­xæ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: t ä¸­æç¤ºï¼ï¼èexpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã s ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå s çæåï¼è x !in s æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in s)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in s å x !in sãåºå s çé¿åº¦è¡¨ç¤ºä¸º |s|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |s| çç´¢å¼ãè¡¨è¾¾å¼ s[j] è¡¨ç¤ºåºå s çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ s[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |s|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯s ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» s[m]ãs[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ s[n]ï¼ãè¡¨è¾¾å¼ s[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâ)ä¸ s[m..|s|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ s çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ s[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ s[0..n] ç¸åï¼å³å®è¿åç± s çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå s çææç´¢å¼ï¼åè¡¨è¾¾å¼ s[j := x];æ¯ç±»ä¼¼äº s çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾ [x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if boolexpr then expr0 else expr1\n\nå¶ä¸­ expr0 å expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"ç®åä¸æ",frontmatter:{title:"ç®åä¸æ",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/39fb20/",categories:["éç½®"],tags:[null],readingShow:"top"},regularPath:"/10.%E9%85%8D%E7%BD%AE/10.%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%90%A7/10.%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B.html",relativePath:"10.éç½®/10.ç¨èµ·æ¥å§/10.ç®åä¸æ.md",key:"v-4ac269ee",path:"/pages/39fb20/",headers:[{level:2,title:"å®æ¶éªè¯",slug:"å®æ¶éªè¯",normalizedTitle:"å®æ¶éªè¯",charIndex:42},{level:2,title:"hello,Dafny",slug:"hello-dafny",normalizedTitle:"hello,dafny",charIndex:51}],headersStr:"å®æ¶éªè¯ hello,Dafny",content:"# Demo\n\néç½®å®æï¼è®©æä»¬æ¥åå»ºä¸ªç®åçdafnyæä»¶æ¥ä½éªä¸ä¸å§ï¼\n\n\n# å®æ¶éªè¯\n\n\n# hello,Dafny",normalizedContent:"# demo\n\néç½®å®æï¼è®©æä»¬æ¥åå»ºä¸ªç®åçdafnyæä»¶æ¥ä½éªä¸ä¸å§ï¼\n\n\n# å®æ¶éªè¯\n\n\n# hello,dafny",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"çè¨æ¿",frontmatter:{title:"çè¨æ¿",date:"2022-03-24T12:22:23.000Z",permalink:"/pages/caf1f9/",categories:["ç¤¾åºçè¨æ¿"],tags:null,article:!1,sidebar:!1,editLink:!1,readingShow:"top"},regularPath:"/100.%E7%A4%BE%E5%8C%BA%E7%95%99%E8%A8%80%E6%9D%BF/%E7%95%99%E8%A8%80%E6%9D%BF.html",relativePath:"100.ç¤¾åºçè¨æ¿/çè¨æ¿.md",key:"v-135bff0e",path:"/pages/caf1f9/",headersStr:null,content:"# Welcome Developers\n\nç¬è®°\n\nDafnyä¸­æç¤¾åºæ¬¢è¿åä½ä½¿ç¨èç§¯æåé¦,æä»¬å°å¨æ­¤å®æ¶æ´æ°æ¬ç«ç¹ä¸»é¢åç¸å³ç»ä»¶ççæ¬ä¿¡æ¯åèµæºé¾æ¥ã\n\n",normalizedContent:"# welcome developers\n\nç¬è®°\n\ndafnyä¸­æç¤¾åºæ¬¢è¿åä½ä½¿ç¨èç§¯æåé¦,æä»¬å°å¨æ­¤å®æ¶æ´æ°æ¬ç«ç¹ä¸»é¢åç¸å³ç»ä»¶ççæ¬ä¿¡æ¯åèµæºé¾æ¥ã\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/25, 21:08:04",lastUpdatedTimestamp:1648213684e3},{title:"åºç¡ Basic",frontmatter:{title:"åºç¡ Basic",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/6e15a6/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/00.%E5%9F%BA%E7%A1%80%20Basic.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/00.åºç¡ Basic.md",key:"v-240065b4",path:"/pages/6e15a6/",headers:[{level:2,title:"Dafnyæ¯ä»ä¹æ ·ï¼",slug:"dafnyæ¯ä»ä¹æ ·",normalizedTitle:"dafnyæ¯ä»ä¹æ ·ï¼",charIndex:128},{level:2,title:"åºæ¬å®ä¹",slug:"åºæ¬å®ä¹",normalizedTitle:"åºæ¬å®ä¹",charIndex:459}],headersStr:"Dafnyæ¯ä»ä¹æ ·ï¼ åºæ¬å®ä¹",content:"# åºç¡å­¦ä¹ \n\næç¤º\n\næ­¤é¡µé¢è¯´æäº Dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ Dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\n\n# Dafnyæ¯ä»ä¹æ ·ï¼\n\nDafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼Dafnyæä»¶æ¯ä»¥.dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼mainä¸æ¯å¿é¡»çã\n\næ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)Tï¼\n\nvar x: T\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\nDafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<T>ï¼ä¸å¯åçæ åºéå\n * seq<T>ï¼ä¸å¯åçæåºéå\n * array<T>ãarray2<T>ãarray3<T>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã",normalizedContent:"# åºç¡å­¦ä¹ \n\næç¤º\n\næ­¤é¡µé¢è¯´æäº dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\n\n# dafnyæ¯ä»ä¹æ ·ï¼\n\ndafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼dafnyæä»¶æ¯ä»¥.dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼mainä¸æ¯å¿é¡»çã\n\næ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)tï¼\n\nvar x: t\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\ndafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<t>ï¼ä¸å¯åçæ åºéå\n * seq<t>ï¼ä¸å¯åçæåºéå\n * array<t>ãarray2<t>ãarray3<t>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"æ¹æ³ Method",frontmatter:{title:"æ¹æ³ Method",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/eba166/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05.%E6%96%B9%E6%B3%95%20Method.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/05.æ¹æ³ Method.md",key:"v-4fafc755",path:"/pages/eba166/",headers:[{level:2,title:"æ¡æ¶Frame",slug:"æ¡æ¶frame",normalizedTitle:"æ¡æ¶frame",charIndex:563},{level:2,title:"åä½å½æ° variant function",slug:"åä½å½æ°-variant-function",normalizedTitle:"åä½å½æ° variant function",charIndex:802}],headersStr:"æ¡æ¶Frame åä½å½æ° variant function",content:"# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //è¾å¥è¾åºåæ°\n\trequires Pre\t//åç½®æ¡ä»¶  \n\tmodifies Frame  //æ¡æ¶\n\tensures Post\t//åç½®æ¡ä»¶\n  decreases TerminationMetric //åä½å½æ°\n{\n \tmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //è¾å¥è¾åºåæ°\n \t requires Pre\t//åç½®æ¡ä»¶\t\n \t modifies Frame  //æ¡æ¶\t\n \t ensures Post\t//åç½®æ¡ä»¶\n \t decreases TerminationMetric //åä½å½æ°\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * Pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * Frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°\n * Post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * TerminationMetric: æ¯æ¹æ³çåä½å½æ°\n\n\n# æ¡æ¶Frame\n\næ¡æ¶Frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶Frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»Cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çtopåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼Dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\nDafny IDE å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã",normalizedContent:"# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //è¾å¥è¾åºåæ°\n\trequires pre\t//åç½®æ¡ä»¶  \n\tmodifies frame  //æ¡æ¶\n\tensures post\t//åç½®æ¡ä»¶\n  decreases terminationmetric //åä½å½æ°\n{\n \tmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //è¾å¥è¾åºåæ°\n \t requires pre\t//åç½®æ¡ä»¶\t\n \t modifies frame  //æ¡æ¶\t\n \t ensures post\t//åç½®æ¡ä»¶\n \t decreases terminationmetric //åä½å½æ°\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°\n * post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * terminationmetric: æ¯æ¹æ³çåä½å½æ°\n\n\n# æ¡æ¶frame\n\næ¡æ¶frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çtopåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\ndafny ide å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å³é®å­ Keyword",frontmatter:{title:"å³é®å­ Keyword",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/83cdf9/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/10.%E5%85%B3%E9%94%AE%E5%AD%97%20Keyword.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/10.å³é®å­ Keyword.md",key:"v-350b180b",path:"/pages/83cdf9/",headers:[{level:2,title:"ghost å³é®å­",slug:"ghost-å³é®å­",normalizedTitle:"ghost å³é®å­",charIndex:12},{level:2,title:"this å³é®å­",slug:"this-å³é®å­",normalizedTitle:"this å³é®å­",charIndex:75},{level:2,title:"æé å½æ°/æé ä½ constructor",slug:"æé å½æ°-æé ä½-constructor",normalizedTitle:"æé å½æ°/æé ä½ constructor",charIndex:179},{level:2,title:"lemma å³é®å­",slug:"lemma-å³é®å­",normalizedTitle:"lemma å³é®å­",charIndex:496}],headersStr:"ghost å³é®å­ this å³é®å­ æé å½æ°/æé ä½ constructor lemma å³é®å­",content:"# ç¹æ®å³é®å­\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéææ¹æ³ M å¯ä»¥ç± C.M(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨\nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼\n{\n  Body\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³methodå³é®å­ä¼è¢«å¼çlemmasåä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶\n\n{\n  x, y, z := a, b, c;\n  if z < y {\n    y, z := z, y;\n  }\n  if y < x {\n    x, y := y, x;\n  }\n  if z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# ç¹æ®å³é®å­\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéææ¹æ³ m å¯ä»¥ç± c.m(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨\nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³methodå³é®å­ä¼è¢«å¼çlemmasåä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶\n\n{\n  x, y, z := a, b, c;\n  if z < y {\n    y, z := z, y;\n  }\n  if y < x {\n    x, y := y, x;\n  }\n  if z < y {\n    y, z := z, y;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å½æ° Function",frontmatter:{title:"å½æ° Function",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/01d76e/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/15.%E5%87%BD%E6%95%B0%20Function.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/15.å½æ° Function.md",key:"v-e0d76c86",path:"/pages/01d76e/",headersStr:null,content:"# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction F(a: A, b: B, c: C): T\n  requires Pre  //åç½®æ¡ä»¶pre\n  reads Frame\t//æ¡æ¶frame\n  ensures Post //åç½®æ¡ä»¶post\n  decreases TerminationMetric //åä½å½æ°\n{\n  Body\t//å½æ°ä½\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : è¾å¥çå½¢åï¼\n * T : è¿åç»æçç±»åï¼\n * Pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * Frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * Post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * TerminationMetric: åä½å½æ°\n * Body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ Dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦Factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction Factorial(n: int): int\n requires 0 <= n //åç½®æ¡ä»¶pre\n\n ensures 1 <= Factorial(n) //åç½®æ¡ä»¶post\n\n{\n if n == 0 then 1 else Factorial(n-1) * n //å½æ°ä½body\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéæå½æ° F å¯ä»¥è¢« C.F(...) è°ç¨ã",normalizedContent:"# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction f(a: a, b: b, c: c): t\n  requires pre  //åç½®æ¡ä»¶pre\n  reads frame\t//æ¡æ¶frame\n  ensures post //åç½®æ¡ä»¶post\n  decreases terminationmetric //åä½å½æ°\n{\n  body\t//å½æ°ä½\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * a, b, c : è¾å¥çå½¢åï¼\n * t : è¿åç»æçç±»åï¼\n * pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * terminationmetric: åä½å½æ°\n * body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction factorial(n: int): int\n requires 0 <= n //åç½®æ¡ä»¶pre\n\n ensures 1 <= factorial(n) //åç½®æ¡ä»¶post\n\n{\n if n == 0 then 1 else factorial(n-1) * n //å½æ°ä½body\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéæå½æ° f å¯ä»¥è¢« c.f(...) è°ç¨ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"ç±» Class",frontmatter:{title:"ç±» Class",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/0fadc1/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/20.%E7%B1%BB%20Class.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/20.ç±» Class.md",key:"v-a626afce",path:"/pages/0fadc1/",headersStr:null,content:"# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass C {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã",normalizedContent:"# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass c {\n // member declarations go here\n}\n\n\n1\n2\n3\n\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"æ³å Generics",frontmatter:{title:"æ³å Generics",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/a010ab/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/30.%E6%B3%9B%E5%9E%8B%20Generics.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/30.æ³å Generics.md",key:"v-57bdc255",path:"/pages/a010ab/",headersStr:null,content:"# æ³å Generics\n\nDafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åT\n\nclass MyMultiset<T> {\n /*...*/\n}\t\t//ç±»æ³å\n\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //èªå®ä¹æ°æ®æ³å\nmethod Find<T>(key: T, collection: Tree<T>) { //æ¹æ³æ³å\n /*...*/\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T {\t//å½æ°æ³å\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# æ³å generics\n\ndafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åt\n\nclass mymultiset<t> {\n /*...*/\n}\t\t//ç±»æ³å\n\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //èªå®ä¹æ°æ®æ³å\nmethod find<t>(key: t, collection: tree<t>) { //æ¹æ³æ³å\n /*...*/\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t {\t//å½æ°æ³å\n /*...*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å£°æ Statement",frontmatter:{title:"å£°æ Statement",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/c4fda3/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/35.%E5%A3%B0%E6%98%8E%20Statement.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/35.å£°æ Statement.md",key:"v-96b41596",path:"/pages/c4fda3/",headers:[{level:2,title:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",slug:"å½æ°-æ¹æ³çè¿åå¼èµå¼ç»åé",normalizedTitle:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",charIndex:467},{level:2,title:"assert å£°æ",slug:"assert-å£°æ",normalizedTitle:"assert å£°æ",charIndex:905},{level:2,title:"print æå°è¯­å¥",slug:"print-æå°è¯­å¥",normalizedTitle:"print æå°è¯­å¥",charIndex:953},{level:2,title:"if éæ©è¯­å¥",slug:"if-éæ©è¯­å¥",normalizedTitle:"if éæ©è¯­å¥",charIndex:1037},{level:2,title:"while å¾ªç¯è¯­å¥",slug:"while-å¾ªç¯è¯­å¥",normalizedTitle:"while å¾ªç¯è¯­å¥",charIndex:1108},{level:2,title:"matchè¯­å¥",slug:"matchè¯­å¥",normalizedTitle:"matchè¯­å¥",charIndex:1369},{level:2,title:"breakè¯­å¥",slug:"breakè¯­å¥",normalizedTitle:"breakè¯­å¥",charIndex:1503}],headersStr:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé assert å£°æ print æå°è¯­å¥ if éæ©è¯­å¥ while å¾ªç¯è¯­å¥ matchè¯­å¥ breakè¯­å¥",content:"# å£°æ Statement\n\nä»¥ä¸æ¯ Dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar LocalVariables := ExprList;\n Lvalues := ExprList;\n assert BoolExpr;\n print ExprList;\n if BoolExpr0 {\n  Stmts0\n } else if BoolExpr1 {\n  Stmts1\n } else {\n  Stmts2\n }\n\n while BoolExpr\n\n  invariant Inv\n\n  modifies Frame\n\n  decreases Rank\n\n {\n  Stmts\n }\n\nmatch Expr {\n  case Empty => Stmts0\n  case Node(l, d, r) => Stmts1\n}\n\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ª å±é¨åé èå·²ï¼\n\nvar LocalVariables := ExprList;\n\nvar è¯­å¥å¼å¥äºå±é¨åéã\n\nLvalues := ExprList; èµå¼è¯­å¥å° ExprListåéèµç»Lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç L å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º T çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºTæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifies è¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reduction è¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã\n\nwhile BoolExpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶ invariant Inv modifies Frame decreases Rank { Statements }\n\n\n# matchè¯­å¥\n\nmatch è¯­å¥è®¡ç®æºExprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã",normalizedContent:"# å£°æ statement\n\nä»¥ä¸æ¯ dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar localvariables := exprlist;\n lvalues := exprlist;\n assert boolexpr;\n print exprlist;\n if boolexpr0 {\n  stmts0\n } else if boolexpr1 {\n  stmts1\n } else {\n  stmts2\n }\n\n while boolexpr\n\n  invariant inv\n\n  modifies frame\n\n  decreases rank\n\n {\n  stmts\n }\n\nmatch expr {\n  case empty => stmts0\n  case node(l, d, r) => stmts1\n}\n\n break;\n return;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ª å±é¨åé èå·²ï¼\n\nvar localvariables := exprlist;\n\nvar è¯­å¥å¼å¥äºå±é¨åéã\n\nlvalues := exprlist; èµå¼è¯­å¥å° exprliståéèµç»lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç l å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º t çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºtæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifies è¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reduction è¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã\n\nwhile boolexpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶ invariant inv modifies frame decreases rank { statements }\n\n\n# matchè¯­å¥\n\nmatch è¯­å¥è®¡ç®æºexprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"è¡¨è¾¾å¼ Expression",frontmatter:{title:"è¡¨è¾¾å¼ Expression",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/e8438e/",categories:["æå"],tags:[null],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/00.Dafny%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/40.%E8%A1%A8%E8%BE%BE%E5%BC%8F%20Expression.html",relativePath:"20.æå/00.Dafnyå¿«éå¥é¨/40.è¡¨è¾¾å¼ Expression.md",key:"v-6de99164",path:"/pages/e8438e/",headers:[{level:2,title:"åºæ¬è¿ç®ç¬¦",slug:"åºæ¬è¿ç®ç¬¦",normalizedTitle:"åºæ¬è¿ç®ç¬¦",charIndex:68},{level:2,title:"æ´æ°è¿ç®",slug:"æ´æ°è¿ç®",normalizedTitle:"æ´æ°è¿ç®",charIndex:527},{level:2,title:"ç¦»æ£æ°å­¦",slug:"ç¦»æ£æ°å­¦",normalizedTitle:"ç¦»æ£æ°å­¦",charIndex:695},{level:2,title:"éåè¿ç®",slug:"éåè¿ç®",normalizedTitle:"éåè¿ç®",charIndex:814},{level:2,title:"åºåè¿ç®",slug:"åºåè¿ç®",normalizedTitle:"åºåè¿ç®",charIndex:1036},{level:2,title:"if-then-elseå¤æ­è¯­å¥",slug:"if-then-elseå¤æ­è¯­å¥",normalizedTitle:"if-then-elseå¤æ­è¯­å¥",charIndex:1582},{level:2,title:"matchå¹éè¡¨è¾¾å¼",slug:"matchå¹éè¡¨è¾¾å¼",normalizedTitle:"matchå¹éè¡¨è¾¾å¼",charIndex:1746}],headersStr:"åºæ¬è¿ç®ç¬¦ æ´æ°è¿ç® ç¦»æ£æ°å­¦ éåè¿ç® åºåè¿ç® if-then-elseå¤æ­è¯­å¥ matchå¹éè¡¨è¾¾å¼",content:"# è¡¨è¾¾å¼ Expressions\n\nDafny ä¸­çè¡¨è¾¾å¼ä¸ç±» Java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼Dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==> ä½çç»å®åï¼èåèåæ¯ && å || å·ææ´ä½çç»å®åã\n\nDafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çâç¸åæ¹åâçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.Length == N\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.Length && a.Length == N\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ ==å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å%ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç% æ»æ¯å¯¼è´éè´æ°ã\n\n> å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ CãJava æ C# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/Modulo_operationãï¼\n\n\n# ç¦»æ£æ°å­¦\n\nDafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: Expr åexists x :: Exprï¼å¶ä¸­x æ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: T ä¸­æç¤ºï¼ï¼èExpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã S ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå S çæåï¼è x !in S æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in S)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in S å x !in Sãåºå S çé¿åº¦è¡¨ç¤ºä¸º |S|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |S| çç´¢å¼ãè¡¨è¾¾å¼ S[j] è¡¨ç¤ºåºå S çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ S[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |S|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯S ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» S[m]ãS[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ S[n]ï¼ãè¡¨è¾¾å¼ S[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâï¼ä¸ S[m..|S|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ S çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ S[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ S[0..n] ç¸åï¼å³å®è¿åç± S çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå S çææç´¢å¼ï¼åè¡¨è¾¾å¼ S[j := x];æ¯ç±»ä¼¼äº S çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾[x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if BoolExpr then Expr0 else Expr1\n\nå¶ä¸­ Expr0 å Expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",normalizedContent:"# è¡¨è¾¾å¼ expressions\n\ndafny ä¸­çè¡¨è¾¾å¼ä¸ç±» java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==> ä½çç»å®åï¼èåèåæ¯ && å || å·ææ´ä½çç»å®åã\n\ndafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çâç¸åæ¹åâçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.length == n\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.length && a.length == n\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ ==å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å%ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç% æ»æ¯å¯¼è´éè´æ°ã\n\n> å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ cãjava æ c# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/modulo_operationãï¼\n\n\n# ç¦»æ£æ°å­¦\n\ndafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: expr åexists x :: exprï¼å¶ä¸­x æ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: t ä¸­æç¤ºï¼ï¼èexpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã s ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå s çæåï¼è x !in s æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in s)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in s å x !in sãåºå s çé¿åº¦è¡¨ç¤ºä¸º |s|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |s| çç´¢å¼ãè¡¨è¾¾å¼ s[j] è¡¨ç¤ºåºå s çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ s[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |s|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯s ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» s[m]ãs[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ s[n]ï¼ãè¡¨è¾¾å¼ s[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâï¼ä¸ s[m..|s|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ s çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ s[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ s[0..n] ç¸åï¼å³å®è¿åç± s çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå s çææç´¢å¼ï¼åè¡¨è¾¾å¼ s[j := x];æ¯ç±»ä¼¼äº s çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾[x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if boolexpr then expr0 else expr1\n\nå¶ä¸­ expr0 å expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å¯»æ¾æå¤§åæå°æ°",frontmatter:{title:"å¯»æ¾æå¤§åæå°æ°",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/0978ce/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/00.%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E5%92%8C%E6%9C%80%E5%B0%8F%E6%95%B0.html",relativePath:"20.æå/10.ç®åä¾å­/00.å¯»æ¾æå¤§åæå°æ°.md",key:"v-fb6a0bc6",path:"/pages/0978ce/",headersStr:null,content:"# å¯»æ¾æå¤§åæå°æ°\n\nè¾å¥ä¸¤ä¸ªæ´æ°ï¼è¿åä¸¤ä¸ªå¼ï¼å®ä»¬ç»è¿+/-è¿ç®åè¾å¤§çæ°åè¾å°çæ°ã\n\næä»¬å¨å½æ°ä½ä¸­å®ä¹è¾å¤§å¼ä¸ºä¸¤èå åï¼è¾å°å¼ä¸ºä¸¤èç¸åã\n\nå¨è¿åå¼returnséæä»¬å¯ä»¥å®ä¹åémoreï¼lessï¼ä»¥ä¾¿å¨å½æ°ä½ä¸­ä½¿ç¨å®ä»¬ã\n\nmethod Maxmin(x:int, y:int) returns (more:int, less:int)    \nensures y > 0 ==> less < x < more\nensures y < 0 ==> more < x < less  \n{\n    more := x + y;\n    less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¶ä¸­ï¼ensuresä»£è¡¨åç½®æ¡ä»¶ï¼è¿ééè¦ç¡®ä¿ç¬¬äºä¸ªæ°å¤§äº0æ¶ï¼è¾å¤§æ°å¤§äºç¬¬ä¸ä¸ªæ°ï¼ç¬¬äºä¸ªæ°å°äº0æ¶ï¼è¾å°æ°å¤§äºç¬¬ä¸ä¸ªæ°ãç±äºæä»¬å¨å½æ°ä½ä¸­å®ä¹è¾å¤§å¼ä¸ºä¸¤èå åï¼è¾å°å¼ä¸ºä¸¤èç¸åï¼æ¾ç¶å¨y < 0æ¶æ¯ä¸æç«çï¼å©ç¨è¿ä¸¤ä¸ªéå®æ¡ä»¶å¯ä»¥å¸®å©Dafnyå¤æ­è¯¥ç¨åºçæ­£ç¡®æ§ã",normalizedContent:"# å¯»æ¾æå¤§åæå°æ°\n\nè¾å¥ä¸¤ä¸ªæ´æ°ï¼è¿åä¸¤ä¸ªå¼ï¼å®ä»¬ç»è¿+/-è¿ç®åè¾å¤§çæ°åè¾å°çæ°ã\n\næä»¬å¨å½æ°ä½ä¸­å®ä¹è¾å¤§å¼ä¸ºä¸¤èå åï¼è¾å°å¼ä¸ºä¸¤èç¸åã\n\nå¨è¿åå¼returnséæä»¬å¯ä»¥å®ä¹åémoreï¼lessï¼ä»¥ä¾¿å¨å½æ°ä½ä¸­ä½¿ç¨å®ä»¬ã\n\nmethod maxmin(x:int, y:int) returns (more:int, less:int)    \nensures y > 0 ==> less < x < more\nensures y < 0 ==> more < x < less  \n{\n    more := x + y;\n    less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¶ä¸­ï¼ensuresä»£è¡¨åç½®æ¡ä»¶ï¼è¿ééè¦ç¡®ä¿ç¬¬äºä¸ªæ°å¤§äº0æ¶ï¼è¾å¤§æ°å¤§äºç¬¬ä¸ä¸ªæ°ï¼ç¬¬äºä¸ªæ°å°äº0æ¶ï¼è¾å°æ°å¤§äºç¬¬ä¸ä¸ªæ°ãç±äºæä»¬å¨å½æ°ä½ä¸­å®ä¹è¾å¤§å¼ä¸ºä¸¤èå åï¼è¾å°å¼ä¸ºä¸¤èç¸åï¼æ¾ç¶å¨y < 0æ¶æ¯ä¸æç«çï¼å©ç¨è¿ä¸¤ä¸ªéå®æ¡ä»¶å¯ä»¥å¸®å©dafnyå¤æ­è¯¥ç¨åºçæ­£ç¡®æ§ã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"ææ³¢é£å¥æ°å",frontmatter:{title:"ææ³¢é£å¥æ°å",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/e3e481/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/05.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",relativePath:"20.æå/10.ç®åä¾å­/05.ææ³¢é£å¥æ°å.md",key:"v-022af798",path:"/pages/e3e481/",headersStr:null,content:"# ææ³¢é£å¥æ°å\n\nè¾å¥ä¸ä¸ªæ´æ°nï¼è¿åææ³¢é£å¥æ°åç¬¬né¡¹çå¼ã\n\nææ³¢é£å¥æ°åçç¬¬ä¸ãäºé¡¹æ¯1ï¼1ï¼åé¢çé¡¹æ¯å¶åä¸¤é¡¹çå åï¼å®¹æååºä¸ä¸ªéå½çå¼å­ã\n\nfunction Fibonacci(n:int):int   \nrequires n > 0\ndecreases n\n{\n    if n == 1 || n == 2 then 1 else Fibonacci(n - 2) + Fibonacci(n - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næ³¨æï¼ææ³¢é£å¥æ°åçé¡¹æ¾ç¶æ¯ä»1å¼å§çæ´æ°ï¼ä¸ºäºè§èç¨åºçæ­£ç¡®æ§ï¼éè¦å å¥åç½®æ¡ä»¶requiresï¼éå®çå¸å°è¡¨è¾¾å¼ä¸ºn > 0ã\n\nç±äºè¿åå¼æ¯ä¸ä¸ªæ´æ°ï¼æä»¬å¯ä»¥ç¨ä¸æ¡ç®æ´çå¼å­è¡¨ç¤ºææ³¢é£å¥æ°åçè¿åå¼ãæ³¨æï¼ç±äºå­å¨éå½é¡¹Fibonacci(n - 2)ï¼Fibonacci(n - 1)ï¼æä»¬éè¦åå ä¸decreases nè¡¨ç¤ºnæ¯éæ¬¡åå°ç(ä½æ¯ä¸ä¼åä¸º0)ï¼Dafnyå¨æ§è¡éå½æ¶æ¯æ¬¡é½ä¼æ£æµè¯¥æ¡ä»¶ä»¥ä¿è¯ç¨åºçæ­£ç¡®æ§ã",normalizedContent:"# ææ³¢é£å¥æ°å\n\nè¾å¥ä¸ä¸ªæ´æ°nï¼è¿åææ³¢é£å¥æ°åç¬¬né¡¹çå¼ã\n\nææ³¢é£å¥æ°åçç¬¬ä¸ãäºé¡¹æ¯1ï¼1ï¼åé¢çé¡¹æ¯å¶åä¸¤é¡¹çå åï¼å®¹æååºä¸ä¸ªéå½çå¼å­ã\n\nfunction fibonacci(n:int):int   \nrequires n > 0\ndecreases n\n{\n    if n == 1 || n == 2 then 1 else fibonacci(n - 2) + fibonacci(n - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næ³¨æï¼ææ³¢é£å¥æ°åçé¡¹æ¾ç¶æ¯ä»1å¼å§çæ´æ°ï¼ä¸ºäºè§èç¨åºçæ­£ç¡®æ§ï¼éè¦å å¥åç½®æ¡ä»¶requiresï¼éå®çå¸å°è¡¨è¾¾å¼ä¸ºn > 0ã\n\nç±äºè¿åå¼æ¯ä¸ä¸ªæ´æ°ï¼æä»¬å¯ä»¥ç¨ä¸æ¡ç®æ´çå¼å­è¡¨ç¤ºææ³¢é£å¥æ°åçè¿åå¼ãæ³¨æï¼ç±äºå­å¨éå½é¡¹fibonacci(n - 2)ï¼fibonacci(n - 1)ï¼æä»¬éè¦åå ä¸decreases nè¡¨ç¤ºnæ¯éæ¬¡åå°ç(ä½æ¯ä¸ä¼åä¸º0)ï¼dafnyå¨æ§è¡éå½æ¶æ¯æ¬¡é½ä¼æ£æµè¯¥æ¡ä»¶ä»¥ä¿è¯ç¨åºçæ­£ç¡®æ§ã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"çº¿æ§æ¥è¯¢",frontmatter:{title:"çº¿æ§æ¥è¯¢",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/02fdef/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/10.%E7%BA%BF%E6%80%A7%E6%9F%A5%E8%AF%A2.html",relativePath:"20.æå/10.ç®åä¾å­/10.çº¿æ§æ¥è¯¢.md",key:"v-9ec8b0e0",path:"/pages/02fdef/",headersStr:null,content:"# çº¿æ§æ¥è¯¢\n\nè¾å¥ä¸ä¸ªæ´åæ°ç»åä¸ä¸ªæ´æ°keyï¼è¿åè¯¥æ°ç»ä¸­ç­äºkeyçåç´ æå¨çä½ç½®ï¼æ¾ç¶æ°ç»çä¸æ ä»0å¼å§ã\n\nç®æ³ä¸ï¼ç´æ¥éåè¯¥æ°ç»ï¼å¤æ­å½ååç´ æ¯å¦ç­äºkeyå³å¯ï¼è¥ç­äºåç¨åºè¿åï¼æå¾çnå°±æ¯è¦æ±çä½ç½®ï¼è¥ä¸ç­äºåå¾åå¯»æ¾ã\n\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)   \nensures 0 <= n <= a.Length\nensures n == a.Length || a[n] == key\n{\n    n := 0;\n    while n < a.Length\n    invariant n <= a.Length\n    decreases a.Length - n      //éä¿è¯è¯¥è¡¨è¾¾å¼éåä¸ä¸å°äº0\n    {\n        if a[n] == key \n        {\n            return;\n        }\n        n := n + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nå®¹ææ³å°ï¼nçæ°å¼æ¯å¤§äºç­äº0çæ´æ°ï¼ä¸ä¸è½è¶è¿æ°ç»çé¿åº¦ï¼å¦åäº§çè¶çé®é¢ï¼æä»¥è¦æensures 0 <= n <= a.Lengthã\n\nå¶æ¬¡ï¼ç¨åºè¿åçæ¡ä»¶è¦ä¹æ¯æ¾å°äºå¯¹åºçä½ç½®ï¼æ¥æ¾æåï¼è¦ä¹æ¯nçå¼è¾¾å°äºæ°ç»çé¿åº¦è¿æ²¡ææ¾å°ç¸åºåç´ ï¼æ¥æ¾å¤±è´¥ãå æ­¤è¦æensures n == a.Length || a[n] == key\n\nå½æ°ä¸»ä½é¨åï¼æä»¬å¨éåæ¶ä½¿ç¨çæ¯whileè¯­å¥ï¼è¿éæ¶åå°å¾ªç¯ä¸åä½invariantçä½¿ç¨ï¼Dafnyå¨æ§è¡å¾ªç¯æ¶æ¯æ¬¡é½ä¼å¤æ­å¾ªç¯ä¸åä½æ¯å¦æ»¡è¶³æ¡ä»¶ï¼ä»¥å¤æ­å¾ªç¯åæ¯å¦æéè¯¯ï¼å æ­¤æä»¬å ä¸invariant n <= a.Lengthæ¯æ´ä¸¥è°¨çåæ³ãåæ¶ï¼ç±äºæ¯æ¬¡å¾ªç¯ånå¢å¤§ï¼éè¦å ä¸decreases a.Length - nä¿è¯æ°ç»é¿åº¦ - næ¯åå°çï¼åæ¶ä¸ä¼æ¯0å°ã",normalizedContent:"# çº¿æ§æ¥è¯¢\n\nè¾å¥ä¸ä¸ªæ´åæ°ç»åä¸ä¸ªæ´æ°keyï¼è¿åè¯¥æ°ç»ä¸­ç­äºkeyçåç´ æå¨çä½ç½®ï¼æ¾ç¶æ°ç»çä¸æ ä»0å¼å§ã\n\nç®æ³ä¸ï¼ç´æ¥éåè¯¥æ°ç»ï¼å¤æ­å½ååç´ æ¯å¦ç­äºkeyå³å¯ï¼è¥ç­äºåç¨åºè¿åï¼æå¾çnå°±æ¯è¦æ±çä½ç½®ï¼è¥ä¸ç­äºåå¾åå¯»æ¾ã\n\nmethod linearsearch(a: array<int>, key: int) returns (n: nat)   \nensures 0 <= n <= a.length\nensures n == a.length || a[n] == key\n{\n    n := 0;\n    while n < a.length\n    invariant n <= a.length\n    decreases a.length - n      //éä¿è¯è¯¥è¡¨è¾¾å¼éåä¸ä¸å°äº0\n    {\n        if a[n] == key \n        {\n            return;\n        }\n        n := n + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nå®¹ææ³å°ï¼nçæ°å¼æ¯å¤§äºç­äº0çæ´æ°ï¼ä¸ä¸è½è¶è¿æ°ç»çé¿åº¦ï¼å¦åäº§çè¶çé®é¢ï¼æä»¥è¦æensures 0 <= n <= a.lengthã\n\nå¶æ¬¡ï¼ç¨åºè¿åçæ¡ä»¶è¦ä¹æ¯æ¾å°äºå¯¹åºçä½ç½®ï¼æ¥æ¾æåï¼è¦ä¹æ¯nçå¼è¾¾å°äºæ°ç»çé¿åº¦è¿æ²¡ææ¾å°ç¸åºåç´ ï¼æ¥æ¾å¤±è´¥ãå æ­¤è¦æensures n == a.length || a[n] == key\n\nå½æ°ä¸»ä½é¨åï¼æä»¬å¨éåæ¶ä½¿ç¨çæ¯whileè¯­å¥ï¼è¿éæ¶åå°å¾ªç¯ä¸åä½invariantçä½¿ç¨ï¼dafnyå¨æ§è¡å¾ªç¯æ¶æ¯æ¬¡é½ä¼å¤æ­å¾ªç¯ä¸åä½æ¯å¦æ»¡è¶³æ¡ä»¶ï¼ä»¥å¤æ­å¾ªç¯åæ¯å¦æéè¯¯ï¼å æ­¤æä»¬å ä¸invariant n <= a.lengthæ¯æ´ä¸¥è°¨çåæ³ãåæ¶ï¼ç±äºæ¯æ¬¡å¾ªç¯ånå¢å¤§ï¼éè¦å ä¸decreases a.length - nä¿è¯æ°ç»é¿åº¦ - næ¯åå°çï¼åæ¶ä¸ä¼æ¯0å°ã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°",frontmatter:{title:"å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/9b332b/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/15.%20%E5%BC%95%E7%90%86-%E8%AE%A1%E7%AE%97%E5%BA%8F%E5%88%97%E4%B8%AD%E9%9D%9E%E8%B4%9F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.html",relativePath:"20.æå/10.ç®åä¾å­/15. å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°.md",key:"v-78a1ec51",path:"/pages/9b332b/",headersStr:null,content:"# å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°\n\næ¹æ³count(a)çä½ç¨æ¯ï¼è¾å¥ä¸ä¸ªæ´ååºåaï¼è¿åaä¸­éè´åç´ çä¸ªæ°ã\n\nå¨Dafnyä¸­è¡¨ç¤ºåºåaé¿åº¦çæ¹æ³ä¸º|a|ï¼åç»ååºåçåçåéå½çæè·¯ï¼å®¹æååºä¸é¢çcount()æ¹æ³ï¼å½açé¿åº¦ä¸º0æ¶è¿å0ï¼å¦åå°aåå²æç¬¬ä¸ä¸ªåç´ åå©ä¸çåç´ ï¼å¯¹åä¸ªåç´ å¯ç´æ¥å¤æ­å®çéè´æ§ï¼å¯¹å¤ä¸ªåç´ åå¯¹å®éå½æ±è§£ï¼æåè¿åå®ä»¬çåã\n\nfunction count(a :seq<int>): nat   // è¿ååºåaä¸­éè´åç´ ä¸ªæ°\n{\n    if |a| == 0 then 0 else\n    (if a[0] >= 0 then 1 else 0) + count(a[1..])\n}\n\nmethod m1(){\n    assert count([0, -1, 1] + [-1, 2]) == 3;    // error!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå¯¹äºä¸é¢çcount()ç¨ç±»ä¼¼assert count([1, -1, 0]) == 2è¿æ ·çæ­è¨æ¯å¯ä»¥éªè¯éè¿çï¼ä½æ¯å¦æç¨ç±»ä¼¼assert count([0, -1, 1] + [-1, 2]) == 3è¿æ ·æ¶ååºåæ¼æ¥çæ­è¨æ¯ä¸è½éªè¯éè¿çï¼å¶åå å¨äºåºåæ¼æ¥ç+åcount()ä¸­æ´åç+å«ä¹ä¸åï¼count()å¹¶æ²¡æè§å®åæ°ä¸­åºåçâç¸å âã\n\nä¸ºäºè®©Dafnyè½å¤éªè¯ä¸è¿°æ­è¨ï¼æä»¬éè¦å¼è¿å¼çlemmaï¼ä¸ç§ç¨äºè¯ææç§æ§è´¨ä»¥ä¾åç»­éªè¯çæ¹æ³ã\n\nå¨ä¸è¿°æ­è¨ä¸­ï¼æä»¬ä½¿ç¨count()æ¶é»è®¤äºå®å¯¹äº+çåéæ§è´¨ï¼å æ­¤æä»¬éè¦å¯¹äºå®çåéæ§åç»åºè¯æï¼ä»¥ä½¿Dafnyè½å¤æ­£ç¡®è¯å«æå³æ­è¨ï¼å¦ä¸ã\n\n// å¼ç\nlemma Distributive(a: seq<int>, b: seq<int>)    // è¯æ'+'å¯¹äºcount()æ¯å¯åéç\n    ensures count(a + b) == count(a) + count(b)\n{\n    if a == []\n    {\n        assert a + b == b;\n    }   \n    else\n    {\n        Distributive(a[1..], b);\n        assert a + b == [a[0]] + (a[1..] + b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nåéå¾æ§è´¨éè¦ç¡®ä¿count(a + b) == count(a) + count(b)ï¼è¿æ¯æä»¬æ³è¦çç»æãé¦åï¼è¥åºåaä¸ºç©ºï¼åéªè¯æ­è¨a + b == bï¼å¦ååå»açé¦ä½åç´ ï¼éå½è°ç¨Distributive()ï¼å³éªè¯åé¢ææåºåçåéæ§ï¼éªè¯æ­è¨assert a + b == [a[0]] + (a[1..] + b)å³åºåæ¼æ¥çæ­£ç¡®æ§ãæ´ä¸ªéå½çæµç¨ç¸å½äºæ¯ä¸ºDafnyæä¾äºéªè¯æè·¯ã\n\næ¹æ³m1ä¸­ï¼æä»¬åè°ç¨Distributive()è¯æcount()å¯¹äºç¸å³åºåçåéå¾ï¼åéªè¯æ­è¨ã\n\nmethod m1(){\n    Distributive([0, -1, 1], [-1, 2]);  // åç¨å¼çè¯æåéå¾\n    assert count([0, -1, 1] + [-1, 2]) == 3;    \n}\n\n\n1\n2\n3\n4\n\n\néªè¯éè¿ã",normalizedContent:"# å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°\n\næ¹æ³count(a)çä½ç¨æ¯ï¼è¾å¥ä¸ä¸ªæ´ååºåaï¼è¿åaä¸­éè´åç´ çä¸ªæ°ã\n\nå¨dafnyä¸­è¡¨ç¤ºåºåaé¿åº¦çæ¹æ³ä¸º|a|ï¼åç»ååºåçåçåéå½çæè·¯ï¼å®¹æååºä¸é¢çcount()æ¹æ³ï¼å½açé¿åº¦ä¸º0æ¶è¿å0ï¼å¦åå°aåå²æç¬¬ä¸ä¸ªåç´ åå©ä¸çåç´ ï¼å¯¹åä¸ªåç´ å¯ç´æ¥å¤æ­å®çéè´æ§ï¼å¯¹å¤ä¸ªåç´ åå¯¹å®éå½æ±è§£ï¼æåè¿åå®ä»¬çåã\n\nfunction count(a :seq<int>): nat   // è¿ååºåaä¸­éè´åç´ ä¸ªæ°\n{\n    if |a| == 0 then 0 else\n    (if a[0] >= 0 then 1 else 0) + count(a[1..])\n}\n\nmethod m1(){\n    assert count([0, -1, 1] + [-1, 2]) == 3;    // error!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå¯¹äºä¸é¢çcount()ç¨ç±»ä¼¼assert count([1, -1, 0]) == 2è¿æ ·çæ­è¨æ¯å¯ä»¥éªè¯éè¿çï¼ä½æ¯å¦æç¨ç±»ä¼¼assert count([0, -1, 1] + [-1, 2]) == 3è¿æ ·æ¶ååºåæ¼æ¥çæ­è¨æ¯ä¸è½éªè¯éè¿çï¼å¶åå å¨äºåºåæ¼æ¥ç+åcount()ä¸­æ´åç+å«ä¹ä¸åï¼count()å¹¶æ²¡æè§å®åæ°ä¸­åºåçâç¸å âã\n\nä¸ºäºè®©dafnyè½å¤éªè¯ä¸è¿°æ­è¨ï¼æä»¬éè¦å¼è¿å¼çlemmaï¼ä¸ç§ç¨äºè¯ææç§æ§è´¨ä»¥ä¾åç»­éªè¯çæ¹æ³ã\n\nå¨ä¸è¿°æ­è¨ä¸­ï¼æä»¬ä½¿ç¨count()æ¶é»è®¤äºå®å¯¹äº+çåéæ§è´¨ï¼å æ­¤æä»¬éè¦å¯¹äºå®çåéæ§åç»åºè¯æï¼ä»¥ä½¿dafnyè½å¤æ­£ç¡®è¯å«æå³æ­è¨ï¼å¦ä¸ã\n\n// å¼ç\nlemma distributive(a: seq<int>, b: seq<int>)    // è¯æ'+'å¯¹äºcount()æ¯å¯åéç\n    ensures count(a + b) == count(a) + count(b)\n{\n    if a == []\n    {\n        assert a + b == b;\n    }   \n    else\n    {\n        distributive(a[1..], b);\n        assert a + b == [a[0]] + (a[1..] + b);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nåéå¾æ§è´¨éè¦ç¡®ä¿count(a + b) == count(a) + count(b)ï¼è¿æ¯æä»¬æ³è¦çç»æãé¦åï¼è¥åºåaä¸ºç©ºï¼åéªè¯æ­è¨a + b == bï¼å¦ååå»açé¦ä½åç´ ï¼éå½è°ç¨distributive()ï¼å³éªè¯åé¢ææåºåçåéæ§ï¼éªè¯æ­è¨assert a + b == [a[0]] + (a[1..] + b)å³åºåæ¼æ¥çæ­£ç¡®æ§ãæ´ä¸ªéå½çæµç¨ç¸å½äºæ¯ä¸ºdafnyæä¾äºéªè¯æè·¯ã\n\næ¹æ³m1ä¸­ï¼æä»¬åè°ç¨distributive()è¯æcount()å¯¹äºç¸å³åºåçåéå¾ï¼åéªè¯æ­è¨ã\n\nmethod m1(){\n    distributive([0, -1, 1], [-1, 2]);  // åç¨å¼çè¯æåéå¾\n    assert count([0, -1, 1] + [-1, 2]) == 3;    \n}\n\n\n1\n2\n3\n4\n\n\néªè¯éè¿ã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"éå",frontmatter:{title:"éå",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/3d1110/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/20.%E9%9B%86%E5%90%88.html",relativePath:"20.æå/10.ç®åä¾å­/20.éå.md",key:"v-0c0b0a3c",path:"/pages/3d1110/",headersStr:null,content:"# éå\n\nDafnyçéåä¸ºæéésetï¼æ ééisetï¼ä¸é¢æ¯å®ä»¬çä¸äºä¾å­ã\n\nmethod m2(){\n   var s1 := {1, 2, 3};\n   var s2 := {1, 3, 6};\n   assert s1 + s2 == {1, 2, 3, 6}; // set union\n   assert s1 * s2 == {1, 3}; // set intersection\n   assert s1 - s2 == {2}; // set difference\n\n   assert s2 - {1} in (iset s3 : set<int> | forall x :: x in s3 ==> x % 3 == 0); // éåçå¦ä¸ç§å½¢å¼\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\néåçå¹¶ãäº¤ãå·®å¯ä»¥ç¨+, *, -æ¥è¡¨ç¤º\n\néåçå¦ä¸ç§è¡¨ç°å½¢å¼æ¯set x: T | p(x) :: f(x),å³è¯¥éåçåç´ xç±»åä¸ºTï¼æ»¡è¶³p(x)ï¼å¹¶åºç¨f(x)ãè¿éç»åºçä¾å­ä¸­çéåå«ä¹æ¯ï¼è¯¥æ ééçææåç´ æ¯æ´åéåï¼ä¸å¯¹äºä»»æçåç´ (ç§°ä¹ä¸ºs3)é½æï¼è¯¥æ´åéåä¸­çåç´ è½è¢«3æ´é¤ãç±äºs2 - {1}çç»æä¸º{3, 6}æ¾ç¶å±äºè¯¥éåï¼æè¯¥æ­è¨æ­£ç¡®ã",normalizedContent:"# éå\n\ndafnyçéåä¸ºæéésetï¼æ ééisetï¼ä¸é¢æ¯å®ä»¬çä¸äºä¾å­ã\n\nmethod m2(){\n   var s1 := {1, 2, 3};\n   var s2 := {1, 3, 6};\n   assert s1 + s2 == {1, 2, 3, 6}; // set union\n   assert s1 * s2 == {1, 3}; // set intersection\n   assert s1 - s2 == {2}; // set difference\n\n   assert s2 - {1} in (iset s3 : set<int> | forall x :: x in s3 ==> x % 3 == 0); // éåçå¦ä¸ç§å½¢å¼\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\néåçå¹¶ãäº¤ãå·®å¯ä»¥ç¨+, *, -æ¥è¡¨ç¤º\n\néåçå¦ä¸ç§è¡¨ç°å½¢å¼æ¯set x: t | p(x) :: f(x),å³è¯¥éåçåç´ xç±»åä¸ºtï¼æ»¡è¶³p(x)ï¼å¹¶åºç¨f(x)ãè¿éç»åºçä¾å­ä¸­çéåå«ä¹æ¯ï¼è¯¥æ ééçææåç´ æ¯æ´åéåï¼ä¸å¯¹äºä»»æçåç´ (ç§°ä¹ä¸ºs3)é½æï¼è¯¥æ´åéåä¸­çåç´ è½è¢«3æ´é¤ãç±äºs2 - {1}çç»æä¸º{3, 6}æ¾ç¶å±äºè¯¥éåï¼æè¯¥æ­è¨æ­£ç¡®ã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"ç»æ­¢",frontmatter:{title:"ç»æ­¢",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/2146d4/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"],readingShow:"top"},regularPath:"/20.%E6%8C%87%E5%8D%97/10.%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/25.%E7%BB%88%E6%AD%A2.html",relativePath:"20.æå/10.ç®åä¾å­/25.ç»æ­¢.md",key:"v-af1f7912",path:"/pages/2146d4/",headersStr:null,content:"# ç»æ­¢\n\nDafnyä¸­çå³é®å­predicateè¡¨ç¤ºå½æ°ç»æ­¢ã\n\nä¸é¢æ¯ä¸ä¸ªå¥å¶æ ¡éªçä¾å­ãå¯¹äºæ­£æ´æ°nï¼å½nä¸ºå¶æ°æ¶å¯¹n - 1è¿è¡å¥æ ¡éªï¼å½nä¸ºå¥æ°æ¶å¯¹n - 1è¿è¡å¶æ ¡éªãå½nåå°å°0æ¶ï¼è¥ä¸ºå¶æ ¡éªè°ç¨åè¿åçï¼ä¸ºå¥æ ¡éªè°ç¨åè¿ååã\n\npredicate even(n: nat)  // å¶æ ¡éª\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\n\npredicate odd(n: nat)   //å¥æ ¡éª\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸è¿°ä¸¤ä¸ªæ¹æ³ç¼ºä¸ä¸å¯ï¼å ä¸ºå®ä»¬è¦è¾¾å°ç»æ­¢æ¡ä»¶å°±å¿é¡»äºç¸è°ç¨ç´è³å¶ä¸­ä¸ä¸ªæ¹æ³éå½è¿åã",normalizedContent:"# ç»æ­¢\n\ndafnyä¸­çå³é®å­predicateè¡¨ç¤ºå½æ°ç»æ­¢ã\n\nä¸é¢æ¯ä¸ä¸ªå¥å¶æ ¡éªçä¾å­ãå¯¹äºæ­£æ´æ°nï¼å½nä¸ºå¶æ°æ¶å¯¹n - 1è¿è¡å¥æ ¡éªï¼å½nä¸ºå¥æ°æ¶å¯¹n - 1è¿è¡å¶æ ¡éªãå½nåå°å°0æ¶ï¼è¥ä¸ºå¶æ ¡éªè°ç¨åè¿åçï¼ä¸ºå¥æ ¡éªè°ç¨åè¿ååã\n\npredicate even(n: nat)  // å¶æ ¡éª\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\n\npredicate odd(n: nat)   //å¥æ ¡éª\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸è¿°ä¸¤ä¸ªæ¹æ³ç¼ºä¸ä¸å¯ï¼å ä¸ºå®ä»¬è¦è¾¾å°ç»æ­¢æ¡ä»¶å°±å¿é¡»äºç¸è°ç¨ç´è³å¶ä¸­ä¸ä¸ªæ¹æ³éå½è¿åã",charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"ä»ç»",frontmatter:{title:"ä»ç»",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/877eb3/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/00.%E4%BB%8B%E7%BB%8D.html",relativePath:"30.æç¨/00.Dafnyæç¨/00.ä»ç».md",key:"v-3dbdb6b8",path:"/pages/877eb3/",headersStr:null,content:"# ä»ç»\n\nDafnyæ¯ä¸ç§æ¨å¨ç®åç¼åæ­£ç¡®ä»£ç çè¯­è¨ãè¿æå³çä¸å­å¨ä»»ä½è¿è¡æ¶çéè¯¯ï¼åæ¶å¨å®éåç¨åºåå¸æå®åçäºæä¸ä¹æ¯æ­£ç¡®çãä¸ºäºå®ç°è¿ä¸ç¹ï¼Dafnyä¾èµäºé«çº§æ³¨éæ¥æ¨çåè¯æä»£ç çæ­£ç¡®æ§ãä¸æ®µä»£ç çææå¯ä»¥æ½è±¡å°ç»åºï¼ä½¿ç¨ææè¡ä¸ºçèªç¶ãé«çº§è¡¨è¾¾å¼ï¼è¿æ´å®¹æç¼åï¼ä¹æ´ä¸å®¹æåºéãDafnyç¶åçæä»£ç ä¸æ³¨éå¹éçè¯æ(å½ç¶ï¼åè®¾å®ä»¬æ¯æ­£ç¡®ç!)ãDafnyå°ç¼åæ bugçä»£ç çåæäºç¼åæ bugçãè¿éå¸¸æ¯ç¼åä»£ç æ´å®¹æï¼å ä¸ºæ³¨éæ´ç­ãæ´ç´æ¥ãä¾å¦ï¼Dafnyä¸­ä¸é¢çæ³¨éçæ®µè¡¨ç¤ºæ°ç»ä¸­çæ¯ä¸ªåç´ é½æ¯ä¸¥æ ¼æ­£ç:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nè¿æå³çå¯¹äºæ°ç»ä¸­ææçç´¢å¼ä¸ºkçæ´æ°ï¼ç´¢å¼å¤çå¼å¤§äº0ãéè¿ç¼åè¿äºæ³¨éï¼å¯ä»¥ç¡®ä¿¡ä»£ç æ¯æ­£ç¡®çãæ­¤å¤ï¼ç¼åæ³¨éçè¡ä¸ºå¯ä»¥å¸®å©äººä»¬å¨æ´æ·±çå±æ¬¡ä¸çè§£ä»£ç æ­£å¨åä»ä¹ã é¤äºè¯æä¸ç¨æ·æä¾çæ³¨éçå¯¹åºå³ç³»å¤ï¼Dafnyè¿è¯ææ²¡æè¿è¡æ¶éè¯¯ï¼æ¯å¦ç´¢å¼è¶çãç©ºè§£å¼ç¨ãé¤é¶ç­ãè¿æ¯ä¸ä¸ªå¼ºæåçä¿è¯ï¼æ¯ä½¿ç¨Dafnyåç±»ä¼¼å·¥å·çä¸ä¸ªå¼ºæåçä¾å­ãDafnyä¹è¯æäºä»£ç çç»æ­¢ï¼é¤äºå¨ç¹æ®æå®çå¾ªç¯ä¸­ã è®©æä»¬å¼å§ç¼åä¸äºDafnyç¨åºã",normalizedContent:"# ä»ç»\n\ndafnyæ¯ä¸ç§æ¨å¨ç®åç¼åæ­£ç¡®ä»£ç çè¯­è¨ãè¿æå³çä¸å­å¨ä»»ä½è¿è¡æ¶çéè¯¯ï¼åæ¶å¨å®éåç¨åºåå¸æå®åçäºæä¸ä¹æ¯æ­£ç¡®çãä¸ºäºå®ç°è¿ä¸ç¹ï¼dafnyä¾èµäºé«çº§æ³¨éæ¥æ¨çåè¯æä»£ç çæ­£ç¡®æ§ãä¸æ®µä»£ç çææå¯ä»¥æ½è±¡å°ç»åºï¼ä½¿ç¨ææè¡ä¸ºçèªç¶ãé«çº§è¡¨è¾¾å¼ï¼è¿æ´å®¹æç¼åï¼ä¹æ´ä¸å®¹æåºéãdafnyç¶åçæä»£ç ä¸æ³¨éå¹éçè¯æ(å½ç¶ï¼åè®¾å®ä»¬æ¯æ­£ç¡®ç!)ãdafnyå°ç¼åæ bugçä»£ç çåæäºç¼åæ bugçãè¿éå¸¸æ¯ç¼åä»£ç æ´å®¹æï¼å ä¸ºæ³¨éæ´ç­ãæ´ç´æ¥ãä¾å¦ï¼dafnyä¸­ä¸é¢çæ³¨éçæ®µè¡¨ç¤ºæ°ç»ä¸­çæ¯ä¸ªåç´ é½æ¯ä¸¥æ ¼æ­£ç:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nè¿æå³çå¯¹äºæ°ç»ä¸­ææçç´¢å¼ä¸ºkçæ´æ°ï¼ç´¢å¼å¤çå¼å¤§äº0ãéè¿ç¼åè¿äºæ³¨éï¼å¯ä»¥ç¡®ä¿¡ä»£ç æ¯æ­£ç¡®çãæ­¤å¤ï¼ç¼åæ³¨éçè¡ä¸ºå¯ä»¥å¸®å©äººä»¬å¨æ´æ·±çå±æ¬¡ä¸çè§£ä»£ç æ­£å¨åä»ä¹ã é¤äºè¯æä¸ç¨æ·æä¾çæ³¨éçå¯¹åºå³ç³»å¤ï¼dafnyè¿è¯ææ²¡æè¿è¡æ¶éè¯¯ï¼æ¯å¦ç´¢å¼è¶çãç©ºè§£å¼ç¨ãé¤é¶ç­ãè¿æ¯ä¸ä¸ªå¼ºæåçä¿è¯ï¼æ¯ä½¿ç¨dafnyåç±»ä¼¼å·¥å·çä¸ä¸ªå¼ºæåçä¾å­ãdafnyä¹è¯æäºä»£ç çç»æ­¢ï¼é¤äºå¨ç¹æ®æå®çå¾ªç¯ä¸­ã è®©æä»¬å¼å§ç¼åä¸äºdafnyç¨åºã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ¹æ³",frontmatter:{title:"æ¹æ³",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/bf40c0/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/05.%E6%96%B9%E6%B3%95.html",relativePath:"30.æç¨/00.Dafnyæç¨/05.æ¹æ³.md",key:"v-5e14a608",path:"/pages/bf40c0/",headersStr:null,content:"# æ¹æ³\n\nDafnyå¨è®¸å¤æ¹é¢ç±»ä¼¼äºå¸åçå½ä»¤å¼ç¼ç¨è¯­è¨ãææ¹æ³ãåéãç±»åãå¾ªç¯ãifè¯­å¥ãæ°ç»ãæ´æ°ç­ç­ãä»»ä½Dafnyç¨åºçåºæ¬ååä¹ä¸å°±æ¯æ¹æ³ãæ¹æ³æ¯ä¸æ®µå½ä»¤å¼çãå¯æ§è¡çä»£ç ãå¨å¶ä»è¯­è¨ä¸­ï¼å®ä»¬å¯è½è¢«ç§°ä¸ºè¿ç¨æå½æ°ï¼ä½å¨Dafnyä¸­ï¼è¿ä¸ªæ¯è¯­æ¯ä¸ºä¸ä¸ªä¸åçæ¦å¿µä¿ççï¼æä»¬ç¨åå°è®¨è®ºè¿ä¸ªæ¦å¿µãæ¹æ³çå£°ææ¹å¼å¦ä¸:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nå®å£°æäºä¸ä¸ªåä¸ºAbsçæ¹æ³ï¼å®æ¥åä¸ä¸ªåä¸ºxçæ´æ°åæ°ï¼å¹¶è¿åä¸ä¸ªåä¸ºyçæ´æ°ãè¯·æ³¨æï¼æ¯ä¸ªåæ°åè¿åå¼é½éè¦ç±»åï¼å¹¶å¨æ¯ä¸ªåç§°åé¢è·ä¸ä¸ªåå·(:)ãåæ ·ï¼è¿åå¼æ¯å½åçï¼å¹¶ä¸å¯ä»¥æå¤ä¸ªè¿åå¼ï¼å¦ä¸æç¤º:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\næ¹æ³ä¸»ä½æ¯åå«å¨å¤§æ¬å·ä¸­çä»£ç ï¼å°ç®åä¸ºæ­¢ï¼å®è¢«ç®æå°è¡¨ç¤ºä¸º ... (è¿ä¸æ¯Dafnyçè¯­æ³). ä¸»ä½ç±ä¸ç³»åè¯­å¥ç»æ,ä¾å¦çæçå½ä»¤å¼èµå¼, ifè¯­å¥, å¾ªç¯ï¼å¶ä»æ¹æ³è°ç¨, returnè¯­å¥ç­ç­ãä¾å¦, MultipleReturnsæ¹æ³å¯ä»¥å£°æä¸º:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nèµå¼ä¸ä½¿ç¨=, èæ¯ä½¿ç¨:=. (äºå®ä¸Dafnyä½¿ç¨ == è¡¨ç¤ºç¸ç­, Dafnyçè¡¨è¾¾å¼ä¸­æ²¡æä½¿ç¨åä¸ªçç­å·ã) ç®åè¯­å¥åé¢å¿é¡»æåå·ï¼ç©ºæ ¼åæ³¨é (//å /**/) å°ä¼è¢«å¿½ç¥. ä¸ºäºä»æ¹æ³ä¸­è¿åå¼, è¯¥å¼å¨returnè¯­å¥ä¹åçæä¸ªæ¶é´è¢«åéç»ä¸ä¸ªæå®çè¿åå¼ãå®éä¸ï¼è¿åå¼çè¡ä¸ºéå¸¸ç±»ä¼¼äºå±é¨åéï¼å¹¶ä¸å¯ä»¥è¢«èµå¼ä¸æ­¢ä¸æ¬¡ãä½æ¯ï¼è¾å¥åæ°æ¯åªè¯»çãreturnè¯­å¥ç¨äºå¨å°è¾¾æ¹æ³çä¸»ä½åç»æä¹åè¿åãreturnè¯­å¥å¯ä»¥åªæ¯returnå³é®å­ (å¶ä¸­ä½¿ç¨äºoutåæ°çå½åå¼), ä¹å¯ä»¥è·åè¦è¿åçå¼åè¡¨ãä¹æå¤åè¯­å¥ï¼å¦ifè¯­å¥ãifè¯­å¥ä¸éè¦å¨å¸å°æ¡ä»¶å¨å´å ä¸æ¬å·ï¼å¶ä½ç¨æ­£å¦äººä»¬æææçé£æ ·:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\néè¦æ³¨æçæ¯ï¼å®ä»¬æ»æ¯éè¦å¨åæ¯å¨å´ä½¿ç¨å¤§æ¬å·ï¼å³ä½¿åæ¯åªåå«ä¸ä¸ªè¯­å¥(å¤åè¯­å¥æå¶ä»è¯­å¥)ãè¿éçifè¯­å¥ä½¿ç¨çæçæ¯è¾è¿ç®ç¬¦è¯­æ³æ£æ¥xæ¯å¦å°äºé¶ï¼å¹¶è¿åéå½çç»å¯¹å¼ã(å¶ä»æ¯è¾è¿ç®ç¬¦ <=, >, >=, !=å==, å·æé¢æçå«ä¹ãæå³æä½ç¬¦çæ´å¤ä¿¡æ¯ï¼è¯·åè§åèèµæã)",normalizedContent:"# æ¹æ³\n\ndafnyå¨è®¸å¤æ¹é¢ç±»ä¼¼äºå¸åçå½ä»¤å¼ç¼ç¨è¯­è¨ãææ¹æ³ãåéãç±»åãå¾ªç¯ãifè¯­å¥ãæ°ç»ãæ´æ°ç­ç­ãä»»ä½dafnyç¨åºçåºæ¬ååä¹ä¸å°±æ¯æ¹æ³ãæ¹æ³æ¯ä¸æ®µå½ä»¤å¼çãå¯æ§è¡çä»£ç ãå¨å¶ä»è¯­è¨ä¸­ï¼å®ä»¬å¯è½è¢«ç§°ä¸ºè¿ç¨æå½æ°ï¼ä½å¨dafnyä¸­ï¼è¿ä¸ªæ¯è¯­æ¯ä¸ºä¸ä¸ªä¸åçæ¦å¿µä¿ççï¼æä»¬ç¨åå°è®¨è®ºè¿ä¸ªæ¦å¿µãæ¹æ³çå£°ææ¹å¼å¦ä¸:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nå®å£°æäºä¸ä¸ªåä¸ºabsçæ¹æ³ï¼å®æ¥åä¸ä¸ªåä¸ºxçæ´æ°åæ°ï¼å¹¶è¿åä¸ä¸ªåä¸ºyçæ´æ°ãè¯·æ³¨æï¼æ¯ä¸ªåæ°åè¿åå¼é½éè¦ç±»åï¼å¹¶å¨æ¯ä¸ªåç§°åé¢è·ä¸ä¸ªåå·(:)ãåæ ·ï¼è¿åå¼æ¯å½åçï¼å¹¶ä¸å¯ä»¥æå¤ä¸ªè¿åå¼ï¼å¦ä¸æç¤º:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\næ¹æ³ä¸»ä½æ¯åå«å¨å¤§æ¬å·ä¸­çä»£ç ï¼å°ç®åä¸ºæ­¢ï¼å®è¢«ç®æå°è¡¨ç¤ºä¸º ... (è¿ä¸æ¯dafnyçè¯­æ³). ä¸»ä½ç±ä¸ç³»åè¯­å¥ç»æ,ä¾å¦çæçå½ä»¤å¼èµå¼, ifè¯­å¥, å¾ªç¯ï¼å¶ä»æ¹æ³è°ç¨, returnè¯­å¥ç­ç­ãä¾å¦, multiplereturnsæ¹æ³å¯ä»¥å£°æä¸º:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nèµå¼ä¸ä½¿ç¨=, èæ¯ä½¿ç¨:=. (äºå®ä¸dafnyä½¿ç¨ == è¡¨ç¤ºç¸ç­, dafnyçè¡¨è¾¾å¼ä¸­æ²¡æä½¿ç¨åä¸ªçç­å·ã) ç®åè¯­å¥åé¢å¿é¡»æåå·ï¼ç©ºæ ¼åæ³¨é (//å /**/) å°ä¼è¢«å¿½ç¥. ä¸ºäºä»æ¹æ³ä¸­è¿åå¼, è¯¥å¼å¨returnè¯­å¥ä¹åçæä¸ªæ¶é´è¢«åéç»ä¸ä¸ªæå®çè¿åå¼ãå®éä¸ï¼è¿åå¼çè¡ä¸ºéå¸¸ç±»ä¼¼äºå±é¨åéï¼å¹¶ä¸å¯ä»¥è¢«èµå¼ä¸æ­¢ä¸æ¬¡ãä½æ¯ï¼è¾å¥åæ°æ¯åªè¯»çãreturnè¯­å¥ç¨äºå¨å°è¾¾æ¹æ³çä¸»ä½åç»æä¹åè¿åãreturnè¯­å¥å¯ä»¥åªæ¯returnå³é®å­ (å¶ä¸­ä½¿ç¨äºoutåæ°çå½åå¼), ä¹å¯ä»¥è·åè¦è¿åçå¼åè¡¨ãä¹æå¤åè¯­å¥ï¼å¦ifè¯­å¥ãifè¯­å¥ä¸éè¦å¨å¸å°æ¡ä»¶å¨å´å ä¸æ¬å·ï¼å¶ä½ç¨æ­£å¦äººä»¬æææçé£æ ·:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\néè¦æ³¨æçæ¯ï¼å®ä»¬æ»æ¯éè¦å¨åæ¯å¨å´ä½¿ç¨å¤§æ¬å·ï¼å³ä½¿åæ¯åªåå«ä¸ä¸ªè¯­å¥(å¤åè¯­å¥æå¶ä»è¯­å¥)ãè¿éçifè¯­å¥ä½¿ç¨çæçæ¯è¾è¿ç®ç¬¦è¯­æ³æ£æ¥xæ¯å¦å°äºé¶ï¼å¹¶è¿åéå½çç»å¯¹å¼ã(å¶ä»æ¯è¾è¿ç®ç¬¦ <=, >, >=, !=å==, å·æé¢æçå«ä¹ãæå³æä½ç¬¦çæ´å¤ä¿¡æ¯ï¼è¯·åè§åèèµæã)",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"åç½®ååç½®æ¡ä»¶",frontmatter:{title:"åç½®ååç½®æ¡ä»¶",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/2e0c73/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/10.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6.html",relativePath:"30.æç¨/00.Dafnyæç¨/10.åç½®ååç½®æ¡ä»¶.md",key:"v-4f011ddc",path:"/pages/2e0c73/",headersStr:null,content:"# åç½®ååç½®æ¡ä»¶\n\nå°ç®åä¸ºæ­¢ï¼æä»¬æçå°çææä»£ç é½æ²¡æä»»ä½è§è:ä»£ç å ä¹å¯ä»¥ç¨ä»»ä½å½ä»¤å¼è¯­è¨ç¼å(éå½èèå¤ä¸ªè¿åå¼)ãDafnyççæ­£å¼ºå¤§ä¹å¤å¨äºè½å¤æ³¨éè¿äºæ¹æ³æ¥æå®å®ä»¬çè¡ä¸ºãä¾å¦ï¼æä»¬ä½¿ç¨Absæ¹æ³è§å¯å°çä¸ä¸ªå±æ§æ¯ï¼ä¸ç®¡è¾å¥æ¯ä»ä¹ï¼ç»ææ»æ¯å¤§äºæç­äºé¶ãæä»¬å¯ä»¥æè¿ä¸ªè§å¯ç»ææ¾å¨æ³¨éä¸­ï¼ä½æ¯æä»¬æ²¡æåæ³ç¥éè¿ä¸ªæ¹æ³æ¯å¦ççæè¿ä¸ªå±æ§ãèä¸ï¼å¦ææäººæ¹åäºæ¹æ³ï¼æä»¬ä¸è½ä¿è¯æ³¨éä¹ä¼ç¸åºæ¹åãéè¿æ³¨éï¼æä»¬å¯ä»¥è®©Dafnyè¯ææä»¬å£°æçæ¹æ³çå±æ§æ¯ççãæå ç§æ¹æ³å¯ä»¥ç»åºæ³¨è§£ï¼ä½æå¸¸è§åæåºæ¬çæ¯æ¹æ³çåç½®æ¡ä»¶ååç½®æ¡ä»¶ã Absæ¹æ³çè¿ä¸ªå±æ§ï¼å³ç»ææ»æ¯éè´çï¼æ¯åç½®æ¡ä»¶çä¸ä¸ªä¾å­:å®æ¯å¨æ¹æ³è¿ååä¸ºçãç¨ensureså³é®å­å£°æçåç½®æ¡ä»¶ï¼ä½ä¸ºæ¹æ³å£°æçä¸é¨åï¼å¨è¿åå¼ä¹å(å¦æå­å¨)åæ¹æ³ä½ä¹åç»åºãå³é®å­åé¢è·çå¸å°è¡¨è¾¾å¼ãåifæ whileæ¡ä»¶åå¤§å¤æ°è§èä¸æ ·ï¼åç½®æ¡ä»¶æ»æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼:å¯ä»¥æ¯trueæ false. å¨Absæ¹æ³çæåµä¸ï¼ä¸ä¸ªåççåç½®æ¡ä»¶å¦ä¸:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ å¯ä»¥å¨è¿éçå°ä¸ºä»ä¹è¿åå¼è¢«èµäºåç§°ãè¿ä½¿å¾å®ä»¬å¾å®¹æå¨æ¹æ³çåç½®æ¡ä»¶ä¸­å¼ç¨ãå½è¡¨è¾¾å¼ä¸ºçæ¶ï¼æä»¬è¯´åç½®æ¡ä»¶ä¿çãåç½®æ¡ä»¶å¿é¡»éç¨äºå½æ°çæ¯æ¬¡è°ç¨ï¼ä»¥åæ¯ä¸ªå¯è½çè¿åç¹ (åæ¬å½æ°ä½æ«å°¾çéå¼è¿åç¹)ãå¨è¿ç§æåµä¸ï¼æä»¬å¯ä¸è¦è¡¨è¾¾çå±æ§æ¯è¿åå¼æ»æ¯è³å°ä¸ºé¶ã ææ¶ï¼æä»¬éè¦ä¸ºä»£ç å»ºç«å¤ä¸ªå±æ§ãå¨è¿ç§æåµä¸ï¼æä»¬æä¸¤ä¸ªéæ©ãæä»¬å¯ä»¥ç¨å¸å°åçandæä½ç¬¦(&&), å°è¿ä¸¤ä¸ªæ¡ä»¶è¿æ¥èµ·æ¥ï¼æèå¯ä»¥ç¼åå¤ä¸ªensuresè¡¨è¾¾å¼ãåèä¸åèåºæ¬ç¸åï¼ä½å®åºåäºä¸åçå±æ§ãä¾å¦ï¼MultipleReturns æ¹æ³çè¿åå¼åç§°å¯è½ä¼å¯¼è´äººä»¬çæµä»¥ä¸åç½®æ¡ä»¶:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nåç½®æ¡ä»¶ä¹å¯ä»¥è¿æ ·å:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nçè³æ¯è¿æ ·ï¼\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå ä¸ºDafnyä¸­ä½¿ç¨äºé¾æ¥æ¯è¾è¿ç®ç¬¦è¯­æ³ã(ä¸è¬æ¥è¯´ï¼å¤§å¤æ°æ¯è¾è¿ç®ç¬¦å¯ä»¥ä¸²èï¼ä½åªè½åç¸è¿æ¥ï¼å³ä¸è½æ··åä½¿ç¨å¤§äºåå°äºãè¯¦æè¯·åéåèèµæã) è¡¨ç¤ºåç½®æ¡ä»¶çç¬¬ä¸ç§æ¹å¼å°lessé¨åä¸moreé¨ååå¼ï¼è¿å¯è½æ¯å¯åçãå¦ä¸ä»¶éè¦æ³¨æçäºææ¯ï¼æä»¬å¨åç½®æ¡ä»¶ä¸­åå«äºä¸ä¸ªè¾å¥åæ°ãè¿æ¯æç¨çï¼å ä¸ºå®åè®¸æä»¬å°æ¹æ³çè¾å¥åè¾åºç¸äºå³è(è¿æ¯å ä¸ºè¾å¥åæ°æ¯åªè¯»çï¼æä»¥å¨æ«å°¾åå¼å§æ¶æ¯ä¸æ ·ç)ã Dafnyå®éä¸æç»äºè¿ä¸ªç¨åºï¼å£°ç§°ç¬¬ä¸ä¸ªåç½®æ¡ä»¶ä¸æç« (å³ä¸ä¸ºç)ãè¿æå³çDafnyä¸è½è¯æè¯¥æ³¨éå¨æ¯æ¬¡æ¹æ³è¿åæ¶é½ææãéå¸¸ï¼Dafnyéªè¯éè¯¯æä¸¤ä¸ªä¸»è¦åå :è§èä¸ä»£ç ä¸ä¸è´ï¼ä»¥åå®ä¸å¤èªææ¥è¯ææéå±æ§çæåµãåºåè¿ä¸¤ç§å¯è½æ§å¯è½æ¯ä¸é¡¹å°é¾çä»»å¡ï¼ä½å¹¸è¿çæ¯ï¼Dafnyåå®æåºäºçBoogie/Z3ç³»ç»éå¸¸èªæï¼å¹¶ä¸å°è¯æä»£ç åè§èçå¹ééå¸¸ç®åã å¨è¿ç§æåµä¸ï¼Dafnyè¯´ä»£ç æéè¯¯æ¯æ­£ç¡®çãé®é¢çå³é®å¨äºyæ¯æ´æ°ï¼æä»¥å®å¯ä»¥æ¯è´çãå¦æyä¸ºè´(æä¸ºé¶)ï¼é£ä¹moreå¯ä»¥å°äºæç­äºxãé¤éyä¸¥æ ¼å¤§äºé¶ï¼å¦åæä»¬çæ¹æ³å°æ æ³æ­£å¸¸å·¥ä½ãè¿æ­£æ¯çæ¦å¿µãåç½®æ¡ä»¶ç±»ä¼¼äºåç½®æ¡ä»¶ï¼é¤äºå®å¿é¡»å¨æ¹æ³è¢«è°ç¨ä¹åä¸ºçãå½æ¨è°ç¨ä¸ä¸ªæ¹æ³æ¶ï¼æ¨çå·¥ä½æ¯å»ºç«(ä½¿)åå³æ¡ä»¶ä¸ºçï¼è¿æ¯Dafnyä½¿ç¨è¯ææ¥å®ç°çãåæ ·ï¼å½æ¨ç¼åä¸ä¸ªæ¹æ³æ¶ï¼æ¨å¯ä»¥åå®åå³æ¡ä»¶ï¼ä½æ¯æ¨å¿é¡»å»ºç«åç½®æ¡ä»¶ãç¶åï¼æ¹æ³çè°ç¨èå¯ä»¥åå®æ¹æ³è¿ååç½®æ¡ä»¶ä¿æä¸åã åææ¡ä»¶æèªå·±çå³é®å­requiresãæä»¬å¯ä»¥ç»äºå¤æ¬¡è¿åå¿è¦çåå³æ¡ä»¶å¦ä¸:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä¸åç½®æ¡ä»¶ä¸æ ·ï¼å¤ä¸ªåç½®æ¡ä»¶å¯ä»¥ç¨å¸å°åçandæä½ç¬¦(&&)æå¤ä¸ªrequireå³é®å­æ¥åãä¼ ç»ä¸ï¼æºä»£ç ä¸­çrequiresä¼åäºensureï¼å°½ç®¡è¿å¹¶ä¸æ¯ç»å¯¹å¿è¦ç(å°½ç®¡requiresåensureæ³¨éç¸å¯¹äºå¶ä»åç±»åæ³¨éçé¡ºåºææ¶ä¼å¾éè¦ï¼æä»¬å°å¨åé¢çå°)ãæ·»å äºè¿ä¸ªæ¡ä»¶åï¼Dafnyç°å¨éªè¯ä»£ç æ¯å¦æ­£ç¡®ï¼åªéè¦ä¿è¯è¿ä¸ªåè®¾æ­£ç¡®ï¼å°±å¯ä»¥ä¿è¯æ¹æ³ä½ä¸­çä»£ç æ¯æ­£ç¡®çã\n\nç»ä¹ 0\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæ¹æ³Maxï¼å®æ¥åä¸¤ä¸ªæ´æ°åæ°å¹¶è¿åå®ä»¬çæå¤§å¼ãæ·»å éå½çæ³¨éï¼å¹¶ç¡®ä¿å¯¹ä»£ç è¿è¡éªè¯ã\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¹¶ä¸æ¯ææçæ¹æ³é½æåå³æ¡ä»¶ãä¾å¦ï¼æä»¬å·²ç»çå°çAbsæ¹æ³æ¯ä¸ºæææ´æ°å®ä¹çï¼å æ­¤æ²¡æä»»ä½åå³æ¡ä»¶(é¤äºå®çåæ°æ¯æ´æ°è¿ä¸çç¢çè¦æ±ï¼è¿æ¯ç±ç±»åç³»ç»å¼ºå¶æ§è¡ç)ãå°½ç®¡å®ä¸éè¦åå³æ¡ä»¶ï¼Abså½æ°ç®åçæåµä¸å¹¶ä¸æ¯å¾æç¨ãä¸ºäºæ¢ç©¶å¶ä¸­çåå ï¼æä»¬éè¦ä½¿ç¨å¦ä¸ç§æ³¨éï¼å³æ­è¨ã",normalizedContent:"# åç½®ååç½®æ¡ä»¶\n\nå°ç®åä¸ºæ­¢ï¼æä»¬æçå°çææä»£ç é½æ²¡æä»»ä½è§è:ä»£ç å ä¹å¯ä»¥ç¨ä»»ä½å½ä»¤å¼è¯­è¨ç¼å(éå½èèå¤ä¸ªè¿åå¼)ãdafnyççæ­£å¼ºå¤§ä¹å¤å¨äºè½å¤æ³¨éè¿äºæ¹æ³æ¥æå®å®ä»¬çè¡ä¸ºãä¾å¦ï¼æä»¬ä½¿ç¨absæ¹æ³è§å¯å°çä¸ä¸ªå±æ§æ¯ï¼ä¸ç®¡è¾å¥æ¯ä»ä¹ï¼ç»ææ»æ¯å¤§äºæç­äºé¶ãæä»¬å¯ä»¥æè¿ä¸ªè§å¯ç»ææ¾å¨æ³¨éä¸­ï¼ä½æ¯æä»¬æ²¡æåæ³ç¥éè¿ä¸ªæ¹æ³æ¯å¦ççæè¿ä¸ªå±æ§ãèä¸ï¼å¦ææäººæ¹åäºæ¹æ³ï¼æä»¬ä¸è½ä¿è¯æ³¨éä¹ä¼ç¸åºæ¹åãéè¿æ³¨éï¼æä»¬å¯ä»¥è®©dafnyè¯ææä»¬å£°æçæ¹æ³çå±æ§æ¯ççãæå ç§æ¹æ³å¯ä»¥ç»åºæ³¨è§£ï¼ä½æå¸¸è§åæåºæ¬çæ¯æ¹æ³çåç½®æ¡ä»¶ååç½®æ¡ä»¶ã absæ¹æ³çè¿ä¸ªå±æ§ï¼å³ç»ææ»æ¯éè´çï¼æ¯åç½®æ¡ä»¶çä¸ä¸ªä¾å­:å®æ¯å¨æ¹æ³è¿ååä¸ºçãç¨ensureså³é®å­å£°æçåç½®æ¡ä»¶ï¼ä½ä¸ºæ¹æ³å£°æçä¸é¨åï¼å¨è¿åå¼ä¹å(å¦æå­å¨)åæ¹æ³ä½ä¹åç»åºãå³é®å­åé¢è·çå¸å°è¡¨è¾¾å¼ãåifæ whileæ¡ä»¶åå¤§å¤æ°è§èä¸æ ·ï¼åç½®æ¡ä»¶æ»æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼:å¯ä»¥æ¯trueæ false. å¨absæ¹æ³çæåµä¸ï¼ä¸ä¸ªåççåç½®æ¡ä»¶å¦ä¸:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ å¯ä»¥å¨è¿éçå°ä¸ºä»ä¹è¿åå¼è¢«èµäºåç§°ãè¿ä½¿å¾å®ä»¬å¾å®¹æå¨æ¹æ³çåç½®æ¡ä»¶ä¸­å¼ç¨ãå½è¡¨è¾¾å¼ä¸ºçæ¶ï¼æä»¬è¯´åç½®æ¡ä»¶ä¿çãåç½®æ¡ä»¶å¿é¡»éç¨äºå½æ°çæ¯æ¬¡è°ç¨ï¼ä»¥åæ¯ä¸ªå¯è½çè¿åç¹ (åæ¬å½æ°ä½æ«å°¾çéå¼è¿åç¹)ãå¨è¿ç§æåµä¸ï¼æä»¬å¯ä¸è¦è¡¨è¾¾çå±æ§æ¯è¿åå¼æ»æ¯è³å°ä¸ºé¶ã ææ¶ï¼æä»¬éè¦ä¸ºä»£ç å»ºç«å¤ä¸ªå±æ§ãå¨è¿ç§æåµä¸ï¼æä»¬æä¸¤ä¸ªéæ©ãæä»¬å¯ä»¥ç¨å¸å°åçandæä½ç¬¦(&&), å°è¿ä¸¤ä¸ªæ¡ä»¶è¿æ¥èµ·æ¥ï¼æèå¯ä»¥ç¼åå¤ä¸ªensuresè¡¨è¾¾å¼ãåèä¸åèåºæ¬ç¸åï¼ä½å®åºåäºä¸åçå±æ§ãä¾å¦ï¼multiplereturns æ¹æ³çè¿åå¼åç§°å¯è½ä¼å¯¼è´äººä»¬çæµä»¥ä¸åç½®æ¡ä»¶:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nåç½®æ¡ä»¶ä¹å¯ä»¥è¿æ ·å:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nçè³æ¯è¿æ ·ï¼\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå ä¸ºdafnyä¸­ä½¿ç¨äºé¾æ¥æ¯è¾è¿ç®ç¬¦è¯­æ³ã(ä¸è¬æ¥è¯´ï¼å¤§å¤æ°æ¯è¾è¿ç®ç¬¦å¯ä»¥ä¸²èï¼ä½åªè½åç¸è¿æ¥ï¼å³ä¸è½æ··åä½¿ç¨å¤§äºåå°äºãè¯¦æè¯·åéåèèµæã) è¡¨ç¤ºåç½®æ¡ä»¶çç¬¬ä¸ç§æ¹å¼å°lessé¨åä¸moreé¨ååå¼ï¼è¿å¯è½æ¯å¯åçãå¦ä¸ä»¶éè¦æ³¨æçäºææ¯ï¼æä»¬å¨åç½®æ¡ä»¶ä¸­åå«äºä¸ä¸ªè¾å¥åæ°ãè¿æ¯æç¨çï¼å ä¸ºå®åè®¸æä»¬å°æ¹æ³çè¾å¥åè¾åºç¸äºå³è(è¿æ¯å ä¸ºè¾å¥åæ°æ¯åªè¯»çï¼æä»¥å¨æ«å°¾åå¼å§æ¶æ¯ä¸æ ·ç)ã dafnyå®éä¸æç»äºè¿ä¸ªç¨åºï¼å£°ç§°ç¬¬ä¸ä¸ªåç½®æ¡ä»¶ä¸æç« (å³ä¸ä¸ºç)ãè¿æå³çdafnyä¸è½è¯æè¯¥æ³¨éå¨æ¯æ¬¡æ¹æ³è¿åæ¶é½ææãéå¸¸ï¼dafnyéªè¯éè¯¯æä¸¤ä¸ªä¸»è¦åå :è§èä¸ä»£ç ä¸ä¸è´ï¼ä»¥åå®ä¸å¤èªææ¥è¯ææéå±æ§çæåµãåºåè¿ä¸¤ç§å¯è½æ§å¯è½æ¯ä¸é¡¹å°é¾çä»»å¡ï¼ä½å¹¸è¿çæ¯ï¼dafnyåå®æåºäºçboogie/z3ç³»ç»éå¸¸èªæï¼å¹¶ä¸å°è¯æä»£ç åè§èçå¹ééå¸¸ç®åã å¨è¿ç§æåµä¸ï¼dafnyè¯´ä»£ç æéè¯¯æ¯æ­£ç¡®çãé®é¢çå³é®å¨äºyæ¯æ´æ°ï¼æä»¥å®å¯ä»¥æ¯è´çãå¦æyä¸ºè´(æä¸ºé¶)ï¼é£ä¹moreå¯ä»¥å°äºæç­äºxãé¤éyä¸¥æ ¼å¤§äºé¶ï¼å¦åæä»¬çæ¹æ³å°æ æ³æ­£å¸¸å·¥ä½ãè¿æ­£æ¯çæ¦å¿µãåç½®æ¡ä»¶ç±»ä¼¼äºåç½®æ¡ä»¶ï¼é¤äºå®å¿é¡»å¨æ¹æ³è¢«è°ç¨ä¹åä¸ºçãå½æ¨è°ç¨ä¸ä¸ªæ¹æ³æ¶ï¼æ¨çå·¥ä½æ¯å»ºç«(ä½¿)åå³æ¡ä»¶ä¸ºçï¼è¿æ¯dafnyä½¿ç¨è¯ææ¥å®ç°çãåæ ·ï¼å½æ¨ç¼åä¸ä¸ªæ¹æ³æ¶ï¼æ¨å¯ä»¥åå®åå³æ¡ä»¶ï¼ä½æ¯æ¨å¿é¡»å»ºç«åç½®æ¡ä»¶ãç¶åï¼æ¹æ³çè°ç¨èå¯ä»¥åå®æ¹æ³è¿ååç½®æ¡ä»¶ä¿æä¸åã åææ¡ä»¶æèªå·±çå³é®å­requiresãæä»¬å¯ä»¥ç»äºå¤æ¬¡è¿åå¿è¦çåå³æ¡ä»¶å¦ä¸:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä¸åç½®æ¡ä»¶ä¸æ ·ï¼å¤ä¸ªåç½®æ¡ä»¶å¯ä»¥ç¨å¸å°åçandæä½ç¬¦(&&)æå¤ä¸ªrequireå³é®å­æ¥åãä¼ ç»ä¸ï¼æºä»£ç ä¸­çrequiresä¼åäºensureï¼å°½ç®¡è¿å¹¶ä¸æ¯ç»å¯¹å¿è¦ç(å°½ç®¡requiresåensureæ³¨éç¸å¯¹äºå¶ä»åç±»åæ³¨éçé¡ºåºææ¶ä¼å¾éè¦ï¼æä»¬å°å¨åé¢çå°)ãæ·»å äºè¿ä¸ªæ¡ä»¶åï¼dafnyç°å¨éªè¯ä»£ç æ¯å¦æ­£ç¡®ï¼åªéè¦ä¿è¯è¿ä¸ªåè®¾æ­£ç¡®ï¼å°±å¯ä»¥ä¿è¯æ¹æ³ä½ä¸­çä»£ç æ¯æ­£ç¡®çã\n\nç»ä¹ 0\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæ¹æ³maxï¼å®æ¥åä¸¤ä¸ªæ´æ°åæ°å¹¶è¿åå®ä»¬çæå¤§å¼ãæ·»å éå½çæ³¨éï¼å¹¶ç¡®ä¿å¯¹ä»£ç è¿è¡éªè¯ã\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¹¶ä¸æ¯ææçæ¹æ³é½æåå³æ¡ä»¶ãä¾å¦ï¼æä»¬å·²ç»çå°çabsæ¹æ³æ¯ä¸ºæææ´æ°å®ä¹çï¼å æ­¤æ²¡æä»»ä½åå³æ¡ä»¶(é¤äºå®çåæ°æ¯æ´æ°è¿ä¸çç¢çè¦æ±ï¼è¿æ¯ç±ç±»åç³»ç»å¼ºå¶æ§è¡ç)ãå°½ç®¡å®ä¸éè¦åå³æ¡ä»¶ï¼abså½æ°ç®åçæåµä¸å¹¶ä¸æ¯å¾æç¨ãä¸ºäºæ¢ç©¶å¶ä¸­çåå ï¼æä»¬éè¦ä½¿ç¨å¦ä¸ç§æ³¨éï¼å³æ­è¨ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ­è¨",frontmatter:{title:"æ­è¨",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/36c1b4/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/15.%E6%96%AD%E8%A8%80.html",relativePath:"30.æç¨/00.Dafnyæç¨/15.æ­è¨.md",key:"v-8af21fba",path:"/pages/36c1b4/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# æ­è¨\n\nä¸åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸åï¼æ­è¨è¢«æ¾ç½®å¨æ¹æ³çä¸­é´ãååé¢ä¸¤ä¸ªæ³¨éä¸æ ·ï¼æ­è¨æä¸ä¸ªå³é®å­assertï¼åé¢è·çå¸å°è¡¨è¾¾å¼åç»æç®åè¯­å¥çåå·ãæ­è¨è¡¨ç¤ºï¼å½æ§å¶å°è¾¾ä»£ç çè¿ä¸é¨åæ¶ï¼ç¹å®çè¡¨è¾¾å¼æ»æ¯ä¿æä¸åãä¾å¦ï¼ä¸é¢æ¯ä¸ä¸ªå¨èææ¹æ³ä¸­ä½¿ç¨æ­è¨çç®åä¾å­:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try \"asserting\" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafnyè¯æäºè¿ç§æ¹æ³æ¯æ­£ç¡®çï¼å ä¸º2æ»æ¯å°äº3ãæ­è¨æå ä¸ªç¨éï¼ä½å¶ä¸­æä¸»è¦çæ¯æ£æ¥ä½ çææå¨ä¸åçç¹ä¸æ¯å¦ççæ¯ççãå¦ä¸æè¿°ï¼æ¨å¯ä»¥ä½¿ç¨å®æ¥æ£æ¥åºæ¬çç®æ¯äºå®ï¼ä½å®ä»¬ä¹å¯ä»¥ç¨äºæ´å¤æçæåµãéè¿æ£æ¥Dafnyè½å¤è¯ææ¨çä»£ç ï¼æ­è¨æ¯è°è¯æ³¨éçå¼ºå¤§å·¥å·ãä¾å¦ï¼æä»¬å¯ä»¥ç¨å®æ¥ç ç©¶Dafnyå¯¹Abså½æ°çäºè§£ã ä¸ºæ­¤ï¼æä»¬è¿éè¦ä¸ä¸ªæ¦å¿µ:å±é¨åéãå±é¨åéçè¡ä¸ºä¸æ¨æææçå®å¨ä¸æ ·ï¼é¤äºå¯è½å­å¨ä¸äºä¸é®è½æå³çé®é¢ã(è¯¦è§åèèµæ)å±é¨åéç¨varå³é®å­å£°æï¼å¹¶ä¸å¯ä»¥æç±»åå£°æãä¸éè¦ç±»åçæ¹æ³åæ°ä¸åï¼Dafnyå ä¹å¯ä»¥å¨æææåµä¸æ¨æ­åºå±é¨åéçç±»åãä¸é¢æ¯ä¸ä¸ªåå§åçæ¾å¼ç±»ååéå£°æçä¾å­:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nå¨è¿ç§æåµä¸ï¼å¯ä»¥å é¤ç±»åæ³¨é:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nå¯ä»¥åæ¶å£°æå¤ä¸ªåé:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\næ¾å¼ç±»åå£°æåªéç¨äºç´§æ¥å¨åé¢çåéï¼å æ­¤è¿éçboolå£°æåªéç¨äºzï¼èä¸éç¨äºxæyï¼å®ä»¬é½è¢«æ¨æ­ä¸ºintãæä»¬éè¦åéï¼å ä¸ºæä»¬æ³è®¨è®ºAbsæ¹æ³çè¿åå¼ãæä»¬ä¸è½ç´æ¥å°Absæ¾å¥è§èä¸­ï¼å ä¸ºè¯¥æ¹æ³å¯è½ä¼æ¹ååå­ç¶æä»¥åå¶ä»é®é¢ãå æ­¤ï¼æä»¬æè·è°ç¨Absçè¿åå¼å¦ä¸:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nè¿æ¯ä¸ä¸ªä¾å­ï¼æä»¬å¯ä»¥é®Dafnyå®ç¥éä»£ç ä¸­çå¼ï¼å¨è¿ä¸ªä¾å­ä¸­æ¯vãæä»¬éè¿æ·»å æ­è¨æ¥å®ç°ï¼å°±åä¸é¢çæ­è¨ä¸æ ·ãæ¯å½Dafnyéå°æ­è¨æ¶ï¼å®é½ä¼è¯å¾è¯æè¯¥æ¡ä»¶éç¨äºä»£ç çæææ§è¡ãå¨æ¬ä¾ä¸­ï¼éè¿è¯¥æ¹æ³åªæä¸æ¡æ§å¶è·¯å¾ï¼Dafnyè½å¤è½»æ¾å°è¯ææ³¨éï¼å ä¸ºå®æ­£æ¯Absæ¹æ³çååæ¡ä»¶ãAbsä¿è¯è¿åå¼æ¯éè´çï¼æä»¥å®å¾å®¹æè·évï¼ä¹å°±æ¯è¿ä¸ªå¼ï¼å¨è°ç¨Absä¹åæ¯éè´çã\n\nç»ä¹ 1\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæµè¯æ¹æ³ï¼è°ç¨ç»ä¹ 0ä¸­çMaxæ¹æ³ï¼ç¶åå¯¹ç»æè¿è¡æ­è¨å¤çã\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä½æä»¬å¯¹Absæ³ææ´æ·±çäºè§£ãç¹å«æ¯å¯¹äºéè´çxï¼Abs(x) == xãå·ä½æ¥è¯´ï¼å¨ä¸é¢çç¨åºä¸­ï¼vçå¼ä¸º3ãå¦ææä»¬å°è¯æ·»å ä¸ä¸ªæ­è¨(ææ´æ¹ç°æçæ­è¨):\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\næä»¬åç°Dafnyä¸è½è¯ææä»¬çæ­è¨ï¼å¹¶ç»åºä¸ä¸ªéè¯¯ãåçè¿ç§æåµçåå æ¯ï¼Dafnyå¿è®°äºé¤å½åæ­£å¨å¤ççæ¹æ³ä¹å¤çæææ¹æ³çä¸»ä½ãè¿æå¤§å°ç®åäºDafnyçå·¥ä½ï¼ä¹æ¯å®è½å¤ä»¥åçéåº¦è¿è¡çåå ä¹ä¸ãå®è¿éè¿å°ç¨åºåè§£æ¥å¸®å©æä»¬å¯¹ç¨åºè¿è¡æ¨çï¼è¿æ ·æä»¬å°±å¯ä»¥åç¬åææ¯ä¸ªæ¹æ³*(ç»åºå¶ä»æ¹æ³çæ³¨é)*ãå½æä»¬è°ç¨æ¯ä¸ªæ¹æ³æ¶ï¼æä»¬æ ¹æ¬ä¸å³å¿å®åé¨åçäºä»ä¹ï¼åªè¦å®æ»¡è¶³å®çæ³¨è§£ãè¿æ¯å¯è¡çï¼å ä¸ºDafnyå°è¯æææçæ¹æ³é½æ»¡è¶³å®ä»¬çæ³¨éï¼å¹¶æç»ç¼è¯æä»¬çä»£ç ï¼ç´å°å®ä»¬æ»¡è¶³ã\n\nå¯¹äºAbsæ¹æ³ï¼è¿æå³çDafnyå¨testæ¹æ³ä¸­æç¥éçå³äºAbsè¿åå¼çå¯ä¸ä¿¡æ¯å°±æ¯åç½®æ¡ä»¶å¯¹å®çè¯´æï¼ä»æ­¤èå·²ãè¿æå³çDafnyä¸ç¥éå³äºAbsåéè´æ´æ°çå¥½å±æ§ï¼é¤éæä»¬æå®æ¾å¨Absæ¹æ³çåç½®æ¡ä»¶ä¸­ãå¦ä¸ç§æ¹æ³æ¯å°æ¹æ³æ³¨é(ä»¥ååæ°åè¿åå¼çç±»å)è§ä¸ºä¿®å¤æ¹æ³è¡ä¸ºçæ¹æ³ãå¨ä»»ä½ä½¿ç¨è¯¥æ¹æ³çå°æ¹ï¼æä»¬åå®å®æ¯æ»¡è¶³åç½®ååç½®æ¡ä»¶çä»»ä½ä¸ç§å¯æ³è±¡çæ¹æ³ãå¨Absæåµä¸ï¼æä»¬å¯ä»¥è¿æ ·å:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nè¯¥æ¹æ³æ»¡è¶³åç½®æ¡ä»¶ï¼ä½æ¾ç¶æ»¡è¶³ç¨åºçæ®µ:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¨è¿ä¸ªä¾å­ä¸­æ¯ä¸æç«çãDafnyæ­£å¨ä»¥ä¸ç§æ½è±¡çæ¹å¼èèå¸¦æè¿äºæ³¨éçæææ¹æ³ãæ°å­¦ç»å¯¹å¼å½ç¶æ¯è¿æ ·ä¸ç§æ¹æ³ï¼ä½æ¯ææè¿åæ­£å¸¸æ°çæ¹æ³ä¹æ¯è¿æ ·ãæä»¬éè¦æ´å¼ºçåç½®æ¡ä»¶æ¥æ¶é¤è¿äºå¶ä»å¯è½æ§ï¼å¹¶å°æ¹æ³ä¿®æ­£ä¸ºæä»¬æ³è¦çæ¹æ³ãæä»¬å¯ä»¥éè¿ä»¥ä¸æ¹æ³é¨åå°åå°è¿ä¸ç¹:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿æ­£å¥½è¡¨è¾¾äºæä»¬ä¹åè®¨è®ºè¿çæ§è´¨ï¼å³éè´æ´æ°çç»å¯¹å¼æ¯ç¸åçãç¬¬äºä¸ªç¡®ä¿æ¯éè¿éå«æä½ç¬¦è¡¨ç¤ºçï¼å®åºæ¬ä¸è¯´ï¼å¨æ°å­¦æä¹ä¸ï¼å·¦è¾¹æå³çå³è¾¹(å®çç»å®æ¯å¸å°andåæ¯è¾æ´å¼±ï¼æä»¥ä¸é¢è¯´ï¼0 <= xæå³çy == x)ãå·¦å³ä¸¤è¾¹å¿é¡»é½æ¯å¸å°è¡¨è¾¾å¼ã åç½®æ¡ä»¶æ¯ï¼å¨Absè¢«è°ç¨åï¼å¦æxçå¼æ¯éè´çï¼é£ä¹yç­äºxãè¿ä¸ªæç¤ºçä¸ä¸ªè­¦åæ¯ï¼å¦æå·¦é¨å(åè¡è¯)ä¸ºåï¼å®ä»ç¶ä¸ºçãæä»¥å½xä¸ºè´æ¶ç¬¬äºä¸ªåç½®æ¡ä»¶æ¯æç«çãäºå®ä¸ï¼æ³¨è§£è¯´çå¯ä¸ä¸ä»¶äºæ¯å½xä¸ºè´æ¶ï¼ç»æyä¸ºæ­£ãä½è¿ä»ç¶ä¸è¶³ä»¥ä¿®å¤è¯¥æ¹æ³ï¼æä»¥æä»¬å¿é¡»æ·»å å¦ä¸ä¸ªåç½®æ¡ä»¶ï¼ä»¥ä½¿ä»¥ä¸å®æ´çæ³¨éè¦çæææåµ:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nè¿äºæ³¨éè¶³ä»¥è¦æ±æä»¬çæ¹æ³å®éè®¡ç®xçç»å¯¹å¼ãè¿äºåç½®æ¡ä»¶å¹¶ä¸æ¯è¡¨ç¤ºè¯¥å±æ§çå¯ä¸æ¹æ³ãä¾å¦ï¼è¿æ¯è¡¨è¾¾åä¸ä»¶äºçä¸ç§ä¸åçï¼ç¨å¾®ç®ç­çæ¹å¼:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä¸è¬æ¥è¯´ï¼æå¾å¤æ¹æ³å¯ä»¥ååºä¸ä¸ªç»å®çæ§è´¨ãå¤§å¤æ°æ¶åï¼éæ©åªä¸ä¸ªå¹¶ä¸éè¦ï¼ä½æ¯ä¸ä¸ªå¥½çéæ©å¯ä»¥ä½¿æ¨æ´å®¹æçè§£æè¿°çå±æ§å¹¶éªè¯å¶æ­£ç¡®æ§ã ä½æä»¬ä»ç¶æä¸ä¸ªé®é¢:ä¼¼ä¹æå¾å¤éå¤ãæ¹æ³çä¸»ä½å¨æ³¨éä¸­å¾å°äºéå¸¸å¯åçåæ ãè½ç¶è¿æ¯æ­£ç¡®çä»£ç ï¼ä½æä»¬å¸ææ¶é¤è¿ç§åä½ãæ­£å¦æ¨å¯è½çå°çï¼Dafnyæä¾äºä¸ç§å®ç°è¿ä¸ç¹çæ¹æ³:å½æ°ã\n\nç»ä¹ 2\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä½¿ç¨åç½®æ¡ä»¶ï¼æ¹åAbsï¼è¯´å®åªè½è°ç¨è´å¼ãå°Absçä¸»ä½ç®åä¸ºä¸ä¸ªè¿åè¯­å¥ï¼å¹¶ç¡®ä¿è¯¥æ¹æ³ä»ç¶è¢«éªè¯ã\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nç»ä¹ 3\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿æAbsçåç½®æ¡ä»¶ä¸ä¸é¢ç¸åï¼å°Absçä¸»ä½æ´æ¹ä¸ºy:= x + 2ãä¸ºäºè¿è¡éªè¯ï¼æ¨éè¦ä½¿ç¨ä»ä¹åææ¡ä»¶æ¥æ³¨éæ¹æ³?å¦æä¸»ä½æ¯y:= x + 1ï¼ä½ éè¦ä»ä¹åææ¡ä»¶?å½ä½ å¯ä»¥è°ç¨è¿ä¸ªæ¹æ³æ¶ï¼åå³æ¡ä»¶è¯´äºä»ä¹?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n#",normalizedContent:"# æ­è¨\n\nä¸åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸åï¼æ­è¨è¢«æ¾ç½®å¨æ¹æ³çä¸­é´ãååé¢ä¸¤ä¸ªæ³¨éä¸æ ·ï¼æ­è¨æä¸ä¸ªå³é®å­assertï¼åé¢è·çå¸å°è¡¨è¾¾å¼åç»æç®åè¯­å¥çåå·ãæ­è¨è¡¨ç¤ºï¼å½æ§å¶å°è¾¾ä»£ç çè¿ä¸é¨åæ¶ï¼ç¹å®çè¡¨è¾¾å¼æ»æ¯ä¿æä¸åãä¾å¦ï¼ä¸é¢æ¯ä¸ä¸ªå¨èææ¹æ³ä¸­ä½¿ç¨æ­è¨çç®åä¾å­:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try \"asserting\" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafnyè¯æäºè¿ç§æ¹æ³æ¯æ­£ç¡®çï¼å ä¸º2æ»æ¯å°äº3ãæ­è¨æå ä¸ªç¨éï¼ä½å¶ä¸­æä¸»è¦çæ¯æ£æ¥ä½ çææå¨ä¸åçç¹ä¸æ¯å¦ççæ¯ççãå¦ä¸æè¿°ï¼æ¨å¯ä»¥ä½¿ç¨å®æ¥æ£æ¥åºæ¬çç®æ¯äºå®ï¼ä½å®ä»¬ä¹å¯ä»¥ç¨äºæ´å¤æçæåµãéè¿æ£æ¥dafnyè½å¤è¯ææ¨çä»£ç ï¼æ­è¨æ¯è°è¯æ³¨éçå¼ºå¤§å·¥å·ãä¾å¦ï¼æä»¬å¯ä»¥ç¨å®æ¥ç ç©¶dafnyå¯¹abså½æ°çäºè§£ã ä¸ºæ­¤ï¼æä»¬è¿éè¦ä¸ä¸ªæ¦å¿µ:å±é¨åéãå±é¨åéçè¡ä¸ºä¸æ¨æææçå®å¨ä¸æ ·ï¼é¤äºå¯è½å­å¨ä¸äºä¸é®è½æå³çé®é¢ã(è¯¦è§åèèµæ)å±é¨åéç¨varå³é®å­å£°æï¼å¹¶ä¸å¯ä»¥æç±»åå£°æãä¸éè¦ç±»åçæ¹æ³åæ°ä¸åï¼dafnyå ä¹å¯ä»¥å¨æææåµä¸æ¨æ­åºå±é¨åéçç±»åãä¸é¢æ¯ä¸ä¸ªåå§åçæ¾å¼ç±»ååéå£°æçä¾å­:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nå¨è¿ç§æåµä¸ï¼å¯ä»¥å é¤ç±»åæ³¨é:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nå¯ä»¥åæ¶å£°æå¤ä¸ªåé:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\næ¾å¼ç±»åå£°æåªéç¨äºç´§æ¥å¨åé¢çåéï¼å æ­¤è¿éçboolå£°æåªéç¨äºzï¼èä¸éç¨äºxæyï¼å®ä»¬é½è¢«æ¨æ­ä¸ºintãæä»¬éè¦åéï¼å ä¸ºæä»¬æ³è®¨è®ºabsæ¹æ³çè¿åå¼ãæä»¬ä¸è½ç´æ¥å°absæ¾å¥è§èä¸­ï¼å ä¸ºè¯¥æ¹æ³å¯è½ä¼æ¹ååå­ç¶æä»¥åå¶ä»é®é¢ãå æ­¤ï¼æä»¬æè·è°ç¨absçè¿åå¼å¦ä¸:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nè¿æ¯ä¸ä¸ªä¾å­ï¼æä»¬å¯ä»¥é®dafnyå®ç¥éä»£ç ä¸­çå¼ï¼å¨è¿ä¸ªä¾å­ä¸­æ¯vãæä»¬éè¿æ·»å æ­è¨æ¥å®ç°ï¼å°±åä¸é¢çæ­è¨ä¸æ ·ãæ¯å½dafnyéå°æ­è¨æ¶ï¼å®é½ä¼è¯å¾è¯æè¯¥æ¡ä»¶éç¨äºä»£ç çæææ§è¡ãå¨æ¬ä¾ä¸­ï¼éè¿è¯¥æ¹æ³åªæä¸æ¡æ§å¶è·¯å¾ï¼dafnyè½å¤è½»æ¾å°è¯ææ³¨éï¼å ä¸ºå®æ­£æ¯absæ¹æ³çååæ¡ä»¶ãabsä¿è¯è¿åå¼æ¯éè´çï¼æä»¥å®å¾å®¹æè·évï¼ä¹å°±æ¯è¿ä¸ªå¼ï¼å¨è°ç¨absä¹åæ¯éè´çã\n\nç»ä¹ 1\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæµè¯æ¹æ³ï¼è°ç¨ç»ä¹ 0ä¸­çmaxæ¹æ³ï¼ç¶åå¯¹ç»æè¿è¡æ­è¨å¤çã\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä½æä»¬å¯¹absæ³ææ´æ·±çäºè§£ãç¹å«æ¯å¯¹äºéè´çxï¼abs(x) == xãå·ä½æ¥è¯´ï¼å¨ä¸é¢çç¨åºä¸­ï¼vçå¼ä¸º3ãå¦ææä»¬å°è¯æ·»å ä¸ä¸ªæ­è¨(ææ´æ¹ç°æçæ­è¨):\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\næä»¬åç°dafnyä¸è½è¯ææä»¬çæ­è¨ï¼å¹¶ç»åºä¸ä¸ªéè¯¯ãåçè¿ç§æåµçåå æ¯ï¼dafnyå¿è®°äºé¤å½åæ­£å¨å¤ççæ¹æ³ä¹å¤çæææ¹æ³çä¸»ä½ãè¿æå¤§å°ç®åäºdafnyçå·¥ä½ï¼ä¹æ¯å®è½å¤ä»¥åçéåº¦è¿è¡çåå ä¹ä¸ãå®è¿éè¿å°ç¨åºåè§£æ¥å¸®å©æä»¬å¯¹ç¨åºè¿è¡æ¨çï¼è¿æ ·æä»¬å°±å¯ä»¥åç¬åææ¯ä¸ªæ¹æ³*(ç»åºå¶ä»æ¹æ³çæ³¨é)*ãå½æä»¬è°ç¨æ¯ä¸ªæ¹æ³æ¶ï¼æä»¬æ ¹æ¬ä¸å³å¿å®åé¨åçäºä»ä¹ï¼åªè¦å®æ»¡è¶³å®çæ³¨è§£ãè¿æ¯å¯è¡çï¼å ä¸ºdafnyå°è¯æææçæ¹æ³é½æ»¡è¶³å®ä»¬çæ³¨éï¼å¹¶æç»ç¼è¯æä»¬çä»£ç ï¼ç´å°å®ä»¬æ»¡è¶³ã\n\nå¯¹äºabsæ¹æ³ï¼è¿æå³çdafnyå¨testæ¹æ³ä¸­æç¥éçå³äºabsè¿åå¼çå¯ä¸ä¿¡æ¯å°±æ¯åç½®æ¡ä»¶å¯¹å®çè¯´æï¼ä»æ­¤èå·²ãè¿æå³çdafnyä¸ç¥éå³äºabsåéè´æ´æ°çå¥½å±æ§ï¼é¤éæä»¬æå®æ¾å¨absæ¹æ³çåç½®æ¡ä»¶ä¸­ãå¦ä¸ç§æ¹æ³æ¯å°æ¹æ³æ³¨é(ä»¥ååæ°åè¿åå¼çç±»å)è§ä¸ºä¿®å¤æ¹æ³è¡ä¸ºçæ¹æ³ãå¨ä»»ä½ä½¿ç¨è¯¥æ¹æ³çå°æ¹ï¼æä»¬åå®å®æ¯æ»¡è¶³åç½®ååç½®æ¡ä»¶çä»»ä½ä¸ç§å¯æ³è±¡çæ¹æ³ãå¨absæåµä¸ï¼æä»¬å¯ä»¥è¿æ ·å:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nè¯¥æ¹æ³æ»¡è¶³åç½®æ¡ä»¶ï¼ä½æ¾ç¶æ»¡è¶³ç¨åºçæ®µ:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¨è¿ä¸ªä¾å­ä¸­æ¯ä¸æç«çãdafnyæ­£å¨ä»¥ä¸ç§æ½è±¡çæ¹å¼èèå¸¦æè¿äºæ³¨éçæææ¹æ³ãæ°å­¦ç»å¯¹å¼å½ç¶æ¯è¿æ ·ä¸ç§æ¹æ³ï¼ä½æ¯ææè¿åæ­£å¸¸æ°çæ¹æ³ä¹æ¯è¿æ ·ãæä»¬éè¦æ´å¼ºçåç½®æ¡ä»¶æ¥æ¶é¤è¿äºå¶ä»å¯è½æ§ï¼å¹¶å°æ¹æ³ä¿®æ­£ä¸ºæä»¬æ³è¦çæ¹æ³ãæä»¬å¯ä»¥éè¿ä»¥ä¸æ¹æ³é¨åå°åå°è¿ä¸ç¹:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿æ­£å¥½è¡¨è¾¾äºæä»¬ä¹åè®¨è®ºè¿çæ§è´¨ï¼å³éè´æ´æ°çç»å¯¹å¼æ¯ç¸åçãç¬¬äºä¸ªç¡®ä¿æ¯éè¿éå«æä½ç¬¦è¡¨ç¤ºçï¼å®åºæ¬ä¸è¯´ï¼å¨æ°å­¦æä¹ä¸ï¼å·¦è¾¹æå³çå³è¾¹(å®çç»å®æ¯å¸å°andåæ¯è¾æ´å¼±ï¼æä»¥ä¸é¢è¯´ï¼0 <= xæå³çy == x)ãå·¦å³ä¸¤è¾¹å¿é¡»é½æ¯å¸å°è¡¨è¾¾å¼ã åç½®æ¡ä»¶æ¯ï¼å¨absè¢«è°ç¨åï¼å¦æxçå¼æ¯éè´çï¼é£ä¹yç­äºxãè¿ä¸ªæç¤ºçä¸ä¸ªè­¦åæ¯ï¼å¦æå·¦é¨å(åè¡è¯)ä¸ºåï¼å®ä»ç¶ä¸ºçãæä»¥å½xä¸ºè´æ¶ç¬¬äºä¸ªåç½®æ¡ä»¶æ¯æç«çãäºå®ä¸ï¼æ³¨è§£è¯´çå¯ä¸ä¸ä»¶äºæ¯å½xä¸ºè´æ¶ï¼ç»æyä¸ºæ­£ãä½è¿ä»ç¶ä¸è¶³ä»¥ä¿®å¤è¯¥æ¹æ³ï¼æä»¥æä»¬å¿é¡»æ·»å å¦ä¸ä¸ªåç½®æ¡ä»¶ï¼ä»¥ä½¿ä»¥ä¸å®æ´çæ³¨éè¦çæææåµ:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nè¿äºæ³¨éè¶³ä»¥è¦æ±æä»¬çæ¹æ³å®éè®¡ç®xçç»å¯¹å¼ãè¿äºåç½®æ¡ä»¶å¹¶ä¸æ¯è¡¨ç¤ºè¯¥å±æ§çå¯ä¸æ¹æ³ãä¾å¦ï¼è¿æ¯è¡¨è¾¾åä¸ä»¶äºçä¸ç§ä¸åçï¼ç¨å¾®ç®ç­çæ¹å¼:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä¸è¬æ¥è¯´ï¼æå¾å¤æ¹æ³å¯ä»¥ååºä¸ä¸ªç»å®çæ§è´¨ãå¤§å¤æ°æ¶åï¼éæ©åªä¸ä¸ªå¹¶ä¸éè¦ï¼ä½æ¯ä¸ä¸ªå¥½çéæ©å¯ä»¥ä½¿æ¨æ´å®¹æçè§£æè¿°çå±æ§å¹¶éªè¯å¶æ­£ç¡®æ§ã ä½æä»¬ä»ç¶æä¸ä¸ªé®é¢:ä¼¼ä¹æå¾å¤éå¤ãæ¹æ³çä¸»ä½å¨æ³¨éä¸­å¾å°äºéå¸¸å¯åçåæ ãè½ç¶è¿æ¯æ­£ç¡®çä»£ç ï¼ä½æä»¬å¸ææ¶é¤è¿ç§åä½ãæ­£å¦æ¨å¯è½çå°çï¼dafnyæä¾äºä¸ç§å®ç°è¿ä¸ç¹çæ¹æ³:å½æ°ã\n\nç»ä¹ 2\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä½¿ç¨åç½®æ¡ä»¶ï¼æ¹åabsï¼è¯´å®åªè½è°ç¨è´å¼ãå°absçä¸»ä½ç®åä¸ºä¸ä¸ªè¿åè¯­å¥ï¼å¹¶ç¡®ä¿è¯¥æ¹æ³ä»ç¶è¢«éªè¯ã\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nç»ä¹ 3\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿æabsçåç½®æ¡ä»¶ä¸ä¸é¢ç¸åï¼å°absçä¸»ä½æ´æ¹ä¸ºy:= x + 2ãä¸ºäºè¿è¡éªè¯ï¼æ¨éè¦ä½¿ç¨ä»ä¹åææ¡ä»¶æ¥æ³¨éæ¹æ³?å¦æä¸»ä½æ¯y:= x + 1ï¼ä½ éè¦ä»ä¹åææ¡ä»¶?å½ä½ å¯ä»¥è°ç¨è¿ä¸ªæ¹æ³æ¶ï¼åå³æ¡ä»¶è¯´äºä»ä¹?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"å½æ°",frontmatter:{title:"å½æ°",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/a1d5a4/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/20.%E5%87%BD%E6%95%B0.html",relativePath:"30.æç¨/00.Dafnyæç¨/20.å½æ°.md",key:"v-305b9b44",path:"/pages/a1d5a4/",headersStr:null,content:"# å½æ°\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nè¿å£°æäºä¸ä¸ªåä¸º' abs 'çå½æ°ï¼å®æ¥åä¸ä¸ªæ´æ°ï¼å¹¶è¿åä¸ä¸ªæ´æ°(ç¬¬äºä¸ª' int ')ãä¸æ¹æ³ä¸åï¼æ¹æ³çä½ä¸­å¯ä»¥æåç§åæ ·çè¯­å¥ï¼å½æ°ä½å¿é¡»ç±ä¸ä¸ªæ­£ç¡®ç±»åçè¡¨è¾¾å¼ç»æãè¿éæä»¬çbodyå¿é¡»æ¯ä¸ä¸ªæ´æ°è¡¨è¾¾å¼ãä¸ºäºå®ç°ç»å¯¹å¼å½æ°ï¼æä»¬éè¦ä½¿ç¨ä¸ä¸ª ' if 'è¡¨è¾¾å¼ã' if 'è¡¨è¾¾å¼ç±»ä¼¼äºå¶ä»è¯­è¨ä¸­çä¸åè¿ç®ç¬¦ã\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\næ¾ç¶ï¼æ¡ä»¶å¿é¡»æ¯å¸å°è¡¨è¾¾å¼ï¼ä¸¤ä¸ªåæ¯å¿é¡»å·æç¸åçç±»åãæ¨å¯è½ä¼æ³ï¼å¦æä¸æ¹æ³ç¸æ¯ï¼å½æ°çåè½å¦æ­¤æéï¼ä¸ºä»ä¹è¿ä¼æäººä¸ºå½æ°è´¹å¿å¢?å½æ°çå¼ºå¤§ä¹å¤å¨äºå®ä»¬å¯ä»¥ç´æ¥å¨è§èä¸­ä½¿ç¨ãæä»¬å¯ä»¥è¿æ ·å:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\näºå®ä¸ï¼æä»¬ä¸ä»å¯ä»¥ç´æ¥ç¼åè¿ä¸ªè¯­å¥èä¸æè·ä¸ä¸ªå±é¨åéï¼çè³ä¸éè¦ç¼åæ¹æ³ä¸­æåçææåç½®æ¡ä»¶(å°½ç®¡å½æ°éå¸¸å¯ä»¥å¹¶ä¸ç¡®å®æåç½®æ¡ä»¶ååç½®æ¡ä»¶)ãæ­£æ¯å½æ°çå±éæ§è®©Dafnyåå°äºè¿ä¸ç¹ãä¸æ¹æ³ä¸åï¼å¨èèå¶ä»å½æ°æ¶ï¼Dafnyä¸ä¼å¿è®°å½æ°ä½ãå æ­¤ï¼å®å¯ä»¥æ©å±ä¸è¿°æ­è¨ä¸­çâabsâçå®ä¹ï¼å¹¶ç¡®å®ç»æå®éä¸æ¯â3âã\n\nç»ä¹ 4. ç¼åä¸ä¸ªå½æ°' max 'ï¼è¿åä¸¤ä¸ªç»å®æ´æ°åæ°ä¸­è¾å¤§çä¸ä¸ªãä½¿ç¨' assert 'ç¼åæµè¯æ¹æ³ï¼æ£æ¥å½æ°æ¯å¦æ­£ç¡®ã\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå³äºå½æ°çä¸ä¸ªè­¦åæ¯ï¼å®ä»¬ä¸ä»å¯ä»¥åºç°å¨æ³¨éä¸­ï¼èä¸åªè½åºç°å¨æ³¨éä¸­ãä½ ä¸è½è¿æ ·å:\n\n   var v := abs(3);\n\n\n1\n\n\nå ä¸ºè¿ä¸æ¯æ³¨éãå½æ°ä»æ¥ä¸æ¯æç»ç¼è¯çç¨åºçä¸é¨åï¼å®ä»¬åªæ¯å¸®å©æä»¬éªè¯ä»£ç çå·¥å·ãææ¶å¨å®éä»£ç ä¸­ä½¿ç¨å½æ°æ¯å¾æ¹ä¾¿çï¼æä»¥å¯ä»¥å®ä¹ä¸ä¸ªâå½æ°æ¹æ³âï¼å®å¯ä»¥ä»å®éä»£ç ä¸­è°ç¨ãè¯·æ³¨æï¼å¯¹äºåªäºå½æ°å¯ä»¥æ¯å½æ°æ¹æ³æä¸äºéå¶(è¯¦ç»ä¿¡æ¯è¯·åéåèèµæ)ã\n\nç»ä¹ 5. å°ç»ä¹ 4ä¸­çæµè¯æ¹æ³æ´æ¹ä¸ºå°' max 'çå¼æè·å°ä¸ä¸ªåéï¼ç¶åä½¿ç¨è¯¥åéæ§è¡ç»ä¹ 4ä¸­çæ£æ¥ãDafnyä¼æç»è¿ä¸ªç¨åºï¼å ä¸ºä½ æ­£å¨ä»çæ­£çä»£ç ä¸­è°ç¨' max 'ãä½¿ç¨âå½æ°æ¹æ³âä¿®å¤è¿ä¸ªé®é¢ã\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç»ä¹ 6. ç°å¨æä»¬æäºä¸ä¸ª' abs 'å½æ°ï¼æ¹å' abs 'æ¹æ³çåç½®æ¡ä»¶æ¥ä½¿ç¨' abs 'ãå¨ç¡®è®¤è¯¥æ¹æ³ä¹åä»ç¶è¿è¡éªè¯ï¼å°' Abs 'çä¸»ä½æ´æ¹ä¸ºä¹ä½¿ç¨' Abs 'ã(è¿æ ·åä¹åï¼æ¨å°ä¼æè¯å°ï¼ä½¿ç¨ä¸ä¸ªæ¹æ³æ¥åä¸å½æ°æ¹æ³å®å¨ç¸åçäºæå¹¶æ²¡æå¤å¤§æä¹ã)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nä¸æ¹æ³ä¸åï¼å½æ°å¯ä»¥åºç°å¨è¡¨è¾¾å¼ä¸­ãå æ­¤ï¼æä»¬å¯ä»¥åä¸äºäºæï¼æ¯å¦å®ç°æ°å­¦ææ³¢çº³å¥å½æ°:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿éæä»¬ä½¿ç¨ânatâï¼å³èªç¶æ°(éè´æ´æ°)çç±»åï¼è¿éå¸¸æ¯å°ææåå®¹é½æ³¨éä¸ºéè´æ´æ¹ä¾¿ãæä»¬å¯ä»¥æè¿ä¸ªå½æ°åæå½æ°æ¹æ³ãä½è¿å°æ¯éå¸¸ç¼æ¢çï¼å ä¸ºè¿ä¸ªçæ¬çè®¡ç®ææ³¢çº³å¥æ°å·æææ°å¤æåº¦ãæå¾å¤æ´å¥½çæ¹æ³æ¥è®¡ç®ææ³¢é£å¥å½æ°ãä½æ¯è¿ä¸ªå½æ°ä»ç¶æç¨ï¼å ä¸ºæä»¬å¯ä»¥è®©Dafnyè¯æä¸ä¸ªå¿«éçæ¬ç¡®å®ç¬¦åæ°å­¦å®ä¹ãæä»¬å¯ä»¥ä¸¤å¨å¶ç¾:ä¿è¯æ­£ç¡®æ§åæä»¬æ³è¦çæ§è½ã æä»¬å¯ä»¥åä¸é¢è¿æ ·å®ä¹ä¸ä¸ªæ¹æ³:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\næä»¬è¿æ²¡æç¼åä¸»ä½ï¼æä»¥Dafnyä¼æ±æ¨åç½®æ¡ä»¶ä¸æç«ãæä»¬éè¦ä¸ä¸ªç®æ³æ¥è®¡ç®ç¬¬nä¸ªææ³¢é£å¥æ°ãå¶åºæ¬ææ³æ¯ä¿æä¸ä¸ªè®¡æ°å¨ï¼å¹¶éå¤è®¡ç®ç¸é»çææ³¢é£å¥æ°å¯¹ï¼ç´å°è¾¾å°æéçæ°ãä¸ºæ­¤ï¼æä»¬éè¦ä¸ä¸ªå¾ªç¯ãå¨Dafnyä¸­ï¼è¿æ¯éè¿ä¸ä¸ª ' while 'å¾ªç¯å®æçãwhileå¾ªç¯å¦ä¸æç¤º:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nè¿æ¯ä¸ä¸ªç®åçå¾ªç¯ï¼åªå¢å ' i 'ç´å°' n 'ãè¿å°æææä»¬è®¡ç®ææ³¢é£å¥æ°åçå¾ªç¯çæ ¸å¿ã",normalizedContent:"# å½æ°\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nè¿å£°æäºä¸ä¸ªåä¸º' abs 'çå½æ°ï¼å®æ¥åä¸ä¸ªæ´æ°ï¼å¹¶è¿åä¸ä¸ªæ´æ°(ç¬¬äºä¸ª' int ')ãä¸æ¹æ³ä¸åï¼æ¹æ³çä½ä¸­å¯ä»¥æåç§åæ ·çè¯­å¥ï¼å½æ°ä½å¿é¡»ç±ä¸ä¸ªæ­£ç¡®ç±»åçè¡¨è¾¾å¼ç»æãè¿éæä»¬çbodyå¿é¡»æ¯ä¸ä¸ªæ´æ°è¡¨è¾¾å¼ãä¸ºäºå®ç°ç»å¯¹å¼å½æ°ï¼æä»¬éè¦ä½¿ç¨ä¸ä¸ª ' if 'è¡¨è¾¾å¼ã' if 'è¡¨è¾¾å¼ç±»ä¼¼äºå¶ä»è¯­è¨ä¸­çä¸åè¿ç®ç¬¦ã\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\næ¾ç¶ï¼æ¡ä»¶å¿é¡»æ¯å¸å°è¡¨è¾¾å¼ï¼ä¸¤ä¸ªåæ¯å¿é¡»å·æç¸åçç±»åãæ¨å¯è½ä¼æ³ï¼å¦æä¸æ¹æ³ç¸æ¯ï¼å½æ°çåè½å¦æ­¤æéï¼ä¸ºä»ä¹è¿ä¼æäººä¸ºå½æ°è´¹å¿å¢?å½æ°çå¼ºå¤§ä¹å¤å¨äºå®ä»¬å¯ä»¥ç´æ¥å¨è§èä¸­ä½¿ç¨ãæä»¬å¯ä»¥è¿æ ·å:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\näºå®ä¸ï¼æä»¬ä¸ä»å¯ä»¥ç´æ¥ç¼åè¿ä¸ªè¯­å¥èä¸æè·ä¸ä¸ªå±é¨åéï¼çè³ä¸éè¦ç¼åæ¹æ³ä¸­æåçææåç½®æ¡ä»¶(å°½ç®¡å½æ°éå¸¸å¯ä»¥å¹¶ä¸ç¡®å®æåç½®æ¡ä»¶ååç½®æ¡ä»¶)ãæ­£æ¯å½æ°çå±éæ§è®©dafnyåå°äºè¿ä¸ç¹ãä¸æ¹æ³ä¸åï¼å¨èèå¶ä»å½æ°æ¶ï¼dafnyä¸ä¼å¿è®°å½æ°ä½ãå æ­¤ï¼å®å¯ä»¥æ©å±ä¸è¿°æ­è¨ä¸­çâabsâçå®ä¹ï¼å¹¶ç¡®å®ç»æå®éä¸æ¯â3âã\n\nç»ä¹ 4. ç¼åä¸ä¸ªå½æ°' max 'ï¼è¿åä¸¤ä¸ªç»å®æ´æ°åæ°ä¸­è¾å¤§çä¸ä¸ªãä½¿ç¨' assert 'ç¼åæµè¯æ¹æ³ï¼æ£æ¥å½æ°æ¯å¦æ­£ç¡®ã\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå³äºå½æ°çä¸ä¸ªè­¦åæ¯ï¼å®ä»¬ä¸ä»å¯ä»¥åºç°å¨æ³¨éä¸­ï¼èä¸åªè½åºç°å¨æ³¨éä¸­ãä½ ä¸è½è¿æ ·å:\n\n   var v := abs(3);\n\n\n1\n\n\nå ä¸ºè¿ä¸æ¯æ³¨éãå½æ°ä»æ¥ä¸æ¯æç»ç¼è¯çç¨åºçä¸é¨åï¼å®ä»¬åªæ¯å¸®å©æä»¬éªè¯ä»£ç çå·¥å·ãææ¶å¨å®éä»£ç ä¸­ä½¿ç¨å½æ°æ¯å¾æ¹ä¾¿çï¼æä»¥å¯ä»¥å®ä¹ä¸ä¸ªâå½æ°æ¹æ³âï¼å®å¯ä»¥ä»å®éä»£ç ä¸­è°ç¨ãè¯·æ³¨æï¼å¯¹äºåªäºå½æ°å¯ä»¥æ¯å½æ°æ¹æ³æä¸äºéå¶(è¯¦ç»ä¿¡æ¯è¯·åéåèèµæ)ã\n\nç»ä¹ 5. å°ç»ä¹ 4ä¸­çæµè¯æ¹æ³æ´æ¹ä¸ºå°' max 'çå¼æè·å°ä¸ä¸ªåéï¼ç¶åä½¿ç¨è¯¥åéæ§è¡ç»ä¹ 4ä¸­çæ£æ¥ãdafnyä¼æç»è¿ä¸ªç¨åºï¼å ä¸ºä½ æ­£å¨ä»çæ­£çä»£ç ä¸­è°ç¨' max 'ãä½¿ç¨âå½æ°æ¹æ³âä¿®å¤è¿ä¸ªé®é¢ã\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç»ä¹ 6. ç°å¨æä»¬æäºä¸ä¸ª' abs 'å½æ°ï¼æ¹å' abs 'æ¹æ³çåç½®æ¡ä»¶æ¥ä½¿ç¨' abs 'ãå¨ç¡®è®¤è¯¥æ¹æ³ä¹åä»ç¶è¿è¡éªè¯ï¼å°' abs 'çä¸»ä½æ´æ¹ä¸ºä¹ä½¿ç¨' abs 'ã(è¿æ ·åä¹åï¼æ¨å°ä¼æè¯å°ï¼ä½¿ç¨ä¸ä¸ªæ¹æ³æ¥åä¸å½æ°æ¹æ³å®å¨ç¸åçäºæå¹¶æ²¡æå¤å¤§æä¹ã)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nä¸æ¹æ³ä¸åï¼å½æ°å¯ä»¥åºç°å¨è¡¨è¾¾å¼ä¸­ãå æ­¤ï¼æä»¬å¯ä»¥åä¸äºäºæï¼æ¯å¦å®ç°æ°å­¦ææ³¢çº³å¥å½æ°:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿éæä»¬ä½¿ç¨ânatâï¼å³èªç¶æ°(éè´æ´æ°)çç±»åï¼è¿éå¸¸æ¯å°ææåå®¹é½æ³¨éä¸ºéè´æ´æ¹ä¾¿ãæä»¬å¯ä»¥æè¿ä¸ªå½æ°åæå½æ°æ¹æ³ãä½è¿å°æ¯éå¸¸ç¼æ¢çï¼å ä¸ºè¿ä¸ªçæ¬çè®¡ç®ææ³¢çº³å¥æ°å·æææ°å¤æåº¦ãæå¾å¤æ´å¥½çæ¹æ³æ¥è®¡ç®ææ³¢é£å¥å½æ°ãä½æ¯è¿ä¸ªå½æ°ä»ç¶æç¨ï¼å ä¸ºæä»¬å¯ä»¥è®©dafnyè¯æä¸ä¸ªå¿«éçæ¬ç¡®å®ç¬¦åæ°å­¦å®ä¹ãæä»¬å¯ä»¥ä¸¤å¨å¶ç¾:ä¿è¯æ­£ç¡®æ§åæä»¬æ³è¦çæ§è½ã æä»¬å¯ä»¥åä¸é¢è¿æ ·å®ä¹ä¸ä¸ªæ¹æ³:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\næä»¬è¿æ²¡æç¼åä¸»ä½ï¼æä»¥dafnyä¼æ±æ¨åç½®æ¡ä»¶ä¸æç«ãæä»¬éè¦ä¸ä¸ªç®æ³æ¥è®¡ç®ç¬¬nä¸ªææ³¢é£å¥æ°ãå¶åºæ¬ææ³æ¯ä¿æä¸ä¸ªè®¡æ°å¨ï¼å¹¶éå¤è®¡ç®ç¸é»çææ³¢é£å¥æ°å¯¹ï¼ç´å°è¾¾å°æéçæ°ãä¸ºæ­¤ï¼æä»¬éè¦ä¸ä¸ªå¾ªç¯ãå¨dafnyä¸­ï¼è¿æ¯éè¿ä¸ä¸ª ' while 'å¾ªç¯å®æçãwhileå¾ªç¯å¦ä¸æç¤º:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nè¿æ¯ä¸ä¸ªç®åçå¾ªç¯ï¼åªå¢å ' i 'ç´å°' n 'ãè¿å°æææä»¬è®¡ç®ææ³¢é£å¥æ°åçå¾ªç¯çæ ¸å¿ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"å¾ªç¯ä¸åå¼",frontmatter:{title:"å¾ªç¯ä¸åå¼",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/d89435/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/25.%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F.html",relativePath:"30.æç¨/00.Dafnyæç¨/25.å¾ªç¯ä¸åå¼.md",key:"v-2b81695b",path:"/pages/d89435/",headersStr:null,content:"# å¾ªç¯ä¸åå¼\n\nâwhileâå¾ªç¯ç»Dafnyå¸¦æ¥äºä¸ä¸ªé®é¢ãDafnyæ æ³æåç¥éä»£ç å°å¾ªç¯å¤å°æ¬¡ãä½æ¯Dafnyéè¦èèç¨åºä¸­çææè·¯å¾ï¼è¿å¯è½åæ¬å¾ªç¯ä»»ææ¬¡æ°ãä¸ºäºä½¿Dafnyè½å¤ä½¿ç¨å¾ªç¯ï¼æ¨éè¦æä¾å¾ªç¯ä¸åå¼ï¼è¿æ¯å¦ä¸ç§æ³¨éã å¾ªç¯ä¸åå¼æ¯å¨è¿å¥å¾ªç¯æ¶ä»¥åæ¯æ¬¡å¾ªç¯ä½æ§è¡åä¿å­çè¡¨è¾¾å¼ãå®æè·äºä¸äºä¸åçä¸è¥¿ï¼ä¹å°±æ¯è¯´ï¼å¨å¾ªç¯çæ¯ä¸æ­¥ä¸­é½æ¯ä¸åçãç°å¨ï¼å¾ææ¾ï¼æä»¬éè¦å¨æ¯æ¬¡å¾ªç¯çæ¶åæ¹ååéï¼ç­ç­ï¼å¦åæä»¬å°±ä¸éè¦å¾ªç¯äºãååç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸æ ·ï¼ä¸åéæ¯ä¸ä¸ªå±æ§ï¼å®å¨æ¯æ¬¡å¾ªç¯æ§è¡æ¶é½è¢«ä¿çï¼ä½¿ç¨æä»¬å·²ç»çå°çå¸å°è¡¨è¾¾å¼è¡¨ç¤ºãä¾å¦ï¼æä»¬å¨ä¸é¢çå¾ªç¯ä¸­çå°ï¼å¦æ' i 'ä¸å¼å§æ¯æ­£çï¼é£ä¹å®å°±ä¸ç´æ¯æ­£çãå æ­¤ï¼æä»¬å¯ä»¥ä½¿ç¨å®èªå·±çå³é®å­å°ä¸åéæ·»å å°å¾ªç¯ä¸­:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nå½æ¨æå®ä¸ä¸ªä¸åéæ¶ï¼Dafnyè¯æäºä¸¤ä»¶äº:ä¸åéå¨è¿å¥å¾ªç¯æ¶ä¿æä¸åï¼å¹¶ä¸è¢«å¾ªç¯ä¿å­ãéè¿ä¿çï¼æä»¬çæææ¯åè®¾å¨å¾ªç¯å¼å§æ¶ä¸åå¼ä¿æä¸åï¼æä»¬å¿é¡»è¯ææ§è¡å¾ªç¯ä½ä¸æ¬¡ä½¿ä¸åå¼åæ¬¡ä¿æä¸åãDafnyåªè½å¨åæå¾ªç¯ä½æ¶ç¥éä¸åéè¯´äºä»ä¹ï¼é¤äºå¾ªç¯ä¿æ¤(å¾ªç¯æ¡ä»¶)ãå°±åDafnyèªå·±ä¸ä¼åç°æ¹æ³çå±æ§ä¸æ ·ï¼é¤ééè¿ä¸ä¸ªä¸åéåè¯å®ï¼å¦åå®åªä¼ç¥éå¾ªç¯çæåºæ¬å±æ§è¢«ä¿çã å¨æä»¬çä¾å­ä¸­ï¼å¾ªç¯çéç¹æ¯æ¯æ¬¡å»ºç«ä¸ä¸ª(å¥½å§ï¼ä¸¤ä¸ª)ææ³¢é£å¥æ°ï¼ç´å°æä»¬è¾¾å°æ³è¦çæ°ãéåºå¾ªç¯åï¼æä»¬å°å¾å°' i == n 'ï¼å ä¸ºå½iè¾¾å°' n 'æ¶ï¼' i 'å°åæ­¢éå¢ãæä»¬å¯ä»¥ä½¿ç¨æ­è¨æå·§æ¥æ£æ¥Dafnyæ¯å¦ä¹çå°äºè¿ä¸ªäºå®:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\næä»¬åç°è¿ä¸ªæ­è¨å¤±è´¥äºãæ®Dafnyæç¥ï¼å¨å¾ªç¯è¿ç¨ä¸­çæä¸ªç¹ä¸ï¼âiâå¯è½ä»¥æç§æ¹å¼åå¾æ¯ânâå¤§å¾å¤ãå¨å¾ªç¯éåºå(å³å¨å¾ªç¯ç»æåçä»£ç ä¸­)ï¼å®æç¥éçæ¯å¾ªç¯ä¿æ¤å¤±è´¥ï¼ä¸åéä¿æä¸åãå¨æ¬ä¾ä¸­ï¼è¿ç¸å½äº' n <= i 'å' 0 <= i 'ãä½è¿å¹¶ä¸è¶³ä»¥ä¿è¯' i == n 'ï¼åªä¿è¯' n <= i 'ãæä»¬éè¦æ¶é¤iè¶è¿nçå¯è½æ§ãè§£å³è¿ä¸ªé®é¢çç¬¬ä¸ä¸ªçæ³å¯è½æ¯:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nè¿å¹¶ä¸éªè¯ï¼å ä¸ºDafnyä¼æ¥éå¾ªç¯æ²¡æä¿å­(ä¹ç§°ä¸ºæ²¡æç»´æ¤)ä¸åå¼ãæä»¬å¸æè½å¤è¯´ï¼å¨å¾ªç¯ç»æåï¼ææä¸åå¼é½ä¿çä¸æ¥ãæä»¬çä¸åå¼éç¨äºå¾ªç¯çæ¯ä¸æ¬¡æ§è¡ï¼é¤äºæåä¸æ¬¡ãå ä¸ºå¾ªç¯ä½åªæå¨å¾ªç¯ä¿æ¤çææ¶ææ§è¡ï¼æä»¥å¨æåä¸æ¬¡è¿­ä»£ä¸­ï¼âiâä»ân - 1âå°ânâï¼ä½å¨å¾ªç¯éåºæ¶ä¸ä¼è¿ä¸æ­¥å¢å ãå æ­¤ï¼æä»¬åªä»æä»¬çä¸åéä¸­çç¥äºä¸ç§æåµï¼ä¿®å¤å®ç¸å¯¹å®¹æ:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nç°å¨ï¼æä»¬å¯ä»¥è¯´ï¼ân <= iâæ¥èªå¾ªç¯ä¿æ¤ï¼â0 <= i <= nâæ¥èªä¸åéï¼è¿åè®¸Dafnyè¯æâi == nâæ­è¨ãéæ©å¾ªç¯ä¸åéçææå¨äºæ¾å°ä¸ä¸ªè¢«å¾ªç¯ä¿ççä¸åéï¼èä¸å®è¿è½è®©æ¨è¯æå¨å¾ªç¯æ§è¡åéè¦ä»ä¹ã\n\nç»ä¹ 7. å°å¾ªç¯ä¸åéæ¹ä¸º' 0 <= i <= n+2 'ãå¾ªç¯æ¯å¦ä»ç¶éªè¯?æ­è¨' i == n 'å¨å¾ªç¯ä¹åä»ç¶éªè¯å?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nç»ä¹ 8. ä½¿ç¨åæ¥çå¾ªç¯ä¸åå¼ï¼å°å¾ªç¯å®å«ä»' i < n 'æ´æ¹ä¸º' i != n 'ãå¾ªç¯åå¾ªç¯åçæ­è¨ä»ç¶è¿è¡éªè¯å?ä¸ºä»ä¹æä¸ºä»ä¹ä¸?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\né¤äºè®¡æ°å¨ä¹å¤ï¼æä»¬çç®æ³è¿éè¦ä¸å¯¹è¡¨ç¤ºåºåä¸­ç¸é»ææ³¢é£å¥æ°åçæ°å­ãä¸åºææï¼æä»¬å°æå¦å¤ä¸ä¸¤ä¸ªä¸åå¼æ¥å°è¿äºæ°å­åè®¡æ°å¨èç³»èµ·æ¥ãä¸ºäºæ¾å°è¿äºä¸åéï¼æä»¬ä½¿ç¨äºä¸ç§å¸¸è§çDafnyæå·§:ä»åç½®æ¡ä»¶ååè®¡ç®ã ææ³¢é£å¥æ¹æ³çåç½®æ¡ä»¶æ¯è¿åå¼' b 'ç­äº' fib(n) 'ãä½æ¯å¨å¾ªç¯ä¹åï¼æä»¬æäº' i == n 'ï¼æä»¥å¨å¾ªç¯çæåæä»¬éè¦' b == fib(i) 'ãè¿å¯è½æ¯ä¸ä¸ªå¾å¥½çä¸åéï¼å ä¸ºå®ä¸å¾ªç¯è®¡æ°å¨ç¸å³ãè¿ç§ç°è±¡å¨Dafnyçç¨åºä¸­éå¸¸æ®éãéå¸¸ï¼ä¸ä¸ªæ¹æ³åªæ¯ä¸ä¸ªå¾ªç¯ï¼å½å®ç»ææ¶ï¼éè¿ä½¿è®¡æ°å¨è¾¾å°å¦ä¸ä¸ªæ°å­ï¼éå¸¸æ¯ä¸ä¸ªåæ°ææ°ç»æåºåçé¿åº¦ï¼ä½¿åç½®æ¡ä»¶ä¸ºçãåébï¼ä¹å°±æ¯æä»¬çè¾åºåæ°ï¼å°ä¼æ¯å½åçææ³¢é£å¥æ°å:\n\n   invariant b == fib(i)\n\n\n1\n\n\næä»¬è¿æ³¨æå°ï¼å¨æä»¬çç®æ³ä¸­ï¼æä»¬å¯ä»¥éè¿è·è¸ªä¸å¯¹æ°å­æ¥è®¡ç®ä»»ä½ææ³¢é£å¥æ°ï¼å¹¶å°å®ä»¬ç¸å å¾å°ä¸ä¸ä¸ªæ°å­ãæä»¬æ³è¦ä¸ç§æ¹æ³æ¥è¿½è¸ªä¹åçææ³¢é£å¥æ°ï¼æä»¬ç§°ä¹ä¸º' a 'å¦ä¸ä¸ªä¸åå¼å°è¡¨ç¤ºè¯¥æ°å­ä¸å¾ªç¯è®¡æ°å¨çå³ç³»ãä¸åéæ:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nå¨å¾ªç¯çæ¯ä¸æ­¥ï¼å¯¹è¿ä¸¤ä¸ªå¼æ±åä»¥å¾å°ä¸ä¸ä¸ªåå¯¼æ°ï¼èåé¢çæ°å­æ¯æ§çåå¯¼æ°ãä½¿ç¨å¹¶è¡èµå¼ï¼æä»¬å¯ä»¥ç¼åä¸ä¸ªå¾ªç¯æ¥æ§è¡ä»¥ä¸æä½:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nè¿é' a 'æ¯ç»å°¾æ°ï¼' b 'æ¯åå¯¼æ°ãå¹¶è¡èµå¼æå³çå¨å¯¹åéèµå¼ä¹åè®¡ç®æ´ä¸ªå³æè¾¹ãå æ­¤ï¼âaâå°å¾å°âbâçæ§å¼ï¼èâbâå°å¾å°ä¸¤ä¸ªæ§å¼çåï¼è¿æ­£æ¯æä»¬æ³è¦çè¡ä¸ºã æä»¬è¿å¯¹å¾ªç¯è®¡æ°å¨' i 'è¿è¡äºæ´æ¹ãå ä¸ºæä»¬è¿æ³è·è¸ªåé¢çæ°å­ï¼æä»¥æä»¬ä¸è½ä»0å¼å§è®¡æ°å¨ï¼å¦åæä»¬å°ä¸å¾ä¸è®¡ç®ä¸ä¸ªè´çææ³¢é£å¥æ°ãè¿æ ·åçé®é¢æ¯ï¼å½æä»¬è¿å¥å¾ªç¯æ¶ï¼å¾ªç¯è®¡æ°å¨ä¸åå¼å¯è½ä¸æç«ãå¯ä¸çé®é¢æ¯å½nä¸º0æ¶ãè¿å¯ä»¥ä½ä¸ºä¸ç§ç¹æ®æåµæ¶é¤ï¼æ¹æ³æ¯å¨å¾ªç¯å¼å§æ¶æµè¯è¯¥æ¡ä»¶ãå®æçææ³¢é£å¥æ¹æ³åæ:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafnyä¸åæ¥éå¾ªç¯ä¸åå¼ä¸æç«ï¼å ä¸ºå¦æ' n 'ä¸ºé¶ï¼å®å°å¨å°è¾¾å¾ªç¯ä¹åè¿åãDafnyè¿è½å¤ä½¿ç¨å¾ªç¯ä¸åéæ¥è¯æï¼å¨å¾ªç¯ä¹åï¼' i == n 'å' b == fib(i) 'ï¼å®ä»¬ä¸èµ·éå«äºåç½®æ¡ä»¶' b == fib(n) 'ã\n\nç»ä¹ 9. ä¸é¢ç' ComputeFib 'æ¹æ³æ¯å¿è¦çè¦å¤æå¾å¤ãåä¸ä¸ªç®åçç¨åºï¼ä¸å¼å¥' a 'ä½ä¸º' b 'åé¢çææ³¢é£å¥æ°ï¼èæ¯å¼å¥ä¸ä¸ªåé' c 'å¨' b 'åé¢ãæ ¹æ®ææ³¢é£å¥æ°åçæ°å­¦å®ä¹æ¥éªè¯ä½ çç¨åºæ¯æ­£ç¡®çã\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nç»ä¹ 10. ä»ä¸é¢å®æç' ComputeFib 'æ¹æ³å¼å§ï¼å é¤' if 'è¯­å¥ï¼å¹¶å°' i 'åå§åä¸º' 0 'ï¼' a 'åå§åä¸º' 1 'ï¼' b 'åå§åä¸º' 0 'ãéè¿è°æ´å¾ªç¯ä¸åéæ¥å¹éæ°çè¡ä¸ºæ¥éªè¯è¿ä¸ªæ°ç¨åºã\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nä½¿ç¨ä¸åéçä¸ä¸ªé®é¢æ¯ï¼å¾å®¹æå¿è®°è®©å¾ªç¯âåå¾è¿å±âï¼å³å¨æ¯ä¸æ­¥åå·¥ä½ãä¾å¦ï¼æä»¬å¯ä»¥å¨åé¢çç¨åºä¸­çç¥æ´ä¸ªå¾ªç¯ä½ãè¿äºä¸åéæ¯æ­£ç¡®çï¼å ä¸ºå®ä»¬å¨è¿å¥å¾ªç¯æ¶ä»ç¶ä¸ºçï¼èä¸ç±äºå¾ªç¯æ²¡ææ¹åä»»ä½ä¸è¥¿ï¼å®ä»¬å°è¢«å¾ªç¯ä¿å­ä¸æ¥ãæä»¬ç¥éï¼å¦æéåºå¾ªç¯ï¼é£ä¹æä»¬å¯ä»¥åè®¾å®å«åä¸åéä¸ºè´å¼ï¼ä½è¿å¹¶æ²¡æè¯´æå¦ææä»¬æ°¸è¿ä¸éåºå¾ªç¯ä¼åçä»ä¹ãå æ­¤ï¼æä»¬å¸æç¡®ä¿å¾ªç¯å¨æä¸ªç¹ç»æï¼è¿ç»äºæä»¬ä¸ä¸ªæ´å¼ºçæ­£ç¡®æ§ä¿è¯(ææ¯æ¯è¯­æ¯å®å¨æ­£ç¡®æ§)ã",normalizedContent:"# å¾ªç¯ä¸åå¼\n\nâwhileâå¾ªç¯ç»dafnyå¸¦æ¥äºä¸ä¸ªé®é¢ãdafnyæ æ³æåç¥éä»£ç å°å¾ªç¯å¤å°æ¬¡ãä½æ¯dafnyéè¦èèç¨åºä¸­çææè·¯å¾ï¼è¿å¯è½åæ¬å¾ªç¯ä»»ææ¬¡æ°ãä¸ºäºä½¿dafnyè½å¤ä½¿ç¨å¾ªç¯ï¼æ¨éè¦æä¾å¾ªç¯ä¸åå¼ï¼è¿æ¯å¦ä¸ç§æ³¨éã å¾ªç¯ä¸åå¼æ¯å¨è¿å¥å¾ªç¯æ¶ä»¥åæ¯æ¬¡å¾ªç¯ä½æ§è¡åä¿å­çè¡¨è¾¾å¼ãå®æè·äºä¸äºä¸åçä¸è¥¿ï¼ä¹å°±æ¯è¯´ï¼å¨å¾ªç¯çæ¯ä¸æ­¥ä¸­é½æ¯ä¸åçãç°å¨ï¼å¾ææ¾ï¼æä»¬éè¦å¨æ¯æ¬¡å¾ªç¯çæ¶åæ¹ååéï¼ç­ç­ï¼å¦åæä»¬å°±ä¸éè¦å¾ªç¯äºãååç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸æ ·ï¼ä¸åéæ¯ä¸ä¸ªå±æ§ï¼å®å¨æ¯æ¬¡å¾ªç¯æ§è¡æ¶é½è¢«ä¿çï¼ä½¿ç¨æä»¬å·²ç»çå°çå¸å°è¡¨è¾¾å¼è¡¨ç¤ºãä¾å¦ï¼æä»¬å¨ä¸é¢çå¾ªç¯ä¸­çå°ï¼å¦æ' i 'ä¸å¼å§æ¯æ­£çï¼é£ä¹å®å°±ä¸ç´æ¯æ­£çãå æ­¤ï¼æä»¬å¯ä»¥ä½¿ç¨å®èªå·±çå³é®å­å°ä¸åéæ·»å å°å¾ªç¯ä¸­:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nå½æ¨æå®ä¸ä¸ªä¸åéæ¶ï¼dafnyè¯æäºä¸¤ä»¶äº:ä¸åéå¨è¿å¥å¾ªç¯æ¶ä¿æä¸åï¼å¹¶ä¸è¢«å¾ªç¯ä¿å­ãéè¿ä¿çï¼æä»¬çæææ¯åè®¾å¨å¾ªç¯å¼å§æ¶ä¸åå¼ä¿æä¸åï¼æä»¬å¿é¡»è¯ææ§è¡å¾ªç¯ä½ä¸æ¬¡ä½¿ä¸åå¼åæ¬¡ä¿æä¸åãdafnyåªè½å¨åæå¾ªç¯ä½æ¶ç¥éä¸åéè¯´äºä»ä¹ï¼é¤äºå¾ªç¯ä¿æ¤(å¾ªç¯æ¡ä»¶)ãå°±ådafnyèªå·±ä¸ä¼åç°æ¹æ³çå±æ§ä¸æ ·ï¼é¤ééè¿ä¸ä¸ªä¸åéåè¯å®ï¼å¦åå®åªä¼ç¥éå¾ªç¯çæåºæ¬å±æ§è¢«ä¿çã å¨æä»¬çä¾å­ä¸­ï¼å¾ªç¯çéç¹æ¯æ¯æ¬¡å»ºç«ä¸ä¸ª(å¥½å§ï¼ä¸¤ä¸ª)ææ³¢é£å¥æ°ï¼ç´å°æä»¬è¾¾å°æ³è¦çæ°ãéåºå¾ªç¯åï¼æä»¬å°å¾å°' i == n 'ï¼å ä¸ºå½iè¾¾å°' n 'æ¶ï¼' i 'å°åæ­¢éå¢ãæä»¬å¯ä»¥ä½¿ç¨æ­è¨æå·§æ¥æ£æ¥dafnyæ¯å¦ä¹çå°äºè¿ä¸ªäºå®:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\næä»¬åç°è¿ä¸ªæ­è¨å¤±è´¥äºãæ®dafnyæç¥ï¼å¨å¾ªç¯è¿ç¨ä¸­çæä¸ªç¹ä¸ï¼âiâå¯è½ä»¥æç§æ¹å¼åå¾æ¯ânâå¤§å¾å¤ãå¨å¾ªç¯éåºå(å³å¨å¾ªç¯ç»æåçä»£ç ä¸­)ï¼å®æç¥éçæ¯å¾ªç¯ä¿æ¤å¤±è´¥ï¼ä¸åéä¿æä¸åãå¨æ¬ä¾ä¸­ï¼è¿ç¸å½äº' n <= i 'å' 0 <= i 'ãä½è¿å¹¶ä¸è¶³ä»¥ä¿è¯' i == n 'ï¼åªä¿è¯' n <= i 'ãæä»¬éè¦æ¶é¤iè¶è¿nçå¯è½æ§ãè§£å³è¿ä¸ªé®é¢çç¬¬ä¸ä¸ªçæ³å¯è½æ¯:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nè¿å¹¶ä¸éªè¯ï¼å ä¸ºdafnyä¼æ¥éå¾ªç¯æ²¡æä¿å­(ä¹ç§°ä¸ºæ²¡æç»´æ¤)ä¸åå¼ãæä»¬å¸æè½å¤è¯´ï¼å¨å¾ªç¯ç»æåï¼ææä¸åå¼é½ä¿çä¸æ¥ãæä»¬çä¸åå¼éç¨äºå¾ªç¯çæ¯ä¸æ¬¡æ§è¡ï¼é¤äºæåä¸æ¬¡ãå ä¸ºå¾ªç¯ä½åªæå¨å¾ªç¯ä¿æ¤çææ¶ææ§è¡ï¼æä»¥å¨æåä¸æ¬¡è¿­ä»£ä¸­ï¼âiâä»ân - 1âå°ânâï¼ä½å¨å¾ªç¯éåºæ¶ä¸ä¼è¿ä¸æ­¥å¢å ãå æ­¤ï¼æä»¬åªä»æä»¬çä¸åéä¸­çç¥äºä¸ç§æåµï¼ä¿®å¤å®ç¸å¯¹å®¹æ:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nç°å¨ï¼æä»¬å¯ä»¥è¯´ï¼ân <= iâæ¥èªå¾ªç¯ä¿æ¤ï¼â0 <= i <= nâæ¥èªä¸åéï¼è¿åè®¸dafnyè¯æâi == nâæ­è¨ãéæ©å¾ªç¯ä¸åéçææå¨äºæ¾å°ä¸ä¸ªè¢«å¾ªç¯ä¿ççä¸åéï¼èä¸å®è¿è½è®©æ¨è¯æå¨å¾ªç¯æ§è¡åéè¦ä»ä¹ã\n\nç»ä¹ 7. å°å¾ªç¯ä¸åéæ¹ä¸º' 0 <= i <= n+2 'ãå¾ªç¯æ¯å¦ä»ç¶éªè¯?æ­è¨' i == n 'å¨å¾ªç¯ä¹åä»ç¶éªè¯å?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nç»ä¹ 8. ä½¿ç¨åæ¥çå¾ªç¯ä¸åå¼ï¼å°å¾ªç¯å®å«ä»' i < n 'æ´æ¹ä¸º' i != n 'ãå¾ªç¯åå¾ªç¯åçæ­è¨ä»ç¶è¿è¡éªè¯å?ä¸ºä»ä¹æä¸ºä»ä¹ä¸?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\né¤äºè®¡æ°å¨ä¹å¤ï¼æä»¬çç®æ³è¿éè¦ä¸å¯¹è¡¨ç¤ºåºåä¸­ç¸é»ææ³¢é£å¥æ°åçæ°å­ãä¸åºææï¼æä»¬å°æå¦å¤ä¸ä¸¤ä¸ªä¸åå¼æ¥å°è¿äºæ°å­åè®¡æ°å¨èç³»èµ·æ¥ãä¸ºäºæ¾å°è¿äºä¸åéï¼æä»¬ä½¿ç¨äºä¸ç§å¸¸è§çdafnyæå·§:ä»åç½®æ¡ä»¶ååè®¡ç®ã ææ³¢é£å¥æ¹æ³çåç½®æ¡ä»¶æ¯è¿åå¼' b 'ç­äº' fib(n) 'ãä½æ¯å¨å¾ªç¯ä¹åï¼æä»¬æäº' i == n 'ï¼æä»¥å¨å¾ªç¯çæåæä»¬éè¦' b == fib(i) 'ãè¿å¯è½æ¯ä¸ä¸ªå¾å¥½çä¸åéï¼å ä¸ºå®ä¸å¾ªç¯è®¡æ°å¨ç¸å³ãè¿ç§ç°è±¡å¨dafnyçç¨åºä¸­éå¸¸æ®éãéå¸¸ï¼ä¸ä¸ªæ¹æ³åªæ¯ä¸ä¸ªå¾ªç¯ï¼å½å®ç»ææ¶ï¼éè¿ä½¿è®¡æ°å¨è¾¾å°å¦ä¸ä¸ªæ°å­ï¼éå¸¸æ¯ä¸ä¸ªåæ°ææ°ç»æåºåçé¿åº¦ï¼ä½¿åç½®æ¡ä»¶ä¸ºçãåébï¼ä¹å°±æ¯æä»¬çè¾åºåæ°ï¼å°ä¼æ¯å½åçææ³¢é£å¥æ°å:\n\n   invariant b == fib(i)\n\n\n1\n\n\næä»¬è¿æ³¨æå°ï¼å¨æä»¬çç®æ³ä¸­ï¼æä»¬å¯ä»¥éè¿è·è¸ªä¸å¯¹æ°å­æ¥è®¡ç®ä»»ä½ææ³¢é£å¥æ°ï¼å¹¶å°å®ä»¬ç¸å å¾å°ä¸ä¸ä¸ªæ°å­ãæä»¬æ³è¦ä¸ç§æ¹æ³æ¥è¿½è¸ªä¹åçææ³¢é£å¥æ°ï¼æä»¬ç§°ä¹ä¸º' a 'å¦ä¸ä¸ªä¸åå¼å°è¡¨ç¤ºè¯¥æ°å­ä¸å¾ªç¯è®¡æ°å¨çå³ç³»ãä¸åéæ:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nå¨å¾ªç¯çæ¯ä¸æ­¥ï¼å¯¹è¿ä¸¤ä¸ªå¼æ±åä»¥å¾å°ä¸ä¸ä¸ªåå¯¼æ°ï¼èåé¢çæ°å­æ¯æ§çåå¯¼æ°ãä½¿ç¨å¹¶è¡èµå¼ï¼æä»¬å¯ä»¥ç¼åä¸ä¸ªå¾ªç¯æ¥æ§è¡ä»¥ä¸æä½:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nè¿é' a 'æ¯ç»å°¾æ°ï¼' b 'æ¯åå¯¼æ°ãå¹¶è¡èµå¼æå³çå¨å¯¹åéèµå¼ä¹åè®¡ç®æ´ä¸ªå³æè¾¹ãå æ­¤ï¼âaâå°å¾å°âbâçæ§å¼ï¼èâbâå°å¾å°ä¸¤ä¸ªæ§å¼çåï¼è¿æ­£æ¯æä»¬æ³è¦çè¡ä¸ºã æä»¬è¿å¯¹å¾ªç¯è®¡æ°å¨' i 'è¿è¡äºæ´æ¹ãå ä¸ºæä»¬è¿æ³è·è¸ªåé¢çæ°å­ï¼æä»¥æä»¬ä¸è½ä»0å¼å§è®¡æ°å¨ï¼å¦åæä»¬å°ä¸å¾ä¸è®¡ç®ä¸ä¸ªè´çææ³¢é£å¥æ°ãè¿æ ·åçé®é¢æ¯ï¼å½æä»¬è¿å¥å¾ªç¯æ¶ï¼å¾ªç¯è®¡æ°å¨ä¸åå¼å¯è½ä¸æç«ãå¯ä¸çé®é¢æ¯å½nä¸º0æ¶ãè¿å¯ä»¥ä½ä¸ºä¸ç§ç¹æ®æåµæ¶é¤ï¼æ¹æ³æ¯å¨å¾ªç¯å¼å§æ¶æµè¯è¯¥æ¡ä»¶ãå®æçææ³¢é£å¥æ¹æ³åæ:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafnyä¸åæ¥éå¾ªç¯ä¸åå¼ä¸æç«ï¼å ä¸ºå¦æ' n 'ä¸ºé¶ï¼å®å°å¨å°è¾¾å¾ªç¯ä¹åè¿åãdafnyè¿è½å¤ä½¿ç¨å¾ªç¯ä¸åéæ¥è¯æï¼å¨å¾ªç¯ä¹åï¼' i == n 'å' b == fib(i) 'ï¼å®ä»¬ä¸èµ·éå«äºåç½®æ¡ä»¶' b == fib(n) 'ã\n\nç»ä¹ 9. ä¸é¢ç' computefib 'æ¹æ³æ¯å¿è¦çè¦å¤æå¾å¤ãåä¸ä¸ªç®åçç¨åºï¼ä¸å¼å¥' a 'ä½ä¸º' b 'åé¢çææ³¢é£å¥æ°ï¼èæ¯å¼å¥ä¸ä¸ªåé' c 'å¨' b 'åé¢ãæ ¹æ®ææ³¢é£å¥æ°åçæ°å­¦å®ä¹æ¥éªè¯ä½ çç¨åºæ¯æ­£ç¡®çã\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nç»ä¹ 10. ä»ä¸é¢å®æç' computefib 'æ¹æ³å¼å§ï¼å é¤' if 'è¯­å¥ï¼å¹¶å°' i 'åå§åä¸º' 0 'ï¼' a 'åå§åä¸º' 1 'ï¼' b 'åå§åä¸º' 0 'ãéè¿è°æ´å¾ªç¯ä¸åéæ¥å¹éæ°çè¡ä¸ºæ¥éªè¯è¿ä¸ªæ°ç¨åºã\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nä½¿ç¨ä¸åéçä¸ä¸ªé®é¢æ¯ï¼å¾å®¹æå¿è®°è®©å¾ªç¯âåå¾è¿å±âï¼å³å¨æ¯ä¸æ­¥åå·¥ä½ãä¾å¦ï¼æä»¬å¯ä»¥å¨åé¢çç¨åºä¸­çç¥æ´ä¸ªå¾ªç¯ä½ãè¿äºä¸åéæ¯æ­£ç¡®çï¼å ä¸ºå®ä»¬å¨è¿å¥å¾ªç¯æ¶ä»ç¶ä¸ºçï¼èä¸ç±äºå¾ªç¯æ²¡ææ¹åä»»ä½ä¸è¥¿ï¼å®ä»¬å°è¢«å¾ªç¯ä¿å­ä¸æ¥ãæä»¬ç¥éï¼å¦æéåºå¾ªç¯ï¼é£ä¹æä»¬å¯ä»¥åè®¾å®å«åä¸åéä¸ºè´å¼ï¼ä½è¿å¹¶æ²¡æè¯´æå¦ææä»¬æ°¸è¿ä¸éåºå¾ªç¯ä¼åçä»ä¹ãå æ­¤ï¼æä»¬å¸æç¡®ä¿å¾ªç¯å¨æä¸ªç¹ç»æï¼è¿ç»äºæä»¬ä¸ä¸ªæ´å¼ºçæ­£ç¡®æ§ä¿è¯(ææ¯æ¯è¯­æ¯å®å¨æ­£ç¡®æ§)ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"ç»æ­¢",frontmatter:{title:"ç»æ­¢",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/af29e4/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/30.%E7%BB%88%E6%AD%A2.html",relativePath:"30.æç¨/00.Dafnyæç¨/30.ç»æ­¢.md",key:"v-d588bd04",path:"/pages/af29e4/",headers:[{level:2,title:"ç»æ­¢",slug:"ç»æ­¢",normalizedTitle:"ç»æ­¢",charIndex:2}],headersStr:"ç»æ­¢",content:"# ç»æ­¢\n\nDafnyéè¿ä½¿ç¨åæ³¨éè¯æäºä»£ç çç»æ­¢ï¼å³ä¸ä¼æ°¸è¿å¾ªç¯ãå¯¹äºè®¸å¤äºæï¼Dafnyè½å¤çåºæ­£ç¡®çæ³¨éï¼ä½ææ¶éè¦æç¡®è¯´æãäºå®ä¸ï¼å¯¹äºæä»¬å°ç®åä¸ºæ­¢çå°çææä»£ç ï¼Dafnyé½è½å¤èªå·±è¿è¡è¿ç§è¯æï¼è¿å°±æ¯ä¸ºä»ä¹æä»¬è¿æ²¡æçå°æ¾å¼çåå°æ³¨éãDafnyå¨ä¸¤ä¸ªå°æ¹è¯æäºç»æ­¢:å¾ªç¯åéå½ãè¿ä¸¤ç§æåµé½éè¦Dafnyæç¡®çæ³¨éææ­£ç¡®ççæµã åå°æ³¨éï¼é¡¾åæä¹ï¼ä¸ºDafnyæä¾äºä¸ä¸ªè¡¨è¾¾å¼ï¼è¯¥è¡¨è¾¾å¼å¨æ¯æ¬¡å¾ªç¯è¿­ä»£æéå½è°ç¨æ¶é½ä¼åå°ãå¨ä½¿ç¨åå°è¡¨è¾¾å¼æ¶ï¼Dafnyéè¦éªè¯ä¸¤ä¸ªæ¡ä»¶:è¡¨è¾¾å¼å®éä¸åå¾æ´å°ï¼ä»¥åå®æ¯æççãå¾å¤æ¶åï¼æ´æ°å¼(èªç¶ææ®éæ´æ°)æ¯åå°çéï¼ä½ä¹å¯ä»¥ä½¿ç¨å¶ä»ä¸è¥¿ã(è¯¦è§åèèµæ)å¨æ´æ°çæåµä¸ï¼åå®è¾¹çä¸ºé¶ãä¾å¦ï¼ä¸é¢æ¯å¨å¾ªç¯ä¸­æ­£ç¡®ä½¿ç¨(å½ç¶æ¯ç¨å®èªå·±çå³é®å­):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿éDafnyæ¥æè¯æç»æ­¢æéçæææ¡ä»¶ãåéiå¨æ¯æ¬¡å¾ªç¯è¿­ä»£ä¸­é½ä¼åå°ï¼å¹¶ä¸å°äº0ãè¿å¾å¥½ï¼é¤äºå¾ªç¯æ¯ååçå¤§å¤æ°å¾ªç¯ï¼è¿å¾å¾æ¯åä¸èä¸æ¯åä¸è®¡æ°ãå¨è¿ç§æåµä¸ï¼åå°çä¸æ¯è®¡æ°å¨æ¬èº«ï¼èæ¯è®¡æ°å¨ä¸ä¸çä¹é´çè·ç¦»ãä¸é¢æ¯ä¸ä¸ªå¤çè¿ç§æåµçç®åæå·§:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿å®éä¸æ¯Dafnyå¯¹è¿ç§æåµççæµï¼å ä¸ºå®çå°i < nï¼å¹¶åè®¾n - iæ¯åå°çæ°éãå¾ªç¯ä¸åéçä¸çæå³ç0 <= n - iï¼å¹¶ç»äºDafnyä¸ä¸ªæ°éçä¸çãå½nçè¾¹çä¸æ¯å¸¸éæ¶ï¼è¿ä¹éç¨ï¼ä¾å¦å¨äºåæç´¢ç®æ³ä¸­ï¼ä¸¤ä¸ªéå½¼æ­¤æ¥è¿ï¼ä¸é½ä¸æ¯åºå®çã\n\nç»ä¹ 11.\n\nç¹å»æ¥çé¢ç®\n\nå¨ä¸é¢çå¾ªç¯ä¸­ï¼ä¸åéi <= nåå¾ªç¯ä¿æ¤çå¦å®åè®¸æä»¬å¨å¾ªç¯ç»æåç»æi == n(æ­£å¦æä»¬ä¹åç¨assertæ£æ¥è¿çé£æ ·)ãè¯·æ³¨æï¼å¦æå¾ªç¯å®å«è¢«åæi != n(å¦ç»ä¹ 8ä¸­æç¤º)ï¼é£ä¹æ è®ºå¾ªç¯ä¸åéæ¯ä»ä¹ï¼å®å«çå¦å®é½ä¼å¨å¾ªç¯ä¹åç«å³ç»åºi == nãå°å¾ªç¯å®å«æ´æ¹ä¸ºi != nï¼å¹¶å é¤ä¸åæ³¨éãç¨åºéªè¯äºå?åçäºä»ä¹äº?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nå¦ä¸ç§éè¦ç»æ­¢è¯æçæåµæ¯éå½æ¹æ³æå½æ°ãä¸æ éå¾ªç¯ç±»ä¼¼ï¼è¿äºæ¹æ³å¯è½æ°¸è¿è°ç¨èªå·±ï¼æ°¸è¿ä¸ä¼è¿åå°å®ä»¬çåå§è°ç¨èãå½Dafnyæ æ³çåºç»æ­¢æ¡ä»¶æ¶ï¼å¯ä»¥ç»åºæ¾å¼çåå°å­å¥ä»¥ååç½®ååç½®æ¡ä»¶ï¼å°±åå¯¹fibå½æ°çä¸å¿è¦æ³¨éä¸æ ·:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nä¸åé¢ä¸æ ·ï¼Dafnyå¯ä»¥èªå·±çæµè¿ä¸ªæ¡ä»¶ï¼ä½ææ¶éåæ¡ä»¶éèå¨å¯¹è±¡çæä¸ªå­æ®µä¸­æå¶ä»Dafnyèªå·±æ æ³æ¾å°çå°æ¹ï¼å®éè¦ä¸ä¸ªæ¾å¼æ³¨éã",normalizedContent:"# ç»æ­¢\n\ndafnyéè¿ä½¿ç¨åæ³¨éè¯æäºä»£ç çç»æ­¢ï¼å³ä¸ä¼æ°¸è¿å¾ªç¯ãå¯¹äºè®¸å¤äºæï¼dafnyè½å¤çåºæ­£ç¡®çæ³¨éï¼ä½ææ¶éè¦æç¡®è¯´æãäºå®ä¸ï¼å¯¹äºæä»¬å°ç®åä¸ºæ­¢çå°çææä»£ç ï¼dafnyé½è½å¤èªå·±è¿è¡è¿ç§è¯æï¼è¿å°±æ¯ä¸ºä»ä¹æä»¬è¿æ²¡æçå°æ¾å¼çåå°æ³¨éãdafnyå¨ä¸¤ä¸ªå°æ¹è¯æäºç»æ­¢:å¾ªç¯åéå½ãè¿ä¸¤ç§æåµé½éè¦dafnyæç¡®çæ³¨éææ­£ç¡®ççæµã åå°æ³¨éï¼é¡¾åæä¹ï¼ä¸ºdafnyæä¾äºä¸ä¸ªè¡¨è¾¾å¼ï¼è¯¥è¡¨è¾¾å¼å¨æ¯æ¬¡å¾ªç¯è¿­ä»£æéå½è°ç¨æ¶é½ä¼åå°ãå¨ä½¿ç¨åå°è¡¨è¾¾å¼æ¶ï¼dafnyéè¦éªè¯ä¸¤ä¸ªæ¡ä»¶:è¡¨è¾¾å¼å®éä¸åå¾æ´å°ï¼ä»¥åå®æ¯æççãå¾å¤æ¶åï¼æ´æ°å¼(èªç¶ææ®éæ´æ°)æ¯åå°çéï¼ä½ä¹å¯ä»¥ä½¿ç¨å¶ä»ä¸è¥¿ã(è¯¦è§åèèµæ)å¨æ´æ°çæåµä¸ï¼åå®è¾¹çä¸ºé¶ãä¾å¦ï¼ä¸é¢æ¯å¨å¾ªç¯ä¸­æ­£ç¡®ä½¿ç¨(å½ç¶æ¯ç¨å®èªå·±çå³é®å­):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿édafnyæ¥æè¯æç»æ­¢æéçæææ¡ä»¶ãåéiå¨æ¯æ¬¡å¾ªç¯è¿­ä»£ä¸­é½ä¼åå°ï¼å¹¶ä¸å°äº0ãè¿å¾å¥½ï¼é¤äºå¾ªç¯æ¯ååçå¤§å¤æ°å¾ªç¯ï¼è¿å¾å¾æ¯åä¸èä¸æ¯åä¸è®¡æ°ãå¨è¿ç§æåµä¸ï¼åå°çä¸æ¯è®¡æ°å¨æ¬èº«ï¼èæ¯è®¡æ°å¨ä¸ä¸çä¹é´çè·ç¦»ãä¸é¢æ¯ä¸ä¸ªå¤çè¿ç§æåµçç®åæå·§:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿å®éä¸æ¯dafnyå¯¹è¿ç§æåµççæµï¼å ä¸ºå®çå°i < nï¼å¹¶åè®¾n - iæ¯åå°çæ°éãå¾ªç¯ä¸åéçä¸çæå³ç0 <= n - iï¼å¹¶ç»äºdafnyä¸ä¸ªæ°éçä¸çãå½nçè¾¹çä¸æ¯å¸¸éæ¶ï¼è¿ä¹éç¨ï¼ä¾å¦å¨äºåæç´¢ç®æ³ä¸­ï¼ä¸¤ä¸ªéå½¼æ­¤æ¥è¿ï¼ä¸é½ä¸æ¯åºå®çã\n\nç»ä¹ 11.\n\nç¹å»æ¥çé¢ç®\n\nå¨ä¸é¢çå¾ªç¯ä¸­ï¼ä¸åéi <= nåå¾ªç¯ä¿æ¤çå¦å®åè®¸æä»¬å¨å¾ªç¯ç»æåç»æi == n(æ­£å¦æä»¬ä¹åç¨assertæ£æ¥è¿çé£æ ·)ãè¯·æ³¨æï¼å¦æå¾ªç¯å®å«è¢«åæi != n(å¦ç»ä¹ 8ä¸­æç¤º)ï¼é£ä¹æ è®ºå¾ªç¯ä¸åéæ¯ä»ä¹ï¼å®å«çå¦å®é½ä¼å¨å¾ªç¯ä¹åç«å³ç»åºi == nãå°å¾ªç¯å®å«æ´æ¹ä¸ºi != nï¼å¹¶å é¤ä¸åæ³¨éãç¨åºéªè¯äºå?åçäºä»ä¹äº?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nå¦ä¸ç§éè¦ç»æ­¢è¯æçæåµæ¯éå½æ¹æ³æå½æ°ãä¸æ éå¾ªç¯ç±»ä¼¼ï¼è¿äºæ¹æ³å¯è½æ°¸è¿è°ç¨èªå·±ï¼æ°¸è¿ä¸ä¼è¿åå°å®ä»¬çåå§è°ç¨èãå½dafnyæ æ³çåºç»æ­¢æ¡ä»¶æ¶ï¼å¯ä»¥ç»åºæ¾å¼çåå°å­å¥ä»¥ååç½®ååç½®æ¡ä»¶ï¼å°±åå¯¹fibå½æ°çä¸å¿è¦æ³¨éä¸æ ·:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nä¸åé¢ä¸æ ·ï¼dafnyå¯ä»¥èªå·±çæµè¿ä¸ªæ¡ä»¶ï¼ä½ææ¶éåæ¡ä»¶éèå¨å¯¹è±¡çæä¸ªå­æ®µä¸­æå¶ä»dafnyèªå·±æ æ³æ¾å°çå°æ¹ï¼å®éè¦ä¸ä¸ªæ¾å¼æ³¨éã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ°ç»",frontmatter:{title:"æ°ç»",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/828a83/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/35.%E6%95%B0%E7%BB%84.html",relativePath:"30.æç¨/00.Dafnyæç¨/35.æ°ç».md",key:"v-2cd59290",path:"/pages/828a83/",headersStr:null,content:"# æ°ç»\n\næä»¬æèèçä¸åå¯¹äºç®åçå½æ°åå°éçæ°å­¦ç»ä¹ æ¥è¯´é½å¾å¥½ï¼ä½æ¯å¯¹äºçæ­£çç¨åºæ¥è¯´å´æ¯«æ å¸®å©ãå°ç®åä¸ºæ­¢ï¼æä»¬ä¸æ¬¡åªèèäºå±é¨åéä¸­çå ä¸ªå¼ãç°å¨æä»¬ææ³¨æåè½¬åæ°æ®æ°ç»ãæ°ç»æ¯è¯­è¨çåç½®é¨åï¼æèªå·±çç±»åarray<T>ï¼å¶ä¸­Tæ¯å¦ä¸ç§ç±»åãç°å¨æä»¬åªèèæ´æ°æ°ç»ï¼array<int>ãæ°ç»å¯ä»¥ä¸ºnullï¼å¹¶æä¸ä¸ªåç½®çé¿åº¦å­æ®µa. lengthãåç´ è®¿é®ä½¿ç¨æ åçæ¬å·è¯­æ³ï¼å¹¶ä»0å¼å§ç´¢å¼ï¼æä»¥a[3]åé¢æ¯3ä¸ªåç´  a[0]ï¼a[1]åa[2]ï¼æè¿ä¸ªé¡ºåºãææçæ°ç»è®¿é®å¿é¡»è¢«è¯æå¨è¾¹çåï¼è¿æ¯Dafnyæ è¿è¡æ¶éè¯¯å®å¨ä¿è¯çä¸é¨åãå ä¸ºè¾¹çæ£æ¥æ¯å¨éªè¯æ¶éªè¯çï¼æä»¥ä¸éè¦è¿è¡è¿è¡æ¶æ£æ¥ãè¦åå»ºä¸ä¸ªæ°æ°ç»ï¼å®å¿é¡»ä½¿ç¨newå³é®å­è¿è¡åéï¼ä½ç®åæä»¬åªä½¿ç¨ä»¥åååéçæ°ç»ä¸ºåæ°çæ¹æ³ã(æå³åéçæ´å¤ä¿¡æ¯ï¼è¯·åéåå­æç¨ã) å¯¹äºä¸ä¸ªæ°ç»ï¼æä»¬å¯è½æ³è¦åçæåºæ¬çäºæä¹ä¸æ¯å¨æ°ç»ä¸­æç´¢ä¸ä¸ªç¹å®çé®ï¼å¹¶è¿åä¸ä¸ªä½ç½®çç´¢å¼ï¼å¦æé®å­å¨ï¼æä»¬å¯ä»¥æ¾å°å®ãæä»¬æä¸¤ä¸ªæç´¢ç»æï¼æ¯ä¸ªç»æé½æä¸åçæ­£ç¡®æ§æ¡ä»¶ãå¦æç®æ³è¿åä¸ä¸ªç´¢å¼(å³éè´æ´æ°)ï¼é£ä¹è¯¥é®åºè¯¥å­å¨äºè¯¥ç´¢å¼å¤ãè¿å¯ä»¥è¡¨ç¤ºä¸º:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nè¿éçæ°ç»ç´¢å¼æ¯å®å¨çï¼å ä¸ºéå«æä½ç¬¦æ¯ç­è·¯ãç­è·¯æå³çå¦æå·¦é¨åä¸ºåï¼é£ä¹ä¸ç®¡ç¬¬äºé¨åççå¼æ¯å¤å°ï¼æç¤ºå·²ç»ä¸ºçï¼å æ­¤ä¸éè¦æ±å¼ãä½¿ç¨éå«è¿ç®ç¬¦çç­è·¯ç¹æ§ï¼ä»¥åå¸å°å¼and(&&)ï¼è¿ä¹æ¯ä¸ç§ç­è·¯ï¼æ¯Dafnyçå¸¸è§å®è·µãæ¡ä»¶index < a. lengthæ¯å¿è¦çï¼å¦åè¯¥æ¹æ³å¯è½è¿åä¸ä¸ªå¤§æ´æ°ï¼èä¸æ¯æ°ç»çä¸æ ãæ»ä¹ï¼ç­è·¯è¡ä¸ºæå³çå½æ¶é´æ§å¶å°è¾¾æ°ç»è®¿é®æ¶ï¼indexå¿é¡»æ¯ä¸ä¸ªææçç´¢å¼ã å¦æè¯¥é®ä¸å¨æ°ç»ä¸­ï¼é£ä¹æä»¬å¸ææ¹æ³è¿åä¸ä¸ªè´æ°ãå¨è¿ä¸ªä¾å­ä¸­ï¼æä»¬æ³è¯´è¿ä¸ªæ¹æ³æ²¡æä¸¢å¤±ä¸ä¸ªé®çåºç°;æ¢å¥è¯è¯´ï¼è¿ä¸ªé®ä¸å¨æ°ç»ä¸­ãä¸ºäºè¡¨è¾¾è¿ä¸ªå±æ§ï¼æä»¬æ±å©äºå¦ä¸ä¸ªå¸¸ç¨çDafnyå·¥å·:éè¯ã",normalizedContent:"# æ°ç»\n\næä»¬æèèçä¸åå¯¹äºç®åçå½æ°åå°éçæ°å­¦ç»ä¹ æ¥è¯´é½å¾å¥½ï¼ä½æ¯å¯¹äºçæ­£çç¨åºæ¥è¯´å´æ¯«æ å¸®å©ãå°ç®åä¸ºæ­¢ï¼æä»¬ä¸æ¬¡åªèèäºå±é¨åéä¸­çå ä¸ªå¼ãç°å¨æä»¬ææ³¨æåè½¬åæ°æ®æ°ç»ãæ°ç»æ¯è¯­è¨çåç½®é¨åï¼æèªå·±çç±»åarray<t>ï¼å¶ä¸­tæ¯å¦ä¸ç§ç±»åãç°å¨æä»¬åªèèæ´æ°æ°ç»ï¼array<int>ãæ°ç»å¯ä»¥ä¸ºnullï¼å¹¶æä¸ä¸ªåç½®çé¿åº¦å­æ®µa. lengthãåç´ è®¿é®ä½¿ç¨æ åçæ¬å·è¯­æ³ï¼å¹¶ä»0å¼å§ç´¢å¼ï¼æä»¥a[3]åé¢æ¯3ä¸ªåç´  a[0]ï¼a[1]åa[2]ï¼æè¿ä¸ªé¡ºåºãææçæ°ç»è®¿é®å¿é¡»è¢«è¯æå¨è¾¹çåï¼è¿æ¯dafnyæ è¿è¡æ¶éè¯¯å®å¨ä¿è¯çä¸é¨åãå ä¸ºè¾¹çæ£æ¥æ¯å¨éªè¯æ¶éªè¯çï¼æä»¥ä¸éè¦è¿è¡è¿è¡æ¶æ£æ¥ãè¦åå»ºä¸ä¸ªæ°æ°ç»ï¼å®å¿é¡»ä½¿ç¨newå³é®å­è¿è¡åéï¼ä½ç®åæä»¬åªä½¿ç¨ä»¥åååéçæ°ç»ä¸ºåæ°çæ¹æ³ã(æå³åéçæ´å¤ä¿¡æ¯ï¼è¯·åéåå­æç¨ã) å¯¹äºä¸ä¸ªæ°ç»ï¼æä»¬å¯è½æ³è¦åçæåºæ¬çäºæä¹ä¸æ¯å¨æ°ç»ä¸­æç´¢ä¸ä¸ªç¹å®çé®ï¼å¹¶è¿åä¸ä¸ªä½ç½®çç´¢å¼ï¼å¦æé®å­å¨ï¼æä»¬å¯ä»¥æ¾å°å®ãæä»¬æä¸¤ä¸ªæç´¢ç»æï¼æ¯ä¸ªç»æé½æä¸åçæ­£ç¡®æ§æ¡ä»¶ãå¦æç®æ³è¿åä¸ä¸ªç´¢å¼(å³éè´æ´æ°)ï¼é£ä¹è¯¥é®åºè¯¥å­å¨äºè¯¥ç´¢å¼å¤ãè¿å¯ä»¥è¡¨ç¤ºä¸º:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nè¿éçæ°ç»ç´¢å¼æ¯å®å¨çï¼å ä¸ºéå«æä½ç¬¦æ¯ç­è·¯ãç­è·¯æå³çå¦æå·¦é¨åä¸ºåï¼é£ä¹ä¸ç®¡ç¬¬äºé¨åççå¼æ¯å¤å°ï¼æç¤ºå·²ç»ä¸ºçï¼å æ­¤ä¸éè¦æ±å¼ãä½¿ç¨éå«è¿ç®ç¬¦çç­è·¯ç¹æ§ï¼ä»¥åå¸å°å¼and(&&)ï¼è¿ä¹æ¯ä¸ç§ç­è·¯ï¼æ¯dafnyçå¸¸è§å®è·µãæ¡ä»¶index < a. lengthæ¯å¿è¦çï¼å¦åè¯¥æ¹æ³å¯è½è¿åä¸ä¸ªå¤§æ´æ°ï¼èä¸æ¯æ°ç»çä¸æ ãæ»ä¹ï¼ç­è·¯è¡ä¸ºæå³çå½æ¶é´æ§å¶å°è¾¾æ°ç»è®¿é®æ¶ï¼indexå¿é¡»æ¯ä¸ä¸ªææçç´¢å¼ã å¦æè¯¥é®ä¸å¨æ°ç»ä¸­ï¼é£ä¹æä»¬å¸ææ¹æ³è¿åä¸ä¸ªè´æ°ãå¨è¿ä¸ªä¾å­ä¸­ï¼æä»¬æ³è¯´è¿ä¸ªæ¹æ³æ²¡æä¸¢å¤±ä¸ä¸ªé®çåºç°;æ¢å¥è¯è¯´ï¼è¿ä¸ªé®ä¸å¨æ°ç»ä¸­ãä¸ºäºè¡¨è¾¾è¿ä¸ªå±æ§ï¼æä»¬æ±å©äºå¦ä¸ä¸ªå¸¸ç¨çdafnyå·¥å·:éè¯ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"éè¯",frontmatter:{title:"éè¯",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/17e8d1/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/40.%E9%87%8F%E8%AF%8D.html",relativePath:"30.æç¨/00.Dafnyæç¨/40.éè¯.md",key:"v-380fb48e",path:"/pages/17e8d1/",headersStr:null,content:"# éè¯\n\nDafnyä¸­çéè¯éå¸¸éç¨forallè¡¨è¾¾å¼çå½¢å¼ï¼ä¹ç§°ä¸ºéç¨éè¯ãé¡¾åæä¹ï¼å¦ææä¸ªå±æ§å¯¹æä¸ªéåçææåç´ é½æç«ï¼åè¯¥è¡¨è¾¾å¼ä¸ºçãç°å¨ï¼æä»¬å°èèæ´æ°çéåãå¨ç§°éè¯çä¾å­ï¼åè£å¨ä¸ä¸ªæ­è¨ä¸­ï¼å¦ä¸æç¤º:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\néè¯ä¸ºå®æèèçéåä¸­çæ¯ä¸ªåç´ å¼å¥ä¸ä¸ªä¸´æ¶åç§°ãè¿å«åç»å®åéï¼å¨è¿éæ¯kãç»å®åéæä¸ä¸ªç±»åï¼å®å ä¹æ»æ¯æ¨æ­åºæ¥çï¼èä¸æ¯æ¾å¼ç»åºçï¼èä¸éå¸¸æ¯intã(ä¸è¬æ¥è¯´ï¼ä¸ä¸ªäººå¯ä»¥æä»»ææ°éçç»å®åéï¼è¿ä¸ªä¸»é¢æä»¬å°å¨åé¢è¿åã)ä¸å¯¹åå·(::)å°ç»å®åéåå¶å¯éç±»åä¸éåå±æ§åéå¼(éåå±æ§çç±»åå¿é¡»ä¸ºbool)ãå¨æ¬ä¾ä¸­ï¼å±æ§æ¯å¯¹ä»»ä½æ´æ°å 1é½æ¯ä¸ä¸ªä¸¥æ ¼çæ´å¤§çæ´æ°ãDafnyè½å¤èªå¨è¯æè¿ä¸ªç®åçæ§è´¨ãä¸è¬æ¥è¯´ï¼å¯¹æ ééè¿è¡éåä¸æ¯å¾æç¨ï¼æ¯å¦ææçæ´æ°ãéè¯éå¸¸ç¨äºéåæ°ç»ææ°æ®ç»æä¸­çææåç´ ãå¯¹äºæ°ç»ï¼æä»¬å¯ä»¥ä½¿ç¨éå«è¿ç®ç¬¦ï¼ä½¿å¾éåå±æ§å¯¹äºéç´¢å¼çå¼å¾å¹³å¡å°ä¸ºç:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\nè¿è¯´ææ°ç»çæ¯ä¸ªåç´ é½æä¸ä¸ªå±æ§ãå®çå«ä¹æ¯ï¼å¨è®¡ç®è¡¨è¾¾å¼çç¬¬äºé¨åä¹åï¼ç¡®ä¿kå®éä¸æ¯æ°ç»ä¸­çææä¸æ ãDafnyä¸ä»å¯ä»¥ä½¿ç¨è¿ä¸ªäºå®æ¥è¯ææ°ç»æ¯å®å¨è®¿é®çï¼èä¸è¿å¯ä»¥å°å¿é¡»èèçæ´æ°éåå°å°åªèèæ°ç»ä¸­çä¸æ ã å¯¹äºéè¯ï¼è¯´æé®ä¸å¨æ°ç»ä¸­æ¯å¾ç®åç:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\nå æ­¤ï¼æä»¬çæ¹æ³åç½®æ¡ä»¶åæ(å ä¸aä¸çéé¶æ¡ä»¶): method Find(a: array<int>, key: int) returns (index: int)\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næä»¬å¯ä»¥ç¨å¤ç§æ¹å¼å¡«åè¿ä¸ªæ¹æ³çä¸»ä½ï¼ä½ä¹è®¸æç®åçæ¯çº¿æ§æç´¢ï¼å®ç°å¦ä¸:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\næ­£å¦æ¨æçå°çï¼æä»¬å¨whileå¾ªç¯ä¸­çç¥äºå¾ªç¯ä¸åéï¼å æ­¤Dafnyå¨å¶ä¸­ä¸ä¸ªåç½®æ¡ä»¶ä¸ç»åºäºä¸ä¸ªéªè¯éè¯¯ãæä»¬å¾å°éè¯¯çåå æ¯Dafnyä¸ç¥éå¾ªç¯å®éä¸è¦çäºææçåç´ ãä¸ºäºè®©Dafnyç¸ä¿¡è¿ä¸ç¹ï¼æä»¬å¿é¡»ç¼åä¸ä¸ªä¸åå¼ï¼è¯´æå½åç´¢å¼ä¹åçææåå®¹é½å·²ç»è¢«æ¥çè¿äº(å¹¶ä¸ä¸æ¯é®)ãå°±ååç½®æ¡ä»¶ä¸æ ·ï¼æä»¬å¯ä»¥ä½¿ç¨ä¸ä¸ªéè¯æ¥è¡¨è¾¾è¿ä¸ªå±æ§:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nè¿è¯´æï¼é¤äºä¹åçä¸åï¼å½åçææ°å¹¶ä¸æ¯å³é®ãè¯·æ³¨æï¼å¨è¿å¥å¾ªç¯æ¶ï¼iä¸ºé¶ï¼å æ­¤éå«çç¬¬ä¸é¨åæ»æ¯åçï¼å æ­¤éåå±æ§æ»æ¯ççãè¿ç§å¸¸è§çæåµè¢«ç§°ä¸ºç©ºæ´ççâ:éè¯ä¹æä»¥æç«ï¼æ¯å ä¸ºå®éåäºä¸ç»ç©ºçå¯¹è±¡ãè¿æå³çå®å¨è¿å¥å¾ªç¯æ¶ä¸ºçãæä»¬å¨æ©å±æ°ç»çéé®é¨åä¹åæµè¯æ°ç»çå¼ï¼å æ­¤Dafnyå¯ä»¥è¯æè¿ä¸ªä¸åéæ¯ä¿ççãå½æä»¬è¯å¾æ·»å è¿ä¸ªä¸åéæ¶ï¼åºç°äºä¸ä¸ªé®é¢:Dafnyæ±æ¨ç´¢å¼è¶åºäºä¸åéä¸­æ°ç»è®¿é®çèå´ã è¿æ®µä»£ç æ²¡æéªè¯ï¼å ä¸ºå¨indexä¸æ²¡æä¸åå¼ï¼æä»¥å®å¯è½å¤§äºæ°ç»çé¿åº¦ãé£ä¹ç»å®åékå¯è½ä¼è¶è¿æ°ç»çé¿åº¦ãä¸ºäºè§£å³è¿ä¸ªé®é¢ï¼æä»¬å°æ åè¾¹çæ¾å¨indexä¸ï¼0 <= index <= a.Lengthãæ³¨æï¼å ä¸ºæä»¬ä½¿ç¨äºk < indexï¼æä»¥å³ä½¿å¨index == a.Lengthæ¶ï¼æ°ç»è®¿é®ä¹ä¸ä¼åºç°éè¯¯ãå¨å¤çæ°ç»æ¶ï¼ä½¿ç¨è¶åºå¢é¿èå´æ«å°¾ä¸å¤çåéæ¯ä¸ç§å¸¸è§æ¨¡å¼ï¼å¨æ°ç»ä¸­ï¼éå¸¸ä½¿ç¨å®æ¯æ¬¡æå»ºä¸ä¸ªåç´ çå±æ§ãå®æ´çæ¹æ³å¦ä¸:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nç»ä¹ 12.\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæ¥åæ´æ°æ°ç»çæ¹æ³ï¼è¯¥æ¹æ³è¦æ±æ°ç»è³å°æä¸ä¸ªåç´ ï¼å¹¶è¿åæ°ç»ä¸­æå¤§åç´ çç´¢å¼ãç¨è¡¨ç¤ºæ¹æ³æå¾çåç½®ååç½®æ¡ä»¶æ¥æ³¨éæ¹æ³ï¼å¹¶ç¨å¾ªç¯ä¸åå¼æ¥æ³¨éå¶ä¸»ä½ä»¥éªè¯æ¹æ³ã\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nçº¿æ§æç´¢ä¸æ¯å¾ææï¼ç¹å«æ¯å½è®¸å¤æ¥è¯¢ç±ç¸åçæ°æ®ç»ææ¶ãå¦ææ°ç»æ¯æåºçï¼é£ä¹æä»¬å¯ä»¥ä½¿ç¨éå¸¸ææçäºè¿å¶æç´¢è¿ç¨æ¥æ¾å°é®ãä½æ¯ä¸ºäºè½å¤è¯ææä»¬çå®ç°æ¯æ­£ç¡®çï¼æä»¬éè¦ä¸äºæ¹æ³æ¥è¦æ±è¾å¥çæ°ç»å®éä¸æ¯æåºçãæä»¬å¯ä»¥å¨æ¹æ³çrequireå­å¥ä¸­ç´æ¥ä½¿ç¨éè¯æ¥å®ç°è¿ä¸ç¹ï¼ä½æ´æ¨¡ååçè¡¨è¾¾æ¹å¼æ¯éè¿ä¸ä¸ªpredicateã",normalizedContent:"# éè¯\n\ndafnyä¸­çéè¯éå¸¸éç¨forallè¡¨è¾¾å¼çå½¢å¼ï¼ä¹ç§°ä¸ºéç¨éè¯ãé¡¾åæä¹ï¼å¦ææä¸ªå±æ§å¯¹æä¸ªéåçææåç´ é½æç«ï¼åè¯¥è¡¨è¾¾å¼ä¸ºçãç°å¨ï¼æä»¬å°èèæ´æ°çéåãå¨ç§°éè¯çä¾å­ï¼åè£å¨ä¸ä¸ªæ­è¨ä¸­ï¼å¦ä¸æç¤º:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\néè¯ä¸ºå®æèèçéåä¸­çæ¯ä¸ªåç´ å¼å¥ä¸ä¸ªä¸´æ¶åç§°ãè¿å«åç»å®åéï¼å¨è¿éæ¯kãç»å®åéæä¸ä¸ªç±»åï¼å®å ä¹æ»æ¯æ¨æ­åºæ¥çï¼èä¸æ¯æ¾å¼ç»åºçï¼èä¸éå¸¸æ¯intã(ä¸è¬æ¥è¯´ï¼ä¸ä¸ªäººå¯ä»¥æä»»ææ°éçç»å®åéï¼è¿ä¸ªä¸»é¢æä»¬å°å¨åé¢è¿åã)ä¸å¯¹åå·(::)å°ç»å®åéåå¶å¯éç±»åä¸éåå±æ§åéå¼(éåå±æ§çç±»åå¿é¡»ä¸ºbool)ãå¨æ¬ä¾ä¸­ï¼å±æ§æ¯å¯¹ä»»ä½æ´æ°å 1é½æ¯ä¸ä¸ªä¸¥æ ¼çæ´å¤§çæ´æ°ãdafnyè½å¤èªå¨è¯æè¿ä¸ªç®åçæ§è´¨ãä¸è¬æ¥è¯´ï¼å¯¹æ ééè¿è¡éåä¸æ¯å¾æç¨ï¼æ¯å¦ææçæ´æ°ãéè¯éå¸¸ç¨äºéåæ°ç»ææ°æ®ç»æä¸­çææåç´ ãå¯¹äºæ°ç»ï¼æä»¬å¯ä»¥ä½¿ç¨éå«è¿ç®ç¬¦ï¼ä½¿å¾éåå±æ§å¯¹äºéç´¢å¼çå¼å¾å¹³å¡å°ä¸ºç:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\nè¿è¯´ææ°ç»çæ¯ä¸ªåç´ é½æä¸ä¸ªå±æ§ãå®çå«ä¹æ¯ï¼å¨è®¡ç®è¡¨è¾¾å¼çç¬¬äºé¨åä¹åï¼ç¡®ä¿kå®éä¸æ¯æ°ç»ä¸­çææä¸æ ãdafnyä¸ä»å¯ä»¥ä½¿ç¨è¿ä¸ªäºå®æ¥è¯ææ°ç»æ¯å®å¨è®¿é®çï¼èä¸è¿å¯ä»¥å°å¿é¡»èèçæ´æ°éåå°å°åªèèæ°ç»ä¸­çä¸æ ã å¯¹äºéè¯ï¼è¯´æé®ä¸å¨æ°ç»ä¸­æ¯å¾ç®åç:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\nå æ­¤ï¼æä»¬çæ¹æ³åç½®æ¡ä»¶åæ(å ä¸aä¸çéé¶æ¡ä»¶): method find(a: array<int>, key: int) returns (index: int)\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næä»¬å¯ä»¥ç¨å¤ç§æ¹å¼å¡«åè¿ä¸ªæ¹æ³çä¸»ä½ï¼ä½ä¹è®¸æç®åçæ¯çº¿æ§æç´¢ï¼å®ç°å¦ä¸:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\næ­£å¦æ¨æçå°çï¼æä»¬å¨whileå¾ªç¯ä¸­çç¥äºå¾ªç¯ä¸åéï¼å æ­¤dafnyå¨å¶ä¸­ä¸ä¸ªåç½®æ¡ä»¶ä¸ç»åºäºä¸ä¸ªéªè¯éè¯¯ãæä»¬å¾å°éè¯¯çåå æ¯dafnyä¸ç¥éå¾ªç¯å®éä¸è¦çäºææçåç´ ãä¸ºäºè®©dafnyç¸ä¿¡è¿ä¸ç¹ï¼æä»¬å¿é¡»ç¼åä¸ä¸ªä¸åå¼ï¼è¯´æå½åç´¢å¼ä¹åçææåå®¹é½å·²ç»è¢«æ¥çè¿äº(å¹¶ä¸ä¸æ¯é®)ãå°±ååç½®æ¡ä»¶ä¸æ ·ï¼æä»¬å¯ä»¥ä½¿ç¨ä¸ä¸ªéè¯æ¥è¡¨è¾¾è¿ä¸ªå±æ§:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nè¿è¯´æï¼é¤äºä¹åçä¸åï¼å½åçææ°å¹¶ä¸æ¯å³é®ãè¯·æ³¨æï¼å¨è¿å¥å¾ªç¯æ¶ï¼iä¸ºé¶ï¼å æ­¤éå«çç¬¬ä¸é¨åæ»æ¯åçï¼å æ­¤éåå±æ§æ»æ¯ççãè¿ç§å¸¸è§çæåµè¢«ç§°ä¸ºç©ºæ´ççâ:éè¯ä¹æä»¥æç«ï¼æ¯å ä¸ºå®éåäºä¸ç»ç©ºçå¯¹è±¡ãè¿æå³çå®å¨è¿å¥å¾ªç¯æ¶ä¸ºçãæä»¬å¨æ©å±æ°ç»çéé®é¨åä¹åæµè¯æ°ç»çå¼ï¼å æ­¤dafnyå¯ä»¥è¯æè¿ä¸ªä¸åéæ¯ä¿ççãå½æä»¬è¯å¾æ·»å è¿ä¸ªä¸åéæ¶ï¼åºç°äºä¸ä¸ªé®é¢:dafnyæ±æ¨ç´¢å¼è¶åºäºä¸åéä¸­æ°ç»è®¿é®çèå´ã è¿æ®µä»£ç æ²¡æéªè¯ï¼å ä¸ºå¨indexä¸æ²¡æä¸åå¼ï¼æä»¥å®å¯è½å¤§äºæ°ç»çé¿åº¦ãé£ä¹ç»å®åékå¯è½ä¼è¶è¿æ°ç»çé¿åº¦ãä¸ºäºè§£å³è¿ä¸ªé®é¢ï¼æä»¬å°æ åè¾¹çæ¾å¨indexä¸ï¼0 <= index <= a.lengthãæ³¨æï¼å ä¸ºæä»¬ä½¿ç¨äºk < indexï¼æä»¥å³ä½¿å¨index == a.lengthæ¶ï¼æ°ç»è®¿é®ä¹ä¸ä¼åºç°éè¯¯ãå¨å¤çæ°ç»æ¶ï¼ä½¿ç¨è¶åºå¢é¿èå´æ«å°¾ä¸å¤çåéæ¯ä¸ç§å¸¸è§æ¨¡å¼ï¼å¨æ°ç»ä¸­ï¼éå¸¸ä½¿ç¨å®æ¯æ¬¡æå»ºä¸ä¸ªåç´ çå±æ§ãå®æ´çæ¹æ³å¦ä¸:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nç»ä¹ 12.\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nç¼åä¸ä¸ªæ¥åæ´æ°æ°ç»çæ¹æ³ï¼è¯¥æ¹æ³è¦æ±æ°ç»è³å°æä¸ä¸ªåç´ ï¼å¹¶è¿åæ°ç»ä¸­æå¤§åç´ çç´¢å¼ãç¨è¡¨ç¤ºæ¹æ³æå¾çåç½®ååç½®æ¡ä»¶æ¥æ³¨éæ¹æ³ï¼å¹¶ç¨å¾ªç¯ä¸åå¼æ¥æ³¨éå¶ä¸»ä½ä»¥éªè¯æ¹æ³ã\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nçº¿æ§æç´¢ä¸æ¯å¾ææï¼ç¹å«æ¯å½è®¸å¤æ¥è¯¢ç±ç¸åçæ°æ®ç»ææ¶ãå¦ææ°ç»æ¯æåºçï¼é£ä¹æä»¬å¯ä»¥ä½¿ç¨éå¸¸ææçäºè¿å¶æç´¢è¿ç¨æ¥æ¾å°é®ãä½æ¯ä¸ºäºè½å¤è¯ææä»¬çå®ç°æ¯æ­£ç¡®çï¼æä»¬éè¦ä¸äºæ¹æ³æ¥è¦æ±è¾å¥çæ°ç»å®éä¸æ¯æåºçãæä»¬å¯ä»¥å¨æ¹æ³çrequireå­å¥ä¸­ç´æ¥ä½¿ç¨éè¯æ¥å®ç°è¿ä¸ç¹ï¼ä½æ´æ¨¡ååçè¡¨è¾¾æ¹å¼æ¯éè¿ä¸ä¸ªpredicateã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"è°è¯",frontmatter:{title:"è°è¯",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/cc01af/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/45.%E8%B0%93%E8%AF%8D.html",relativePath:"30.æç¨/00.Dafnyæç¨/45.è°è¯.md",key:"v-a6041e50",path:"/pages/cc01af/",headersStr:null,content:"# è°è¯\n\nè°è¯æ¯ä¸ä¸ªè¿åå¸å°å¼çå½æ°ãè¿æ¯ä¸ä¸ªç®åä½å¼ºå¤§çæ³æ³ï¼åçå¨Dafnyçç¨åºãä¾å¦ï¼æä»¬å°æ´æ°æ°ç»ä¸çsortedè°è¯å®ä¹ä¸ºä¸ä¸ªå½æ°ï¼è¯¥å½æ°æ¥åä¸ä¸ªæ°ç»ä½ä¸ºåæ°ï¼å½ä¸ä»å½è¯¥æ°ç»æéå¢é¡ºåºæåºæ¶ï¼è¿åtrueãè°è¯çä½¿ç¨ä½¿æä»¬çä»£ç æ´ç­ï¼å ä¸ºæä»¬ä¸éè¦ä¸éåä¸éå°ååºä¸ä¸ªå¾é¿çå±æ§ãå®è¿å¯ä»¥éè¿ç»ä¸ä¸ªå¬å±å±æ§å½åæ¥ä½¿æä»¬çä»£ç æ´å®¹æéè¯»ã æä»¬æå¾å¤æ¹æ³å¯ä»¥åsortedè°è¯ï¼ä½æç®åçæ¯å¨æ°ç»çä¸æ ä¸ä½¿ç¨ä¸ä¸ªéè¯ãæä»¬å¯ä»¥åä¸ä¸ªéè¯æ¥è¡¨ç¤ºå±æ§âå¦ææ°ç»ä¸­xå¨yä¹åï¼é£ä¹x <= yï¼ä½ä¸ºä¸ä¸ªéè¯å¨ä¸¤ä¸ªç»å®åéä¸:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\nè¿éæä»¬æä¸¤ä¸ªç»å®åéï¼jåkï¼é½æ¯æ´æ°ãä¸¤èä¹é´çæ¯è¾ä¿è¯äºå®ä»¬å¨æ°ç»ä¸­é½æ¯ææçä¸æ ï¼å¹¶ä¸jå¨kä¹åãç¶åç¬¬äºé¨åè¯´å®ä»¬å½¼æ­¤ä¹é´çé¡ºåºæ¯æ­£ç¡®çãéè¯å¨Dafnyä¸­åªæ¯ä¸ç§å¸å°å¼è¡¨è¾¾å¼ï¼æä»¥æä»¬å¯ä»¥å°æåºè°è¯åä¸º:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\næ³¨æï¼æ²¡æè¿åç±»åï¼å ä¸ºè°è¯æ»æ¯è¿åå¸å°å¼ã Dafnyæç»ç»åºçè¿æ®µä»£ç ï¼å£°ç§°è°è¯è¯»ä¸åºaãä¿®å¤æ­¤é®é¢éè¦å¦ä¸ä¸ªæ³¨éï¼è¯»åæ³¨éã",normalizedContent:"# è°è¯\n\nè°è¯æ¯ä¸ä¸ªè¿åå¸å°å¼çå½æ°ãè¿æ¯ä¸ä¸ªç®åä½å¼ºå¤§çæ³æ³ï¼åçå¨dafnyçç¨åºãä¾å¦ï¼æä»¬å°æ´æ°æ°ç»ä¸çsortedè°è¯å®ä¹ä¸ºä¸ä¸ªå½æ°ï¼è¯¥å½æ°æ¥åä¸ä¸ªæ°ç»ä½ä¸ºåæ°ï¼å½ä¸ä»å½è¯¥æ°ç»æéå¢é¡ºåºæåºæ¶ï¼è¿åtrueãè°è¯çä½¿ç¨ä½¿æä»¬çä»£ç æ´ç­ï¼å ä¸ºæä»¬ä¸éè¦ä¸éåä¸éå°ååºä¸ä¸ªå¾é¿çå±æ§ãå®è¿å¯ä»¥éè¿ç»ä¸ä¸ªå¬å±å±æ§å½åæ¥ä½¿æä»¬çä»£ç æ´å®¹æéè¯»ã æä»¬æå¾å¤æ¹æ³å¯ä»¥åsortedè°è¯ï¼ä½æç®åçæ¯å¨æ°ç»çä¸æ ä¸ä½¿ç¨ä¸ä¸ªéè¯ãæä»¬å¯ä»¥åä¸ä¸ªéè¯æ¥è¡¨ç¤ºå±æ§âå¦ææ°ç»ä¸­xå¨yä¹åï¼é£ä¹x <= yï¼ä½ä¸ºä¸ä¸ªéè¯å¨ä¸¤ä¸ªç»å®åéä¸:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\nè¿éæä»¬æä¸¤ä¸ªç»å®åéï¼jåkï¼é½æ¯æ´æ°ãä¸¤èä¹é´çæ¯è¾ä¿è¯äºå®ä»¬å¨æ°ç»ä¸­é½æ¯ææçä¸æ ï¼å¹¶ä¸jå¨kä¹åãç¶åç¬¬äºé¨åè¯´å®ä»¬å½¼æ­¤ä¹é´çé¡ºåºæ¯æ­£ç¡®çãéè¯å¨dafnyä¸­åªæ¯ä¸ç§å¸å°å¼è¡¨è¾¾å¼ï¼æä»¥æä»¬å¯ä»¥å°æåºè°è¯åä¸º:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\næ³¨æï¼æ²¡æè¿åç±»åï¼å ä¸ºè°è¯æ»æ¯è¿åå¸å°å¼ã dafnyæç»ç»åºçè¿æ®µä»£ç ï¼å£°ç§°è°è¯è¯»ä¸åºaãä¿®å¤æ­¤é®é¢éè¦å¦ä¸ä¸ªæ³¨éï¼è¯»åæ³¨éã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ¡æ¶",frontmatter:{title:"æ¡æ¶",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/13bbcd/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/50.%E6%A1%86%E6%9E%B6.html",relativePath:"30.æç¨/00.Dafnyæç¨/50.æ¡æ¶.md",key:"v-56398717",path:"/pages/13bbcd/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# æ¡æ¶\n\næåºåçè°è¯ä¸è½è®¿é®æ°ç»ï¼å ä¸ºè¯¥æ°ç»ä¸åå«å¨å½æ°çè¯»åå¸§ä¸­ãå½æ°(æè°è¯)çè¯»åæ¡æ¶æ¯å½æ°åè®¸è¯»åçææåå­ä½ç½®ãéå¶å½æ°å¯è¯»åå®¹çåå æ¯ï¼å½åå¥åå­æ¶ï¼å¯ä»¥ç¡®ä¿æ²¡æè¯»åè¯¥åå­é¨åçå½æ°å·æä¸ä¹åç¸åçå¼ãä¾å¦ï¼æä»¬å¯è½æä¸¤ä¸ªæ°ç»ï¼æä»¬ç¥éå¶ä¸­ä¸ä¸ªæ¯æåºçãå¦ææ²¡æå¨å·²æåºçè°è¯ä¸æ¾ç½®readsæ³¨éï¼é£ä¹å½ä¿®æ¹æªæåºçæ°ç»æ¶ï¼å°±æ æ³ç¡®å®å¦ä¸ä¸ªæ°ç»æ¯å¦åæ­¢æåºãè½ç¶å¨è¿ç§æåµä¸ï¼æä»¬å¯ä»¥æä¾ä¸åéæ¥ä¿å­å®ï¼ä½å¨æä½æ°æ®ç»ææ¶ï¼å®ä¼åå¾æ´å å¤æãå¨è¿ç§æåµä¸ï¼æ¡æ¶æ¯ä½¿æ ¸æ¥è¿ç¨å¯è¡çå³é®ã\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreadsæ³¨éä¸æ¯å¸å°è¡¨è¾¾å¼ï¼å°±åæä»¬çå°çå¶ä»æ³¨éä¸æ ·ï¼å®å¯ä»¥ä¸åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸èµ·åºç°å¨ä»»ä½å°æ¹ãå®æå®äºå½æ°åè®¸è®¿é®çä¸ç»åå­ä½ç½®ï¼èä¸æ¯åºè¯¥ä¸ºççå±æ§ãæ°ç»çåç§°ï¼å°±åä¸é¢ä¾å­ä¸­çaï¼ä»£è¡¨è¯¥æ°ç»çææåç´ ãä¹å¯ä»¥æå®å¯¹è±¡å­æ®µåå¯¹è±¡éï¼ä½æä»¬å¨è¿éä¸è®¨è®ºè¿äºä¸»é¢ãDafnyå°æ£æ¥æ¨æ²¡æè¯»åè¯»åå¸§ä¸­æ²¡æå£°æçä»»ä½åå­ä½ç½®ãè¿æå³çå½æ°åçå½æ°è°ç¨å¿é¡»å·æä½ä¸ºè°ç¨å½æ°è¯»åå¸§å­éçè¯»åå¸§ãéè¦æ³¨æçä¸ç¹æ¯ï¼å½æ°çåæ°å¦æä¸æ¯åå­ä½ç½®ï¼åä¸éè¦å£°æã æ¡æ¶ä¹ä¼å½±åæ¹æ³ãæ­£å¦æ¨å¯è½å·²ç»çå°çï¼å®ä»¬ä¸éè¦ååºå®ä»¬æè¯»åçåå®¹ï¼å ä¸ºæä»¬å·²ç»ç¼åäºä¸ä¸ªæ¹æ³æ¥è®¿é®æ²¡æreadsæ³¨éçæ°ç»ãæ¹æ³å¯ä»¥è¯»åå®ä»¬æ³è¦çä»»ä½åå­ï¼ä½å®ä»¬éè¦ç¨modifies annotationååºå®ä»¬ä¿®æ¹çåå­çåªäºé¨åãå®ä»¬å ä¹åå®ä»¬çè¯»åè¡¨äº²ä¸æ ·ï¼é¤äºå®ä»¬è¯´çæ¯å¯ä»¥æ¹åä»ä¹ï¼èä¸æ¯å½æ°çå¼åå³äºä»ä¹ãç»åè¯»åï¼ä¿®æ¹éå¶åè®¸Dafnyè¯æä»£ç çå±æ§ï¼å¦åå°éå¸¸å°é¾æä¸å¯è½ãè¯»ååä¿®æ¹æ¯åè®¸Dafnyä¸æ¬¡åªå¤çä¸ä¸ªæ¹æ³çå·¥å·ä¹ä¸ï¼å ä¸ºå®ä»¬éå¶äºå¯¹åå­çä»»æä¿®æ¹ï¼ä½¿Dafnyè½å¤æ¨çã è¯·æ³¨æï¼å¸§ååªéç¨äºå ï¼æéè¿å¼ç¨è®¿é®çåå­ãå±é¨åéä¸æ¯å­å¨å¨ä¸çï¼æä»¥å®ä»¬ä¸è½å¨readsæ³¨éä¸­è¢«æåãè¿è¯·æ³¨æï¼åéåãåºååå¤éè¿æ ·çç±»åé½æ¯å¼ç±»åï¼å®ä»¬è¢«è§ä¸ºæ´æ°æå±é¨åéãæ°ç»åå¯¹è±¡æ¯å å¼ç¨ç±»åï¼å®ä»¬å­å¨å¨å ä¸(å°½ç®¡å¼ç¨æ¬èº«åå®ææåçå¼ä¹é´æ»æ¯æå¾®å¦çåºå«)ã\n\nç»ä¹ 13\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿®æ¹' sorted 'è°è¯çå®ä¹ï¼ä»¥ä¾¿å½æ°ç»è¢«æåºä¸å¶ææåç´ é½ä¸ç¸åæ¶ï¼å®åç¡®å°è¿åtrueã\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç»ä¹ 14\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nå¦æç§»é¤åç½®æ¡ä»¶' a != null 'ä¼åçä»ä¹?æ´æ¹' sorted 'çå®ä¹ï¼ä½¿å¶åè®¸åæ°ä¸ºnullï¼ä½å¦ææ¯åè¿åfalseã\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as \"not sorted\".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n#",normalizedContent:"# æ¡æ¶\n\næåºåçè°è¯ä¸è½è®¿é®æ°ç»ï¼å ä¸ºè¯¥æ°ç»ä¸åå«å¨å½æ°çè¯»åå¸§ä¸­ãå½æ°(æè°è¯)çè¯»åæ¡æ¶æ¯å½æ°åè®¸è¯»åçææåå­ä½ç½®ãéå¶å½æ°å¯è¯»åå®¹çåå æ¯ï¼å½åå¥åå­æ¶ï¼å¯ä»¥ç¡®ä¿æ²¡æè¯»åè¯¥åå­é¨åçå½æ°å·æä¸ä¹åç¸åçå¼ãä¾å¦ï¼æä»¬å¯è½æä¸¤ä¸ªæ°ç»ï¼æä»¬ç¥éå¶ä¸­ä¸ä¸ªæ¯æåºçãå¦ææ²¡æå¨å·²æåºçè°è¯ä¸æ¾ç½®readsæ³¨éï¼é£ä¹å½ä¿®æ¹æªæåºçæ°ç»æ¶ï¼å°±æ æ³ç¡®å®å¦ä¸ä¸ªæ°ç»æ¯å¦åæ­¢æåºãè½ç¶å¨è¿ç§æåµä¸ï¼æä»¬å¯ä»¥æä¾ä¸åéæ¥ä¿å­å®ï¼ä½å¨æä½æ°æ®ç»ææ¶ï¼å®ä¼åå¾æ´å å¤æãå¨è¿ç§æåµä¸ï¼æ¡æ¶æ¯ä½¿æ ¸æ¥è¿ç¨å¯è¡çå³é®ã\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreadsæ³¨éä¸æ¯å¸å°è¡¨è¾¾å¼ï¼å°±åæä»¬çå°çå¶ä»æ³¨éä¸æ ·ï¼å®å¯ä»¥ä¸åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸èµ·åºç°å¨ä»»ä½å°æ¹ãå®æå®äºå½æ°åè®¸è®¿é®çä¸ç»åå­ä½ç½®ï¼èä¸æ¯åºè¯¥ä¸ºççå±æ§ãæ°ç»çåç§°ï¼å°±åä¸é¢ä¾å­ä¸­çaï¼ä»£è¡¨è¯¥æ°ç»çææåç´ ãä¹å¯ä»¥æå®å¯¹è±¡å­æ®µåå¯¹è±¡éï¼ä½æä»¬å¨è¿éä¸è®¨è®ºè¿äºä¸»é¢ãdafnyå°æ£æ¥æ¨æ²¡æè¯»åè¯»åå¸§ä¸­æ²¡æå£°æçä»»ä½åå­ä½ç½®ãè¿æå³çå½æ°åçå½æ°è°ç¨å¿é¡»å·æä½ä¸ºè°ç¨å½æ°è¯»åå¸§å­éçè¯»åå¸§ãéè¦æ³¨æçä¸ç¹æ¯ï¼å½æ°çåæ°å¦æä¸æ¯åå­ä½ç½®ï¼åä¸éè¦å£°æã æ¡æ¶ä¹ä¼å½±åæ¹æ³ãæ­£å¦æ¨å¯è½å·²ç»çå°çï¼å®ä»¬ä¸éè¦ååºå®ä»¬æè¯»åçåå®¹ï¼å ä¸ºæä»¬å·²ç»ç¼åäºä¸ä¸ªæ¹æ³æ¥è®¿é®æ²¡æreadsæ³¨éçæ°ç»ãæ¹æ³å¯ä»¥è¯»åå®ä»¬æ³è¦çä»»ä½åå­ï¼ä½å®ä»¬éè¦ç¨modifies annotationååºå®ä»¬ä¿®æ¹çåå­çåªäºé¨åãå®ä»¬å ä¹åå®ä»¬çè¯»åè¡¨äº²ä¸æ ·ï¼é¤äºå®ä»¬è¯´çæ¯å¯ä»¥æ¹åä»ä¹ï¼èä¸æ¯å½æ°çå¼åå³äºä»ä¹ãç»åè¯»åï¼ä¿®æ¹éå¶åè®¸dafnyè¯æä»£ç çå±æ§ï¼å¦åå°éå¸¸å°é¾æä¸å¯è½ãè¯»ååä¿®æ¹æ¯åè®¸dafnyä¸æ¬¡åªå¤çä¸ä¸ªæ¹æ³çå·¥å·ä¹ä¸ï¼å ä¸ºå®ä»¬éå¶äºå¯¹åå­çä»»æä¿®æ¹ï¼ä½¿dafnyè½å¤æ¨çã è¯·æ³¨æï¼å¸§ååªéç¨äºå ï¼æéè¿å¼ç¨è®¿é®çåå­ãå±é¨åéä¸æ¯å­å¨å¨ä¸çï¼æä»¥å®ä»¬ä¸è½å¨readsæ³¨éä¸­è¢«æåãè¿è¯·æ³¨æï¼åéåãåºååå¤éè¿æ ·çç±»åé½æ¯å¼ç±»åï¼å®ä»¬è¢«è§ä¸ºæ´æ°æå±é¨åéãæ°ç»åå¯¹è±¡æ¯å å¼ç¨ç±»åï¼å®ä»¬å­å¨å¨å ä¸(å°½ç®¡å¼ç¨æ¬èº«åå®ææåçå¼ä¹é´æ»æ¯æå¾®å¦çåºå«)ã\n\nç»ä¹ 13\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿®æ¹' sorted 'è°è¯çå®ä¹ï¼ä»¥ä¾¿å½æ°ç»è¢«æåºä¸å¶ææåç´ é½ä¸ç¸åæ¶ï¼å®åç¡®å°è¿åtrueã\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç»ä¹ 14\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nå¦æç§»é¤åç½®æ¡ä»¶' a != null 'ä¼åçä»ä¹?æ´æ¹' sorted 'çå®ä¹ï¼ä½¿å¶åè®¸åæ°ä¸ºnullï¼ä½å¦ææ¯åè¿åfalseã\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as \"not sorted\".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"äºåæ¥æ¾",frontmatter:{title:"äºåæ¥æ¾",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/1319be/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/55.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"30.æç¨/00.Dafnyæç¨/55.äºåæ¥æ¾.md",key:"v-29984e8a",path:"/pages/1319be/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"",content:"# äºåæ¥æ¾\n\nè°è¯éå¸¸ç¨äºä½¿å¶ä»æ³¨éæ´æ¸æ°:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\næä»¬æåçº¿æ§æç´¢ä¸æ ·çåç½®æ¡ä»¶ï¼å ä¸ºç®æ æ¯ä¸æ ·çãä¸åçæ¯ï¼ç°å¨æä»¬ç¥éæ°ç»æ¯æåºçãå ä¸ºDafnyå¯ä»¥å±å¼å½æ°ï¼æä»¥å¨æ¹æ³ä½ä¸­å®ä¹ç¥éè¿ä¸ç¹ãç¶åæä»¬å¯ä»¥ç¨è¿ä¸ªæ§è´¨æ¥è¯ææç´¢çæ­£ç¡®æ§ãæ¹æ³ä½å¦ä¸æç¤º:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nè¿æ¯ä¸ä¸ªç¸å½æ åçäºåæ¥æ¾å®ç°ãé¦åï¼æä»¬å£°æè¦æç´¢çèå´ãè¿å¯ä»¥è¢«è®¤ä¸ºæ¯é¥åå¯è½å­å¨çå©ä½ç©ºé´ãèå´æ¯åå«-æä»çï¼æå³çå®åæ¬ææ°[lowï¼high)ãç¬¬ä¸ä¸ªä¸åéè¡¨ç¤ºè¿ä¸ªèå´å¨æ°ç»åãç¬¬äºä¸ªè¡¨ç¤ºé®ä¸å¨è¿ä¸ªèå´ä¹å¤çä»»ä½å°æ¹ãå¨ifé¾çåä¸¤ä¸ªåæ¯ä¸­ï¼æä»¬åç°åºé´ä¸­é´çåç´ ä¸æ¯é®ï¼å æ­¤æä»¬ç§»å¨åºé´ä»¥æé¤è¯¥åç´ åå¶ç¸åºä¸ä¾§çææå¶ä»åç´ ãå½ç§»å¨èå´çä¸ç«¯æ¶ï¼æä»¬éè¦å ä¸1ï¼å ä¸ºå®å¨ä½ç«¯æ¯åå«çãå¦æä¸å 1ï¼é£ä¹å½mid == lowæ¶ï¼å¾ªç¯å¯è½ä¼æ°¸è¿ç»§ç»­ä¸å»ï¼å½low + 1 == highæ¶å°±ä¼åçè¿ç§æåµãæä»¬å¯ä»¥æ¹åå®ï¼å½lowåhighç¸å·®1æ¶ï¼å¾ªç¯éåºï¼ä½è¿æå³çæä»¬éè¦å¨å¾ªç¯ä¹åè¿è¡é¢å¤çæ£æ¥ï¼ä»¥ç¡®å®æ¯å¦å¨å©ä¸çä¸ä¸ªç´¢å¼ä¸­æ¾å°é®ãå¨ä¸é¢çå¬å¼ä¸­ï¼è¿æ¯ä¸å¿è¦çï¼å ä¸ºå½low == highæ¶ï¼å¾ªç¯éåºãä½è¿æå³çæç´¢èå´åæ²¡æåç´ çä¸ï¼å æ­¤æ²¡ææ¾å°é®ãè¿å¯ä»¥ä»å¾ªç¯ä¸åéæ¨å¯¼åºæ¥:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nå½low == highæ¶ï¼å«ä¹çç¬¬ä¸é¨åçå¦å®æ¡ä»¶æ»æ¯ä¸ºç(å ä¸ºæ²¡æiå¯ä»¥è³å°æä¸¥æ ¼å°äºç¸åçå¼)ãå æ­¤ï¼ä¸åéè¡¨ç¤ºæ°ç»ä¸­çææåç´ é½ä¸æ¯é®ï¼ç¬¬äºä¸ªåç½®æ¡ä»¶æç«ãæ­£å¦æ¨æçå°çï¼å¨è¿æ®µä»£ç ä¸­å¾å®¹æåºç°ä¸ä¸ªéè¯¯ãæäºè¿äºä¸åéï¼Dafnyä¸ä»å¯ä»¥è¯æä»£ç æ¯æ­£ç¡®çï¼èä¸æä»¬èªå·±ä¹å¯ä»¥æ´å®¹æå°çè§£ä»£ç çæä½ã\n\nç»ä¹ 15.\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿®æ¹BinarySearchå½æ°ä½ä¸­çèµå¼ï¼å°lowè®¾ç½®ä¸ºmidï¼æå°highè®¾ç½®ä¸ºmid - 1ãå¨æ¯ç§æåµä¸ï¼åªéåºäºé®é¢?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n#",normalizedContent:"# äºåæ¥æ¾\n\nè°è¯éå¸¸ç¨äºä½¿å¶ä»æ³¨éæ´æ¸æ°:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\næä»¬æåçº¿æ§æç´¢ä¸æ ·çåç½®æ¡ä»¶ï¼å ä¸ºç®æ æ¯ä¸æ ·çãä¸åçæ¯ï¼ç°å¨æä»¬ç¥éæ°ç»æ¯æåºçãå ä¸ºdafnyå¯ä»¥å±å¼å½æ°ï¼æä»¥å¨æ¹æ³ä½ä¸­å®ä¹ç¥éè¿ä¸ç¹ãç¶åæä»¬å¯ä»¥ç¨è¿ä¸ªæ§è´¨æ¥è¯ææç´¢çæ­£ç¡®æ§ãæ¹æ³ä½å¦ä¸æç¤º:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nè¿æ¯ä¸ä¸ªç¸å½æ åçäºåæ¥æ¾å®ç°ãé¦åï¼æä»¬å£°æè¦æç´¢çèå´ãè¿å¯ä»¥è¢«è®¤ä¸ºæ¯é¥åå¯è½å­å¨çå©ä½ç©ºé´ãèå´æ¯åå«-æä»çï¼æå³çå®åæ¬ææ°[lowï¼high)ãç¬¬ä¸ä¸ªä¸åéè¡¨ç¤ºè¿ä¸ªèå´å¨æ°ç»åãç¬¬äºä¸ªè¡¨ç¤ºé®ä¸å¨è¿ä¸ªèå´ä¹å¤çä»»ä½å°æ¹ãå¨ifé¾çåä¸¤ä¸ªåæ¯ä¸­ï¼æä»¬åç°åºé´ä¸­é´çåç´ ä¸æ¯é®ï¼å æ­¤æä»¬ç§»å¨åºé´ä»¥æé¤è¯¥åç´ åå¶ç¸åºä¸ä¾§çææå¶ä»åç´ ãå½ç§»å¨èå´çä¸ç«¯æ¶ï¼æä»¬éè¦å ä¸1ï¼å ä¸ºå®å¨ä½ç«¯æ¯åå«çãå¦æä¸å 1ï¼é£ä¹å½mid == lowæ¶ï¼å¾ªç¯å¯è½ä¼æ°¸è¿ç»§ç»­ä¸å»ï¼å½low + 1 == highæ¶å°±ä¼åçè¿ç§æåµãæä»¬å¯ä»¥æ¹åå®ï¼å½lowåhighç¸å·®1æ¶ï¼å¾ªç¯éåºï¼ä½è¿æå³çæä»¬éè¦å¨å¾ªç¯ä¹åè¿è¡é¢å¤çæ£æ¥ï¼ä»¥ç¡®å®æ¯å¦å¨å©ä¸çä¸ä¸ªç´¢å¼ä¸­æ¾å°é®ãå¨ä¸é¢çå¬å¼ä¸­ï¼è¿æ¯ä¸å¿è¦çï¼å ä¸ºå½low == highæ¶ï¼å¾ªç¯éåºãä½è¿æå³çæç´¢èå´åæ²¡æåç´ çä¸ï¼å æ­¤æ²¡ææ¾å°é®ãè¿å¯ä»¥ä»å¾ªç¯ä¸åéæ¨å¯¼åºæ¥:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nå½low == highæ¶ï¼å«ä¹çç¬¬ä¸é¨åçå¦å®æ¡ä»¶æ»æ¯ä¸ºç(å ä¸ºæ²¡æiå¯ä»¥è³å°æä¸¥æ ¼å°äºç¸åçå¼)ãå æ­¤ï¼ä¸åéè¡¨ç¤ºæ°ç»ä¸­çææåç´ é½ä¸æ¯é®ï¼ç¬¬äºä¸ªåç½®æ¡ä»¶æç«ãæ­£å¦æ¨æçå°çï¼å¨è¿æ®µä»£ç ä¸­å¾å®¹æåºç°ä¸ä¸ªéè¯¯ãæäºè¿äºä¸åéï¼dafnyä¸ä»å¯ä»¥è¯æä»£ç æ¯æ­£ç¡®çï¼èä¸æä»¬èªå·±ä¹å¯ä»¥æ´å®¹æå°çè§£ä»£ç çæä½ã\n\nç»ä¹ 15.\n\nç¹å»æ¥çé¢ç®åä»£ç \n\nä¿®æ¹binarysearchå½æ°ä½ä¸­çèµå¼ï¼å°lowè®¾ç½®ä¸ºmidï¼æå°highè®¾ç½®ä¸ºmid - 1ãå¨æ¯ç§æåµä¸ï¼åªéåºäºé®é¢?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"ç»è®º",frontmatter:{title:"ç»è®º",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/30a8c2/",categories:["æç¨"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/00.Dafny%E6%95%99%E7%A8%8B/60.%E7%BB%93%E8%AE%BA.html",relativePath:"30.æç¨/00.Dafnyæç¨/60.ç»è®º.md",key:"v-3a5a84d4",path:"/pages/30a8c2/",headersStr:null,content:"# ç»è®º\n\næä»¬å·²ç»çå°äºDafnyçä¸»è¦åè½ï¼å¹¶å°å¶ç¨äºä¸äºæè¶£çä¾å­ï¼å¦ææ¯å¨å°æ¹é¢çè¯ï¼è¯´æDafnyå¯ä»¥åä»ä¹ãä½æ¯ï¼è¦çæ­£å©ç¨Dafnyæä¾çåè½ï¼éè¦æ·±å¥å­¦ä¹ é«çº§ä¸»é¢:å¯¹è±¡ãåºååéåãæ°æ®ç»æãå¼çç­ãç°å¨æ¨å·²ç»çæäºDafnyçåºç¡ç¥è¯ï¼æ¨å¯ä»¥å¨é²ææ¶éè¯»å³äºè¿äºä¸»é¢çæç¨ãæ¯ä¸ªæç¨é½è¢«è®¾è®¡æç¸å¯¹ç¬ç«çä¸»é¢æåï¼å°½ç®¡æäºæç¨å¯ä»¥ä»äºåéè¯»å¶ä»æç¨ä¸­åçãè¿äºä¾å­ä¹æ¯å¯»æ¾Dafnyæ¨¡åç¨åºçå¥½å°æ¹ãæåï¼å¼ç¨åå«äºDafnyè¯­æ³åè¯­ä¹çè¯¦ç»ä¿¡æ¯ï¼å½æ¨åªéè¦ç¥éä¸ç¸äº¤éåæä½ç¬¦æ¯ä»ä¹(å®æ¯!!)ã\n\ntips\n\nå³ä½¿æ¨ä¸ç»å¸¸ä½¿ç¨Dafnyï¼ä»¥ä¸ç§ç²¾ç¡®çæ¹å¼åç¡®å°åä¸ä»£ç æåçäºæï¼å¹¶ä½¿ç¨å®æ¥è¯æä»£ç æ¯æ­£ç¡®çï¼è¿æ¯ä¸ç§æç¨çæè½ãä¸åéãåç½®ååç½®æ¡ä»¶ä»¥åæ³¨éå¨è°è¯ä»£ç ä¸­éå¸¸æç¨ï¼ä¹å¯ä»¥ä½ä¸ºå°æ¥å¼åäººåçææ¡£ãå½ä¿®æ¹ææ·»å ä»£ç åºæ¶ï¼å®ä»¬ç¡®è®¤ç°æä»£ç çä¿è¯æ²¡æè¢«ç ´åãä»ä»¬è¿éè¿å½¢å¼åè¡ä¸ºåéæ±å¹¶å¼ºå¶æ§è¡æ­£ç¡®çç¨æ³ï¼ç¡®ä¿apiè¢«æ­£ç¡®ä½¿ç¨ãä»ä¸åéæ¨çãèèåç½®ååç½®æ¡ä»¶ï¼ä»¥åç¼åæ­è¨æ¥æ£æ¥åè®¾ï¼è¿äºé½æ¯éç¨çè®¡ç®æºç§å­¦æè½ï¼æ è®ºä½¿ç¨åªç§è¯­è¨ï¼è¿äºæè½é½å°ä½¿æ¨åçã",normalizedContent:"# ç»è®º\n\næä»¬å·²ç»çå°äºdafnyçä¸»è¦åè½ï¼å¹¶å°å¶ç¨äºä¸äºæè¶£çä¾å­ï¼å¦ææ¯å¨å°æ¹é¢çè¯ï¼è¯´ædafnyå¯ä»¥åä»ä¹ãä½æ¯ï¼è¦çæ­£å©ç¨dafnyæä¾çåè½ï¼éè¦æ·±å¥å­¦ä¹ é«çº§ä¸»é¢:å¯¹è±¡ãåºååéåãæ°æ®ç»æãå¼çç­ãç°å¨æ¨å·²ç»çæäºdafnyçåºç¡ç¥è¯ï¼æ¨å¯ä»¥å¨é²ææ¶éè¯»å³äºè¿äºä¸»é¢çæç¨ãæ¯ä¸ªæç¨é½è¢«è®¾è®¡æç¸å¯¹ç¬ç«çä¸»é¢æåï¼å°½ç®¡æäºæç¨å¯ä»¥ä»äºåéè¯»å¶ä»æç¨ä¸­åçãè¿äºä¾å­ä¹æ¯å¯»æ¾dafnyæ¨¡åç¨åºçå¥½å°æ¹ãæåï¼å¼ç¨åå«äºdafnyè¯­æ³åè¯­ä¹çè¯¦ç»ä¿¡æ¯ï¼å½æ¨åªéè¦ç¥éä¸ç¸äº¤éåæä½ç¬¦æ¯ä»ä¹(å®æ¯!!)ã\n\ntips\n\nå³ä½¿æ¨ä¸ç»å¸¸ä½¿ç¨dafnyï¼ä»¥ä¸ç§ç²¾ç¡®çæ¹å¼åç¡®å°åä¸ä»£ç æåçäºæï¼å¹¶ä½¿ç¨å®æ¥è¯æä»£ç æ¯æ­£ç¡®çï¼è¿æ¯ä¸ç§æç¨çæè½ãä¸åéãåç½®ååç½®æ¡ä»¶ä»¥åæ³¨éå¨è°è¯ä»£ç ä¸­éå¸¸æç¨ï¼ä¹å¯ä»¥ä½ä¸ºå°æ¥å¼åäººåçææ¡£ãå½ä¿®æ¹ææ·»å ä»£ç åºæ¶ï¼å®ä»¬ç¡®è®¤ç°æä»£ç çä¿è¯æ²¡æè¢«ç ´åãä»ä»¬è¿éè¿å½¢å¼åè¡ä¸ºåéæ±å¹¶å¼ºå¶æ§è¡æ­£ç¡®çç¨æ³ï¼ç¡®ä¿apiè¢«æ­£ç¡®ä½¿ç¨ãä»ä¸åéæ¨çãèèåç½®ååç½®æ¡ä»¶ï¼ä»¥åç¼åæ­è¨æ¥æ£æ¥åè®¾ï¼è¿äºé½æ¯éç¨çè®¡ç®æºç§å­¦æè½ï¼æ è®ºä½¿ç¨åªç§è¯­è¨ï¼è¿äºæè½é½å°ä½¿æ¨åçã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"å¼çåå½çº³",frontmatter:{title:"å¼çåå½çº³",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/273cac/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/00.%E5%BC%95%E7%90%86%E5%92%8C%E5%BD%92%E7%BA%B3.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/00.å¼çåå½çº³.md",key:"v-5546a966",path:"/pages/273cac/",headers:[{level:2,title:"å¼è¨",slug:"å¼è¨",normalizedTitle:"å¼è¨",charIndex:12},{level:2,title:"é¶æç´¢",slug:"é¶æç´¢",normalizedTitle:"é¶æç´¢",charIndex:340},{level:2,title:"å¼ç",slug:"å¼ç",normalizedTitle:"å¼ç",charIndex:2},{level:2,title:"è®¡æ°",slug:"è®¡æ°",normalizedTitle:"è®¡æ°",charIndex:6679},{level:2,title:"è¯æåéæ§è´¨",slug:"è¯æåéæ§è´¨",normalizedTitle:"è¯æåéæ§è´¨",charIndex:8547},{level:2,title:"å½çº³",slug:"å½çº³",normalizedTitle:"å½çº³",charIndex:5},{level:2,title:"æåå¾çè·¯å¾",slug:"æåå¾çè·¯å¾",normalizedTitle:"æåå¾çè·¯å¾",charIndex:12097}],headersStr:"å¼è¨ é¶æç´¢ å¼ç è®¡æ° è¯æåéæ§è´¨ å½çº³ æåå¾çè·¯å¾",content:"# å¼çåå½çº³\n\n\n# å¼è¨\n\nææ¶éè¦ä¸äºé»è¾æ­¥éª¤æ¥è¯æä¸ä¸ªç¨åºæ¯æ­£ç¡®çï¼ä½æ¯å¯¹äºDafnyæ¥è¯´ï¼è¿äºæ­¥éª¤å¤ªå¤æäºãå½è¿ç§æåµåçæ¶ï¼æä»¬éå¸¸å¯ä»¥éè¿æä¾å¼çæ¥å¸®å©Dafnyè¯æç¨åºã\n\nå¼çæ¯ç¨æ¥è¯æå¦ä¸ä¸ªç»æçå®çï¼èä¸æ¯ç¨æ¥è¯ææ¬èº«ãä»ä»¬åè®¸Dafnyå°è¯æåæä¸¤é¨å:è¯æå¼çï¼ç¶åç¨å¼çæ¥è¯ææç»ç»æ;æåçç»æå°±æ¯ç¨åºæ­£ç¡®æ§çè¯æãéè¿è¿æ ·åå²å®ï¼ä½ å¯ä»¥é²æ­¢Dafnyè¯å¾è¯æè¿è¶å®è¯æè½åçç¨åºãæ»çæ¥è¯´ï¼Dafnyåè®¡ç®æºå¨å¤çä¸å å·ä½ç»èæåµæ¹é¢é½åå¾å¾å¥½ï¼ä½å®ç¼ºä¹çå°è½ä½¿è¯æè¿ç¨åå¾æ´å®¹æçä¸­é´æ­¥éª¤çè½åã\n\néè¿ä½¿ç¨å¼çï¼ä½ å¯ä»¥æ¾åºè¿äºä¸­é´æ­¥éª¤æ¯ä»ä¹ï¼ä»¥åä»ä¹æ¶åå¨ç¨åºä½¿ç¨å®ä»¬ãå¯¹äºæå³å½çº³è®ºè¯çé®é¢æ¥è¯´ï¼lemmaæ çæ¯å¯¹çä¸è¯çä¸åè¯æ¹ã\n\n\n# é¶æç´¢\n\næä»¬é¦æ¬¡æ¥è§¦å¼çï¼åæ¥å­¦ä¹ ä¸ä¸ªç®åçä¾å­:å¨æ°ç»ä¸­æç´¢é¶ãè¿ä¸ªé®é¢æè¶£å¨äºæä»¬æ­£å¨æç´¢çè¿ä¸ªæ°ç»æä¸¤ä¸ªç¹æ®çå±æ§: ææåç´ é½æ¯éè´çã æ¯ä¸ªè¿ç»­åç´ æå¤æ¯åä¸ä¸ªåç´ å°ä¸ã å¨ä»£ç :\n\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n{\n}\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næè¿æ ·çä¸å è¦æ±æ¡ä»¶ï¼æä»¬å¯ä»¥ç¨ä¸äºèªæçæ¹æ³:æä»¬å¯ä»¥è·³è¿åç´ ãåè®¾æä»¬æ­£å¨éåæ°ç»ï¼çå°a[j] == 7ãç¶åæä»¬ç¥é6 <= a[j+1]ï¼5 <= a[j+2]ï¼ç­ç­ãäºå®ä¸ï¼ä¸ä¸ä¸ª0è¦ç­å°æ°ç»ä¸­7ä¸ªåç´ å¨é¨èµ°ä¸éæ¶æä¼åºç°ãæä»¥æä»¬çè³ä¸éè¦å»æå¯»æ¾0åªç¨ä¸ç´a[j+a[j]]å°±è¡äºãæä»¥æä»¬å¯ä»¥è¿æ ·åä¸ä¸ªå¾ªç¯:\n\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿æ®µä»£ç å°è®¡ç®å¾å°æ­£ç¡®çç»æï¼ä½æ¯Dafnyå¨ç¬¬äºä¸ªå¾ªç¯ä¸åéæ¥éãDafnyå¹¶ä¸è®¤ä¸ºè·³è¿ææè¿äºåç´ æ¯åççãåå æ¯ï¼åç½®æ¡ä»¶è¯´çæ¯ï¼æ¯ä¸ªè¿ç»­çåç´ æå¤åä¸ï¼ä½å®æ²¡æè¯´é´éæ´è¿çåç´ æ¯å¦ä½å³èçãä¸ºäºè®©Dafnyç¸ä¿¡è¿äºå®ï¼æä»¬éè¦ä½¿ç¨å¼çã\n\n\n# å¼ç\n\nå¼çå¶å®å°±æ¯ä¸ªghostæ¹æ³ãå¼ç(æ´åç¡®å°è¯´ï¼å¼ççç»è®º)æè¦æ±çæ§è´¨è¢«å£°æä¸ºåç½®æ¡ä»¶ï¼å°±åå¨æ®éæ¹æ³å£°æçä¸æ ·ãä¸æ¹æ³ä¸åï¼å¼çæ°¸è¿ä¸ä¼è¢«æ¹åç¶æãå ä¸ºå¼çæ¯ghostæ¹æ³ï¼æä»¥ä¸éè¦å¨è¿è¡æ¶è°ç¨å®ï¼æä»¥ç¼è¯å¨å¨çæå¯æ§è¡ä»£ç ä¹åä¼å é¤ãæ è§å®ãå æ­¤ï¼å¼ççå­å¨ä»ä»æ¯å ä¸ºå®å¯¹ç¨åºéªè¯æä¸å®ä½ç¨ãä¸ä¸ªå¸åçå¼çé¿è¿æ ·ç:\n\nlemma Lemma(...)\n   ensures (desirable property)\n{\n   ...\n}\t\t\t\t\n\n\n1\n2\n3\n4\n5\n\n\nå¯¹äºé¶æç´¢é®é¢ï¼çæ³çæ§è´¨æ¯å¨index + a[index]ä¹åï¼indexä¸­çåç´ é½ä¸è½ä¸ºé¶ãæç§FindZeroçrequiermentsï¼æä»¬å°æ°ç»åèµ·å§ç´¢å¼ä½ä¸ºåæ°:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   //...\n}\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nåç½®æ¡ä»¶å°±æ¯æä»¬æ³è¦çå±æ§ãiæé¢å¤éå¶æ¯å ä¸ºj + a[j]å¯è½è¶è¿äºæ°ç»çæ«å°¾ãæä»¬åªæ³è®¨è®ºè¿ä¸ªèå´åçä¸æ ä¹å°±æ¯æ°ç»ä¸­çä¸æ ãç¶åæä»¬åäºä¸ä¸ªå³é®çæ­¥éª¤:æ£æ¥æä»¬çå¼çæ¯å¦è¶³ä»¥è¯æå¾ªç¯ä¸åéãéè¿å¨å¡«åå¼çä½ä¹åè¿è¡æ£æ¥ï¼æä»¬ç¡®ä¿æä»¬è¯å¾è¯æçæ¯æ­£ç¡®çä¸è¥¿ãFindZeroæ¹æ³åæ:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   //...\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç°å¨ï¼Dafnyæ²¡ææ¥éFindZeroæ¹æ³ï¼å ä¸ºå¼ççåç½®æ¡ä»¶æ¾ç¤ºå¾ªç¯ä¸åå¼è¢«ä¿çäºãä½å®å¯¹å¼çæ¬èº«æ¥éï¼è¿å¹¶ä¸å¥æªï¼å ä¸ºä¸»ä½æ¯ç©ºçãä¸ºäºè®©Dafnyæ¥åå¼çï¼æä»¬å¿é¡»è¯æåç½®æ¡ä»¶ä¸ºçãå°±åæä»¬å¨Dafnyä¸­åçææäºæä¸æ ·:ç¼åä»£ç ã\n\næä»¬ä»æ°ç»çå³é®å±æ§å¼å§ï¼å ä¸ºé¶æç´¢é®é¢ä¸­çåç´ é½åªä¼ç¼æ¢ä¸éãæä»¬å¯ä»¥éè¿ä½¿ç¨æ­è¨æ¥è¯¢é®æäºå±æ§æ¯å¦å­å¨ãä¾å¦ï¼æä»¬å¯ä»¥çå°Dafnyç¥é:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length - 3\n   // Note: the above has been changed so that the array indices below are good.\n{\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n\n\n1\n2\n3\n4\n5\n\n\nå æ­¤ï¼æä»¬å¯ä»¥çå°ï¼Dafnyå¯ä»¥è·éä»»ä½åç¬çæ­¥éª¤ï¼çè³å¯ä»¥éå½å°é¾ãä½æ¯æä»¬éè¦çæ­¥æ°ä¸æ¯æå®ç:å®å¯è½åå³äºa[j]çå¼ãä½æ¯æä»¬å·²ç»æäºä¸ä¸ªç¨äºå¤çå¯åæ°éæ­¥éª¤çæé :whileå¾ªç¯!\n\næä»¬å¯ä»¥ç¨åæ ·çç»æè®©Dafnyææ­¥éª¤è¿å¨ä¸èµ·ãæä»¬æ³è¦ä»jè¿­ä»£å°j + a[j]ï¼åæ¶è·è¸ªä¸çãæä»¬è¿ä¼è·è¸ªå°æä»¬ç®åçå°çææåç´ é½ä¸ä¸ºé¶çäºå®:\n\nlemma SkippingLemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n   var i := j;\n   while i < j + a[j] && i < a.Length\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç¬¬ä¸ä¸ªä¸åå¼ç»åºå½ååç´ çè¾¹çï¼å¦ææä»¬è¿æ²¡æè·å°æ°ç»çæ«å°¾ãå¯¹äºè¶è¿jçæ¯ä¸ä¸ªç´¢å¼(å¶ä¸­æi-j)ï¼æ°ç»åç´ å¯ä»¥å°ä¸ï¼å æ­¤ä»a[j]ä¸­åå»è¿ä¸ªå¼ãè¿åªæ¯è¯´å½ååç´ ä¸è½ä¸ºé¶ï¼æä»¥å¦ææ²¡æç¬¬äºä¸ªä¸åéï¼Dafnyå°±ä¸è½ç¥éæ°ç»éæ²¡æé¶ãDafnyå¿è®°äºå¾ªç¯æ§è¡çææåå®¹ï¼é¤äºå¨ä¸åéä¸­ç»åºçåå®¹ï¼æä»¥æä»¬éè¦å»ºç«è¿æ ·ä¸ä¸ªäºå®ï¼å³å°ç®åä¸ºæ­¢ï¼ä»»ä½å°æ¹é½æ²¡æé¶ã å¾ªç¯ä½åªæ¯ä½¿è®¡æ°å¨å 1ãæ­£å¦æä»¬ä¹åçå°çï¼Dafnyè½å¤èªå·±è®¡ç®åºæ¯ä¸æ­¥ï¼æä»¥æä»¬ä¸éè¦åä»»ä½è¿ä¸æ­¥çæä½ãæä»¬åªéè¦ç»å®ä¸ä¸ªéè¦è¯æçç»æãææ¶ï¼åä¸ªæ­¥éª¤æ¬èº«å°±è¶³å¤å¤æå°å®ä»¬éè¦èªå·±çå­è¯æï¼éè¿ä½¿ç¨ä¸ç³»åæ­è¨è¯­å¥ææ´ä¸ªå¶ä»å¼çã\n\nå¨ä½¿ç¨æ°ç»æ¶ï¼è¿­ä»£æ¯è®¸å¤é®é¢çèªç¶è§£å³æ¹æ¡ãä½æ¯ï¼ææ¶ä¼ä½¿ç¨éå½æ¥å®ä¹å½æ°æå±æ§ãå¨è¿äºæåµä¸ï¼å¼çéå¸¸å·æç¸åçéå½ç»æãä¸ºäºçä¸ä¸ªä¾å­ï¼æä»¬å°èèè®¡æ°çé®é¢ã\n\n\n# è®¡æ°\n\næä»¬å°ä½¿ç¨countå½æ°å¨ä¸ä¸ªboolåºåä¸­è®¡ç®trueçæ°éï¼å¦ä¸æç¤º:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m()\n{\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n...\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä»£ç éå¸¸ç®åï¼ä½éè¦æ³¨æçä¸ç¹æ¯ï¼è¯¥å½æ°æ¯éå½å®ä¹çãåè¿æ ·çéå½å½æ°å¾å®¹æéè¦å¼çãæä»¬å¸æå¨éªè¯ä½¿ç¨æ­¤å½æ°çç¨åºæ¶è½å¤ä½¿ç¨countçä¸ä¸ªå±æ§:å®åºç¨äºå æ³ä¸ãæä»¬çæææ¯:\n\nforall a, b :: count(a + b) == count(a) + count(b)\n\n\n1\n\n\nè¿éï¼ç¬¬ä¸ä¸ªå å·(+)æ¯åºåæ¼æ¥ï¼ç¬¬äºä¸ªå å·æ¯æ´æ°ç¸å ãæ¾ç¶ï¼æä»¬å¯ä»¥å°ä»»æåºååè§£ä¸ºä¸¤ä¸ªåºåaåbï¼åå«è®¡ç®å®ä»¬ï¼å¹¶å°ç»æç¸å ãè¿æ¯äºå®ï¼ä½Dafnyæ æ³ç´æ¥è¯æãé®é¢æ¯å½æ°å¹¶æ²¡æä»¥è¿ç§æ¹å¼åå²åºåãè¯¥å½æ°åç¬¬ä¸ä¸ªåç´ ï¼è®¡ç®å¶è®¡æ°ï¼ç¶åå°å¶æ·»å å°åºåçå¶ä½é¨åãå¦æaå¾é¿ï¼é£ä¹å¨è¿ä¸ªå±å¼è¿ç¨å®éå°è¾¾count(b)ä¹åå¯è½éè¦ä¸æ®µæ¶é´ï¼å æ­¤Dafnyåªå°è¯å±å¼å ä¸ªéå½è°ç¨ã(ç¡®åå°è¯´ï¼æ¯ä¸¤ä¸ªãåè§Amin, Leino, and Rompfçè®ºæComputing with an SMT solver, TAP 2014ã)è¿æ¯ä¸ä¸ªéè¦å¼çæ¥è¯æçæ§è´¨çä¾å­ã\n\nå¨æä»¬çä¾å­ä¸­,æä»¬æä¸¤ä¸ªéæ©å¼ç:æä»¬ä¹å¯ä»¥åå¨ç§°éè¯,æèæä»¬å¯ä»¥ä½¿å¼çç¹å®åºåaåbãäºå®è¯æ,å½æä»¬æ³è¦åéå¾,æä»¬ä¸éè¦å®æ´çéç¨å±æ§ãæä»¬æå´è¶£çæ¯ï¼å¯¹äºç¨åºä¸­å·²ç¥çä¸¤ä¸ªç¹å®çaåb, count(a + b) == count(a) + count(b)ãå æ­¤ï¼å½æä»¬è°ç¨å¼çæ¥å¾å°è¿ä¸ªæ§è´¨æ¶ï¼æä»¬å¯ä»¥åè¯å®æä»¬æå´è¶£çæ¯åªä¸¤ä¸ªåºåãå¦ææä»¬å¨å¶ä»å°æ¹æä¸åçåºåï¼æä»¬å¯ä»¥ç¨ä¸åçåæ°è°ç¨æ¹æ³ï¼å°±åæ®éæ¹æ³ä¸æ ·ãäºå®è¯æï¼è¯æå®æ´çå¨ç§°æ§è´¨ï¼è½ç¶æ¯å¯è½çï¼ä½æ¯è¯æå·ä½çï¼å·ä½çæåµè¦å¤æå¾å¤ï¼æä»¥æä»¬åæ¥å¤çè¿ä¸ªæåµã\n\nå æ­¤å¼çåºè¯¥å°æå´è¶£çåºåä½ä¸ºåæ°ï¼åç½®æ¡ä»¶å¦ä¸:\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\n\n\n1\n2\n3\n4\n\n\n\n# è¯æåéæ§è´¨\n\nä¸ºäºååºå¼çï¼æä»¬å¿é¡»æ³åºä¸ä¸ªè¯æå®çæ¹æ³ãæ­£å¦æ¨å¯ä»¥å¨ä¸é¢éªè¯ç(æ²¡æåå³è¯­)ï¼å¼çè¿ä¸è½å·¥ä½ï¼å¦åå¼çå°æ¯ä¸å¿è¦çãä¸ºäºåå°è¿ä¸ç¹ï¼æä»¬æ³¨æå°Dafnyæ æ³é¦åè¯æè¿ä¸ç¹çåå æ¯countå½æ°ä»åºåçå¼å§å®ä¹ï¼èåéå¾åå¨åºåçä¸­é´æä½ãå æ­¤ï¼å¦ææä»¬è½æ¾å°ä¸ç§ä»åºåçåé¢å¼å§å·¥ä½çæ¹æ³ï¼é£ä¹Dafnyå°±å¯ä»¥ç´æ¥ä½¿ç¨å½æ°çå®ä¹ãè¿ä¸ªåºåçç¬¬ä¸ä¸ªåç´ æ¯ä»ä¹?å¨ä¸äºæåµä¸ï¼aåbæ¯ç©ºåºå(å¦ææçè¯)ãå æ­¤æä»¬çå¼çå¿é¡»èèå¤ç§æåµï¼å¼ççå±åç¹å¾ãæä»¬æ³¨æå°ï¼å¦æa ==[]ï¼é£ä¹a+ b == bï¼ä¸ç®¡bæ¯å¤å°ãå¼çå¤çæåµçæ¹å¼ä¸ä»£ç å¤çæåµçæ¹å¼ç¸å:ifè¯­å¥ãä¸é¢ä½¿ç¨æ­è¨ç»åºäºæéå±æ§çç®ç­è¯æã\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n      assert count(a) == 0;\n      assert count(a + b) == count(b);\n      assert count(a + b) == count(a) + count(b);\n   }\n   else\n   {\n      //...\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nif a == []\n{\n   assert a + b == b;\n   assert count(a) == 0;\n   assert count(a + b) == count(b);\n   assert count(a + b) == count(a) + count(b);\n}\nelse\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¨è¿ç§æåµä¸ï¼æä»¬å¯ä»¥éè¿æ·»å ä¸ä¸ªrequireså­å¥æ¥æ£éªå¼çãæä»¬åç°ä»£ç éªè¯ãè¿æå³çå¦æa ==[]ï¼åå¼çå°æ­£ç¡®å°è¯æåç½®æ¡ä»¶ãå¨è¿ç§æåµä¸ï¼åªéè¦ä¸é¢çç¬¬ä¸ä¸ªæ­è¨;Dafnyèªå·±å®æäºå©ä¸çæ­¥éª¤(è¯è¯å§!)ç°å¨æä»¬å¯ä»¥èèå¦ä¸ç§æåµï¼å½0 < |a|ã\n\næä»¬çç®æ æ¯å°count(a + b)ä¸count(a)åcount(b)èç³»èµ·æ¥ãå¦æaä¸æ¯ç©ºåºåï¼é£ä¹å½æä»¬æç§å®ä¹å±å¼count(a + b)æ¶ï¼æä»¬å¾å°:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert a + b == [a[0]] + (a[1..] + b);\n   assert count(a + b) == count([a[0]]) + count(a[1..] + b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nassert a + b == [a[0]] + (a[1..] + b);\nassert count(a + b) == count([a[0]]) + count(a[1..] + b);\n\n\n1\n2\n\n\næ³¨æï¼æä»¬å¾å°count([a[0]])åa[1..]ãå¦ææä»¬æ©å±count(a)ï¼è¿ä¸¤é¡¹ä¹ä¼åºç°ãå·ä½å°è¯´:\n\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert count(a) == count([a[0]]) + count(a[1..]);\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nassert count(a) == count([a[0]]) + count(a[1..]);\n\n\n1\n\n\næåï¼æä»¬å¯ä»¥å°count(a)çå®ä¹æ¿æ¢ä¸ºåç½®æ¡ä»¶ï¼ä»¥è·å¾:\n\nassert count(a + b) == count(a) + count(b); // postcondition\nassert count(a + b) == count([a[0]]) + count(a[1..]) + count(b);\n\n\n1\n2\n\n\nç°å¨è¿çèµ·æ¥å¾åæä»¬å±å¼count(a + b)åå¾å°çè¡¨è¾¾å¼ãå¯ä¸çåºå«æ¯count(a[1.. .) + count(a[1..]) + count(b)ãä½è¿æ­£æ¯æä»¬è¦è¯æçæ§è´¨!\n\n\n# å½çº³\n\næä»¬è¯å¾æåºçè®ºç¹æ¯å½çº³çãæä»¬å¯ä»¥è¯ææä»¬çç®æ ï¼åªè¦è¿ä¸ªé®é¢çä¸ä¸ªå°çæ¬æ¯æ­£ç¡®çãè¿æ­£æ¯å½çº³æ³çæ¦å¿µ:ç¨ä¸ä¸ªå°é®é¢æ¥è¯æä¸ä¸ªå¤§é®é¢ãä¸ºæ­¤ï¼æä»¬å¨ä»£ç ä¸­è°ç¨éå½å±æ§ãå®æ¯ä¸ä¸ªæ¹æ³ï¼æä»¥æä»¬å¯ä»¥å¨éè¦å®çæ¶åè°ç¨å®ã\n\nDafnyå°åå®éå½è°ç¨æ»¡è¶³è§èãè¿å°±æ¯å½çº³åè®¾ï¼ææå¼ççéå½è°ç¨é½æ¯ææçãè¿å³é®åå³äºDafnyä¹è¯æäºç»æ­¢ãè¿æå³çæç»ï¼å¼çä¸ä¼åè¿è¡éå½è°ç¨ãå¨æ¬ä¾ä¸­ï¼è¿æ¯ifè¯­å¥çç¬¬ä¸ä¸ªåæ¯ãå¦ææ²¡æéå½è°ç¨ï¼é£ä¹å¼çå¿é¡»ç´æ¥è¯æè¿ç§æåµãç¶åï¼å æ ä¸­çæ¯ä¸ªè°ç¨é½æ¯åççï¼åè®¾å¼çéç¨äºè¾å°çæåµãå¦æDafnyæ²¡æè¯æé¾ç»æ­¢ï¼é£ä¹é¾å¯ä»¥æ°¸è¿ç»§ç»­ï¼å¹¶ä¸å¯¹äºæ¯ä¸ªè°ç¨çåè®¾é½æ¯ä¸åççã\n\nå½çº³æ³éå¸¸æ¯å¯»æ¾ä¸ç§æ¹æ³ï¼ä¸æ­¥ä¸æ­¥å°å»ºç«ä½ çç®æ ãä»å¦ä¸ä¸ªè§åº¦æ¥çï¼å®è¯æäºä½ çç®æ æ¯ä¸ä¸ªæ´å°ççæ¬ãéè¿ä¸æ¬¡åè§£ä¸ä¸ªåç´ ï¼ç´å°ç¬¬ä¸ä¸ªåºåå®å¨æ¶å¤±ï¼è¯æäºåéå¼çãè¿ç§æåµè¢«è¯ææ¯ä¸ä¸ªåºæ¬æåµï¼ç¶åæ´ä¸ªé¾çè§£æè¢«éªè¯ã\n\næåçå³é®æ¯Dafnyä»æ¥ä¸ç¨èèæ´ä¸ªéè¯é¾ãéè¿æ£éªç»æ­¢ï¼å¾å°é¾æ¯æéçãç¶åå®è¦åçå°±æ¯æ£æ¥ä¸æ­¥ãå¦æä»»æä¸æ­¥æ¯ææçï¼é£ä¹æ´ä¸ªé¾ä¹æ¯ææçãè¿ä¸Dafnyå¨å¾ªç¯ä¸­ä½¿ç¨çé»è¾ç¸å:æ£æ¥åå§ä¸åé¡¹æ¯å¦æç«ï¼ä»»æä¸ä¸ªæ­¥éª¤æ¯å¦ä¿æä¸åï¼ç¶åæ£æ¥æ´ä¸ªå¾ªç¯ï¼ä¸ç®¡å¾ªç¯å¾ªç¯äºå¤å°æ¬¡ãè¿ç§ç¸ä¼¼æ§ä¸ä»ä»æ¯è¡¨é¢çãè¿ä¸¤ç§å¼ç(ä»¥åDafnyå¯¹ç¨åºçä¸¤ç§æ¨ç)é½æ¯å½çº³çãèèå°è¿­ä»£åéå½ä½ä¸ºå®ç°åä¸ç®æ çä¸¤ç§æ¹æ³ä¹é´çå³ç³»ï¼è¿ä¹ä¸è¶³ä¸ºå¥ã\n\nè®°ä½è¿ä¸ç¹ï¼æä»¬å¯ä»¥éè¿å¨ifè¯­å¥çelseåæ¯ä¸­éå½å°è°ç¨å¼çæ¥å®æå¼ç:\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      DistributiveLemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n  if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      DistributiveLemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nç°å¨è¿ä¸ªå¼çå¾å°äºéªè¯ãä½æ¯å¦ææä»¬æ³è¦è¡¨è¾¾æ¯ä¸å¯¹åºåé½æ¯è¿æ ·èç³»çå¢?ä¸ºäºåå°è¿ä¸ç¹ï¼æä»¬å¿é¡»ççå¼çå¨Dafnyä¸­çå¦ä¸ç§ç¨æ³ï¼æä»¬å°ç¨å¦ä¸ä¸ªä¾å­æ¥æ¢ç´¢ã\n\n\n# æåå¾çè·¯å¾\n\nä½ä¸ºæåä¸ä¸ªæ´é«çº§çä¾å­ï¼æä»¬å°è¯æä¸ä¸ªå³äºæåå¾ä¸­è·¯å¾çæ§è´¨ãä¸ºæ­¤ï¼æä»¬ææºä¼ç§°ä¸ä¸ªå¼çå¨ææèç¹åºåä¸æ¯æ®éçãä¸ä¸ªæåå¾ç±è¥å¹²ä¸ªèç¹ç»æï¼æ¯ä¸ªèç¹é½æä¸äºå°å¶ä»èç¹çé¾æ¥ãè¿äºé¾æ¥æ¯ååçï¼å¯¹å®ä»¬çå¯ä¸éå¶æ¯èç¹ä¸è½é¾æ¥å°èªå·±ãèç¹å®ä¹ä¸º:\n\nclass Node\n{\n   // a single field giving the nodes linked to\n   var next: seq<Node>\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬å°å¾è¡¨ç¤ºä¸ºä¸ç»èç¹ï¼è¿äºèç¹åªæåå¾ä¸­çå¶ä»èç¹ï¼èä¸æåèªå·±ãæä»¬ç§°è¿æ ·ä¸ç»èç¹ä¸ºå°é­ç:\n\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==>\n      forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næä»¬å°è·¯å¾è¡¨ç¤ºä¸ºéç©ºèç¹åºåï¼å¶ä¸­æ¯ä¸ªèç¹é½ä¸è·¯å¾ä¸­çåä¸ä¸ªèç¹ç¸è¿ãæä»¬å®ä¹äºä¸¤ä¸ªè°è¯ï¼ä¸ä¸ªç¨äºå®ä¹ææè·¯å¾ï¼å¦ä¸ä¸ªç¨äºç¡®å®ç»å®è·¯å¾æ¯å¦ä¸ºå¾ä¸­ä¸¤ä¸ªç¹å®èç¹ä¹é´çææè·¯å¾:\n\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nç°å¨æä»¬åå¤å¥½éè¿°æä»¬è¦è¯æçå¼çäºãæä»¬èèä¸ä¸ªå¾åä¸ä¸ªå­å¾:ä¸ä¸ªä¹ææä¸ä¸ªå¾çèç¹çå­éãè¿ä¸ªå­å¾å¿é¡»æ¯å°é­çï¼å³ä¸åå«èªèº«ä¹å¤çé¾æ¥ãå¦ææä»¬æè¿æ ·çæåµï¼é£ä¹ä»å­å¾ä¸­çä¸ä¸ªèç¹å°å­å¾ä¹å¤çä¸ä¸ªèç¹ä¸å¯è½æä¸æ¡ææçè·¯å¾ãæä»¬å°è¿ä¸ªäºå®ç§°ä¸ºé­åå¼çï¼æä»¬å¨Dafnyä¸­è¿æ ·è¡¨è¿°:\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   //...\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nåææ¡ä»¶è¯´æäºææçè¦æ±:å¾åå­å¾é½æ¯ææçï¼æ ¹èç¹å¨å­å¾ä¸­ä½ç®æ ä¸å¨ï¼ææåå®¹é½åå«å¨ä¸»å¾ä¸­ãåç½®æ¡ä»¶å£°ææ²¡æä»æ ¹å°ç®æ çææè·¯å¾ãè¿éæä»¬åªå¯¹ç¹å®çå¼å§/ç»æèç¹å¯¹è¯æå®ã\n\nè¯ææç©ä¸å­å¨çä¸ç§æ¹æ³æ¯è¯æç»å®çä»»æèç¹åºåå®ä¸æ¯ä¸ä¸ªææè·¯å¾ãæä»¬å¯ä»¥ç¨ï¼ä½ çå¯¹äºï¼å¦ä¸ä¸ªå¼çãè¿ä¸ªå¼çå°è¯æï¼å¯¹äºä»»ä½ç»å®çåºåï¼å®ä¸æ¯ä»æ ¹rootå°ç®æ goalçææè·¯å¾ãè·¯å¾å¼ççåè¯å¦ä¸:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nåæä¸é­å¼çç¸åãè¦å¨é­å¼çClosedLemmaä¸­ä½¿ç¨åè¯æå¼çDisproofLemmaï¼æä»¬éè¦å¯¹æ¯ä¸ªèç¹åºåè°ç¨å®ä¸æ¬¡ãè¿å¯ä»¥éè¿Dafnyçforallè¯­å¥æ¥å®æï¼è¯¥è¯­å¥èåäºç»å®ç»å®åéçææå¼å¯¹å¶ä¸»ä½çå½±åã\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph =\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   ...\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¦ä½ æè§ï¼è¿ä½¿å¾é­å¼çClosedLemmaå¾å°éªè¯ï¼æä»¥æä»¬å¯¹å¼ççæµè¯æ¯æåçãå æ­¤ï¼åè¯æå¼çDisproofLemmaæ¯è¶³å¤å¼ºçï¼æä»¬çå·¥ä½ä»ä»æ¯è¯æå®ã\n\næå ç§ä¸åçæ¹å¼å¯ä»¥ä½¿èç¹åºåæä¸ºæ æè·¯å¾ãå¦æè·¯å¾ä¸ºç©ºï¼åå®ä¸è½æ¯ææè·¯å¾ãæ­¤å¤ï¼è·¯å¾çç¬¬ä¸ä¸ªåç´ å¿é¡»æ¯æ ¹rootï¼æåä¸ä¸ªåç´ å¿é¡»æ¯ç®æ goalãå ä¸ºroot in subgraphï¼goal !in subgraphï¼æä»¬å¿é¡»æroot != goalï¼æä»¥åºåå¿é¡»è³å°æä¸¤ä¸ªåç´ ãä¸ºäºéªè¯Dafnyæ¯å¦çå°äºè¿ä¸ç¹ï¼æä»¬å¯ä»¥ä¸´æ¶å¨å¼çä¸å ä¸åå³æ¡ä»¶ï¼å¦ä¸æç¤º:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ensures !pathSpecific(p, root, goal, graph)\n{\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires ...  // as before\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ...\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næ³¨æï¼è¿å°å¯¼è´é­å¼çClosedLemmaåæ­¢éªè¯ï¼å ä¸ºå¼çç°å¨åªå¯¹ä¸äºåºåææãæä»¬å°å¿½ç¥é­åå¼çClosedLemmaï¼ç´å°æä»¬å®æåé©³å¼çDisproofLemmaãè¿å°±è¯æäºï¼è¿æå³çDafnyè½å¤å¨è¿äºæåµä¸è¯æåç½®æ¡ä»¶ãå æ­¤ï¼æä»¬åªéè¦è¯æå½è¿äºæ¡ä»¶ä¸æç«æ¶ï¼è·¯å¾æ¯æ æçãæä»¬å¯ä»¥ç¨ifè¯­å¥æ¥è¡¨è¾¾:\n\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      (further proof)\n   }\n\n\n1\n2\n3\n\n\nå¦æè·¯å¾è³å°æä¸¤ä¸ªåç´ é¿ï¼ç¬¬ä¸ä¸ªåç´ æ¯æ ¹rootåç´ ï¼æåä¸ä¸ªåç´ æ¯ç®æ goalåç´ ï¼é£ä¹æä»¬å°±æäºè¿ä¸æ­¥çè¯æãå¦æè¿äºæ¡ä»¶æ²¡ææ»¡è¶³(ä¹å°±æ¯è¯´ï¼å¦æifè¯­å¥çä¿æ¤ä¸ºfalseï¼å¹¶ä¸æ§å¶å¨éå¼elseåæ¯ä¸­ç»§ç»­)ï¼Dafnyå°èªå·±è¯æåç½®æ¡ä»¶(é«çº§å¤æ³¨:ä½ å¯ä»¥éè¿ä¸´æ¶æ·»å è¯­å¥assume falseæ¥æ£æ¥è¿ä¸ç¹;å¨ifçthenåæ¯ä¸­)ãç°å¨æä»¬åªéè¦å¡«å¥è¿ä¸æ­¥çè¯æé¨åãå¨è¿æ ·åæ¶ï¼æä»¬å¯ä»¥åå®ifè¯­å¥çä¿æ¤æ¡ä»¶ãæä»¬ç°å¨å¯ä»¥ä½¿ç¨åä¸é¢ä¸æ ·çå½çº³æå·§ã\n\nå¦æåºåä»æ ¹rootèç¹å¼å§ï¼å¹¶å¨ç®æ èç¹goalç»æï¼åå®ä¸è½ææï¼å ä¸ºåºåå¿é¡»å¨æä¸ªç¹ä¸æä¸ä¸ªä¸å¨åä¸ä¸ªèç¹ä¸ä¸ä¸ªåè¡¨ä¸­çèç¹ãå½æä»¬å¾å°ä»»ä½åè¿æ ·çç¹å®åºåæ¶ï¼æä»¬å¯ä»¥å°å®åä¸ºä¸¤ç§æåµ:è¦ä¹åºåå¨ä»ç¬¬ä¸ä¸ªèç¹å°ç¬¬äºä¸ªèç¹çé¾æ¥ä¸­æ æï¼è¦ä¹å®å¨ä¸è¡ä¸­çæä¸ªå°æ¹è¢«ææ­äºãå°±åå¨è®¡æ°ç¤ºä¾ä¸­ä¸æ ·ï¼Dafnyå¯ä»¥çå°ï¼å¦æç¬¬ä¸ä¸ªå°ç¬¬äºä¸ªèç¹é¾æ¥æ æï¼é£ä¹åºåå°±ä¸è½æ¯è·¯å¾ï¼å ä¸ºè¿åæ äºè·¯å¾pathçå®ä¹ãå æ­¤ï¼åªæå½ç¬¬ä¸ä¸ªé¾æ¥æææ¶ï¼æä»¬ææè¿ä¸æ­¥çå·¥ä½è¦åãæä»¬å¯ä»¥ç¨å¦ä¸ä¸ªifè¯­å¥æ¥è¡¨è¾¾:\n\nif 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         (yet further proof)\n      }\n   }\n\n\n1\n2\n3\n4\n5\n\n\nè¿éæ¯å½çº³inductionãæä»¬ç¥ép[0] == root, p[1] in p[0].next.ä¸­ãæä»¬è¿ä»å­å¾çæ ¹root in subgraphçåå³æ¡ä»¶ç¥éãå æ­¤ï¼ç±äºé­å­å¾Â closed(subgraph)ï¼æä»¬ç¥ép[1] in subgraphÂ ãè¿äºæ¡ä»¶åæä»¬å¼å§æ¶æ¯ä¸æ ·ç!æä»¬ç°å¨é¢å¯¹çæ¯åä¸ä¸ªé®é¢çä¸ä¸ªå°çæ¬ãæä»¬å¯ä»¥éå½å°è°ç¨åè¯æå¼çDisproofLemmaæ¥è¯æp[1..ä¸æ¯ä¸æ¡è·¯ãè¿æå³çï¼æ ¹æ®è·¯å¾pathçå®ä¹ï¼pä¸è½æ¯è·¯å¾ï¼å¹¶ä¸æ»¡è¶³ç¬¬äºä¸ªåç½®æ¡ä»¶ãè¿å¯ä»¥å®ç°ä¸º:\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n   forall p {\n      DisproofLemma(p, subgraph, root, goal, graph);\n   }\n}\nclass Node\n{\n   var next: seq<Node>\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<Node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathSpecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nç°å¨é­å¼çDisproofLemmaè¢«éªè¯äºï¼éçæµè¯åæçç§»é¤ï¼æä»¬çå°é­å¼çClosedLemmaä¹è¢«éªè¯äºãç±æ­¤è¯æäºå°é­å­å¾ä¸å­å¨ä»åé¨å°å¤é¨çè·¯å¾ã\n\nå½ä¸ä¸ªå¼çéè¦æ éæ¬¡å®ä¾åæ¶ï¼forallè¯­å¥æ¯æç¨çãè¿ä¸ªä¾å­å±ç¤ºäºforallè¯­å¥çä¸ä¸ªç®åçæ¬ãè¦äºè§£æ´é«çº§ççæ¬ï¼è¯·åè§LeinoçãDafnyä¸­çè¯å¥½åºç¡å½æ°åæç«¯è°è¯:æç¨ãï¼iwill -2015ï¼æDafnyæµè¯å¥ä»¶ä¸­çç¤ºä¾ã\n\næ°¸è¿è®°å¾æ£æ¥ä½ çå¼çæ¯å¦è¶³ä»¥è¯æä½ éè¦çãæ²¡æä»ä¹æ¯è±æ¶é´åå¼çéªè¯ï¼ç»æåç°ä½ éè¦æ´å¼ºå¤§çä¸è¥¿æ´ä»¤äººæ²®ä¸§çäºãè¿ä¹å¯ä»¥è®©ä½ é¿ååå»ºä¸ä¸ªå¸¦æåç½®æ¡ä»¶çå¼çï¼å ä¸ºåç½®æ¡ä»¶çéå¶å¤ªå¤§ï¼ä»¥è³äºä½ ä¸è½å¨éè¦çå°æ¹è°ç¨å®ã",normalizedContent:"# å¼çåå½çº³\n\n\n# å¼è¨\n\nææ¶éè¦ä¸äºé»è¾æ­¥éª¤æ¥è¯æä¸ä¸ªç¨åºæ¯æ­£ç¡®çï¼ä½æ¯å¯¹äºdafnyæ¥è¯´ï¼è¿äºæ­¥éª¤å¤ªå¤æäºãå½è¿ç§æåµåçæ¶ï¼æä»¬éå¸¸å¯ä»¥éè¿æä¾å¼çæ¥å¸®å©dafnyè¯æç¨åºã\n\nå¼çæ¯ç¨æ¥è¯æå¦ä¸ä¸ªç»æçå®çï¼èä¸æ¯ç¨æ¥è¯ææ¬èº«ãä»ä»¬åè®¸dafnyå°è¯æåæä¸¤é¨å:è¯æå¼çï¼ç¶åç¨å¼çæ¥è¯ææç»ç»æ;æåçç»æå°±æ¯ç¨åºæ­£ç¡®æ§çè¯æãéè¿è¿æ ·åå²å®ï¼ä½ å¯ä»¥é²æ­¢dafnyè¯å¾è¯æè¿è¶å®è¯æè½åçç¨åºãæ»çæ¥è¯´ï¼dafnyåè®¡ç®æºå¨å¤çä¸å å·ä½ç»èæåµæ¹é¢é½åå¾å¾å¥½ï¼ä½å®ç¼ºä¹çå°è½ä½¿è¯æè¿ç¨åå¾æ´å®¹æçä¸­é´æ­¥éª¤çè½åã\n\néè¿ä½¿ç¨å¼çï¼ä½ å¯ä»¥æ¾åºè¿äºä¸­é´æ­¥éª¤æ¯ä»ä¹ï¼ä»¥åä»ä¹æ¶åå¨ç¨åºä½¿ç¨å®ä»¬ãå¯¹äºæå³å½çº³è®ºè¯çé®é¢æ¥è¯´ï¼lemmaæ çæ¯å¯¹çä¸è¯çä¸åè¯æ¹ã\n\n\n# é¶æç´¢\n\næä»¬é¦æ¬¡æ¥è§¦å¼çï¼åæ¥å­¦ä¹ ä¸ä¸ªç®åçä¾å­:å¨æ°ç»ä¸­æç´¢é¶ãè¿ä¸ªé®é¢æè¶£å¨äºæä»¬æ­£å¨æç´¢çè¿ä¸ªæ°ç»æä¸¤ä¸ªç¹æ®çå±æ§: ææåç´ é½æ¯éè´çã æ¯ä¸ªè¿ç»­åç´ æå¤æ¯åä¸ä¸ªåç´ å°ä¸ã å¨ä»£ç :\n\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n{\n}\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næè¿æ ·çä¸å è¦æ±æ¡ä»¶ï¼æä»¬å¯ä»¥ç¨ä¸äºèªæçæ¹æ³:æä»¬å¯ä»¥è·³è¿åç´ ãåè®¾æä»¬æ­£å¨éåæ°ç»ï¼çå°a[j] == 7ãç¶åæä»¬ç¥é6 <= a[j+1]ï¼5 <= a[j+2]ï¼ç­ç­ãäºå®ä¸ï¼ä¸ä¸ä¸ª0è¦ç­å°æ°ç»ä¸­7ä¸ªåç´ å¨é¨èµ°ä¸éæ¶æä¼åºç°ãæä»¥æä»¬çè³ä¸éè¦å»æå¯»æ¾0åªç¨ä¸ç´a[j+a[j]]å°±è¡äºãæä»¥æä»¬å¯ä»¥è¿æ ·åä¸ä¸ªå¾ªç¯:\n\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿æ®µä»£ç å°è®¡ç®å¾å°æ­£ç¡®çç»æï¼ä½æ¯dafnyå¨ç¬¬äºä¸ªå¾ªç¯ä¸åéæ¥éãdafnyå¹¶ä¸è®¤ä¸ºè·³è¿ææè¿äºåç´ æ¯åççãåå æ¯ï¼åç½®æ¡ä»¶è¯´çæ¯ï¼æ¯ä¸ªè¿ç»­çåç´ æå¤åä¸ï¼ä½å®æ²¡æè¯´é´éæ´è¿çåç´ æ¯å¦ä½å³èçãä¸ºäºè®©dafnyç¸ä¿¡è¿äºå®ï¼æä»¬éè¦ä½¿ç¨å¼çã\n\n\n# å¼ç\n\nå¼çå¶å®å°±æ¯ä¸ªghostæ¹æ³ãå¼ç(æ´åç¡®å°è¯´ï¼å¼ççç»è®º)æè¦æ±çæ§è´¨è¢«å£°æä¸ºåç½®æ¡ä»¶ï¼å°±åå¨æ®éæ¹æ³å£°æçä¸æ ·ãä¸æ¹æ³ä¸åï¼å¼çæ°¸è¿ä¸ä¼è¢«æ¹åç¶æãå ä¸ºå¼çæ¯ghostæ¹æ³ï¼æä»¥ä¸éè¦å¨è¿è¡æ¶è°ç¨å®ï¼æä»¥ç¼è¯å¨å¨çæå¯æ§è¡ä»£ç ä¹åä¼å é¤ãæ è§å®ãå æ­¤ï¼å¼ççå­å¨ä»ä»æ¯å ä¸ºå®å¯¹ç¨åºéªè¯æä¸å®ä½ç¨ãä¸ä¸ªå¸åçå¼çé¿è¿æ ·ç:\n\nlemma lemma(...)\n   ensures (desirable property)\n{\n   ...\n}\t\t\t\t\n\n\n1\n2\n3\n4\n5\n\n\nå¯¹äºé¶æç´¢é®é¢ï¼çæ³çæ§è´¨æ¯å¨index + a[index]ä¹åï¼indexä¸­çåç´ é½ä¸è½ä¸ºé¶ãæç§findzeroçrequiermentsï¼æä»¬å°æ°ç»åèµ·å§ç´¢å¼ä½ä¸ºåæ°:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   //...\n}\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nåç½®æ¡ä»¶å°±æ¯æä»¬æ³è¦çå±æ§ãiæé¢å¤éå¶æ¯å ä¸ºj + a[j]å¯è½è¶è¿äºæ°ç»çæ«å°¾ãæä»¬åªæ³è®¨è®ºè¿ä¸ªèå´åçä¸æ ä¹å°±æ¯æ°ç»ä¸­çä¸æ ãç¶åæä»¬åäºä¸ä¸ªå³é®çæ­¥éª¤:æ£æ¥æä»¬çå¼çæ¯å¦è¶³ä»¥è¯æå¾ªç¯ä¸åéãéè¿å¨å¡«åå¼çä½ä¹åè¿è¡æ£æ¥ï¼æä»¬ç¡®ä¿æä»¬è¯å¾è¯æçæ¯æ­£ç¡®çä¸è¥¿ãfindzeroæ¹æ³åæ:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall i :: j <= i < j + a[j] && i < a.length ==> a[i] != 0\n{\n   //...\n}\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç°å¨ï¼dafnyæ²¡ææ¥éfindzeroæ¹æ³ï¼å ä¸ºå¼ççåç½®æ¡ä»¶æ¾ç¤ºå¾ªç¯ä¸åå¼è¢«ä¿çäºãä½å®å¯¹å¼çæ¬èº«æ¥éï¼è¿å¹¶ä¸å¥æªï¼å ä¸ºä¸»ä½æ¯ç©ºçãä¸ºäºè®©dafnyæ¥åå¼çï¼æä»¬å¿é¡»è¯æåç½®æ¡ä»¶ä¸ºçãå°±åæä»¬å¨dafnyä¸­åçææäºæä¸æ ·:ç¼åä»£ç ã\n\næä»¬ä»æ°ç»çå³é®å±æ§å¼å§ï¼å ä¸ºé¶æç´¢é®é¢ä¸­çåç´ é½åªä¼ç¼æ¢ä¸éãæä»¬å¯ä»¥éè¿ä½¿ç¨æ­è¨æ¥è¯¢é®æäºå±æ§æ¯å¦å­å¨ãä¾å¦ï¼æä»¬å¯ä»¥çå°dafnyç¥é:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length - 3\n   // note: the above has been changed so that the array indices below are good.\n{\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n   assert a[j  ] - 1 <= a[j+1];\n   assert a[j+1] - 1 <= a[j+2];\n   assert a[j+2] - 1 <= a[j+3];\n   // therefore:\n   assert a[j  ] - 3 <= a[j+3];\n\n\n1\n2\n3\n4\n5\n\n\nå æ­¤ï¼æä»¬å¯ä»¥çå°ï¼dafnyå¯ä»¥è·éä»»ä½åç¬çæ­¥éª¤ï¼çè³å¯ä»¥éå½å°é¾ãä½æ¯æä»¬éè¦çæ­¥æ°ä¸æ¯æå®ç:å®å¯è½åå³äºa[j]çå¼ãä½æ¯æä»¬å·²ç»æäºä¸ä¸ªç¨äºå¤çå¯åæ°éæ­¥éª¤çæé :whileå¾ªç¯!\n\næä»¬å¯ä»¥ç¨åæ ·çç»æè®©dafnyææ­¥éª¤è¿å¨ä¸èµ·ãæä»¬æ³è¦ä»jè¿­ä»£å°j + a[j]ï¼åæ¶è·è¸ªä¸çãæä»¬è¿ä¼è·è¸ªå°æä»¬ç®åçå°çææåç´ é½ä¸ä¸ºé¶çäºå®:\n\nlemma skippinglemma(a: array<int>, j: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.length\n   ensures forall k :: j <= k < j + a[j] && k < a.length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.length\n      invariant i < a.length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod findzero(a: array<int>) returns (index: int)\n   requires forall i :: 0 <= i < a.length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.length && a[index] == 0\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      skippinglemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n   var i := j;\n   while i < j + a[j] && i < a.length\n      invariant i < a.length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç¬¬ä¸ä¸ªä¸åå¼ç»åºå½ååç´ çè¾¹çï¼å¦ææä»¬è¿æ²¡æè·å°æ°ç»çæ«å°¾ãå¯¹äºè¶è¿jçæ¯ä¸ä¸ªç´¢å¼(å¶ä¸­æi-j)ï¼æ°ç»åç´ å¯ä»¥å°ä¸ï¼å æ­¤ä»a[j]ä¸­åå»è¿ä¸ªå¼ãè¿åªæ¯è¯´å½ååç´ ä¸è½ä¸ºé¶ï¼æä»¥å¦ææ²¡æç¬¬äºä¸ªä¸åéï¼dafnyå°±ä¸è½ç¥éæ°ç»éæ²¡æé¶ãdafnyå¿è®°äºå¾ªç¯æ§è¡çææåå®¹ï¼é¤äºå¨ä¸åéä¸­ç»åºçåå®¹ï¼æä»¥æä»¬éè¦å»ºç«è¿æ ·ä¸ä¸ªäºå®ï¼å³å°ç®åä¸ºæ­¢ï¼ä»»ä½å°æ¹é½æ²¡æé¶ã å¾ªç¯ä½åªæ¯ä½¿è®¡æ°å¨å 1ãæ­£å¦æä»¬ä¹åçå°çï¼dafnyè½å¤èªå·±è®¡ç®åºæ¯ä¸æ­¥ï¼æä»¥æä»¬ä¸éè¦åä»»ä½è¿ä¸æ­¥çæä½ãæä»¬åªéè¦ç»å®ä¸ä¸ªéè¦è¯æçç»æãææ¶ï¼åä¸ªæ­¥éª¤æ¬èº«å°±è¶³å¤å¤æå°å®ä»¬éè¦èªå·±çå­è¯æï¼éè¿ä½¿ç¨ä¸ç³»åæ­è¨è¯­å¥ææ´ä¸ªå¶ä»å¼çã\n\nå¨ä½¿ç¨æ°ç»æ¶ï¼è¿­ä»£æ¯è®¸å¤é®é¢çèªç¶è§£å³æ¹æ¡ãä½æ¯ï¼ææ¶ä¼ä½¿ç¨éå½æ¥å®ä¹å½æ°æå±æ§ãå¨è¿äºæåµä¸ï¼å¼çéå¸¸å·æç¸åçéå½ç»æãä¸ºäºçä¸ä¸ªä¾å­ï¼æä»¬å°èèè®¡æ°çé®é¢ã\n\n\n# è®¡æ°\n\næä»¬å°ä½¿ç¨countå½æ°å¨ä¸ä¸ªboolåºåä¸­è®¡ç®trueçæ°éï¼å¦ä¸æç¤º:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m()\n{\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n...\n   assert count([]) == 0;\n   assert count([true]) == 1;\n   assert count([false]) == 0;\n   assert count([true, true]) == 2;\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä»£ç éå¸¸ç®åï¼ä½éè¦æ³¨æçä¸ç¹æ¯ï¼è¯¥å½æ°æ¯éå½å®ä¹çãåè¿æ ·çéå½å½æ°å¾å®¹æéè¦å¼çãæä»¬å¸æå¨éªè¯ä½¿ç¨æ­¤å½æ°çç¨åºæ¶è½å¤ä½¿ç¨countçä¸ä¸ªå±æ§:å®åºç¨äºå æ³ä¸ãæä»¬çæææ¯:\n\nforall a, b :: count(a + b) == count(a) + count(b)\n\n\n1\n\n\nè¿éï¼ç¬¬ä¸ä¸ªå å·(+)æ¯åºåæ¼æ¥ï¼ç¬¬äºä¸ªå å·æ¯æ´æ°ç¸å ãæ¾ç¶ï¼æä»¬å¯ä»¥å°ä»»æåºååè§£ä¸ºä¸¤ä¸ªåºåaåbï¼åå«è®¡ç®å®ä»¬ï¼å¹¶å°ç»æç¸å ãè¿æ¯äºå®ï¼ä½dafnyæ æ³ç´æ¥è¯æãé®é¢æ¯å½æ°å¹¶æ²¡æä»¥è¿ç§æ¹å¼åå²åºåãè¯¥å½æ°åç¬¬ä¸ä¸ªåç´ ï¼è®¡ç®å¶è®¡æ°ï¼ç¶åå°å¶æ·»å å°åºåçå¶ä½é¨åãå¦æaå¾é¿ï¼é£ä¹å¨è¿ä¸ªå±å¼è¿ç¨å®éå°è¾¾count(b)ä¹åå¯è½éè¦ä¸æ®µæ¶é´ï¼å æ­¤dafnyåªå°è¯å±å¼å ä¸ªéå½è°ç¨ã(ç¡®åå°è¯´ï¼æ¯ä¸¤ä¸ªãåè§amin, leino, and rompfçè®ºæcomputing with an smt solver, tap 2014ã)è¿æ¯ä¸ä¸ªéè¦å¼çæ¥è¯æçæ§è´¨çä¾å­ã\n\nå¨æä»¬çä¾å­ä¸­,æä»¬æä¸¤ä¸ªéæ©å¼ç:æä»¬ä¹å¯ä»¥åå¨ç§°éè¯,æèæä»¬å¯ä»¥ä½¿å¼çç¹å®åºåaåbãäºå®è¯æ,å½æä»¬æ³è¦åéå¾,æä»¬ä¸éè¦å®æ´çéç¨å±æ§ãæä»¬æå´è¶£çæ¯ï¼å¯¹äºç¨åºä¸­å·²ç¥çä¸¤ä¸ªç¹å®çaåb, count(a + b) == count(a) + count(b)ãå æ­¤ï¼å½æä»¬è°ç¨å¼çæ¥å¾å°è¿ä¸ªæ§è´¨æ¶ï¼æä»¬å¯ä»¥åè¯å®æä»¬æå´è¶£çæ¯åªä¸¤ä¸ªåºåãå¦ææä»¬å¨å¶ä»å°æ¹æä¸åçåºåï¼æä»¬å¯ä»¥ç¨ä¸åçåæ°è°ç¨æ¹æ³ï¼å°±åæ®éæ¹æ³ä¸æ ·ãäºå®è¯æï¼è¯æå®æ´çå¨ç§°æ§è´¨ï¼è½ç¶æ¯å¯è½çï¼ä½æ¯è¯æå·ä½çï¼å·ä½çæåµè¦å¤æå¾å¤ï¼æä»¥æä»¬åæ¥å¤çè¿ä¸ªæåµã\n\nå æ­¤å¼çåºè¯¥å°æå´è¶£çåºåä½ä¸ºåæ°ï¼åç½®æ¡ä»¶å¦ä¸:\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n}\n\n\n1\n2\n3\n4\n\n\n\n# è¯æåéæ§è´¨\n\nä¸ºäºååºå¼çï¼æä»¬å¿é¡»æ³åºä¸ä¸ªè¯æå®çæ¹æ³ãæ­£å¦æ¨å¯ä»¥å¨ä¸é¢éªè¯ç(æ²¡æåå³è¯­)ï¼å¼çè¿ä¸è½å·¥ä½ï¼å¦åå¼çå°æ¯ä¸å¿è¦çãä¸ºäºåå°è¿ä¸ç¹ï¼æä»¬æ³¨æå°dafnyæ æ³é¦åè¯æè¿ä¸ç¹çåå æ¯countå½æ°ä»åºåçå¼å§å®ä¹ï¼èåéå¾åå¨åºåçä¸­é´æä½ãå æ­¤ï¼å¦ææä»¬è½æ¾å°ä¸ç§ä»åºåçåé¢å¼å§å·¥ä½çæ¹æ³ï¼é£ä¹dafnyå°±å¯ä»¥ç´æ¥ä½¿ç¨å½æ°çå®ä¹ãè¿ä¸ªåºåçç¬¬ä¸ä¸ªåç´ æ¯ä»ä¹?å¨ä¸äºæåµä¸ï¼aåbæ¯ç©ºåºå(å¦ææçè¯)ãå æ­¤æä»¬çå¼çå¿é¡»èèå¤ç§æåµï¼å¼ççå±åç¹å¾ãæä»¬æ³¨æå°ï¼å¦æa ==[]ï¼é£ä¹a+ b == bï¼ä¸ç®¡bæ¯å¤å°ãå¼çå¤çæåµçæ¹å¼ä¸ä»£ç å¤çæåµçæ¹å¼ç¸å:ifè¯­å¥ãä¸é¢ä½¿ç¨æ­è¨ç»åºäºæéå±æ§çç®ç­è¯æã\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n      assert count(a) == 0;\n      assert count(a + b) == count(b);\n      assert count(a + b) == count(a) + count(b);\n   }\n   else\n   {\n      //...\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nif a == []\n{\n   assert a + b == b;\n   assert count(a) == 0;\n   assert count(a + b) == count(b);\n   assert count(a + b) == count(a) + count(b);\n}\nelse\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¨è¿ç§æåµä¸ï¼æä»¬å¯ä»¥éè¿æ·»å ä¸ä¸ªrequireså­å¥æ¥æ£éªå¼çãæä»¬åç°ä»£ç éªè¯ãè¿æå³çå¦æa ==[]ï¼åå¼çå°æ­£ç¡®å°è¯æåç½®æ¡ä»¶ãå¨è¿ç§æåµä¸ï¼åªéè¦ä¸é¢çç¬¬ä¸ä¸ªæ­è¨;dafnyèªå·±å®æäºå©ä¸çæ­¥éª¤(è¯è¯å§!)ç°å¨æä»¬å¯ä»¥èèå¦ä¸ç§æåµï¼å½0 < |a|ã\n\næä»¬çç®æ æ¯å°count(a + b)ä¸count(a)åcount(b)èç³»èµ·æ¥ãå¦æaä¸æ¯ç©ºåºåï¼é£ä¹å½æä»¬æç§å®ä¹å±å¼count(a + b)æ¶ï¼æä»¬å¾å°:\n\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert a + b == [a[0]] + (a[1..] + b);\n   assert count(a + b) == count([a[0]]) + count(a[1..] + b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nassert a + b == [a[0]] + (a[1..] + b);\nassert count(a + b) == count([a[0]]) + count(a[1..] + b);\n\n\n1\n2\n\n\næ³¨æï¼æä»¬å¾å°count([a[0]])åa[1..]ãå¦ææä»¬æ©å±count(a)ï¼è¿ä¸¤é¡¹ä¹ä¼åºç°ãå·ä½å°è¯´:\n\nmethod m2(a: seq<bool>, b:seq<bool>)\n   requires |a| > 0\n{\n   assert count(a) == count([a[0]]) + count(a[1..]);\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nassert count(a) == count([a[0]]) + count(a[1..]);\n\n\n1\n\n\næåï¼æä»¬å¯ä»¥å°count(a)çå®ä¹æ¿æ¢ä¸ºåç½®æ¡ä»¶ï¼ä»¥è·å¾:\n\nassert count(a + b) == count(a) + count(b); // postcondition\nassert count(a + b) == count([a[0]]) + count(a[1..]) + count(b);\n\n\n1\n2\n\n\nç°å¨è¿çèµ·æ¥å¾åæä»¬å±å¼count(a + b)åå¾å°çè¡¨è¾¾å¼ãå¯ä¸çåºå«æ¯count(a[1.. .) + count(a[1..]) + count(b)ãä½è¿æ­£æ¯æä»¬è¦è¯æçæ§è´¨!\n\n\n# å½çº³\n\næä»¬è¯å¾æåºçè®ºç¹æ¯å½çº³çãæä»¬å¯ä»¥è¯ææä»¬çç®æ ï¼åªè¦è¿ä¸ªé®é¢çä¸ä¸ªå°çæ¬æ¯æ­£ç¡®çãè¿æ­£æ¯å½çº³æ³çæ¦å¿µ:ç¨ä¸ä¸ªå°é®é¢æ¥è¯æä¸ä¸ªå¤§é®é¢ãä¸ºæ­¤ï¼æä»¬å¨ä»£ç ä¸­è°ç¨éå½å±æ§ãå®æ¯ä¸ä¸ªæ¹æ³ï¼æä»¥æä»¬å¯ä»¥å¨éè¦å®çæ¶åè°ç¨å®ã\n\ndafnyå°åå®éå½è°ç¨æ»¡è¶³è§èãè¿å°±æ¯å½çº³åè®¾ï¼ææå¼ççéå½è°ç¨é½æ¯ææçãè¿å³é®åå³äºdafnyä¹è¯æäºç»æ­¢ãè¿æå³çæç»ï¼å¼çä¸ä¼åè¿è¡éå½è°ç¨ãå¨æ¬ä¾ä¸­ï¼è¿æ¯ifè¯­å¥çç¬¬ä¸ä¸ªåæ¯ãå¦ææ²¡æéå½è°ç¨ï¼é£ä¹å¼çå¿é¡»ç´æ¥è¯æè¿ç§æåµãç¶åï¼å æ ä¸­çæ¯ä¸ªè°ç¨é½æ¯åççï¼åè®¾å¼çéç¨äºè¾å°çæåµãå¦ædafnyæ²¡æè¯æé¾ç»æ­¢ï¼é£ä¹é¾å¯ä»¥æ°¸è¿ç»§ç»­ï¼å¹¶ä¸å¯¹äºæ¯ä¸ªè°ç¨çåè®¾é½æ¯ä¸åççã\n\nå½çº³æ³éå¸¸æ¯å¯»æ¾ä¸ç§æ¹æ³ï¼ä¸æ­¥ä¸æ­¥å°å»ºç«ä½ çç®æ ãä»å¦ä¸ä¸ªè§åº¦æ¥çï¼å®è¯æäºä½ çç®æ æ¯ä¸ä¸ªæ´å°ççæ¬ãéè¿ä¸æ¬¡åè§£ä¸ä¸ªåç´ ï¼ç´å°ç¬¬ä¸ä¸ªåºåå®å¨æ¶å¤±ï¼è¯æäºåéå¼çãè¿ç§æåµè¢«è¯ææ¯ä¸ä¸ªåºæ¬æåµï¼ç¶åæ´ä¸ªé¾çè§£æè¢«éªè¯ã\n\næåçå³é®æ¯dafnyä»æ¥ä¸ç¨èèæ´ä¸ªéè¯é¾ãéè¿æ£éªç»æ­¢ï¼å¾å°é¾æ¯æéçãç¶åå®è¦åçå°±æ¯æ£æ¥ä¸æ­¥ãå¦æä»»æä¸æ­¥æ¯ææçï¼é£ä¹æ´ä¸ªé¾ä¹æ¯ææçãè¿ä¸dafnyå¨å¾ªç¯ä¸­ä½¿ç¨çé»è¾ç¸å:æ£æ¥åå§ä¸åé¡¹æ¯å¦æç«ï¼ä»»æä¸ä¸ªæ­¥éª¤æ¯å¦ä¿æä¸åï¼ç¶åæ£æ¥æ´ä¸ªå¾ªç¯ï¼ä¸ç®¡å¾ªç¯å¾ªç¯äºå¤å°æ¬¡ãè¿ç§ç¸ä¼¼æ§ä¸ä»ä»æ¯è¡¨é¢çãè¿ä¸¤ç§å¼ç(ä»¥ådafnyå¯¹ç¨åºçä¸¤ç§æ¨ç)é½æ¯å½çº³çãèèå°è¿­ä»£åéå½ä½ä¸ºå®ç°åä¸ç®æ çä¸¤ç§æ¹æ³ä¹é´çå³ç³»ï¼è¿ä¹ä¸è¶³ä¸ºå¥ã\n\nè®°ä½è¿ä¸ç¹ï¼æä»¬å¯ä»¥éè¿å¨ifè¯­å¥çelseåæ¯ä¸­éå½å°è°ç¨å¼çæ¥å®æå¼ç:\n\nlemma distributivelemma(a: seq<bool>, b: seq<bool>)\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      distributivelemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n}\nfunction count(a: seq<bool>): nat\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n  if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      distributivelemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nç°å¨è¿ä¸ªå¼çå¾å°äºéªè¯ãä½æ¯å¦ææä»¬æ³è¦è¡¨è¾¾æ¯ä¸å¯¹åºåé½æ¯è¿æ ·èç³»çå¢?ä¸ºäºåå°è¿ä¸ç¹ï¼æä»¬å¿é¡»ççå¼çå¨dafnyä¸­çå¦ä¸ç§ç¨æ³ï¼æä»¬å°ç¨å¦ä¸ä¸ªä¾å­æ¥æ¢ç´¢ã\n\n\n# æåå¾çè·¯å¾\n\nä½ä¸ºæåä¸ä¸ªæ´é«çº§çä¾å­ï¼æä»¬å°è¯æä¸ä¸ªå³äºæåå¾ä¸­è·¯å¾çæ§è´¨ãä¸ºæ­¤ï¼æä»¬ææºä¼ç§°ä¸ä¸ªå¼çå¨ææèç¹åºåä¸æ¯æ®éçãä¸ä¸ªæåå¾ç±è¥å¹²ä¸ªèç¹ç»æï¼æ¯ä¸ªèç¹é½æä¸äºå°å¶ä»èç¹çé¾æ¥ãè¿äºé¾æ¥æ¯ååçï¼å¯¹å®ä»¬çå¯ä¸éå¶æ¯èç¹ä¸è½é¾æ¥å°èªå·±ãèç¹å®ä¹ä¸º:\n\nclass node\n{\n   // a single field giving the nodes linked to\n   var next: seq<node>\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬å°å¾è¡¨ç¤ºä¸ºä¸ç»èç¹ï¼è¿äºèç¹åªæåå¾ä¸­çå¶ä»èç¹ï¼èä¸æåèªå·±ãæä»¬ç§°è¿æ ·ä¸ç»èç¹ä¸ºå°é­ç:\n\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==>\n      forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næä»¬å°è·¯å¾è¡¨ç¤ºä¸ºéç©ºèç¹åºåï¼å¶ä¸­æ¯ä¸ªèç¹é½ä¸è·¯å¾ä¸­çåä¸ä¸ªèç¹ç¸è¿ãæä»¬å®ä¹äºä¸¤ä¸ªè°è¯ï¼ä¸ä¸ªç¨äºå®ä¹ææè·¯å¾ï¼å¦ä¸ä¸ªç¨äºç¡®å®ç»å®è·¯å¾æ¯å¦ä¸ºå¾ä¸­ä¸¤ä¸ªç¹å®èç¹ä¹é´çææè·¯å¾:\n\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nç°å¨æä»¬åå¤å¥½éè¿°æä»¬è¦è¯æçå¼çäºãæä»¬èèä¸ä¸ªå¾åä¸ä¸ªå­å¾:ä¸ä¸ªä¹ææä¸ä¸ªå¾çèç¹çå­éãè¿ä¸ªå­å¾å¿é¡»æ¯å°é­çï¼å³ä¸åå«èªèº«ä¹å¤çé¾æ¥ãå¦ææä»¬æè¿æ ·çæåµï¼é£ä¹ä»å­å¾ä¸­çä¸ä¸ªèç¹å°å­å¾ä¹å¤çä¸ä¸ªèç¹ä¸å¯è½æä¸æ¡ææçè·¯å¾ãæä»¬å°è¿ä¸ªäºå®ç§°ä¸ºé­åå¼çï¼æä»¬å¨dafnyä¸­è¿æ ·è¡¨è¿°:\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   //...\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nåææ¡ä»¶è¯´æäºææçè¦æ±:å¾åå­å¾é½æ¯ææçï¼æ ¹èç¹å¨å­å¾ä¸­ä½ç®æ ä¸å¨ï¼ææåå®¹é½åå«å¨ä¸»å¾ä¸­ãåç½®æ¡ä»¶å£°ææ²¡æä»æ ¹å°ç®æ çææè·¯å¾ãè¿éæä»¬åªå¯¹ç¹å®çå¼å§/ç»æèç¹å¯¹è¯æå®ã\n\nè¯ææç©ä¸å­å¨çä¸ç§æ¹æ³æ¯è¯æç»å®çä»»æèç¹åºåå®ä¸æ¯ä¸ä¸ªææè·¯å¾ãæä»¬å¯ä»¥ç¨ï¼ä½ çå¯¹äºï¼å¦ä¸ä¸ªå¼çãè¿ä¸ªå¼çå°è¯æï¼å¯¹äºä»»ä½ç»å®çåºåï¼å®ä¸æ¯ä»æ ¹rootå°ç®æ goalçææè·¯å¾ãè·¯å¾å¼ççåè¯å¦ä¸:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nåæä¸é­å¼çç¸åãè¦å¨é­å¼çclosedlemmaä¸­ä½¿ç¨åè¯æå¼çdisprooflemmaï¼æä»¬éè¦å¯¹æ¯ä¸ªèç¹åºåè°ç¨å®ä¸æ¬¡ãè¿å¯ä»¥éè¿dafnyçforallè¯­å¥æ¥å®æï¼è¯¥è¯­å¥èåäºç»å®ç»å®åéçææå¼å¯¹å¶ä¸»ä½çå½±åã\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph =\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   ...\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¦ä½ æè§ï¼è¿ä½¿å¾é­å¼çclosedlemmaå¾å°éªè¯ï¼æä»¥æä»¬å¯¹å¼ççæµè¯æ¯æåçãå æ­¤ï¼åè¯æå¼çdisprooflemmaæ¯è¶³å¤å¼ºçï¼æä»¬çå·¥ä½ä»ä»æ¯è¯æå®ã\n\næå ç§ä¸åçæ¹å¼å¯ä»¥ä½¿èç¹åºåæä¸ºæ æè·¯å¾ãå¦æè·¯å¾ä¸ºç©ºï¼åå®ä¸è½æ¯ææè·¯å¾ãæ­¤å¤ï¼è·¯å¾çç¬¬ä¸ä¸ªåç´ å¿é¡»æ¯æ ¹rootï¼æåä¸ä¸ªåç´ å¿é¡»æ¯ç®æ goalãå ä¸ºroot in subgraphï¼goal !in subgraphï¼æä»¬å¿é¡»æroot != goalï¼æä»¥åºåå¿é¡»è³å°æä¸¤ä¸ªåç´ ãä¸ºäºéªè¯dafnyæ¯å¦çå°äºè¿ä¸ç¹ï¼æä»¬å¯ä»¥ä¸´æ¶å¨å¼çä¸å ä¸åå³æ¡ä»¶ï¼å¦ä¸æç¤º:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ensures !pathspecific(p, root, goal, graph)\n{\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires ...  // as before\n   requires |p| < 2 || p[0] != root || p[|p|-1] != goal\n   ...\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næ³¨æï¼è¿å°å¯¼è´é­å¼çclosedlemmaåæ­¢éªè¯ï¼å ä¸ºå¼çç°å¨åªå¯¹ä¸äºåºåææãæä»¬å°å¿½ç¥é­åå¼çclosedlemmaï¼ç´å°æä»¬å®æåé©³å¼çdisprooflemmaãè¿å°±è¯æäºï¼è¿æå³çdafnyè½å¤å¨è¿äºæåµä¸è¯æåç½®æ¡ä»¶ãå æ­¤ï¼æä»¬åªéè¦è¯æå½è¿äºæ¡ä»¶ä¸æç«æ¶ï¼è·¯å¾æ¯æ æçãæä»¬å¯ä»¥ç¨ifè¯­å¥æ¥è¡¨è¾¾:\n\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      (further proof)\n   }\n\n\n1\n2\n3\n\n\nå¦æè·¯å¾è³å°æä¸¤ä¸ªåç´ é¿ï¼ç¬¬ä¸ä¸ªåç´ æ¯æ ¹rootåç´ ï¼æåä¸ä¸ªåç´ æ¯ç®æ goalåç´ ï¼é£ä¹æä»¬å°±æäºè¿ä¸æ­¥çè¯æãå¦æè¿äºæ¡ä»¶æ²¡ææ»¡è¶³(ä¹å°±æ¯è¯´ï¼å¦æifè¯­å¥çä¿æ¤ä¸ºfalseï¼å¹¶ä¸æ§å¶å¨éå¼elseåæ¯ä¸­ç»§ç»­)ï¼dafnyå°èªå·±è¯æåç½®æ¡ä»¶(é«çº§å¤æ³¨:ä½ å¯ä»¥éè¿ä¸´æ¶æ·»å è¯­å¥assume falseæ¥æ£æ¥è¿ä¸ç¹;å¨ifçthenåæ¯ä¸­)ãç°å¨æä»¬åªéè¦å¡«å¥è¿ä¸æ­¥çè¯æé¨åãå¨è¿æ ·åæ¶ï¼æä»¬å¯ä»¥åå®ifè¯­å¥çä¿æ¤æ¡ä»¶ãæä»¬ç°å¨å¯ä»¥ä½¿ç¨åä¸é¢ä¸æ ·çå½çº³æå·§ã\n\nå¦æåºåä»æ ¹rootèç¹å¼å§ï¼å¹¶å¨ç®æ èç¹goalç»æï¼åå®ä¸è½ææï¼å ä¸ºåºåå¿é¡»å¨æä¸ªç¹ä¸æä¸ä¸ªä¸å¨åä¸ä¸ªèç¹ä¸ä¸ä¸ªåè¡¨ä¸­çèç¹ãå½æä»¬å¾å°ä»»ä½åè¿æ ·çç¹å®åºåæ¶ï¼æä»¬å¯ä»¥å°å®åä¸ºä¸¤ç§æåµ:è¦ä¹åºåå¨ä»ç¬¬ä¸ä¸ªèç¹å°ç¬¬äºä¸ªèç¹çé¾æ¥ä¸­æ æï¼è¦ä¹å®å¨ä¸è¡ä¸­çæä¸ªå°æ¹è¢«ææ­äºãå°±åå¨è®¡æ°ç¤ºä¾ä¸­ä¸æ ·ï¼dafnyå¯ä»¥çå°ï¼å¦æç¬¬ä¸ä¸ªå°ç¬¬äºä¸ªèç¹é¾æ¥æ æï¼é£ä¹åºåå°±ä¸è½æ¯è·¯å¾ï¼å ä¸ºè¿åæ äºè·¯å¾pathçå®ä¹ãå æ­¤ï¼åªæå½ç¬¬ä¸ä¸ªé¾æ¥æææ¶ï¼æä»¬ææè¿ä¸æ­¥çå·¥ä½è¦åãæä»¬å¯ä»¥ç¨å¦ä¸ä¸ªifè¯­å¥æ¥è¡¨è¾¾:\n\nif 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         (yet further proof)\n      }\n   }\n\n\n1\n2\n3\n4\n5\n\n\nè¿éæ¯å½çº³inductionãæä»¬ç¥ép[0] == root, p[1] in p[0].next.ä¸­ãæä»¬è¿ä»å­å¾çæ ¹root in subgraphçåå³æ¡ä»¶ç¥éãå æ­¤ï¼ç±äºé­å­å¾Â closed(subgraph)ï¼æä»¬ç¥ép[1] in subgraphÂ ãè¿äºæ¡ä»¶åæä»¬å¼å§æ¶æ¯ä¸æ ·ç!æä»¬ç°å¨é¢å¯¹çæ¯åä¸ä¸ªé®é¢çä¸ä¸ªå°çæ¬ãæä»¬å¯ä»¥éå½å°è°ç¨åè¯æå¼çdisprooflemmaæ¥è¯æp[1..ä¸æ¯ä¸æ¡è·¯ãè¿æå³çï¼æ ¹æ®è·¯å¾pathçå®ä¹ï¼pä¸è½æ¯è·¯å¾ï¼å¹¶ä¸æ»¡è¶³ç¬¬äºä¸ªåç½®æ¡ä»¶ãè¿å¯ä»¥å®ç°ä¸º:\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         disprooflemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\nlemma closedlemma(subgraph: set<node>, root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !(exists p: seq<node> :: pathspecific(p, root, goal, graph))\n{\n   forall p {\n      disprooflemma(p, subgraph, root, goal, graph);\n   }\n}\nclass node\n{\n   var next: seq<node>\n}\npredicate pathspecific(p: seq<node>, start: node, end: node, graph: set<node>)\n   requires closed(graph)\n   reads graph\n{\n   0 < |p| && // path is nonempty\n   start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n   path(p, graph) // and it is a valid path\n}\npredicate path(p: seq<node>, graph: set<node>)\n   requires closed(graph) && 0 < |p|\n   reads graph\n{\n   p[0] in graph &&\n   (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n      path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate closed(graph: set<node>)\n   reads graph\n{\n   forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nlemma disprooflemma(p: seq<node>, subgraph: set<node>,\n                    root: node, goal: node, graph: set<node>)\n   requires closed(subgraph) && closed(graph) && subgraph <= graph\n   requires root in subgraph && goal in graph - subgraph\n   ensures !pathspecific(p, root, goal, graph)\n{\n   if 1 < |p| && p[0] == root && p[|p|-1] == goal {\n      if p[1] in p[0].next {\n         disprooflemma(p[1..], subgraph, p[1], goal, graph);\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nç°å¨é­å¼çdisprooflemmaè¢«éªè¯äºï¼éçæµè¯åæçç§»é¤ï¼æä»¬çå°é­å¼çclosedlemmaä¹è¢«éªè¯äºãç±æ­¤è¯æäºå°é­å­å¾ä¸å­å¨ä»åé¨å°å¤é¨çè·¯å¾ã\n\nå½ä¸ä¸ªå¼çéè¦æ éæ¬¡å®ä¾åæ¶ï¼forallè¯­å¥æ¯æç¨çãè¿ä¸ªä¾å­å±ç¤ºäºforallè¯­å¥çä¸ä¸ªç®åçæ¬ãè¦äºè§£æ´é«çº§ççæ¬ï¼è¯·åè§leinoçãdafnyä¸­çè¯å¥½åºç¡å½æ°åæç«¯è°è¯:æç¨ãï¼iwill -2015ï¼ædafnyæµè¯å¥ä»¶ä¸­çç¤ºä¾ã\n\næ°¸è¿è®°å¾æ£æ¥ä½ çå¼çæ¯å¦è¶³ä»¥è¯æä½ éè¦çãæ²¡æä»ä¹æ¯è±æ¶é´åå¼çéªè¯ï¼ç»æåç°ä½ éè¦æ´å¼ºå¤§çä¸è¥¿æ´ä»¤äººæ²®ä¸§çäºãè¿ä¹å¯ä»¥è®©ä½ é¿ååå»ºä¸ä¸ªå¸¦æåç½®æ¡ä»¶çå¼çï¼å ä¸ºåç½®æ¡ä»¶çéå¶å¤ªå¤§ï¼ä»¥è³äºä½ ä¸è½å¨éè¦çå°æ¹è°ç¨å®ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ¨¡å",frontmatter:{title:"æ¨¡å",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/9d19b8/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/05.%E6%A8%A1%E5%9D%97.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/05.æ¨¡å.md",key:"v-2472a78b",path:"/pages/9d19b8/",headers:[{level:2,title:"ä»ç»",slug:"ä»ç»",normalizedTitle:"ä»ç»",charIndex:9},{level:2,title:"å£°ææ°æ¨¡å",slug:"å£°ææ°æ¨¡å",normalizedTitle:"å£°ææ°æ¨¡å",charIndex:145},{level:2,title:"å¯¼å¥åå¯¼åºæ¨¡å",slug:"å¯¼å¥åå¯¼åºæ¨¡å",normalizedTitle:"å¯¼å¥åå¯¼åºæ¨¡å",charIndex:1598},{level:3,title:"å¯¼åºéå",slug:"å¯¼åºéå",normalizedTitle:"å¯¼åºéå",charIndex:2417},{level:3,title:"å¯¼åºä¸è´æ§",slug:"å¯¼åºä¸è´æ§",normalizedTitle:"å¯¼åºä¸è´æ§",charIndex:5402},{level:2,title:"å¼æ¾æ¨¡æ¿",slug:"å¼æ¾æ¨¡æ¿",normalizedTitle:"å¼æ¾æ¨¡æ¿",charIndex:6683},{level:2,title:"æ½è±¡æ¨¡å",slug:"æ½è±¡æ¨¡å",normalizedTitle:"æ½è±¡æ¨¡å",charIndex:8019},{level:2,title:"æ¨¡åæåºåä¾èµå³ç³»",slug:"æ¨¡åæåºåä¾èµå³ç³»",normalizedTitle:"æ¨¡åæåºåä¾èµå³ç³»",charIndex:9359},{level:2,title:"åå­åè§£",slug:"åå­åè§£",normalizedTitle:"åå­åè§£",charIndex:10172}],headersStr:"ä»ç» å£°ææ°æ¨¡å å¯¼å¥åå¯¼åºæ¨¡å å¯¼åºéå å¯¼åºä¸è´æ§ å¼æ¾æ¨¡æ¿ æ½è±¡æ¨¡å æ¨¡åæåºåä¾èµå³ç³» åå­åè§£",content:"# æ¨¡å\n\n\n# ä»ç»\n\nå°ç¨åºåè§£æå¤ä¸ªé¨åæ¥æé å®æ¯åå»ºå¤§åç¨åºçéè¦é¨åãå¨Dafnyä¸­ï¼è¿æ¯éè¿æ¨¡åå®ç°çãæ¨¡åæä¾äºä¸ç§å°ç¸å³ç±»åãç±»ãæ¹æ³ãå½æ°åå¶ä»æ¨¡åç»åå¨ä¸èµ·çæ¹æ³ï¼ä»¥åæ§å¶å£°æçä½ç¨åãæ¨¡åå¯ä»¥ç¸äºå¯¼å¥ä»¥å®ç°ä»£ç éç¨ï¼å¹¶ä¸å¯ä»¥å¯¹æ¨¡åè¿è¡æ½è±¡ä»¥å°å®ç°ä¸æ¥å£åç¦»ã\n\n\n# å£°ææ°æ¨¡å\n\nDeclaring New Moduleså£°ææ°æ¨¡å ä¸ä¸ªæ°æ¨¡åæ¯ç¨moduleå³é®å­å£°æçï¼åé¢è·çæ°æ¨¡åçåå­ï¼è¿æä¸å¯¹æ¬ä½æ¨¡åä¸»ä½çè±æ¬å·({}):\n\nmodule Mod {\n  ...\n}\n\n\n1\n2\n3\n\n\næ¨¡åä¸»ä½å¯ä»¥åå«ä»»ä½å¯ä»¥æ¾å¨é¡¶å±çåå®¹ãè¿åæ¬ç±»ãæ°æ®ç±»åãç±»åãæ¹æ³ãå½æ°ç­ã\n\nmodule Mod {\n  class C {\n    var f: int;\n    method m()\n  }\n  datatype Option = A(int) | B(int)\n  type T\n  method m()\n  function f(): int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä½ ä¹å¯ä»¥å°ä¸ä¸ªæ¨¡ååµå¥å°å¦ä¸ä¸ªæ¨¡åä¸­:\n\nmodule Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç¶åï¼ä½ å¯ä»¥å¨Modæ¨¡åä¸­å¼ç¨Helpersæ¨¡åçæåï¼æ¹æ³æ¯å¨å®ä»¬åé¢å ä¸\" Helpers \"ãä¾å¦:\n\nmodule Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int;\n    }\n  }\n  method m() {\n    var x := new Helpers.C;\n    x.doIt();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmodule Mod {\n  module Helpers { ... }\n  method m() {\n    var x := new Helpers.C;\n    x.doIt();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¨æ¨¡åçº§å«å®ä¹çæ¹æ³åå½æ°å¯ä»¥åç±»ä¸æ ·ä½¿ç¨ï¼åªæ¯æ¨¡ååä½ä¸ºåç¼ãå®ä»¬ä¹å¯ä»¥å¨åä¸ä¸ªæ¨¡åä¸­çç±»çæ¹æ³åå½æ°ä¸­ä½¿ç¨ã\n\nmodule Mod {\n  module Helpers {\n    function method addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x); // x is now 6\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\né»è®¤æåµä¸ï¼å½æ°(åè°è¯)çå®ä¹å¨å®ä¹å®ä»¬çæ¨¡åå¤é¨å¬å¼ãè¿å¯ä»¥éè¿å¯¼åºéè¿è¡æ´ç²¾ç¡®çæ§å¶ï¼æä»¬å°å¨ä¸ä¸èä¸­çå°ãæä»¥å¢å \n\nmodule Mod {\n  module Helpers {\n    function method addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x);\n    assert x == 6; // this will succeed\n  }\n}\n\n  assert x == 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä»¥m()ç»å°¾å°è¿è¡éªè¯ã\n\n\n# å¯¼å¥åå¯¼åºæ¨¡å\n\nå£°ææ°çå­æ¨¡åæ¯æç¨çï¼ä½ææ¶æ¨å¸æå¼ç¨æ¥èªç°ææ¨¡åçåå®¹ï¼æ¯å¦åºãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥å°ä¸ä¸ªæ¨¡åå¯¼å¥å¦ä¸ä¸ªæ¨¡åãè¿æ¯éè¿importå³é®å­å®æçï¼æå ç§ä¸åçå½¢å¼ï¼æ¯ä¸ç§é½æä¸åçå«ä¹ãæç®åçå½¢å¼æ¯å·ä½çå¯¼å¥,å¯¼å¥å½¢å¼A = Bè¿ä¸ªæ¨¡åå£°æåå»ºä¸ä¸ªå¼ç¨B(å¿é¡»å·²ç»å­å¨),å¹¶ç»åæ°åç§°æ³¨æè¿ä¸ªæ°åç§°,ä¾å¦Â A,,åªæç»å®æ¨¡ååå«å¯¼å¥å£°æ;å®ä¸ä¼åå»ºå¨å±å«åãä¾å¦ï¼å¦æhelperæ¯å¨Modä¹å¤å®ä¹çï¼é£ä¹æä»¬å¯ä»¥å¯¼å¥å®:\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n\nmodule Helpers {\n  ...\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\næ³¨æï¼å¨m()ä¸­ï¼æä»¬å¿é¡»ä½¿ç¨Aèä¸æ¯helperï¼å ä¸ºæä»¬å°å®ç»å®å°ä¸ä¸ªä¸åçåç§°ãåç§°Helperså¨m()ä¸­ä¸å¯ç¨ï¼å ä¸ºåªæå¨Modä¸­ç»å®çåç§°æå¯ç¨ãä¸ºäºä½¿ç¨æ¥èªå¦ä¸ä¸ªæ¨¡åçæåï¼å®è¦ä¹å¿é¡»ç¨moduleå£°æï¼è¦ä¹ç¨importå¯¼å¥ã\n\nä¸è¿ï¼å¦ææä»¬ä¸æ³ç»Helpersèµ·ä¸ªæ°åå­ï¼ä¹ä¸å¿ãå¦æéè¦ï¼å¯ä»¥ç¼åimport Helpers = Helpers, Dafnyçè³ä¸ºè¿ç§è¡ä¸ºæä¾äºç®ä¾¿çimport Helpersãæ¨ä¸è½åæ¶ç»å®ä¸¤ä¸ªå·æç¸ååç§°çæ¨¡åï¼å æ­¤ææ¶å¿é¡»ä½¿ç¨= çæ¬å·ä»¥ç¡®ä¿åç§°ä¸ä¼å²çªã\n\n\n# å¯¼åºéå\n\né»è®¤æåµä¸ï¼å¯¼å¥importå°åè®¸è®¿é®è¢«å¯¼å¥æ¨¡åçææå£°æ(åå¶å®ä¹)ãä¸ºäºæ´ç²¾ç¡®å°æ§å¶è¿ä¸ç¹ï¼æä»¬å¯ä»¥ä½¿ç¨å¯¼åºexportéãæ¯ä¸ªå¯¼åºexportéå¯è½æå½åæ¨¡åçå£°æåè¡¨ï¼ä»¥providesærevealsçå½¢å¼ç»åºãæ²¡æåç§°çå¯¼åºexportè¢«è®¤ä¸ºæ¯è¯¥æ¨¡åçé»è®¤å¯¼åºï¼å¹¶ä¸å¨æ²¡ææ¾å¼å½åéåæ¶ä½¿ç¨ã\n\nmodule Helpers {\n  export Spec provides addOne, addOne_result\n  export Body reveals addOne\n  export extends Spec\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addOne_result(n : nat)\n     ensures addOne(n) == n + 1\n  { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå¨è¿ä¸ªä¾å­ä¸­ï¼æä»¬å£°æäº3ä¸ªå¯¼åºéï¼SpecÂ éæäºäºå¯¹addOneå½æ°çè®¿é®æï¼ä½æ¯ç±äºå®æ¯ç¨provideså£°æçï¼æä»¥å®æ²¡ææäºå¯¹å¶å®ä¹çè®¿é®æãBodyå¯¼åºéå°addOneå£°æä¸ºrevealsï¼ç°å¨å¯ä»¥è®¿é®addOneçbdoyé¨åãæåï¼é»è®¤å¯¼åºä½ä¸ºSpecçæ©å±extendsç»åºï¼è¿è¡¨æå®åªæ¯ç»åºSpecæå£°æçææå¯¼åºã\n\næä»¬ç°å¨å¯ä»¥å¨å¯¼å¥helperæ¶éæ©è¿äºå¯¼åºéä¸­çä»»ä½ä¸ä¸ªï¼å¹¶è·å¾å®çä¸åè§å¾ã\n\nmodule Helpers {\n  export Spec provides addOne, addOne_result\n  export Body reveals addOne\n  export extends Spec\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addOne_result(n: nat)\n     ensures addOne(n) == n + 1\n  { }\n}\n\nmodule Mod1 {\n  import A = Helpers`Body\n  method m() {\n    assert A.addOne(5) == 6; // succeeds, we have access to addOne's body\n  }\n  method m2() {\n    //A.addOne_result(5); // error, addOne_result is not exported from Body\n    assert A.addOne(5) == 6;\n  }\n}\nmodule Mod2 {\n  import A = Helpers`Spec\n  method m() {\n    assert A.addOne(5) == 6; // fails, we don't have addOne's body\n  }\n  method m2() {\n    A.addOne_result(5);\n    assert A.addOne(5) == 6; // succeeds due to result from addOne_result\n  }\n}\nmodule Mod3 {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6; // fails, we don't have addOne's body\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\næä»¬è¿å¯ä»¥ä½¿ç¨å¯¼åºéexportÂ setsÂ æ¥æ§å¶å¯ç¨çç±»åå®ä¹ãææç±»åå£°æ(å¦newtypeãtypeãdatatypeç­)é½å¯ä»¥å¯¼åºä¸ºæä¾providesææ¾ç¤ºãå¨åä¸ç§æåµä¸ï¼å¯¼å¥è¯¥ç±»åçæ¨¡åå°å¶è§ä¸ºä¸éæç±»åã\n\nmodule Helpers {\n  export provides f, T\n  export Body reveals f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  import A = Helpers\n  function g(): A.T { 0 } // error, T is not known to be int, or even numeric\n  function h(): A.T { A.f() } // okay\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸æ¦å¯¼å¥exportäºæ¾ç¤ºrevealsä»¥åä¸éæç±»åçå¯¼åºï¼åå·²ç¥å¯¹å®çææç°æä½¿ç¨é½æ¯åé¨ç±»åã\n\nmodule Helpers {\n  export provides f, T\n  export Body reveals f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\nmodule Mod2 {\n  import M = Mod\n  import A = Helpers`Body\n  function j(): int\n    ensures j() == 0 //succeeds\n  { M.h() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nä½ä¸ºä¸ç§æ¹ä¾¿çç®åæ¹å¼ï¼ç¹æ®æ è¯ç¬¦â*âå¯ä»¥å¨æä¾providesææ­ç¤ºrevealsä¹åç»åºï¼ä»¥è¡¨ç¤ºææå£°æé½åºè¯¥æä¾ææ­ç¤ºã\n\nmodule A {\n   export All reveals * // reveals T, f, g\n   export Spec provides * // provides T, f, g\n   export Some provides * reveals g // provides T, f reveals g\n   type T = int\n   function f(): T { 0 }\n   function g(): int { 2 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\næä»¬è¿å¯ä»¥ä¸æ¬¡æä¾å¤ä¸ªå¯¼åºæ¥åå»ºä¸ä¸ªèåå¯¼å¥(aggregateÂ import).\n\nmodule A {\n  export Justf reveals f\n  export JustT reveals T\n  type T = int\n  function f(): int { 0 }\n}\nmodule B {\n  import A`{Justf,JustT}\n  function g(): A.T { A.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# å¯¼åºä¸è´æ§\n\nå¯¼åºé(exportÂ set)å¿é¡»å§ç»åç°æ¨¡åçä¸è´è§å¾:ä»»ä½åºç°å¨å¯¼åºå£°æä¸­çåå®¹é½å¿é¡»è¢«å¯¼åºãåé¡¾åé¢çç¤ºä¾ï¼æä»¬ä¸è½åå»ºä¸ä¸ªæ¢æ¾ç¤ºf(revealsÂ f)åæ¾ç¤ºTçå¯¼åºéexportÂ setãåå å¾ç®åï¼æä»¬å°åå»ºä¸ä¸ªç±»åçº¦æ0:Tï¼å¦æTæ¯ä¸éæçï¼åæ æ³è§£å³è¿ä¸ªçº¦æãç±»ä¼¼å°ï¼å¦æä¸æä¾Tï¼åä¸è½åå»ºæä¾providesææ­ç¤ºf revealsÂ fçå¯¼åºéã\n\nmodule Helpers {\n  export provides f, T // good\n  export Body reveals f, T // good\n  export BadSpec reveals f, provides T // bad\n  export BadSpec2 provides f // bad\n  type T = int\n  function f(): T { 0 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç±äºæä»¬å¯ä»¥å®ä¹åæ¶åå«å¯¼å¥importåå¯¼åºexportå£°æçæ¨¡åï¼å æ­¤æä»¬å¯è½éè¦ä»å¤é¨æ¨¡åå¯¼åºå£°æï¼ä»¥åå»ºä¸è´çå¯¼åºéexport setãå¤é¨æ¨¡åçå£°æä¸è½ç´æ¥åå«å¨å¯¼åºexportä¸­ï¼ä½æ¯æä¾å®ä»¬çå¯¼å¥importå¯ä»¥ã\n\nmodule Helpers {\n  export provides f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  export Try1 reveals h // error\n  export Try2 reveals h, provides A.f, A.T // error, can't provide these directly\n  export reveals h, provides A // good\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå½å¯¼å¥Modæ¶ï¼æä»¬ç°å¨ä¹è·å¾äºå¯¹å¶å¯¼å¥a import aä¸­ææä¾çåå®¹çåæ ¼è®¿é®æãæä»¬ä¹å¯ä»¥éæ©ç´æ¥å¯¼å¥è¿äºåå®¹ï¼ç»å®ä»¬ä¸ä¸ªæ´ç­çåç§°ã\n\nmodule Helpers {\n  export provides f, T\n  type T = int\n  function f(): T { 0 }\n}\nmodule Mod {\n  export reveals h, provides A\n  import A = Helpers\n  function h(): A.T { A.f() }\n}\n\nmodule Mod2 {\n  import M = Mod\n  import MA = M.A\n  function j(): M.A.T { M.h() }\n  function k(): MA.T { j() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# å¼æ¾æ¨¡æ¿\n\nææ¶ï¼ä¸ºå¯¼å¥çæ¨¡åçæåå ä¸åç§°åç¼æ¯ä¹å³ä¸é¾ççï¼å³ä½¿æ¨å¨å¯¼å¥æ¶éæ©äºä¸ä¸ªç®ç­çåç§°ãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥å°æ¨¡åå¯¼å¥ä¸ºâopenedâï¼è¿å°ä½¿å¶æææåé½å¯ç¨ï¼èæ éæ·»å æ¨¡ååç§°ãopenedå³é®å­å¿é¡»ç´§è·å¨importä¹åï¼å¦æå®å­å¨çè¯ãä¾å¦ï¼æä»¬å¯ä»¥å°åé¢çaddOneç¤ºä¾åä¸º:\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\n\nmodule Mod {\n  import opened Helpers\n  method m() {\n    assert addOne(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå½æå¼æ¨¡åæ¶ï¼æ°ç»å®çæåå°å·æè¾ä½çä¼åçº§ï¼å æ­¤å®ä»¬å°è¢«å±é¨å®ä¹éèãè¿æå³çï¼å¦ææ¨å®ä¹äºä¸ä¸ªåä¸ºaddOneçå±é¨å½æ°ï¼åhelperä¸­çå½æ°å°ä¸åä»¥è¯¥åç§°æä¾ãå½æ¨¡åè¢«æå¼æ¶ï¼åå§çåç§°ç»å®ä»ç¶å­å¨ï¼æä»¥æ¨æ»æ¯å¯ä»¥ä½¿ç¨ç»å®çåç§°æ¥è·åä»»ä½éèçåå®¹ã\n\nmodule Helpers {\n  function method addOne(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened Helpers\n  function addOne(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert Helpers.addOne(5) == 6; // this is still true\n  }\n}\n\nmodule Mod {\n  import opened Helpers\n  function addOne(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert Helpers.addOne(5) == 6; // this is still true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nå¦ææå¼ä¸¤ä¸ªé½å£°æå·æç¸ååç§°çæåçæ¨¡åï¼é£ä¹å¨æ²¡ææ¨¡ååç¼çæåµä¸ï¼è¿ä¸¤ä¸ªæåé½ä¸è½è¢«å¼ç¨ï¼å ä¸ºåªä¸ªæåçå«ä¹æ¯ä¸æç¡®çãä¸è¿ï¼åªè¦æ¨ä¸è¯å¾ä½¿ç¨å·æå±ååç§°çæåï¼ä»ä»æå¼è¿ä¸¤ä¸ªæ¨¡åå°±ä¸ä¼åºç°éè¯¯ãopenedå³é®å­å¯ä»¥ç¨äºä»»ä½ç±»åçå¯¼å¥importå£°æï¼åæ¬æ¨¡åæ½è±¡å½¢å¼ã\n\n\n# æ½è±¡æ¨¡å\n\nææ¶ï¼ä½¿ç¨ç¹å®çå®ç°æ¯ä¸å¿è¦ç;ç¸åï¼æéè¦çåªæ¯ä¸ä¸ªå®ç°æäºæ¥å£çæ¨¡åãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥ä½¿ç¨æ½è±¡æ¨¡åå¯¼å¥ãå¨Dafny,è¿æ¯åimport A : B.ãè¿æå³çç»å®åç§°A,èæ¯å¾å°ç¡®åçæ¨¡åB,ä½ å¾å°ä»»ä½æ¨¡åçç»åB .éå¸¸æåµä¸,æ¨¡åBå¯è½æ½è±¡ç±»åå®ä¹,åå«è±èæ¹æ³çç±»,æèç´æ¥ä¸éåä½¿ç¨ãç±äºç»åçå®ä¹æ¹å¼ï¼Bçä»»ä½ç»åé½å¯ä»¥å®å¨å°ä½¿ç¨ãä¾å¦ï¼å¦ææä»¬ä»¥:\n\nabstract module Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nå¦ææä»¬ç¥éaddSomeå®éä¸æ­£å¥½å äº1ï¼æä»¬å°±å¯ä»¥æ´ç²¾ç¡®äºãä¸é¢çæ¨¡åå·æè¿ç§è¡ä¸ºãæ­¤å¤ï¼åç½®æ¡ä»¶æ´å¼ºï¼å æ­¤è¿å®éä¸æ¯å¯¹Interfaceæ¨¡åçæ¹è¿ã\n\nmodule Implementation refines Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç¶åï¼æä»¬å¯ä»¥å¨ä¸ä¸ªæ°çæ¨¡åä¸­ç¨Implementationä»£æ¿Aï¼éè¿å£°æModçç²¾ç¼ï¼å®å®ä¹äºAçImplementationã\n\nabstract module Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\nmodule Implementation refines Interface {\n  function method addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule Mod2 refines Mod {\n  import A = Implementation\n  method m() {\n    ...;\n    // this is now provable, because we know A is Implementation\n    assert 6 == A.addSome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nå½ä½ å°ä¸ä¸ªæ½è±¡å¯¼å¥ç»åå°ä¸ä¸ªå·ä½çå¯¼å¥æ¶ï¼å·ä½æ¨¡åå¿é¡»æ¯æ½è±¡æ¨¡åçæ¾å¼ç»å(ä¾å¦ï¼ç¨refineså£°æ)ã\n\n\n# æ¨¡åæåºåä¾èµå³ç³»\n\nDafnyå¹¶ä¸ç¹å«å³æ³¨æ¨¡ååºç°çé¡ºåºï¼ä½å®ä»¬å¿é¡»éµå¾ªä¸äºè§åæè½å½¢æè¯å¥½çç»æãä½ä¸ºä¸ä¸ªç»éªæ³åï¼åºè¯¥æä¸ç§æ¹æ³æ¥å¯¹ç¨åºä¸­çæ¨¡åè¿è¡æåºï¼ä»¥ä¾¿æ¯ä¸ªæ¨¡ååªå¼ç¨æºææ¬ä¸­å¨å®ä¹åå®ä¹çä¸è¥¿ãè¿å¹¶ä¸æå³çæ¨¡åå¿é¡»æè¿ä¸ªé¡ºåºæåãå¦æä½ æ²¡æåä»»ä½å¾ªç¯å¼ç¨ï¼Dafnyä¼å¸®ä½ å¼æ¸æ¥é¡ºåºçãä¾å¦ï¼è¿æ¾ç¶æ¯«æ æä¹:\n\nimport A = B\nimport B = A\n\n\n1\n2\n\n\nä½ å¯ä»¥å¨é¡¶å±æimportè¯­å¥ï¼ä¹å¯ä»¥å¯¼å¥å¨åä¸å±å®ä¹çæ¨¡å:\n\nimport A = B\nmethod m() {\n  A.whatever();\n}\nmodule B {\n  method whatever() {}\n}\n\nimport A = B\nmethod m() {\n  A.whatever();\n}\nmodule B { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¨æ¬ä¾ä¸­ï¼ææåå®¹é½å®ä¹å¾å¾å¥½ï¼å ä¸ºæä»¬å¯ä»¥åæ¾Bï¼ç¶åæ¯Aå¯¼å¥ï¼æåæ¯m()ãå¦ææ²¡æé¡ºåºï¼é£ä¹Dafnyå°ç»åºä¸ä¸ªéè¯¯ï¼æ±æ¨å¾ªç¯ä¾èµå³ç³»ã è¯·æ³¨æï¼å½éæ°æåæ¨¡ååå¯¼å¥æ¶ï¼å®ä»¬å¿é¡»ä¿æå¨ç¸åçåå«æ¨¡åä¸­ï¼è¿å°±ä¸åè®¸ä¸äºçæçæ¨¡åç»æãæ­¤å¤ï¼å¯¼å¥åå­æ¨¡åæ»æ¯è¢«è®¤ä¸ºæ¯æåé¢çï¼å³ä½¿å¨é¡¶å±ä¹æ¯å¦æ­¤ãè¿æå³çä»¥ä¸åå®¹ä¸æ¯å¾å¥½çæ ¼å¼:\n\nmethod doIt() { }\nmodule M {\n  method m() {\n    doIt();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nå ä¸ºæ¨¡åMå¿é¡»åºç°å¨ä»»ä½å¶ä»ç±»åçæåä¹åï¼æ¯å¦æ¹æ³ãè¦åè¿æ ·å®ä¹å¨å±å½æ°ï¼æ¨å¯ä»¥å°å®ä»¬æ¾å¨ä¸ä¸ªæ¨¡å(æ¯å¦ç§°ä¸ºGlobals)ä¸­ï¼å¹¶å°å¶æå¼å°ä»»ä½éè¦å¶åè½çæ¨¡åä¸­ãæåï¼å¦ææ¨éè¿è·¯å¾å¯¼å¥ï¼ä¾å¦import a = B.Cé£ä¹è¿å°åå»ºaå¯¹Bçä¾èµå³ç³»ï¼å ä¸ºæä»¬éè¦ç¥éBæ¯ä»ä¹(å®æ¯æ½è±¡çè¿æ¯å·ä½çï¼è¿æ¯ç»åç?)\n\n\n# åå­åè§£\n\n(å¾åäºé¡¹:ä»¥ä¸åå®¹å·²å¨Dafnyæ´æ¹ãè¿éçæè¿°åºè¯¥æ¹åä»¥åæ æ°çè§åã)\n\nå½Dafnyçå°åA.B.Cè¿æ ·çä¸è¥¿æ¶ï¼å®æä¹ç¥éæ¯ä¸ªé¨åæçæ¯ä»ä¹?Dafnyç¨æ¥ç¡®å®è¿æ ·çæ è¯ç¬¦åºåæå¼ç¨çæ¯åç§°è§£æãè½ç¶è§åå¯è½çèµ·æ¥å¾å¤æï¼ä½å®ä»¬éå¸¸é½ç¬¦åæ¨çé¢æãDafnyé¦åæ¥æ¾åå§æ è¯ç¬¦ãæ ¹æ®ç¬¬ä¸ä¸ªæ è¯ç¬¦å¼ç¨çåå®¹ï¼å°å¨éå½çä¸ä¸æä¸­æ¥æ¾æ è¯ç¬¦çå¶ä½é¨åãå·ä½è§åå¦ä¸: å±é¨åéãåæ°åç»å®åéãè¿äºæ¯x yåiå¨var x;ï¼... returns (y: int)ï¼forall i :: ... æ°æ®ç±»ååæ¨¡åå(å¦æè¿ä¸æ¯æ è¯ç¬¦çå¯ä¸é¨å)ãç±»åè®¸ä»¥è¿ç§æ¹å¼è®¿é®å®ä»¬çéææåï¼æ°æ®ç±»ååè®¸è®¿é®å®ä»¬çæé å½æ°ãæ¨¡ååè®¸åè¿æ ·å¼ç¨å®ä»¬çä»»ä½æå æé å½æ°åç§°(å¦ææ²¡ææ­§ä¹)ãä»»ä½ä¸éè¦éå®çæ°æ®ç±»å(å æ­¤æ°æ®ç±»ååç§°æ¬èº«ä¸éè¦åç¼)ï¼ä»¥åå·æå¯ä¸å½åæé å½æ°çæ°æ®ç±»åï¼é½å¯ä»¥éè¿å¶åç§°å¼ç¨ãæä»¥å¦ædatatype List = Cons(List) | Nilæ¯å¯ä¸å£°æÂ ConsåNilæé å½æ°çæ°æ®ç±»åï¼é£ä¹ä½ å¯ä»¥åCons(Cons(Nil))ãå¦ææé å½æ°åä¸æ¯å¯ä¸çï¼åéè¦å¨å¶åé¢å ä¸æ°æ®ç±»åçåç§°(ä¾å¦List.Cons(List.Nil))ãè¿æ¯æ¯ä¸ªæé å½æ°å®æçï¼èä¸æ¯æ¯ä¸ªæ°æ®ç±»åã å½åç±»çå­æ®µãå½æ°åæ¹æ³(å¦æå¨éæä¸ä¸æä¸­ï¼ååªåè®¸éææ¹æ³åå½æ°)ãæ¨å¯ä»¥è¿æ ·å¼ç¨å½åç±»çå­æ®µthis.fæèfï¼å½ç¶åè®¾fæ²¡æè¢«ä¸é¢çä»»ä½ä¸ä¸ªéèãå¦æéè¦ï¼æ¨æ»æ¯å¯ä»¥å ä¸åç¼thisï¼ä½ä¸è½éèå®ã(æ³¨æï¼åç§°æ¯æ°å­å­ç¬¦ä¸²çå­æ®µå¿é¡»æ»æ¯æä¸äºåç¼ã) å°é­æ¨¡åä¸­çéæå½æ°åæ¹æ³ãæ³¨æï¼è¿åªå¼ç¨å¨æ¨¡åçº§å£°æçå½æ°åæ¹æ³ï¼èä¸æ¯å½åç±»çéææåã æå¼çæ¨¡åå¨æ¯ä¸å±å¤çï¼å¨å½åæ¨¡åçå£°æä¹åãæå¼çæ¨¡ååªå½±åæ­¥éª¤2ã3å5ãå¦æåç°ææ­§ä¹çåç§°ï¼å°çæä¸ä¸ªéè¯¯ï¼èä¸æ¯ç»§ç»­æ²¿çåè¡¨åä¸ãå¨ç¬¬ä¸ä¸ªæ è¯ç¬¦ä¹åï¼è§ååºæ¬ä¸æ¯ç¸åçï¼é¤äºå¨æ°çä¸ä¸æä¸­ãä¾å¦ï¼å¦æç¬¬ä¸ä¸ªæ è¯ç¬¦æ¯ä¸ä¸ªæ¨¡åï¼é£ä¹ä¸ä¸ä¸ªæ è¯ç¬¦å°æ¥çè¯¥æ¨¡åãæå¼çæ¨¡ååªéç¨äºå®è¢«æå¼çæ¨¡åãå¨æ¥æ¾å¦ä¸ä¸ªæ¨¡åæ¶ï¼åªèèå¨è¯¥æ¨¡åä¸­æ¾å¼å£°æçåå®¹ã",normalizedContent:"# æ¨¡å\n\n\n# ä»ç»\n\nå°ç¨åºåè§£æå¤ä¸ªé¨åæ¥æé å®æ¯åå»ºå¤§åç¨åºçéè¦é¨åãå¨dafnyä¸­ï¼è¿æ¯éè¿æ¨¡åå®ç°çãæ¨¡åæä¾äºä¸ç§å°ç¸å³ç±»åãç±»ãæ¹æ³ãå½æ°åå¶ä»æ¨¡åç»åå¨ä¸èµ·çæ¹æ³ï¼ä»¥åæ§å¶å£°æçä½ç¨åãæ¨¡åå¯ä»¥ç¸äºå¯¼å¥ä»¥å®ç°ä»£ç éç¨ï¼å¹¶ä¸å¯ä»¥å¯¹æ¨¡åè¿è¡æ½è±¡ä»¥å°å®ç°ä¸æ¥å£åç¦»ã\n\n\n# å£°ææ°æ¨¡å\n\ndeclaring new moduleså£°ææ°æ¨¡å ä¸ä¸ªæ°æ¨¡åæ¯ç¨moduleå³é®å­å£°æçï¼åé¢è·çæ°æ¨¡åçåå­ï¼è¿æä¸å¯¹æ¬ä½æ¨¡åä¸»ä½çè±æ¬å·({}):\n\nmodule mod {\n  ...\n}\n\n\n1\n2\n3\n\n\næ¨¡åä¸»ä½å¯ä»¥åå«ä»»ä½å¯ä»¥æ¾å¨é¡¶å±çåå®¹ãè¿åæ¬ç±»ãæ°æ®ç±»åãç±»åãæ¹æ³ãå½æ°ç­ã\n\nmodule mod {\n  class c {\n    var f: int;\n    method m()\n  }\n  datatype option = a(int) | b(int)\n  type t\n  method m()\n  function f(): int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä½ ä¹å¯ä»¥å°ä¸ä¸ªæ¨¡ååµå¥å°å¦ä¸ä¸ªæ¨¡åä¸­:\n\nmodule mod {\n  module helpers {\n    class c {\n      method doit()\n      var f: int;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç¶åï¼ä½ å¯ä»¥å¨modæ¨¡åä¸­å¼ç¨helpersæ¨¡åçæåï¼æ¹æ³æ¯å¨å®ä»¬åé¢å ä¸\" helpers \"ãä¾å¦:\n\nmodule mod {\n  module helpers {\n    class c {\n      method doit()\n      var f: int;\n    }\n  }\n  method m() {\n    var x := new helpers.c;\n    x.doit();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmodule mod {\n  module helpers { ... }\n  method m() {\n    var x := new helpers.c;\n    x.doit();\n    x.f := 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¨æ¨¡åçº§å«å®ä¹çæ¹æ³åå½æ°å¯ä»¥åç±»ä¸æ ·ä½¿ç¨ï¼åªæ¯æ¨¡ååä½ä¸ºåç¼ãå®ä»¬ä¹å¯ä»¥å¨åä¸ä¸ªæ¨¡åä¸­çç±»çæ¹æ³åå½æ°ä¸­ä½¿ç¨ã\n\nmodule mod {\n  module helpers {\n    function method addone(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := helpers.addone(x); // x is now 6\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\né»è®¤æåµä¸ï¼å½æ°(åè°è¯)çå®ä¹å¨å®ä¹å®ä»¬çæ¨¡åå¤é¨å¬å¼ãè¿å¯ä»¥éè¿å¯¼åºéè¿è¡æ´ç²¾ç¡®çæ§å¶ï¼æä»¬å°å¨ä¸ä¸èä¸­çå°ãæä»¥å¢å \n\nmodule mod {\n  module helpers {\n    function method addone(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := helpers.addone(x);\n    assert x == 6; // this will succeed\n  }\n}\n\n  assert x == 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä»¥m()ç»å°¾å°è¿è¡éªè¯ã\n\n\n# å¯¼å¥åå¯¼åºæ¨¡å\n\nå£°ææ°çå­æ¨¡åæ¯æç¨çï¼ä½ææ¶æ¨å¸æå¼ç¨æ¥èªç°ææ¨¡åçåå®¹ï¼æ¯å¦åºãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥å°ä¸ä¸ªæ¨¡åå¯¼å¥å¦ä¸ä¸ªæ¨¡åãè¿æ¯éè¿importå³é®å­å®æçï¼æå ç§ä¸åçå½¢å¼ï¼æ¯ä¸ç§é½æä¸åçå«ä¹ãæç®åçå½¢å¼æ¯å·ä½çå¯¼å¥,å¯¼å¥å½¢å¼a = bè¿ä¸ªæ¨¡åå£°æåå»ºä¸ä¸ªå¼ç¨b(å¿é¡»å·²ç»å­å¨),å¹¶ç»åæ°åç§°æ³¨æè¿ä¸ªæ°åç§°,ä¾å¦Â a,,åªæç»å®æ¨¡ååå«å¯¼å¥å£°æ;å®ä¸ä¼åå»ºå¨å±å«åãä¾å¦ï¼å¦æhelperæ¯å¨modä¹å¤å®ä¹çï¼é£ä¹æä»¬å¯ä»¥å¯¼å¥å®:\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule mod {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6;\n  }\n}\n\nmodule helpers {\n  ...\n}\nmodule mod {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\næ³¨æï¼å¨m()ä¸­ï¼æä»¬å¿é¡»ä½¿ç¨aèä¸æ¯helperï¼å ä¸ºæä»¬å°å®ç»å®å°ä¸ä¸ªä¸åçåç§°ãåç§°helperså¨m()ä¸­ä¸å¯ç¨ï¼å ä¸ºåªæå¨modä¸­ç»å®çåç§°æå¯ç¨ãä¸ºäºä½¿ç¨æ¥èªå¦ä¸ä¸ªæ¨¡åçæåï¼å®è¦ä¹å¿é¡»ç¨moduleå£°æï¼è¦ä¹ç¨importå¯¼å¥ã\n\nä¸è¿ï¼å¦ææä»¬ä¸æ³ç»helpersèµ·ä¸ªæ°åå­ï¼ä¹ä¸å¿ãå¦æéè¦ï¼å¯ä»¥ç¼åimport helpers = helpers, dafnyçè³ä¸ºè¿ç§è¡ä¸ºæä¾äºç®ä¾¿çimport helpersãæ¨ä¸è½åæ¶ç»å®ä¸¤ä¸ªå·æç¸ååç§°çæ¨¡åï¼å æ­¤ææ¶å¿é¡»ä½¿ç¨= çæ¬å·ä»¥ç¡®ä¿åç§°ä¸ä¼å²çªã\n\n\n# å¯¼åºéå\n\né»è®¤æåµä¸ï¼å¯¼å¥importå°åè®¸è®¿é®è¢«å¯¼å¥æ¨¡åçææå£°æ(åå¶å®ä¹)ãä¸ºäºæ´ç²¾ç¡®å°æ§å¶è¿ä¸ç¹ï¼æä»¬å¯ä»¥ä½¿ç¨å¯¼åºexportéãæ¯ä¸ªå¯¼åºexportéå¯è½æå½åæ¨¡åçå£°æåè¡¨ï¼ä»¥providesærevealsçå½¢å¼ç»åºãæ²¡æåç§°çå¯¼åºexportè¢«è®¤ä¸ºæ¯è¯¥æ¨¡åçé»è®¤å¯¼åºï¼å¹¶ä¸å¨æ²¡ææ¾å¼å½åéåæ¶ä½¿ç¨ã\n\nmodule helpers {\n  export spec provides addone, addone_result\n  export body reveals addone\n  export extends spec\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addone_result(n : nat)\n     ensures addone(n) == n + 1\n  { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå¨è¿ä¸ªä¾å­ä¸­ï¼æä»¬å£°æäº3ä¸ªå¯¼åºéï¼specÂ éæäºäºå¯¹addoneå½æ°çè®¿é®æï¼ä½æ¯ç±äºå®æ¯ç¨provideså£°æçï¼æä»¥å®æ²¡ææäºå¯¹å¶å®ä¹çè®¿é®æãbodyå¯¼åºéå°addoneå£°æä¸ºrevealsï¼ç°å¨å¯ä»¥è®¿é®addoneçbdoyé¨åãæåï¼é»è®¤å¯¼åºä½ä¸ºspecçæ©å±extendsç»åºï¼è¿è¡¨æå®åªæ¯ç»åºspecæå£°æçææå¯¼åºã\n\næä»¬ç°å¨å¯ä»¥å¨å¯¼å¥helperæ¶éæ©è¿äºå¯¼åºéä¸­çä»»ä½ä¸ä¸ªï¼å¹¶è·å¾å®çä¸åè§å¾ã\n\nmodule helpers {\n  export spec provides addone, addone_result\n  export body reveals addone\n  export extends spec\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n  lemma addone_result(n: nat)\n     ensures addone(n) == n + 1\n  { }\n}\n\nmodule mod1 {\n  import a = helpers`body\n  method m() {\n    assert a.addone(5) == 6; // succeeds, we have access to addone's body\n  }\n  method m2() {\n    //a.addone_result(5); // error, addone_result is not exported from body\n    assert a.addone(5) == 6;\n  }\n}\nmodule mod2 {\n  import a = helpers`spec\n  method m() {\n    assert a.addone(5) == 6; // fails, we don't have addone's body\n  }\n  method m2() {\n    a.addone_result(5);\n    assert a.addone(5) == 6; // succeeds due to result from addone_result\n  }\n}\nmodule mod3 {\n  import a = helpers\n  method m() {\n    assert a.addone(5) == 6; // fails, we don't have addone's body\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\næä»¬è¿å¯ä»¥ä½¿ç¨å¯¼åºéexportÂ setsÂ æ¥æ§å¶å¯ç¨çç±»åå®ä¹ãææç±»åå£°æ(å¦newtypeãtypeãdatatypeç­)é½å¯ä»¥å¯¼åºä¸ºæä¾providesææ¾ç¤ºãå¨åä¸ç§æåµä¸ï¼å¯¼å¥è¯¥ç±»åçæ¨¡åå°å¶è§ä¸ºä¸éæç±»åã\n\nmodule helpers {\n  export provides f, t\n  export body reveals f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  import a = helpers\n  function g(): a.t { 0 } // error, t is not known to be int, or even numeric\n  function h(): a.t { a.f() } // okay\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸æ¦å¯¼å¥exportäºæ¾ç¤ºrevealsä»¥åä¸éæç±»åçå¯¼åºï¼åå·²ç¥å¯¹å®çææç°æä½¿ç¨é½æ¯åé¨ç±»åã\n\nmodule helpers {\n  export provides f, t\n  export body reveals f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\nmodule mod2 {\n  import m = mod\n  import a = helpers`body\n  function j(): int\n    ensures j() == 0 //succeeds\n  { m.h() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nä½ä¸ºä¸ç§æ¹ä¾¿çç®åæ¹å¼ï¼ç¹æ®æ è¯ç¬¦â*âå¯ä»¥å¨æä¾providesææ­ç¤ºrevealsä¹åç»åºï¼ä»¥è¡¨ç¤ºææå£°æé½åºè¯¥æä¾ææ­ç¤ºã\n\nmodule a {\n   export all reveals * // reveals t, f, g\n   export spec provides * // provides t, f, g\n   export some provides * reveals g // provides t, f reveals g\n   type t = int\n   function f(): t { 0 }\n   function g(): int { 2 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\næä»¬è¿å¯ä»¥ä¸æ¬¡æä¾å¤ä¸ªå¯¼åºæ¥åå»ºä¸ä¸ªèåå¯¼å¥(aggregateÂ import).\n\nmodule a {\n  export justf reveals f\n  export justt reveals t\n  type t = int\n  function f(): int { 0 }\n}\nmodule b {\n  import a`{justf,justt}\n  function g(): a.t { a.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# å¯¼åºä¸è´æ§\n\nå¯¼åºé(exportÂ set)å¿é¡»å§ç»åç°æ¨¡åçä¸è´è§å¾:ä»»ä½åºç°å¨å¯¼åºå£°æä¸­çåå®¹é½å¿é¡»è¢«å¯¼åºãåé¡¾åé¢çç¤ºä¾ï¼æä»¬ä¸è½åå»ºä¸ä¸ªæ¢æ¾ç¤ºf(revealsÂ f)åæ¾ç¤ºtçå¯¼åºéexportÂ setãåå å¾ç®åï¼æä»¬å°åå»ºä¸ä¸ªç±»åçº¦æ0:tï¼å¦ætæ¯ä¸éæçï¼åæ æ³è§£å³è¿ä¸ªçº¦æãç±»ä¼¼å°ï¼å¦æä¸æä¾tï¼åä¸è½åå»ºæä¾providesææ­ç¤ºf revealsÂ fçå¯¼åºéã\n\nmodule helpers {\n  export provides f, t // good\n  export body reveals f, t // good\n  export badspec reveals f, provides t // bad\n  export badspec2 provides f // bad\n  type t = int\n  function f(): t { 0 }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç±äºæä»¬å¯ä»¥å®ä¹åæ¶åå«å¯¼å¥importåå¯¼åºexportå£°æçæ¨¡åï¼å æ­¤æä»¬å¯è½éè¦ä»å¤é¨æ¨¡åå¯¼åºå£°æï¼ä»¥åå»ºä¸è´çå¯¼åºéexport setãå¤é¨æ¨¡åçå£°æä¸è½ç´æ¥åå«å¨å¯¼åºexportä¸­ï¼ä½æ¯æä¾å®ä»¬çå¯¼å¥importå¯ä»¥ã\n\nmodule helpers {\n  export provides f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  export try1 reveals h // error\n  export try2 reveals h, provides a.f, a.t // error, can't provide these directly\n  export reveals h, provides a // good\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå½å¯¼å¥modæ¶ï¼æä»¬ç°å¨ä¹è·å¾äºå¯¹å¶å¯¼å¥a import aä¸­ææä¾çåå®¹çåæ ¼è®¿é®æãæä»¬ä¹å¯ä»¥éæ©ç´æ¥å¯¼å¥è¿äºåå®¹ï¼ç»å®ä»¬ä¸ä¸ªæ´ç­çåç§°ã\n\nmodule helpers {\n  export provides f, t\n  type t = int\n  function f(): t { 0 }\n}\nmodule mod {\n  export reveals h, provides a\n  import a = helpers\n  function h(): a.t { a.f() }\n}\n\nmodule mod2 {\n  import m = mod\n  import ma = m.a\n  function j(): m.a.t { m.h() }\n  function k(): ma.t { j() }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# å¼æ¾æ¨¡æ¿\n\nææ¶ï¼ä¸ºå¯¼å¥çæ¨¡åçæåå ä¸åç§°åç¼æ¯ä¹å³ä¸é¾ççï¼å³ä½¿æ¨å¨å¯¼å¥æ¶éæ©äºä¸ä¸ªç®ç­çåç§°ãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥å°æ¨¡åå¯¼å¥ä¸ºâopenedâï¼è¿å°ä½¿å¶æææåé½å¯ç¨ï¼èæ éæ·»å æ¨¡ååç§°ãopenedå³é®å­å¿é¡»ç´§è·å¨importä¹åï¼å¦æå®å­å¨çè¯ãä¾å¦ï¼æä»¬å¯ä»¥å°åé¢çaddoneç¤ºä¾åä¸º:\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\n\nmodule mod {\n  import opened helpers\n  method m() {\n    assert addone(5) == 6;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå½æå¼æ¨¡åæ¶ï¼æ°ç»å®çæåå°å·æè¾ä½çä¼åçº§ï¼å æ­¤å®ä»¬å°è¢«å±é¨å®ä¹éèãè¿æå³çï¼å¦ææ¨å®ä¹äºä¸ä¸ªåä¸ºaddoneçå±é¨å½æ°ï¼åhelperä¸­çå½æ°å°ä¸åä»¥è¯¥åç§°æä¾ãå½æ¨¡åè¢«æå¼æ¶ï¼åå§çåç§°ç»å®ä»ç¶å­å¨ï¼æä»¥æ¨æ»æ¯å¯ä»¥ä½¿ç¨ç»å®çåç§°æ¥è·åä»»ä½éèçåå®¹ã\n\nmodule helpers {\n  function method addone(n: nat): nat\n  {\n    n + 1\n  }\n}\nmodule mod {\n  import opened helpers\n  function addone(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addone(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert helpers.addone(5) == 6; // this is still true\n  }\n}\n\nmodule mod {\n  import opened helpers\n  function addone(n: nat): nat {\n    n + 2\n  }\n  method m() {\n    assert addone(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert helpers.addone(5) == 6; // this is still true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nå¦ææå¼ä¸¤ä¸ªé½å£°æå·æç¸ååç§°çæåçæ¨¡åï¼é£ä¹å¨æ²¡ææ¨¡ååç¼çæåµä¸ï¼è¿ä¸¤ä¸ªæåé½ä¸è½è¢«å¼ç¨ï¼å ä¸ºåªä¸ªæåçå«ä¹æ¯ä¸æç¡®çãä¸è¿ï¼åªè¦æ¨ä¸è¯å¾ä½¿ç¨å·æå±ååç§°çæåï¼ä»ä»æå¼è¿ä¸¤ä¸ªæ¨¡åå°±ä¸ä¼åºç°éè¯¯ãopenedå³é®å­å¯ä»¥ç¨äºä»»ä½ç±»åçå¯¼å¥importå£°æï¼åæ¬æ¨¡åæ½è±¡å½¢å¼ã\n\n\n# æ½è±¡æ¨¡å\n\nææ¶ï¼ä½¿ç¨ç¹å®çå®ç°æ¯ä¸å¿è¦ç;ç¸åï¼æéè¦çåªæ¯ä¸ä¸ªå®ç°æäºæ¥å£çæ¨¡åãå¨è¿ç§æåµä¸ï¼æ¨å¯ä»¥ä½¿ç¨æ½è±¡æ¨¡åå¯¼å¥ãå¨dafny,è¿æ¯åimport a : b.ãè¿æå³çç»å®åç§°a,èæ¯å¾å°ç¡®åçæ¨¡åb,ä½ å¾å°ä»»ä½æ¨¡åçç»åb .éå¸¸æåµä¸,æ¨¡åbå¯è½æ½è±¡ç±»åå®ä¹,åå«è±èæ¹æ³çç±»,æèç´æ¥ä¸éåä½¿ç¨ãç±äºç»åçå®ä¹æ¹å¼ï¼bçä»»ä½ç»åé½å¯ä»¥å®å¨å°ä½¿ç¨ãä¾å¦ï¼å¦ææä»¬ä»¥:\n\nabstract module interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) > n\n}\nabstract module mod {\n  import a : interface\n  method m() {\n    assert 6 <= a.addsome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nå¦ææä»¬ç¥éaddsomeå®éä¸æ­£å¥½å äº1ï¼æä»¬å°±å¯ä»¥æ´ç²¾ç¡®äºãä¸é¢çæ¨¡åå·æè¿ç§è¡ä¸ºãæ­¤å¤ï¼åç½®æ¡ä»¶æ´å¼ºï¼å æ­¤è¿å®éä¸æ¯å¯¹interfaceæ¨¡åçæ¹è¿ã\n\nmodule implementation refines interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) == n + 1\n  {\n    n + 1\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nç¶åï¼æä»¬å¯ä»¥å¨ä¸ä¸ªæ°çæ¨¡åä¸­ç¨implementationä»£æ¿aï¼éè¿å£°æmodçç²¾ç¼ï¼å®å®ä¹äºaçimplementationã\n\nabstract module interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) > n\n}\nabstract module mod {\n  import a : interface\n  method m() {\n    assert 6 <= a.addsome(5);\n  }\n}\nmodule implementation refines interface {\n  function method addsome(n: nat): nat\n    ensures addsome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule mod2 refines mod {\n  import a = implementation\n  method m() {\n    ...;\n    // this is now provable, because we know a is implementation\n    assert 6 == a.addsome(5);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nå½ä½ å°ä¸ä¸ªæ½è±¡å¯¼å¥ç»åå°ä¸ä¸ªå·ä½çå¯¼å¥æ¶ï¼å·ä½æ¨¡åå¿é¡»æ¯æ½è±¡æ¨¡åçæ¾å¼ç»å(ä¾å¦ï¼ç¨refineså£°æ)ã\n\n\n# æ¨¡åæåºåä¾èµå³ç³»\n\ndafnyå¹¶ä¸ç¹å«å³æ³¨æ¨¡ååºç°çé¡ºåºï¼ä½å®ä»¬å¿é¡»éµå¾ªä¸äºè§åæè½å½¢æè¯å¥½çç»æãä½ä¸ºä¸ä¸ªç»éªæ³åï¼åºè¯¥æä¸ç§æ¹æ³æ¥å¯¹ç¨åºä¸­çæ¨¡åè¿è¡æåºï¼ä»¥ä¾¿æ¯ä¸ªæ¨¡ååªå¼ç¨æºææ¬ä¸­å¨å®ä¹åå®ä¹çä¸è¥¿ãè¿å¹¶ä¸æå³çæ¨¡åå¿é¡»æè¿ä¸ªé¡ºåºæåãå¦æä½ æ²¡æåä»»ä½å¾ªç¯å¼ç¨ï¼dafnyä¼å¸®ä½ å¼æ¸æ¥é¡ºåºçãä¾å¦ï¼è¿æ¾ç¶æ¯«æ æä¹:\n\nimport a = b\nimport b = a\n\n\n1\n2\n\n\nä½ å¯ä»¥å¨é¡¶å±æimportè¯­å¥ï¼ä¹å¯ä»¥å¯¼å¥å¨åä¸å±å®ä¹çæ¨¡å:\n\nimport a = b\nmethod m() {\n  a.whatever();\n}\nmodule b {\n  method whatever() {}\n}\n\nimport a = b\nmethod m() {\n  a.whatever();\n}\nmodule b { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå¨æ¬ä¾ä¸­ï¼ææåå®¹é½å®ä¹å¾å¾å¥½ï¼å ä¸ºæä»¬å¯ä»¥åæ¾bï¼ç¶åæ¯aå¯¼å¥ï¼æåæ¯m()ãå¦ææ²¡æé¡ºåºï¼é£ä¹dafnyå°ç»åºä¸ä¸ªéè¯¯ï¼æ±æ¨å¾ªç¯ä¾èµå³ç³»ã è¯·æ³¨æï¼å½éæ°æåæ¨¡ååå¯¼å¥æ¶ï¼å®ä»¬å¿é¡»ä¿æå¨ç¸åçåå«æ¨¡åä¸­ï¼è¿å°±ä¸åè®¸ä¸äºçæçæ¨¡åç»æãæ­¤å¤ï¼å¯¼å¥åå­æ¨¡åæ»æ¯è¢«è®¤ä¸ºæ¯æåé¢çï¼å³ä½¿å¨é¡¶å±ä¹æ¯å¦æ­¤ãè¿æå³çä»¥ä¸åå®¹ä¸æ¯å¾å¥½çæ ¼å¼:\n\nmethod doit() { }\nmodule m {\n  method m() {\n    doit();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nå ä¸ºæ¨¡åmå¿é¡»åºç°å¨ä»»ä½å¶ä»ç±»åçæåä¹åï¼æ¯å¦æ¹æ³ãè¦åè¿æ ·å®ä¹å¨å±å½æ°ï¼æ¨å¯ä»¥å°å®ä»¬æ¾å¨ä¸ä¸ªæ¨¡å(æ¯å¦ç§°ä¸ºglobals)ä¸­ï¼å¹¶å°å¶æå¼å°ä»»ä½éè¦å¶åè½çæ¨¡åä¸­ãæåï¼å¦ææ¨éè¿è·¯å¾å¯¼å¥ï¼ä¾å¦import a = b.cé£ä¹è¿å°åå»ºaå¯¹bçä¾èµå³ç³»ï¼å ä¸ºæä»¬éè¦ç¥ébæ¯ä»ä¹(å®æ¯æ½è±¡çè¿æ¯å·ä½çï¼è¿æ¯ç»åç?)\n\n\n# åå­åè§£\n\n(å¾åäºé¡¹:ä»¥ä¸åå®¹å·²å¨dafnyæ´æ¹ãè¿éçæè¿°åºè¯¥æ¹åä»¥åæ æ°çè§åã)\n\nå½dafnyçå°åa.b.cè¿æ ·çä¸è¥¿æ¶ï¼å®æä¹ç¥éæ¯ä¸ªé¨åæçæ¯ä»ä¹?dafnyç¨æ¥ç¡®å®è¿æ ·çæ è¯ç¬¦åºåæå¼ç¨çæ¯åç§°è§£æãè½ç¶è§åå¯è½çèµ·æ¥å¾å¤æï¼ä½å®ä»¬éå¸¸é½ç¬¦åæ¨çé¢æãdafnyé¦åæ¥æ¾åå§æ è¯ç¬¦ãæ ¹æ®ç¬¬ä¸ä¸ªæ è¯ç¬¦å¼ç¨çåå®¹ï¼å°å¨éå½çä¸ä¸æä¸­æ¥æ¾æ è¯ç¬¦çå¶ä½é¨åãå·ä½è§åå¦ä¸: å±é¨åéãåæ°åç»å®åéãè¿äºæ¯x yåiå¨var x;ï¼... returns (y: int)ï¼forall i :: ... æ°æ®ç±»ååæ¨¡åå(å¦æè¿ä¸æ¯æ è¯ç¬¦çå¯ä¸é¨å)ãç±»åè®¸ä»¥è¿ç§æ¹å¼è®¿é®å®ä»¬çéææåï¼æ°æ®ç±»ååè®¸è®¿é®å®ä»¬çæé å½æ°ãæ¨¡ååè®¸åè¿æ ·å¼ç¨å®ä»¬çä»»ä½æå æé å½æ°åç§°(å¦ææ²¡ææ­§ä¹)ãä»»ä½ä¸éè¦éå®çæ°æ®ç±»å(å æ­¤æ°æ®ç±»ååç§°æ¬èº«ä¸éè¦åç¼)ï¼ä»¥åå·æå¯ä¸å½åæé å½æ°çæ°æ®ç±»åï¼é½å¯ä»¥éè¿å¶åç§°å¼ç¨ãæä»¥å¦ædatatype list = cons(list) | nilæ¯å¯ä¸å£°æÂ consånilæé å½æ°çæ°æ®ç±»åï¼é£ä¹ä½ å¯ä»¥åcons(cons(nil))ãå¦ææé å½æ°åä¸æ¯å¯ä¸çï¼åéè¦å¨å¶åé¢å ä¸æ°æ®ç±»åçåç§°(ä¾å¦list.cons(list.nil))ãè¿æ¯æ¯ä¸ªæé å½æ°å®æçï¼èä¸æ¯æ¯ä¸ªæ°æ®ç±»åã å½åç±»çå­æ®µãå½æ°åæ¹æ³(å¦æå¨éæä¸ä¸æä¸­ï¼ååªåè®¸éææ¹æ³åå½æ°)ãæ¨å¯ä»¥è¿æ ·å¼ç¨å½åç±»çå­æ®µthis.fæèfï¼å½ç¶åè®¾fæ²¡æè¢«ä¸é¢çä»»ä½ä¸ä¸ªéèãå¦æéè¦ï¼æ¨æ»æ¯å¯ä»¥å ä¸åç¼thisï¼ä½ä¸è½éèå®ã(æ³¨æï¼åç§°æ¯æ°å­å­ç¬¦ä¸²çå­æ®µå¿é¡»æ»æ¯æä¸äºåç¼ã) å°é­æ¨¡åä¸­çéæå½æ°åæ¹æ³ãæ³¨æï¼è¿åªå¼ç¨å¨æ¨¡åçº§å£°æçå½æ°åæ¹æ³ï¼èä¸æ¯å½åç±»çéææåã æå¼çæ¨¡åå¨æ¯ä¸å±å¤çï¼å¨å½åæ¨¡åçå£°æä¹åãæå¼çæ¨¡ååªå½±åæ­¥éª¤2ã3å5ãå¦æåç°ææ­§ä¹çåç§°ï¼å°çæä¸ä¸ªéè¯¯ï¼èä¸æ¯ç»§ç»­æ²¿çåè¡¨åä¸ãå¨ç¬¬ä¸ä¸ªæ è¯ç¬¦ä¹åï¼è§ååºæ¬ä¸æ¯ç¸åçï¼é¤äºå¨æ°çä¸ä¸æä¸­ãä¾å¦ï¼å¦æç¬¬ä¸ä¸ªæ è¯ç¬¦æ¯ä¸ä¸ªæ¨¡åï¼é£ä¹ä¸ä¸ä¸ªæ è¯ç¬¦å°æ¥çè¯¥æ¨¡åãæå¼çæ¨¡ååªéç¨äºå®è¢«æå¼çæ¨¡åãå¨æ¥æ¾å¦ä¸ä¸ªæ¨¡åæ¶ï¼åªèèå¨è¯¥æ¨¡åä¸­æ¾å¼å£°æçåå®¹ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"éå",frontmatter:{title:"éå",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/b9300a/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/10.%E9%9B%86%E5%90%88.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/10.éå.md",key:"v-51317608",path:"/pages/b9300a/",headersStr:null,content:"# éå\n\nç¬è®°\n\nåç§ç±»åçéåææäºDafnyéªè¯çæ ¸å¿å·¥å·ä¹ä¸ãéåè¡¨ç¤ºåç´ çæ åºéåï¼éåä¸­æ²¡æéå¤ãä¸åºåä¸æ ·ï¼éåä¹æ¯ä¸å¯åçå¼ç±»åãè¿ä½¿å¾å®ä»¬å¯ä»¥å¾å®¹æå°å¨æ³¨éä¸­ä½¿ç¨ï¼èä¸æ¶åå ï¼å ä¸ºsetä¸æ¦åå»ºå°±æ æ³ä¿®æ¹ãéåçç±»åä¸º:\n\n  set<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ç»æ´æ°ãéå¸¸ï¼éåå ä¹å¯ä»¥æ¯ä»»ä½ç±»åï¼åæ¬å¯¹è±¡ãå·ä½éåå¯ä»¥éè¿ä½¿ç¨æ¾ç¤ºç¬¦å·æ¥æå®:\n\nmethod m()\n{\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n}\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nä¾å­æ¼ç¤ºä¸­å±ç¤ºçsetæ­£æ¯æä»¬æ³è¦çï¼åªåå«æå®åç´ ãä¸é¢æä»¬è¿çå°ä¸ºéåå®ä¹äºç¸ç­ç¬¦å·ï¼å¦æä¸¤ä¸ªéåæå®å¨ç¸åçåç´ ï¼é£ä¹å®ä»¬å°±æ¯ç¸ç­çãä¹å¯ä»¥ä½¿ç¨éåè¿ç®ç¬¦ä»ç°æçéåå»ºæ°çé:\n\nmethod m()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n}\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næ³¨æï¼å ä¸ºéåä¸­çæå¤åªæä¸ä¸ªï¼ä¸è½éå¤ãæä»¥å¾å°çå¹¶éä¸ä¼å°éå¤åç´ è®¡æ°è¶è¿ä¸æ¬¡ãå¦æä¸¤ä¸ªéåé½æ¯æéçï¼é£ä¹éè¿è¿äºæä½ç¬¦å°å¾å°ä¸ä¸ªæééï¼ä¸è½çæä¸ä¸ªæ ééãä¸ç®æ¯è¿ç®ç¬¦ä¸åï¼éåè¿ç®ç¬¦é½æ¯æèªå·±å®ä¹çãé¤äºéå¸¸çéåæä½ç¬¦å¤ï¼è¿æä¸äºæ¯è¾æä½ç¬¦ï¼å®ä»¬éå¸¸å·æä»¥ä¸å«ä¹:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n}\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸åºåä¸æ ·ï¼éåä¹æ¯æinå!inæä½ç¬¦æ¥æµè¯åç´ çæåå³ç³»ãä¾å¦:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\néåç¨äºä¸äºæ³¨éï¼åæ¬è¯»ååä¿®æ¹å­å¥ãå¨æ¬ä¾ä¸­ï¼å®ä»¬å¯ä»¥æ¯ç¹å®å¯¹è±¡ç±»åçéå(å¦é¾è¡¨ä¸­çnodes)ï¼ä¹å¯ä»¥æ¯æ³åå¼ç¨ç±»åå¯¹è±¡objectçéåãå°½ç®¡å®çåå­æ¯è¿æ ·çï¼ä½å®å¯ä»¥æåä»»ä½å¯¹è±¡ææ°ç»ãè¿å¯¹äºå°å½æ°ææ¹æ³å¯è½è¯»åæåå¥çææä¸åç±»åçä½ç½®æç»å¨ä¸èµ·éå¸¸æç¨ã å¨decreaseså­å¥ä¸­ä½¿ç¨æ¶ï¼éåæçå­éæåºãè¦å¨decreaseså­å¥ä¸­ä½¿ç¨setï¼è¿ç»­çå¼å¨æç§æä¹ä¸å¿é¡»æ¯âç¸å³çâï¼è¿éå¸¸æå³çå®ä»¬æ¯éå½è®¡ç®çï¼æç±»ä¼¼çã æ¨å¯ä»¥éè¿å°ä¸ä¸ªéåä¸ç©ºéåè¿è¡æ¯è¾æ¥æµè¯å®æ¯å¦ä¸ºç©º(å½ä¸ä»å½sæ²¡æåç´ æ¶ï¼s =={}ä¸ºç)ã åå»ºéåçä¸ä¸ªæç¨æ¹æ³æ¯ä½¿ç¨set comprehensionãéè¿å°f(x)åå«å°æææ»¡è¶³p(x)çTç±»åçxçéåä¸­ï¼å®å®ä¹äºä¸ä¸ªæ°éå:\n\n   set x: T | p(x) :: f(x)\n\n\n1\n\n\nå®ä»¥ä¸ç§è®©äººæ³èµ·å¨ç§°éè¯(forall)çæ¹å¼æ¥å®ä¹éåãä¸éå®ç¬¦ä¸æ ·ï¼è¯¥ç±»åéå¸¸å¯ä»¥æ¨æ­åºæ¥ãä¸éè¯ç¸åï¼barè¯­æ³(|)éè¦å°è°è¯(p)ä¸ç»å®åé(x)åç¦»ãç»æéååç´ çç±»åæ¯f(x)çè¿åå¼çç±»åãæé çéåçå¼æ¯f(x)çè¿åå¼:xæ¬èº«åªåå½è°è¯påå½æ°fä¹é´çæ¡¥æ¢ãå®éå¸¸å·æä¸ç»æéç¸åçç±»åï¼ä½å®ä¸æ¯å¿é¡»è¦ç¸åãä½ä¸ºä¸ä¸ªä¾å­:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n}\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\nå¦æå½æ°æ¯æç­å¼ï¼é£ä¹è½ä»¥å¾ä¼ç¾çå½¢å¼ååºè¡¨è¾¾å¼\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¬çéåæ¨å¯¼ä¸­çéæç­å½æ°å®¹ææ··æ·Dafnyãä¾å¦ï¼ä»¥ä¸æ¯æ­£ç¡®çï¼ä½Dafnyæ æ³è¯æå®:\n\nmethod m()\n{\n   // assert {0*1, 1*1, 2*1} == {0,1,2};  // include this assertion as a lemma to prove the next line\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\nassert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n6\n\n\nä¸ºäºå¸®å©Dafnyè¯æè¿ä¸ªæ­è¨ï¼å¯ä»¥å¨å®åé¢å ä¸æ­è¨assert {0*1, 1*1, 2*1} == {0,1,2};è¿è®©Dafnyè§£å³äºä¸¤ä¸ªæ­è¨ã\n\nå¦ææ²¡æ³¨æï¼ç¨éåset comprehensionå°éåè§å®ä¸ºæ éæ°éçåç´ ï¼ä½éååªåè®¸ææéæ°éçåç´ ãä¾å¦ï¼å¦ææ¨å°è¯å°set x | x % 2 == 0ä½ä¸ºææå¶æ°çéåï¼é£ä¹æ¨å°å¾å°ä¸ä¸ªéè¯¯ã(å¦æä½ ççæ³è¦ä¸ä¸ªæ ééï¼å¯ä»¥ä½¿ç¨isetç±»åãä¾å¦ï¼iset x | x % 2 == 0å¨ghostç¯å¢ä¸­æ¯åæ³çã)ä¸ºäºç¡®ä¿éåæ¨å¯¼å¾å°æééåï¼Dafnyéç¨äºä¸äºå¯åå¼æ¹æ³ãåå»ºæ´æ°éæ¶ï¼å¯ä»¥éè¿å°æ´æ°éå®å¨è°è¯çè³å°ä¸ä¸ªè¿æ¥è¯ä¸­æ¥å®æ(ç±»ä¼¼äº0 <= x < n)æ¥å®ç°ãè¦æ±éå®åéå¨ç°æéåä¸­ä¹å¯ä»¥ï¼å¦ä¸é¢çx in {0,1,2}.",normalizedContent:"# éå\n\nç¬è®°\n\nåç§ç±»åçéåææäºdafnyéªè¯çæ ¸å¿å·¥å·ä¹ä¸ãéåè¡¨ç¤ºåç´ çæ åºéåï¼éåä¸­æ²¡æéå¤ãä¸åºåä¸æ ·ï¼éåä¹æ¯ä¸å¯åçå¼ç±»åãè¿ä½¿å¾å®ä»¬å¯ä»¥å¾å®¹æå°å¨æ³¨éä¸­ä½¿ç¨ï¼èä¸æ¶åå ï¼å ä¸ºsetä¸æ¦åå»ºå°±æ æ³ä¿®æ¹ãéåçç±»åä¸º:\n\n  set<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ç»æ´æ°ãéå¸¸ï¼éåå ä¹å¯ä»¥æ¯ä»»ä½ç±»åï¼åæ¬å¯¹è±¡ãå·ä½éåå¯ä»¥éè¿ä½¿ç¨æ¾ç¤ºç¬¦å·æ¥æå®:\n\nmethod m()\n{\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n}\n   var s1 := {}; // the empty set\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before\n   assert s1 != s2;  // sets with different elements are different\n   var s3, s4 := {1,2}, {1,4};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nä¾å­æ¼ç¤ºä¸­å±ç¤ºçsetæ­£æ¯æä»¬æ³è¦çï¼åªåå«æå®åç´ ãä¸é¢æä»¬è¿çå°ä¸ºéåå®ä¹äºç¸ç­ç¬¦å·ï¼å¦æä¸¤ä¸ªéåæå®å¨ç¸åçåç´ ï¼é£ä¹å®ä»¬å°±æ¯ç¸ç­çãä¹å¯ä»¥ä½¿ç¨éåè¿ç®ç¬¦ä»ç°æçéåå»ºæ°çé:\n\nmethod m()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n}\n   assert s2 + s4 == {1,2,3,4}; // set union\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection\n   assert s2 - s3 == {3}; // set difference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næ³¨æï¼å ä¸ºéåä¸­çæå¤åªæä¸ä¸ªï¼ä¸è½éå¤ãæä»¥å¾å°çå¹¶éä¸ä¼å°éå¤åç´ è®¡æ°è¶è¿ä¸æ¬¡ãå¦æä¸¤ä¸ªéåé½æ¯æéçï¼é£ä¹éè¿è¿äºæä½ç¬¦å°å¾å°ä¸ä¸ªæééï¼ä¸è½çæä¸ä¸ªæ ééãä¸ç®æ¯è¿ç®ç¬¦ä¸åï¼éåè¿ç®ç¬¦é½æ¯æèªå·±å®ä¹çãé¤äºéå¸¸çéåæä½ç¬¦å¤ï¼è¿æä¸äºæ¯è¾æä½ç¬¦ï¼å®ä»¬éå¸¸å·æä»¥ä¸å«ä¹:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n}\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset\n   assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸åºåä¸æ ·ï¼éåä¹æ¯æinå!inæä½ç¬¦æ¥æµè¯åç´ çæåå³ç³»ãä¾å¦:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\néåç¨äºä¸äºæ³¨éï¼åæ¬è¯»ååä¿®æ¹å­å¥ãå¨æ¬ä¾ä¸­ï¼å®ä»¬å¯ä»¥æ¯ç¹å®å¯¹è±¡ç±»åçéå(å¦é¾è¡¨ä¸­çnodes)ï¼ä¹å¯ä»¥æ¯æ³åå¼ç¨ç±»åå¯¹è±¡objectçéåãå°½ç®¡å®çåå­æ¯è¿æ ·çï¼ä½å®å¯ä»¥æåä»»ä½å¯¹è±¡ææ°ç»ãè¿å¯¹äºå°å½æ°ææ¹æ³å¯è½è¯»åæåå¥çææä¸åç±»åçä½ç½®æç»å¨ä¸èµ·éå¸¸æç¨ã å¨decreaseså­å¥ä¸­ä½¿ç¨æ¶ï¼éåæçå­éæåºãè¦å¨decreaseså­å¥ä¸­ä½¿ç¨setï¼è¿ç»­çå¼å¨æç§æä¹ä¸å¿é¡»æ¯âç¸å³çâï¼è¿éå¸¸æå³çå®ä»¬æ¯éå½è®¡ç®çï¼æç±»ä¼¼çã æ¨å¯ä»¥éè¿å°ä¸ä¸ªéåä¸ç©ºéåè¿è¡æ¯è¾æ¥æµè¯å®æ¯å¦ä¸ºç©º(å½ä¸ä»å½sæ²¡æåç´ æ¶ï¼s =={}ä¸ºç)ã åå»ºéåçä¸ä¸ªæç¨æ¹æ³æ¯ä½¿ç¨set comprehensionãéè¿å°f(x)åå«å°æææ»¡è¶³p(x)çtç±»åçxçéåä¸­ï¼å®å®ä¹äºä¸ä¸ªæ°éå:\n\n   set x: t | p(x) :: f(x)\n\n\n1\n\n\nå®ä»¥ä¸ç§è®©äººæ³èµ·å¨ç§°éè¯(forall)çæ¹å¼æ¥å®ä¹éåãä¸éå®ç¬¦ä¸æ ·ï¼è¯¥ç±»åéå¸¸å¯ä»¥æ¨æ­åºæ¥ãä¸éè¯ç¸åï¼barè¯­æ³(|)éè¦å°è°è¯(p)ä¸ç»å®åé(x)åç¦»ãç»æéååç´ çç±»åæ¯f(x)çè¿åå¼çç±»åãæé çéåçå¼æ¯f(x)çè¿åå¼:xæ¬èº«åªåå½è°è¯påå½æ°fä¹é´çæ¡¥æ¢ãå®éå¸¸å·æä¸ç»æéç¸åçç±»åï¼ä½å®ä¸æ¯å¿é¡»è¦ç¸åãä½ä¸ºä¸ä¸ªä¾å­:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n}\n   assert (set x | x in {0,1,2} :: x + 0) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\nå¦æå½æ°æ¯æç­å¼ï¼é£ä¹è½ä»¥å¾ä¼ç¾çå½¢å¼ååºè¡¨è¾¾å¼\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¬çéåæ¨å¯¼ä¸­çéæç­å½æ°å®¹ææ··æ·dafnyãä¾å¦ï¼ä»¥ä¸æ¯æ­£ç¡®çï¼ä½dafnyæ æ³è¯æå®:\n\nmethod m()\n{\n   // assert {0*1, 1*1, 2*1} == {0,1,2};  // include this assertion as a lemma to prove the next line\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\nassert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n\n\n1\n2\n3\n4\n5\n6\n\n\nä¸ºäºå¸®å©dafnyè¯æè¿ä¸ªæ­è¨ï¼å¯ä»¥å¨å®åé¢å ä¸æ­è¨assert {0*1, 1*1, 2*1} == {0,1,2};è¿è®©dafnyè§£å³äºä¸¤ä¸ªæ­è¨ã\n\nå¦ææ²¡æ³¨æï¼ç¨éåset comprehensionå°éåè§å®ä¸ºæ éæ°éçåç´ ï¼ä½éååªåè®¸ææéæ°éçåç´ ãä¾å¦ï¼å¦ææ¨å°è¯å°set x | x % 2 == 0ä½ä¸ºææå¶æ°çéåï¼é£ä¹æ¨å°å¾å°ä¸ä¸ªéè¯¯ã(å¦æä½ ççæ³è¦ä¸ä¸ªæ ééï¼å¯ä»¥ä½¿ç¨isetç±»åãä¾å¦ï¼iset x | x % 2 == 0å¨ghostç¯å¢ä¸­æ¯åæ³çã)ä¸ºäºç¡®ä¿éåæ¨å¯¼å¾å°æééåï¼dafnyéç¨äºä¸äºå¯åå¼æ¹æ³ãåå»ºæ´æ°éæ¶ï¼å¯ä»¥éè¿å°æ´æ°éå®å¨è°è¯çè³å°ä¸ä¸ªè¿æ¥è¯ä¸­æ¥å®æ(ç±»ä¼¼äº0 <= x < n)æ¥å®ç°ãè¦æ±éå®åéå¨ç°æéåä¸­ä¹å¯ä»¥ï¼å¦ä¸é¢çx in {0,1,2}.",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"åºå",frontmatter:{title:"åºå",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/cb3d21/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/15.%E5%BA%8F%E5%88%97.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/15.åºå.md",key:"v-3957ebbe",path:"/pages/cb3d21/",headersStr:null,content:"# åºå\n\nåºåæ¯ä¸ç§è¡¨ç¤ºæåºåè¡¨çåç½®Dafnyç±»åãå®ä»¬å¯ä»¥ç¨æ¥è¡¨ç¤ºè®¸å¤æåºéåï¼åæ¬åè¡¨ãéåãå æ ç­ãåºåæ¯ä¸ç§ä¸å¯åçå¼ç±»å:å®ä»¬ä¸æ¦åå»ºå°±ä¸è½è¢«ä¿®æ¹ãä»è¿ä¸ªæä¹ä¸è¯´ï¼å®ä»¬ç±»ä¼¼äºJavaåPythonç­è¯­è¨ä¸­çå­ç¬¦ä¸²ï¼åªæ¯å®ä»¬å¯ä»¥æ¯ä»»æç±»åçåºåï¼èä¸ä»ä»æ¯å­ç¬¦ãåºåç±»åå¦ä¸:\n\n   seq<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ä¸ªæ´æ°åºåãä¾å¦ï¼è¿ä¸ªå½æ°å°ä¸ä¸ªåºåä½ä¸ºåæ°:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\nåºåçé¿åº¦åæ|s|ï¼å¦ä¸éè¯æç¤ºãä½¿ç¨ä¸æ°ç»ç¸åçæ¹æ¬å·è¯­æ³è®¿é®åºåçç¹å®åç´ ãè¿è¯·æ³¨æï¼è¯¥å½æ°ä¸éè¦è¯»åå­å¥æ¥è®¿é®åºåãè¿æ¯å ä¸ºåºåä¸æ¯å­å¨å¨å ä¸ç;å®ä»¬æ¯å¼ï¼å æ­¤å½æ°å¨è®¿é®å®ä»¬æ¶ä¸éè¦å£°æãåºåæå¼ºå¤§çå±æ§æ¯æ³¨éåå½æ°å¯ä»¥åå»ºåæä½åºåãä¾å¦ï¼å¦ä¸ç§è¡¨ç¤ºæåºæ§çæ¹æ³æ¯éå½:å¦æç¬¬ä¸ä¸ªåç´ æ¯å¶ä»åç´ å°ï¼èå¶ä½åç´ é½å·²æåºï¼åæ´ä¸ªæ°ç»é½å·²æåº:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\nå¹´ä»£çç¬¦å·(1 . .æ¯å°åºååçãå®çæææ¯ä»ç¬¬ä¸ä¸ªåç´ å¼å§ï¼ååç´ ç´å°æåãè¿ä¸ä¼ä¿®æ¹sï¼å ä¸ºåºåæ¯ä¸å¯åçãç¸åï¼å®åå»ºäºä¸ä¸ªæ°çåºåï¼é¤äºç¬¬ä¸ä¸ªåç´ ä¹å¤ï¼ææåç´ é½æç¸åçé¡ºåºæåãè¿ç±»ä¼¼äºæ´æ°çå æ³ï¼å ä¸ºåå§å¼æ²¡ææ¹åï¼åªæ¯åå»ºäºæ°çå¼ãåçè¡¨ç¤ºæ³æ¯:\n\n   s[i..j]\n\n\n1\n\n\nå¨0 <= i <= j <= |s|è¿ä¸ªèå´ä¸­Dafnyå°å¼ºå¶æ§è¡è¿äºç´¢å¼è¾¹çãç»æåºåå°æ°å¥½æj-iåç´ ï¼å¹¶ä¸å°ä»åç´ s[i]å¼å§ï¼å¦æç»æéç©ºï¼åå°è¿ç»­å°éååºåãè¿æå³çç´¢å¼jå¤çåç´ è¢«æé¤å¨åçä¹å¤ï¼è¿åæ äºç¨äºå¸¸è§ç´¢å¼çç¸åçåå¼åºé´ã\n\nåºåä¹å¯ä»¥ä½¿ç¨æ¾ç¤ºè¡¨ç¤ºæ³ä»å¶åç´ æé :\n\n var s := [1, 2, 3];\n\n\n1\n\n\nå¨è¿éï¼æä»¬å¨ä¸äºå½ä»¤å¼ä»£ç ä¸­æä¸ä¸ªæ´æ°åºååéï¼å¶ä¸­åå«åç´ 1ã2å3ãè¿éä½¿ç¨äºç±»åæ¨æ­æ¥è·å¾åºåæ¯æ´æ°ä¹ä¸çäºå®ãè¿ç§è¡¨ç¤ºæ³åè®¸æä»¬æé ç©ºåºåååä¾åºå:\n\n[] // the empty sequence, which can be a sequence of any type\n   [true] // a singleton sequence of type seq<bool>\n\n\n1\n2\n\n\nåçè¡¨ç¤ºæ³åæ¾ç¤ºè¡¨ç¤ºæ³å¯ä»¥ç¨æ¥æ£æ¥åºåçå±æ§:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // the whole sequence\n}\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nå°ç®åä¸ºæ­¢ï¼å¯¹åºåæå¸¸è§çæä½æ¯è·åç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ï¼ä»¥åè·åé¤ç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ä»¥å¤çææåç´ ï¼å ä¸ºè¿äºéå¸¸ç¨äºéå½å½æ°ï¼å¦ä¸é¢çsorted2ãé¤äºéè¿è®¿é®æåçæ¥è§£æåºåå¤ï¼åºåè¿å¯ä»¥ä½¿ç¨å å·(+)è¿è¡è¿æ¥: ä½æ¯Z3å®çè¯æèä¸ä¼æè¯å°è¿ä¸ç¹ï¼é¤éå®è¢«ä¸ä¸ªå£°æäºå®çæ­è¨æç¤º(å³äºä¸ºä»ä¹è¿æ¯å¿è¦çæ´å¤ä¿¡æ¯ï¼è¯·åéå¼ç/å½çº³æ³)ã åºåè¿æ¯æinå!inæä½ç¬¦ï¼ç¨äºæµè¯åºåä¸­çåå«æåµ:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¿è¿åè®¸æä»¬å¨ä¸å³å¿ç´¢å¼çæåµä¸ï¼å¯¹åºåä¸­çåç´ è¿è¡éåãä¾å¦ï¼æä»¬å¯ä»¥è¦æ±ä¸ä¸ªåºååªåå«è¯¥åºåçä¸æ åç´ :\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿æ¯åºåä¸­æ¯ä¸ªåç¬åç´ çå±æ§ãå¦ææä»¬æ³è®©å¤ä¸ªåç´ ç¸äºå³èï¼å°±éè¦éåææ ï¼å¦ç¬¬ä¸ä¸ªä¾å­æç¤ºã\n\nææ¶æä»¬æ³ä½¿ç¨åºåæ¥æ¨¡ææ°ç»çå¯æ´æ°ç¹æ§ãè½ç¶æä»¬ä¸è½æ¹ååæ¥çåºåï¼ä½æä»¬å¯ä»¥åå»ºä¸ä¸ªæ°åºåï¼å¶ä¸­é¤äºæ´æ°çåç´ å¤ï¼ææåç´ é½æ¯ç¸åç:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\nå½ç¶ï¼ä¸æ iå¿é¡»æ¯æ°ç»çä¸æ ãè¿ä¸ªè¯­æ³åªæ¯å¯ä»¥éè¿å¸¸è§åçåè®¿é®æä½å®æçæä½çå¿«æ·æ¹å¼ãä½ è½å¡«åä¸é¢çä»£ç å?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // This works by concatenating everything that doesn't\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ ä¹å¯ä»¥ç¨æ°ç»çåç´ ç»æä¸ä¸ªåºåãè¿æ¯ä½¿ç¨ä¸ä¸é¢ç¸åçâsliceâè¡¨ç¤ºæ³å®æç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè·å¾æ°ç»çä¸é¨åï¼å¯ä»¥åå¸¸è§åçæä½ä¸æ ·ç»åºè¾¹ç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå ä¸ºåºåæ¯æinå!inï¼è¿ä¸ªæä½ä¸ºæä»¬æä¾äºä¸ç§ç®åçæ¹æ³æ¥è¡¨ç¤ºâelement not in arrayâå±æ§ï¼å³å°è¿ä¸ªè½¬åä¸º\n\nforall k :: 0 <= k < a.Length ==> elem != a[k]\n\n\n1\n\n\nè¿ä¸ªï¼\n\nelem !in a[..]\n\n\n1\n\n\næ­¤å¤ï¼è¾¹çå¾å®¹æåæ¬:\n\nforall k :: 0 <= k < i ==> elem != a[k]\n\n\n1\n\n\nåä»¥ä¸è¿ä¸ªæ¯ä¸æ ·çï¼\n\nelem !in a[..i]\n\n\n1\n",normalizedContent:"# åºå\n\nåºåæ¯ä¸ç§è¡¨ç¤ºæåºåè¡¨çåç½®dafnyç±»åãå®ä»¬å¯ä»¥ç¨æ¥è¡¨ç¤ºè®¸å¤æåºéåï¼åæ¬åè¡¨ãéåãå æ ç­ãåºåæ¯ä¸ç§ä¸å¯åçå¼ç±»å:å®ä»¬ä¸æ¦åå»ºå°±ä¸è½è¢«ä¿®æ¹ãä»è¿ä¸ªæä¹ä¸è¯´ï¼å®ä»¬ç±»ä¼¼äºjavaåpythonç­è¯­è¨ä¸­çå­ç¬¦ä¸²ï¼åªæ¯å®ä»¬å¯ä»¥æ¯ä»»æç±»åçåºåï¼èä¸ä»ä»æ¯å­ç¬¦ãåºåç±»åå¦ä¸:\n\n   seq<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ä¸ªæ´æ°åºåãä¾å¦ï¼è¿ä¸ªå½æ°å°ä¸ä¸ªåºåä½ä¸ºåæ°:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\nåºåçé¿åº¦åæ|s|ï¼å¦ä¸éè¯æç¤ºãä½¿ç¨ä¸æ°ç»ç¸åçæ¹æ¬å·è¯­æ³è®¿é®åºåçç¹å®åç´ ãè¿è¯·æ³¨æï¼è¯¥å½æ°ä¸éè¦è¯»åå­å¥æ¥è®¿é®åºåãè¿æ¯å ä¸ºåºåä¸æ¯å­å¨å¨å ä¸ç;å®ä»¬æ¯å¼ï¼å æ­¤å½æ°å¨è®¿é®å®ä»¬æ¶ä¸éè¦å£°æãåºåæå¼ºå¤§çå±æ§æ¯æ³¨éåå½æ°å¯ä»¥åå»ºåæä½åºåãä¾å¦ï¼å¦ä¸ç§è¡¨ç¤ºæåºæ§çæ¹æ³æ¯éå½:å¦æç¬¬ä¸ä¸ªåç´ æ¯å¶ä»åç´ å°ï¼èå¶ä½åç´ é½å·²æåºï¼åæ´ä¸ªæ°ç»é½å·²æåº:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\nå¹´ä»£çç¬¦å·(1 . .æ¯å°åºååçãå®çæææ¯ä»ç¬¬ä¸ä¸ªåç´ å¼å§ï¼ååç´ ç´å°æåãè¿ä¸ä¼ä¿®æ¹sï¼å ä¸ºåºåæ¯ä¸å¯åçãç¸åï¼å®åå»ºäºä¸ä¸ªæ°çåºåï¼é¤äºç¬¬ä¸ä¸ªåç´ ä¹å¤ï¼ææåç´ é½æç¸åçé¡ºåºæåãè¿ç±»ä¼¼äºæ´æ°çå æ³ï¼å ä¸ºåå§å¼æ²¡ææ¹åï¼åªæ¯åå»ºäºæ°çå¼ãåçè¡¨ç¤ºæ³æ¯:\n\n   s[i..j]\n\n\n1\n\n\nå¨0 <= i <= j <= |s|è¿ä¸ªèå´ä¸­dafnyå°å¼ºå¶æ§è¡è¿äºç´¢å¼è¾¹çãç»æåºåå°æ°å¥½æj-iåç´ ï¼å¹¶ä¸å°ä»åç´ s[i]å¼å§ï¼å¦æç»æéç©ºï¼åå°è¿ç»­å°éååºåãè¿æå³çç´¢å¼jå¤çåç´ è¢«æé¤å¨åçä¹å¤ï¼è¿åæ äºç¨äºå¸¸è§ç´¢å¼çç¸åçåå¼åºé´ã\n\nåºåä¹å¯ä»¥ä½¿ç¨æ¾ç¤ºè¡¨ç¤ºæ³ä»å¶åç´ æé :\n\n var s := [1, 2, 3];\n\n\n1\n\n\nå¨è¿éï¼æä»¬å¨ä¸äºå½ä»¤å¼ä»£ç ä¸­æä¸ä¸ªæ´æ°åºååéï¼å¶ä¸­åå«åç´ 1ã2å3ãè¿éä½¿ç¨äºç±»åæ¨æ­æ¥è·å¾åºåæ¯æ´æ°ä¹ä¸çäºå®ãè¿ç§è¡¨ç¤ºæ³åè®¸æä»¬æé ç©ºåºåååä¾åºå:\n\n[] // the empty sequence, which can be a sequence of any type\n   [true] // a singleton sequence of type seq<bool>\n\n\n1\n2\n\n\nåçè¡¨ç¤ºæ³åæ¾ç¤ºè¡¨ç¤ºæ³å¯ä»¥ç¨æ¥æ£æ¥åºåçå±æ§:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // the whole sequence\n}\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nå°ç®åä¸ºæ­¢ï¼å¯¹åºåæå¸¸è§çæä½æ¯è·åç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ï¼ä»¥åè·åé¤ç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ä»¥å¤çææåç´ ï¼å ä¸ºè¿äºéå¸¸ç¨äºéå½å½æ°ï¼å¦ä¸é¢çsorted2ãé¤äºéè¿è®¿é®æåçæ¥è§£æåºåå¤ï¼åºåè¿å¯ä»¥ä½¿ç¨å å·(+)è¿è¡è¿æ¥: ä½æ¯z3å®çè¯æèä¸ä¼æè¯å°è¿ä¸ç¹ï¼é¤éå®è¢«ä¸ä¸ªå£°æäºå®çæ­è¨æç¤º(å³äºä¸ºä»ä¹è¿æ¯å¿è¦çæ´å¤ä¿¡æ¯ï¼è¯·åéå¼ç/å½çº³æ³)ã åºåè¿æ¯æinå!inæä½ç¬¦ï¼ç¨äºæµè¯åºåä¸­çåå«æåµ:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¿è¿åè®¸æä»¬å¨ä¸å³å¿ç´¢å¼çæåµä¸ï¼å¯¹åºåä¸­çåç´ è¿è¡éåãä¾å¦ï¼æä»¬å¯ä»¥è¦æ±ä¸ä¸ªåºååªåå«è¯¥åºåçä¸æ åç´ :\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿æ¯åºåä¸­æ¯ä¸ªåç¬åç´ çå±æ§ãå¦ææä»¬æ³è®©å¤ä¸ªåç´ ç¸äºå³èï¼å°±éè¦éåææ ï¼å¦ç¬¬ä¸ä¸ªä¾å­æç¤ºã\n\nææ¶æä»¬æ³ä½¿ç¨åºåæ¥æ¨¡ææ°ç»çå¯æ´æ°ç¹æ§ãè½ç¶æä»¬ä¸è½æ¹ååæ¥çåºåï¼ä½æä»¬å¯ä»¥åå»ºä¸ä¸ªæ°åºåï¼å¶ä¸­é¤äºæ´æ°çåç´ å¤ï¼ææåç´ é½æ¯ç¸åç:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\nå½ç¶ï¼ä¸æ iå¿é¡»æ¯æ°ç»çä¸æ ãè¿ä¸ªè¯­æ³åªæ¯å¯ä»¥éè¿å¸¸è§åçåè®¿é®æä½å®æçæä½çå¿«æ·æ¹å¼ãä½ è½å¡«åä¸é¢çä»£ç å?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // this works by concatenating everything that doesn't\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ ä¹å¯ä»¥ç¨æ°ç»çåç´ ç»æä¸ä¸ªåºåãè¿æ¯ä½¿ç¨ä¸ä¸é¢ç¸åçâsliceâè¡¨ç¤ºæ³å®æç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè·å¾æ°ç»çä¸é¨åï¼å¯ä»¥åå¸¸è§åçæä½ä¸æ ·ç»åºè¾¹ç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå ä¸ºåºåæ¯æinå!inï¼è¿ä¸ªæä½ä¸ºæä»¬æä¾äºä¸ç§ç®åçæ¹æ³æ¥è¡¨ç¤ºâelement not in arrayâå±æ§ï¼å³å°è¿ä¸ªè½¬åä¸º\n\nforall k :: 0 <= k < a.length ==> elem != a[k]\n\n\n1\n\n\nè¿ä¸ªï¼\n\nelem !in a[..]\n\n\n1\n\n\næ­¤å¤ï¼è¾¹çå¾å®¹æåæ¬:\n\nforall k :: 0 <= k < i ==> elem != a[k]\n\n\n1\n\n\nåä»¥ä¸è¿ä¸ªæ¯ä¸æ ·çï¼\n\nelem !in a[..i]\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"ç»æ­¢",frontmatter:{title:"ç»æ­¢",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/fc6196/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/20.%E7%BB%88%E6%AD%A2.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/20.ç»æ­¢.md",key:"v-d1f85536",path:"/pages/fc6196/",headersStr:null,content:"# ç»æ­¢\n\nDafnyè¯æææç¨åºç»æ­¢ãæä¸¤ä¸ªæ½å¨çéç»æ­¢(åæ£)è¡ä¸ºæ¥æº:å¾ªç¯ï¼éå½å½æ°åæ¹æ³ãDafnyä½¿ç¨ä¸ç§ææ¯æ¥å¤çè¿ä¸¤ç§æåµï¼åå°æ³¨éã\n\néåæ³¨éæå®ä¸ä¸ªç§°ä¸ºç»æ­¢åº¦éçå¼ï¼è¯¥å¼å¨æ¯æ¬¡éåå¾ªç¯ææ¯æ¬¡è°ç¨éå½å½æ°ææ¹æ³æ¶ä¸¥æ ¼åå°ãè¿ä¸ªå¼ä¹æ¯æççï¼å æ­¤å®ä¸ä¼æ°¸è¿åå°ãè¿æ ·ï¼å¦æå¼ä»ä»»ææéå¼å¼å§ï¼å¾ªç¯æéå½å¿é¡»åæ­¢ãä¸ºäºè¯æè¿ä¸ç¹ï¼Dafnyè¯æäºç»æ­¢åº¦éå¨æ¯æ¬¡è¿­ä»£ä¸­åå¾æ´å°ãå¦æDafnyæ æ³è¯æè¿ä¸ç¹ï¼å®è¡¨ç¤ºæ²¡æåå°ç»æ­¢æªæ½ãå ä¸ºæ¯ä¸ç§ç»æ­¢æªæ½é½æä¸ä¸ªåç½®çä¸çï¼è¿å°±æ¯Dafnyéè¦åçï¼ä»¥è¯æç»æ­¢ã\n\nDafnyå¯ä»¥å¨éåæ³¨éä¸­ä½¿ç¨å ç§ç±»åçå¼ï¼ä½æå¸¸è§çæ¯æ´æ°ãæ´æ°æä¸ä¸ªèªç¶çä¸çï¼0ï¼èä¸éå¸¸å¾å®¹æè¯æå®ä»¬æ¯éåçãç±äºè®¸å¤å¾ªç¯éåç´¢å¼ï¼è¿ç±»ç»æ­¢è¯æéå¸¸å¸¸è§ãä¾å¦ï¼æä»¬å¯è½æä»¥ä¸å¾ªç¯:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      // do something interesting\n      i := i + 1;\n   }\n}\n\nwhile i < n\n   invariant 0 <= i <= n\n{\n   // do something interesting\n   i := i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nå¦ææä»¬æè¿ä¸ªäº¤ç»Dafnyï¼å°±è½ç«å³è¯å®ãä½æ¯å®æ¯æä¹ç¥éå®ä¼ç»æ­¢çå¢?å ä¸ºè¿æ¯å¦æ­¤å¸¸è§çå¾ªç¯å½¢å¼ï¼Dafnyæä¸ä¸ªçæµç»æ­¢åº¦éçç¹æ®è§åãDafnyçå°æ²¡ææ¾å¼çéåæ³¨éï¼æä»¥å®å°è¯çæµä¸ä¸ªãå®çå°å¾ªç¯æ¡ä»¶æ¯A < Bå½¢å¼çæ¯è¾ï¼å¯¹äºæäºAåBï¼æä»¥å®ååºçæµ:\n\n  decreases B - A\n\n\n1\n\n\nå¦æè¿æ ·çè¯\n\n  decreases n - i\n\n\n1\n\n\nå¦ææä»¬å°è¿ä¸ªæ³¨éæ·»å å°å¾ªç¯ä¸­ï¼å®å°ç»§ç»­è¿è¡éªè¯ãDafnyå®éä¸æ²¡æé£ä¹ä¸¥æ ¼è¦æ±ç»æ­¢æµåº¦ä¸º0ãå®çæ­£éè¦çæ¯ï¼å½ç»æ­¢åº¦éä¸ºè´æ¶ï¼å¾ªç¯ä¸ä¼åæ¬¡æ§è¡ãæä»¥æä»¬å¯ä»¥è¿æ ·å:\n\nmethod m()\n{\n   var i, n := 0, 11;\n   while i < n\n      decreases n - i\n   {\n      // do something interesting\n      i := i + 5;\n   }\n}\n\nvar i, n := 0, 11;\nwhile i < n\n   decreases n - i\n{\n   // do something interesting\n   i := i + 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nè¿éï¼å¨æåä¸æ¬¡è¿­ä»£ä¸­ï¼iåæäº15ï¼æä»¥ç»æ­¢æµåº¦æ¯-4ãä½å¨è¿éï¼å¾ªç¯ä¿æ¤ä¸ºåï¼æä»¥å¾ªç¯ä¸ä¼åæ¬¡æ§è¡ãæ³¨æï¼æä»¬å¿é¡»å é¤å¾ªç¯ä¸åå¼ï¼å ä¸ºiç°å¨å¯ä»¥è¶è¿nã\n\nDafnyè¯æäºæ´ä¸ªç¨åºçç»æ­¢ï¼èä¸ä»ä»æ¯å¾ªç¯ãä¸ºæ­¤ï¼å®å¯¹éå½å½æ°åæ¹æ³ä½¿ç¨äºç¸åçææ¯ãDafnyåæåªäºå½æ°/æ¹æ³å½¼æ­¤è°ç¨ï¼ä»¥æ¾åºå¯è½çéå½ãå¯¹äºæ¯ä¸ªå¯è½éå½çå½æ°/æ¹æ³ï¼å®éè¦æ¾å¼æéå¼åå°å½æ°ææ¹æ³ä¸çæ³¨éãå¤§å¤æ°éå½å½æ°/æ¹æ³é½æ¯èªéå½ç: Dafnyè¯æäºæ´ä¸ªç¨åºçç»æ­¢ï¼èä¸ä»ä»æ¯å¾ªç¯ãä¸ºæ­¤ï¼å®å¯¹éå½å½æ°åæ¹æ³ä½¿ç¨äºç¸åçææ¯ãDafnyåæåªäºå½æ°/æ¹æ³å½¼æ­¤è°ç¨ï¼ä»¥æ¾åºå¯è½çéå½ãå¯¹äºæ¯ä¸ªå¯è½éå½çå½æ°/æ¹æ³ï¼å®éè¦æ¾å¼æéå¼åå°å½æ°ææ¹æ³ä¸çæ³¨éãå¤§å¤æ°éå½å½æ°/æ¹æ³é½æ¯èªéå½ç:\n\nfunction fac(n: nat): nat\n{\n   if n == 0 then 1 else n * fac(n-1)\n\n\n1\n2\n3\n\n\nDafnyæ¥åäºè¿ä¸ªè®¡åãå¯¹äºå¤§å¤æ°éå½å½æ°æ¥è¯´ï¼å®ä»¬åªæ¯ç¨æ´å°çåæ°å¼æ¥è°ç¨èªå·±ï¼æä»¥åæ°åå°æ¯é»è®¤ççæµãå¯ä»¥éè¿æ·»å ä»¥ä¸åå®¹:\n\ndecreases n\n\n\n1\n\n\nå°å½æ°å£°ææ¥æç¡®decreasesæ³¨é\n\nææ¶ï¼å·æå¯è½ä¸ä¼ç»æ­¢çå¾ªç¯æç»æ­¢è¯ææªç¥çå¾ªç¯æ¯æççãä¾å¦ï¼èèä»¥ä¸æ¹æ³:\n\nmethod hail(N: nat)\n   decreases *\n{\n   var n := N;\n   while 1 < n\n      decreases *\n   {\n      n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nè¿ä¸ªç¨åºç»æ­¢å½ä¸ä»å½Collatzçæ³ä¸ºçæ¶ï¼è¿æ¯ä¸ä¸ªæ°å­¦ä¸çå¼æ¾é®é¢ï¼æä»¥ä½ ä¸è½ææDafnyè½å¤è¯æç»æ­¢ãæ¨è¿å¯ä»¥ç¼åæµå¤çå¨ä¹ç±»çä»£ç ï¼ä»¥ä¾¿æ°¸è¿è¿è¡ãå æ­¤ï¼Dafnyæä¾äºä¸ä¸ªâoutâï¼ä¸ä¸ªç¹æ®çæ³¨éï¼æç¤ºDafnyä¸è¦è¯å¾è¯æç»æ­¢ï¼è¿å¨åé¢çhailæ¹æ³ä¸­å·²ç»ç»åºãè¿å¯ä»¥ç¨äºææéé¬¼å¾ªç¯ãæ³¨æï¼å¦æä¸ä¸ªæ¹æ³åå«ä¸ä¸ªæ è®°ä¸ºdecreases *çå¾ªç¯ï¼é£ä¹å®æ¬èº«ä¹å¿é¡»è¢«æ è®°ä¸ºdecreases *ã\n\nDafnyå¯ä»¥ä½¿ç¨æ´æ°ä»¥å¤çå¼ä½ä¸ºç»æ­¢åº¦éãå½æå®åºåæ¶ï¼Dafnyèªå¨ä½¿ç¨é¿åº¦ä½ä¸ºç»æ­¢åº¦éãå¦æä¸ä¸ªéåæ¯å¦ä¸ä¸ªéåçä¸¥æ ¼å­éï¼åè®¤ä¸ºè¿ä¸ªéåæ´å°ï¼å æ­¤æ¯ä¸ªéåå¿é¡»åå«å¨åé¢çéåä¸­ãå¯¹äºéåï¼ç©ºéåæ¯å°½å¯è½å°çï¼åºåæèªç¶æ°é¿åº¦ï¼æä»¥è¿ä¸¤ä¸ªé½æä¸çãè½ç¶ä¸æ¯éå¸¸æç¨ï¼ä½ä¹å¯ä»¥å¨éåå­å¥ä¸­ä½¿ç¨boolåreferencesã(å¦æä½ æ³äºè§£ç»èï¼è¯·åéåèèµæã)æåçç»æ­¢åº¦éæ¯å¶ä»ç±»ååº¦éçåç»ãä¾å¦ï¼ä¸é¢çAckermannå½æ°çå®ç°ä½¿ç¨ä¸å¯¹æ´æ°æ¥è¯æç»æ­¢\n\nfunction Ack(m: nat, n: nat): nat\n   decreases m, n\n{\n   if m == 0 then n + 1\n   else if n == 0 then Ack(m - 1, 1)\n   else Ack(m - 1, Ack(m, n - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è¿éï¼éåå­å¥è¢«æç¡®å°åäºåºæ¥ï¼å°½ç®¡Dafnyä¼çåºå®å¨ç¸åçäºæãåç»ä½¿ç¨ç»ä»¶å¼çå¤§å°æ¯è¾æ¥ç¡®å®åº¦éå¼æ¯å¦ç¼©æ°´ãå¨è¿ç§æåµä¸ï¼å®ä½¿ç¨ä¸¤ä¸ªæ´æ°ï¼ä½ä¸è¬æ¥è¯´ï¼ä¸åçé¨åå¯ä»¥å±äºä¸åçç±»å«ãè¿ç§æ¯è¾æ¯æè¯å¸ç¼çºçãå¦æç¬¬ä¸ä¸ªåç´ ï¼å¨è¿éæ¯mï¼æ¯å¶ä»çå¼å°æ²¡å³ç³»ãå®ä»¬å¯ä»¥å¢å ï¼åå°ï¼æä¿æä¸åãåªæå½ç¬¬ä¸ä¸ªåç´ ä¸åæ¶ï¼æèèç¬¬äºä¸ªåç´ ãç¶åï¼ç¬¬äºä¸ªå¼éè¦åå°ãå¦ææ²¡æï¼åç¬¬ä¸ä¸ªåç´ å¿é¡»åå°ï¼ä»¥æ­¤ç±»æ¨ãæç»ï¼å¿æä¸ç§åç´ ä¼åå°ãè¿äºè¿ä¸ªç¹ï¼å¶ä»åç´ å°±å¯ä»¥èªç±å¢å æåå®ä»¬æ³åçäºã å¨Ackå½æ°ä¸­ï¼æä¸ä¸ªéå½è°ç¨ãå¨ç¬¬ä¸ç§æåµä¸ï¼måå°1ï¼ä½nå¢å¤§ãè¿å¾å¥½ï¼å ä¸ºå¨åç»ä¸­nå¨måé¢ãå¨ç¬¬äºä¸ªè°ç¨ä¸­ï¼mä¹åå°äºï¼å æ­¤ç¬¬äºä¸ªåæ°åè®¸æ¯ä»»ä½å¼(è¿å¾å¥½ï¼å ä¸ºDafnyå®éä¸å¹¶æ²¡æè¯æå³äºç¬¬ä¸ä¸ªéå½è°ç¨çç»æçä»»ä½ä¸è¥¿)ãDafnyç¡®å®éè¦è¯æç¬¬ä¸éçµè¯ç¬¦åç»æ­¢æªæ½ãå¯¹äºè¿ä¸ªè°ç¨ï¼mä¿æä¸åï¼ä½nåå°ï¼å æ­¤æ»ä½åº¦éä¹åå°äºã ç»æ­¢ä¸ä»éç¨äºåä¸ªå½æ°/æ¹æ³ï¼è¿éç¨äºå¤ä¸ªç¸äºéå½çå½æ°/æ¹æ³ãä¾å¦ï¼èèè¿å¯¹éå½å®ä¹çå¥å¶æ ¡éªè°è¯:\n\npredicate even(n: nat)\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\npredicate odd(n: nat)\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafnyéè¿èèä¸¤ä¸ªå½æ°ä¸­ææå¯è½çè·¯å¾è¯æäºå®ä»¬çç»æ­¢ã",normalizedContent:"# ç»æ­¢\n\ndafnyè¯æææç¨åºç»æ­¢ãæä¸¤ä¸ªæ½å¨çéç»æ­¢(åæ£)è¡ä¸ºæ¥æº:å¾ªç¯ï¼éå½å½æ°åæ¹æ³ãdafnyä½¿ç¨ä¸ç§ææ¯æ¥å¤çè¿ä¸¤ç§æåµï¼åå°æ³¨éã\n\néåæ³¨éæå®ä¸ä¸ªç§°ä¸ºç»æ­¢åº¦éçå¼ï¼è¯¥å¼å¨æ¯æ¬¡éåå¾ªç¯ææ¯æ¬¡è°ç¨éå½å½æ°ææ¹æ³æ¶ä¸¥æ ¼åå°ãè¿ä¸ªå¼ä¹æ¯æççï¼å æ­¤å®ä¸ä¼æ°¸è¿åå°ãè¿æ ·ï¼å¦æå¼ä»ä»»ææéå¼å¼å§ï¼å¾ªç¯æéå½å¿é¡»åæ­¢ãä¸ºäºè¯æè¿ä¸ç¹ï¼dafnyè¯æäºç»æ­¢åº¦éå¨æ¯æ¬¡è¿­ä»£ä¸­åå¾æ´å°ãå¦ædafnyæ æ³è¯æè¿ä¸ç¹ï¼å®è¡¨ç¤ºæ²¡æåå°ç»æ­¢æªæ½ãå ä¸ºæ¯ä¸ç§ç»æ­¢æªæ½é½æä¸ä¸ªåç½®çä¸çï¼è¿å°±æ¯dafnyéè¦åçï¼ä»¥è¯æç»æ­¢ã\n\ndafnyå¯ä»¥å¨éåæ³¨éä¸­ä½¿ç¨å ç§ç±»åçå¼ï¼ä½æå¸¸è§çæ¯æ´æ°ãæ´æ°æä¸ä¸ªèªç¶çä¸çï¼0ï¼èä¸éå¸¸å¾å®¹æè¯æå®ä»¬æ¯éåçãç±äºè®¸å¤å¾ªç¯éåç´¢å¼ï¼è¿ç±»ç»æ­¢è¯æéå¸¸å¸¸è§ãä¾å¦ï¼æä»¬å¯è½æä»¥ä¸å¾ªç¯:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      // do something interesting\n      i := i + 1;\n   }\n}\n\nwhile i < n\n   invariant 0 <= i <= n\n{\n   // do something interesting\n   i := i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nå¦ææä»¬æè¿ä¸ªäº¤ç»dafnyï¼å°±è½ç«å³è¯å®ãä½æ¯å®æ¯æä¹ç¥éå®ä¼ç»æ­¢çå¢?å ä¸ºè¿æ¯å¦æ­¤å¸¸è§çå¾ªç¯å½¢å¼ï¼dafnyæä¸ä¸ªçæµç»æ­¢åº¦éçç¹æ®è§åãdafnyçå°æ²¡ææ¾å¼çéåæ³¨éï¼æä»¥å®å°è¯çæµä¸ä¸ªãå®çå°å¾ªç¯æ¡ä»¶æ¯a < bå½¢å¼çæ¯è¾ï¼å¯¹äºæäºaåbï¼æä»¥å®ååºçæµ:\n\n  decreases b - a\n\n\n1\n\n\nå¦æè¿æ ·çè¯\n\n  decreases n - i\n\n\n1\n\n\nå¦ææä»¬å°è¿ä¸ªæ³¨éæ·»å å°å¾ªç¯ä¸­ï¼å®å°ç»§ç»­è¿è¡éªè¯ãdafnyå®éä¸æ²¡æé£ä¹ä¸¥æ ¼è¦æ±ç»æ­¢æµåº¦ä¸º0ãå®çæ­£éè¦çæ¯ï¼å½ç»æ­¢åº¦éä¸ºè´æ¶ï¼å¾ªç¯ä¸ä¼åæ¬¡æ§è¡ãæä»¥æä»¬å¯ä»¥è¿æ ·å:\n\nmethod m()\n{\n   var i, n := 0, 11;\n   while i < n\n      decreases n - i\n   {\n      // do something interesting\n      i := i + 5;\n   }\n}\n\nvar i, n := 0, 11;\nwhile i < n\n   decreases n - i\n{\n   // do something interesting\n   i := i + 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nè¿éï¼å¨æåä¸æ¬¡è¿­ä»£ä¸­ï¼iåæäº15ï¼æä»¥ç»æ­¢æµåº¦æ¯-4ãä½å¨è¿éï¼å¾ªç¯ä¿æ¤ä¸ºåï¼æä»¥å¾ªç¯ä¸ä¼åæ¬¡æ§è¡ãæ³¨æï¼æä»¬å¿é¡»å é¤å¾ªç¯ä¸åå¼ï¼å ä¸ºiç°å¨å¯ä»¥è¶è¿nã\n\ndafnyè¯æäºæ´ä¸ªç¨åºçç»æ­¢ï¼èä¸ä»ä»æ¯å¾ªç¯ãä¸ºæ­¤ï¼å®å¯¹éå½å½æ°åæ¹æ³ä½¿ç¨äºç¸åçææ¯ãdafnyåæåªäºå½æ°/æ¹æ³å½¼æ­¤è°ç¨ï¼ä»¥æ¾åºå¯è½çéå½ãå¯¹äºæ¯ä¸ªå¯è½éå½çå½æ°/æ¹æ³ï¼å®éè¦æ¾å¼æéå¼åå°å½æ°ææ¹æ³ä¸çæ³¨éãå¤§å¤æ°éå½å½æ°/æ¹æ³é½æ¯èªéå½ç: dafnyè¯æäºæ´ä¸ªç¨åºçç»æ­¢ï¼èä¸ä»ä»æ¯å¾ªç¯ãä¸ºæ­¤ï¼å®å¯¹éå½å½æ°åæ¹æ³ä½¿ç¨äºç¸åçææ¯ãdafnyåæåªäºå½æ°/æ¹æ³å½¼æ­¤è°ç¨ï¼ä»¥æ¾åºå¯è½çéå½ãå¯¹äºæ¯ä¸ªå¯è½éå½çå½æ°/æ¹æ³ï¼å®éè¦æ¾å¼æéå¼åå°å½æ°ææ¹æ³ä¸çæ³¨éãå¤§å¤æ°éå½å½æ°/æ¹æ³é½æ¯èªéå½ç:\n\nfunction fac(n: nat): nat\n{\n   if n == 0 then 1 else n * fac(n-1)\n\n\n1\n2\n3\n\n\ndafnyæ¥åäºè¿ä¸ªè®¡åãå¯¹äºå¤§å¤æ°éå½å½æ°æ¥è¯´ï¼å®ä»¬åªæ¯ç¨æ´å°çåæ°å¼æ¥è°ç¨èªå·±ï¼æä»¥åæ°åå°æ¯é»è®¤ççæµãå¯ä»¥éè¿æ·»å ä»¥ä¸åå®¹:\n\ndecreases n\n\n\n1\n\n\nå°å½æ°å£°ææ¥æç¡®decreasesæ³¨é\n\nææ¶ï¼å·æå¯è½ä¸ä¼ç»æ­¢çå¾ªç¯æç»æ­¢è¯ææªç¥çå¾ªç¯æ¯æççãä¾å¦ï¼èèä»¥ä¸æ¹æ³:\n\nmethod hail(n: nat)\n   decreases *\n{\n   var n := n;\n   while 1 < n\n      decreases *\n   {\n      n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nè¿ä¸ªç¨åºç»æ­¢å½ä¸ä»å½collatzçæ³ä¸ºçæ¶ï¼è¿æ¯ä¸ä¸ªæ°å­¦ä¸çå¼æ¾é®é¢ï¼æä»¥ä½ ä¸è½æædafnyè½å¤è¯æç»æ­¢ãæ¨è¿å¯ä»¥ç¼åæµå¤çå¨ä¹ç±»çä»£ç ï¼ä»¥ä¾¿æ°¸è¿è¿è¡ãå æ­¤ï¼dafnyæä¾äºä¸ä¸ªâoutâï¼ä¸ä¸ªç¹æ®çæ³¨éï¼æç¤ºdafnyä¸è¦è¯å¾è¯æç»æ­¢ï¼è¿å¨åé¢çhailæ¹æ³ä¸­å·²ç»ç»åºãè¿å¯ä»¥ç¨äºææéé¬¼å¾ªç¯ãæ³¨æï¼å¦æä¸ä¸ªæ¹æ³åå«ä¸ä¸ªæ è®°ä¸ºdecreases *çå¾ªç¯ï¼é£ä¹å®æ¬èº«ä¹å¿é¡»è¢«æ è®°ä¸ºdecreases *ã\n\ndafnyå¯ä»¥ä½¿ç¨æ´æ°ä»¥å¤çå¼ä½ä¸ºç»æ­¢åº¦éãå½æå®åºåæ¶ï¼dafnyèªå¨ä½¿ç¨é¿åº¦ä½ä¸ºç»æ­¢åº¦éãå¦æä¸ä¸ªéåæ¯å¦ä¸ä¸ªéåçä¸¥æ ¼å­éï¼åè®¤ä¸ºè¿ä¸ªéåæ´å°ï¼å æ­¤æ¯ä¸ªéåå¿é¡»åå«å¨åé¢çéåä¸­ãå¯¹äºéåï¼ç©ºéåæ¯å°½å¯è½å°çï¼åºåæèªç¶æ°é¿åº¦ï¼æä»¥è¿ä¸¤ä¸ªé½æä¸çãè½ç¶ä¸æ¯éå¸¸æç¨ï¼ä½ä¹å¯ä»¥å¨éåå­å¥ä¸­ä½¿ç¨boolåreferencesã(å¦æä½ æ³äºè§£ç»èï¼è¯·åéåèèµæã)æåçç»æ­¢åº¦éæ¯å¶ä»ç±»ååº¦éçåç»ãä¾å¦ï¼ä¸é¢çackermannå½æ°çå®ç°ä½¿ç¨ä¸å¯¹æ´æ°æ¥è¯æç»æ­¢\n\nfunction ack(m: nat, n: nat): nat\n   decreases m, n\n{\n   if m == 0 then n + 1\n   else if n == 0 then ack(m - 1, 1)\n   else ack(m - 1, ack(m, n - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è¿éï¼éåå­å¥è¢«æç¡®å°åäºåºæ¥ï¼å°½ç®¡dafnyä¼çåºå®å¨ç¸åçäºæãåç»ä½¿ç¨ç»ä»¶å¼çå¤§å°æ¯è¾æ¥ç¡®å®åº¦éå¼æ¯å¦ç¼©æ°´ãå¨è¿ç§æåµä¸ï¼å®ä½¿ç¨ä¸¤ä¸ªæ´æ°ï¼ä½ä¸è¬æ¥è¯´ï¼ä¸åçé¨åå¯ä»¥å±äºä¸åçç±»å«ãè¿ç§æ¯è¾æ¯æè¯å¸ç¼çºçãå¦æç¬¬ä¸ä¸ªåç´ ï¼å¨è¿éæ¯mï¼æ¯å¶ä»çå¼å°æ²¡å³ç³»ãå®ä»¬å¯ä»¥å¢å ï¼åå°ï¼æä¿æä¸åãåªæå½ç¬¬ä¸ä¸ªåç´ ä¸åæ¶ï¼æèèç¬¬äºä¸ªåç´ ãç¶åï¼ç¬¬äºä¸ªå¼éè¦åå°ãå¦ææ²¡æï¼åç¬¬ä¸ä¸ªåç´ å¿é¡»åå°ï¼ä»¥æ­¤ç±»æ¨ãæç»ï¼å¿æä¸ç§åç´ ä¼åå°ãè¿äºè¿ä¸ªç¹ï¼å¶ä»åç´ å°±å¯ä»¥èªç±å¢å æåå®ä»¬æ³åçäºã å¨ackå½æ°ä¸­ï¼æä¸ä¸ªéå½è°ç¨ãå¨ç¬¬ä¸ç§æåµä¸ï¼måå°1ï¼ä½nå¢å¤§ãè¿å¾å¥½ï¼å ä¸ºå¨åç»ä¸­nå¨måé¢ãå¨ç¬¬äºä¸ªè°ç¨ä¸­ï¼mä¹åå°äºï¼å æ­¤ç¬¬äºä¸ªåæ°åè®¸æ¯ä»»ä½å¼(è¿å¾å¥½ï¼å ä¸ºdafnyå®éä¸å¹¶æ²¡æè¯æå³äºç¬¬ä¸ä¸ªéå½è°ç¨çç»æçä»»ä½ä¸è¥¿)ãdafnyç¡®å®éè¦è¯æç¬¬ä¸éçµè¯ç¬¦åç»æ­¢æªæ½ãå¯¹äºè¿ä¸ªè°ç¨ï¼mä¿æä¸åï¼ä½nåå°ï¼å æ­¤æ»ä½åº¦éä¹åå°äºã ç»æ­¢ä¸ä»éç¨äºåä¸ªå½æ°/æ¹æ³ï¼è¿éç¨äºå¤ä¸ªç¸äºéå½çå½æ°/æ¹æ³ãä¾å¦ï¼èèè¿å¯¹éå½å®ä¹çå¥å¶æ ¡éªè°è¯:\n\npredicate even(n: nat)\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\npredicate odd(n: nat)\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafnyéè¿èèä¸¤ä¸ªå½æ°ä¸­ææå¯è½çè·¯å¾è¯æäºå®ä»¬çç»æ­¢ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"å¼ç±»å",frontmatter:{title:"å¼ç±»å",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/a2a107/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null],readingShow:"top"},regularPath:"/30.%E6%95%99%E7%A8%8B/10.Dafny%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/25.%E5%80%BC%E7%B1%BB%E5%9E%8B.html",relativePath:"30.æç¨/10.Dafnyè¿é¶è¯­æ³/25.å¼ç±»å.md",key:"v-5b4bcfa3",path:"/pages/a2a107/",headers:[{level:2,title:"éå",slug:"éå",normalizedTitle:"éå",charIndex:2},{level:2,title:"åºå",slug:"åºå",normalizedTitle:"åºå",charIndex:50},{level:2,title:"å¤ééå",slug:"å¤ééå",normalizedTitle:"å¤ééå",charIndex:8593},{level:2,title:"æ å°",slug:"æ å°",normalizedTitle:"æ å°",charIndex:367}],headersStr:"éå åºå å¤ééå æ å°",content:'# éåç±»å\n\nå¼ç±»åè¡¨ç¤ºä¸ä¾èµäºå ç¶æçæäºä¿¡æ¯ãè¿äºå¼å·ææ°å­¦ç¹æ§:ä¸æ¦åå»ºï¼å°±æ æ³ä¿®æ¹ãæ¯å¦å¨åºåæèéåä¸­ï¼ä½ ä¸è½åå°æ°ç»æ´æ¹ç´¢å¼é£æ ·æ´æ¹éåãç¸åï¼è¦å¨setéåä¸­æå¥åç´ ï¼éè¦åå»ºä¸ä¸ªåå§setéåååå«æ°åç´ çåä¾éçå¹¶éãå½ç¶ï¼åå§setéåè¿å¨ãéåå¯¹å çç¬ç«æ§ä½¿å¾å¼ç±»åå¨è§èä¸­ç¹å«å¥½ç¨ã\n\nè¿å¹¶ä¸æ¯è¯´ä½ å½æå¼ç±»åå¨éé¢æ¶ä¸è½æ´æ°éåãåå«å¼ç±»åçåéå¯ä»¥æ´æ°ä¸ºåæ ·å¼ç±»åçæ°æ°å¼ãèä»»ä½å¶ä»å·æç¸åsetéåçåéæå­æ®µå°ä¿æå®ä»¬çæ§å¼ãå¼ç±»åå¨è¶ç±»set<object>ä¸­å¯ä»¥åå«å¯¹å çå¼ç¨ãå¨æ¬ä¾ä¸­ï¼å¼ç±»åä¸­çä¿¡æ¯æ¯éåä¸­çå¯¹è±¡ï¼èä¸ä¾èµäºå­å¨å¨è¿äºå¯¹è±¡ä¸­çä»»ä½å­æ®µçå¼ãèä¸ï¼ææDafnyçå¼ç±»åé½å¯ä»¥å­å¨å¨å ä¸çå­æ®µä¸­ï¼é¤äºå¨è§èä¸­ï¼è¿å¯ä»¥å¨å®éä»£ç ä¸­ä½¿ç¨ãDafnyçåå»ºå¼ç±»åæéåãåºåãå¤éååæ å°ã\n\næå³åç§éåç±»ååå¶æä½çå®æ´æåï¼è¯·åéDafny type systemææ¡£ãæ³¨æï¼å¦ææ¨æ³å¨æ§è¡ç¨åºä¸­ä½¿ç¨è¿äºç±»åï¼å¹¶ä¸è¿è¦èèæ§è½çè¯ï¼è¯·å¨ç¼è¯æ¶ä½¿ç¨Dafnyç/optimizeéé¡¹ã\n\n\n# éå\n\nåç§ç±»åçéåææäºDafnyéªè¯çæ ¸å¿å·¥å·ä¹ä¸ãéåè¡¨ç¤ºæ²¡æéå¤åç´ çæ åºéåãä¸åºåä¸æ ·ï¼éåä¹æ¯ä¸å¯åçå¼ç±»åãè¿ä½¿å¾å®ä»¬å¯ä»¥å¾è½»æ¾å°å¨ä¸æ¶åå çæåµä¸å¨æ³¨éä¸­ä½¿ç¨ï¼å ä¸ºsetä¸æ¦åå»ºå°±æ æ³ä¿®æ¹ãéåçç±»åä¸º:\n\n set<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ç»æ´æ°ãéå¸¸ï¼éåå ä¹å¯ä»¥æ¯ä»»ä½ç±»åï¼åæ¬å¯¹è±¡ãå·ä½éåå¯ä»¥éè¿ä½¿ç¨æ¾ç¤ºç¬¦å·æ¥æå®:\n\nmethod()\n{\n   var s1 := {}; // the empty set ç©ºé\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 åå«éå1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before è·ä¸ä¸ªä¸æ ·\n   var s3, s4 := {1,2}, {1,4};// å¹³è¡èµå¼\n}\n  \n   var s1 := {}; // the empty set ç©ºé\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 åå«éå1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before è·ä¸ä¸ªä¸æ ·\n   var s3, s4 := {1,2}, {1,4}; //å¹³è¡èµå¼\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nä¾å­æ¼ç¤ºä¸­å±ç¤ºçsetæ­£æ¯æä»¬æ³è¦çï¼åªåå«æå®åç´ ãä¸é¢æä»¬è¿çå°ä¸ºéåå®ä¹äºç¸ç­ç¬¦å·ï¼å¦æä¸¤ä¸ªéåæå®å¨ç¸åçåç´ ï¼é£ä¹å®ä»¬å°±æ¯ç¸ç­çãä¹å¯ä»¥ä½¿ç¨éåè¿ç®ç¬¦ä»ç°æçéåå»ºæ°çé:\n\nmethod m ()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // éåç¸å  å¹¶é\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // éåç¸äº¤ äº¤é\n   assert s2 - s3 == {3}; // éåç¸å å·®é\n}\n\nassert s2 + s4 == {1,2,3,4}; // éåç¸å  å¹¶é\nassert s2 * s3 == {1,2} && s2 * s4 == {1}; // éåç¸äº¤ äº¤é\nassert s2 - s3 == {3}; // éåç¸å å·®é\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\næ³¨æï¼å ä¸ºéåä¸­çæå¤åªæä¸ä¸ªï¼ä¸è½éå¤ãæä»¥å¾å°çå¹¶éåªä¼è®°å½ä¸æ¬¡éå¤åç´ ãå¦æä¸¤ä¸ªéåé½æ¯æéçï¼é£ä¹éè¿è¿äºæä½ç¬¦å°å¾å°ä¸ä¸ªæééï¼ä¸è½çæä¸ä¸ªæ ééãä¸ç®æ¯è¿ç®ç¬¦ä¸åï¼éåè¿ç®ç¬¦é½æ¯æå±äºèªå·±çå®ä¹ãé¤äºéå¸¸çéåæä½ç¬¦å¤ï¼è¿æä¸äºæ¯è¾æä½ç¬¦ï¼å®ä»¬ä¸è¬å·æä»¥ä¸å«ä¹:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // å­é\n   assert {} < {1, 2} && !({1} < {1}); //çå­é\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // æ å³éå\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // ç¸ç­ä¸ä¸ç¸ç­\n}\n\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // å­é\n   assert {} < {1, 2} && !({1} < {1}); // çå­é\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // æ å³éå\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // ç¸ç­ä¸ä¸ç¸ç­\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\néåä¸åºåä¸æ ·ï¼éåä¹æ¯æinå!inæä½ç¬¦æ¥æµè¯åç´ çæåå³ç³»ãä¾å¦:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\t\n\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\néåç¨äºä¸äºæ³¨éï¼åæ¬è¯»ååä¿®æ¹å­å¥ãå¨æ¬ä¾ä¸­ï¼å®ä»¬å¯ä»¥æ¯ç¹å®å¯¹è±¡ç±»åçéå(å¦é¾è¡¨ä¸­çNodes)ï¼ä¹å¯ä»¥æ¯æ³åå¼ç¨ç±»åå¯¹è±¡çéåãå°½ç®¡å®çåå­æ¯è¿æ ·çï¼ä½å®å¯ä»¥æåä»»ä½å¯¹è±¡ææ°ç»ãè¿å¯¹äºå°å½æ°ææ¹æ³å¯è½è¯»åæåå¥çææä¸åç±»åçä½ç½®æç»å¨ä¸èµ·éå¸¸æç¨ã å¨éåå­å¥ä¸­ä½¿ç¨æ¶ï¼éåsetsæå­éæåºãè¿ä¸ä»æé¿åº¦æåºçåºåsequencesä¸åãä¸ºäºå¨éåå­å¥decreasesä¸­ä½¿ç¨éåï¼è¿ç»­å¼å¨æç§æä¹ä¸å¿é¡»æ¯âç¸å³çâï¼è¿éå¸¸è¡¨ç¤ºå®ä»¬æ¯éå½è®¡ç®ãè¿ä¸ªâç¸å³âè¦æ±æ¯å ä¸ºå¨Dafnyä¸­ï¼æä»¬æ æ³è·å¾éåçåºæ°(å¤§å°)ãä»çå°å¤§å°æ¯æä¸ªæéçèªç¶æ°ç»åºçï¼ä½å®ä¸å¯è¢«è®¿é®ãæ¨å¯ä»¥éè¿å°éåä¸ç©ºéåè¿è¡æ¯è¾æ¥æµè¯å®æ¯å¦ä¸ºç©º(å½ä¸ä»å½sæ²¡æåç´ æ¶ï¼s =={}ä¸ºç)ã åå»ºéåçä¸ä¸ªæç¨æ¹æ³æ¯ä½¿ç¨set comprehensionï¼åå«éï¼ï¼ãéè¿å°æææ»¡è¶³p(x)çTç±»åçxåå«å°f(x)ä¸­ï¼å®å®ä¹äºä¸ä¸ªæ°éå:\n\n   set x: T | p(x) :: f(x)\n\n\n1\n\n\nå®ä»¥ä¸ç§è®©äººæ³èµ·å¨ç§°éè¯(forall)çæ¹å¼æ¥å®ä¹éåãä¸éè¯quanifiersç¸åçæ¯ï¼è¯¥ç±»åéå¸¸å¯ä»¥æ¨æ­åºæ¥ãä¸éè¯ç¸åï¼ç¬¦å·(|)å°è°è¯(p)ä¸åé(x)åç¦»ãè¿åçéååç´ ç±»åæ¯f(x)éåçè¿åå¼ç±»åãè¿åéåçå¼æ¯f(x)çè¿åå¼ï¼xæ¬èº«åªåå½påå½æ°fä¹é´çæ¡¥æ¢ãå®éå¸¸å·æä¸è¿åéç¸åçæ°å¼ç±»åï¼ä½ä¹ä¸ä¸å®ã\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};// assertion violation\n\n\n1\n2\n3\n4\n5\n6\n\n\nå¦æå½æ°æ¯æç­å¼ï¼é£ä¹è½ä»¥å¾ä¼ç¾çå½¢å¼ååºè¡¨è¾¾å¼\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};//å¯¹ç\n\n\n1\n2\n3\n4\n5\n6\n\n\nä¸è¬çéåæ¨å¯¼ä¸­çéæç­å½æ°å®¹ææ··æ·Dafnyãä¾å¦ï¼ä»¥ä¸å¼å­æ¯æ­£ç¡®çï¼ä½Dafnyæ æ³è¯æå®:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};\n}\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};// assertion violation\n\n\n1\n2\n3\n4\n5\n\n\nè¿ç§åæ³æå¯è½åå»ºæ ééï¼è¿å¨Dafnyä¸­æ¯ä¸åè®¸çãä¸ºäºé²æ­¢è¿ç§æåµåçï¼Dafnyä½¿ç¨å¯åå¼æ¹æ³è¯å¾è¯æç»æéæ¯æéçãå½åå»ºæ´æ°éæ¶ï¼å¯ä»¥éè¿å°æ´æ°éå®å¨è°è¯çè³å°ä¸ä¸ªå­å¥ä¸­(ç±»ä¼¼äº0 <= x < n)æ¥å®ç°,å°±åå¨ååå·::åé¢å°±è¡ãè¦æ±éå®åéå¨ç°æçéåä¸­ä¹å¯ä»¥ï¼å¦ä¸é¢çx in {0,1,2}ãè¿åªå¨åå«é¨åä¸è°è¯çå¶ä½é¨åè¿æ¥(&&ç­)æ¶èµ·ä½ç¨ï¼å ä¸ºå®éè¦éå¶è¦èèçå¯è½å¼ã\n\n\n# åºå\n\nåºåæ¯ä¸ç§è¡¨ç¤ºæåºåè¡¨çDafnyåç½®æ°æ®ç±»åãå®ä»¬å¯ä»¥ç¨æ¥è¡¨ç¤ºè®¸å¤æåºéåï¼åæ¬åè¡¨ãéåãå æ ç­ãåºåæ¯ä¸ç§ä¸å¯åçå¼ç±»å:å®ä»¬ä¸æ¦åå»ºå°±ä¸è½è¢«ä¿®æ¹ãä»è¿ä¸ªæä¹ä¸è¯´ï¼å®ä»¬ç±»ä¼¼äºJavaåPythonç­è¯­è¨ä¸­çstringå­ç¬¦ä¸²ï¼åªæ¯å®ä»¬å¯ä»¥æ¯ä»»æç±»åçåºåï¼èä¸ä»ä»æ¯å­ç¬¦ãåºåç±»åå¦ä¸:\n\nseq<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ä¸ªæ´æ°åºåã(æ³¨æï¼å¨Dafnyä¸­æä¸ä¸ªå·²ç¥çéè¯¯ï¼å®é»æ­¢ä½ åå»ºèªç¶çåºånatã)ä¾å¦ï¼è¿ä¸ªå½æ°å°ä¸ä¸ªåºåä½ä¸ºä¼ å¥åæ°:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\nåºåçé¿åº¦åæ|s|ï¼å¦ä¸éè¯æç¤ºãä½¿ç¨ä¸æ°ç»ç¸åçæ¹æ¬å·è¯­æ³è®¿é®åºåçç¹å®åç´ ãæ³¨æï¼è¯¥å½æ°ä¸éè¦è¯»åå­å¥æ¥è®¿é®åºåãè¿æ¯å ä¸ºåºåä¸æ¯å­å¨å¨å ä¸ç;å®ä»¬æ¯å¼ï¼å æ­¤å½æ°å¨è®¿é®å®ä»¬æ¶ä¸éè¦å£°æãåºåæå¼ºå¤§çå±æ§æ¯æ³¨éannotationsåå½æ°functionså¯ä»¥åå»ºåæä½åºåãä¾å¦ï¼å¦ä¸ç§è¡¨ç¤ºæåºæ§çæ¹æ³æ¯éå½:å¦æç¬¬ä¸ä¸ªåç´ æ¯å¶ä»åç´ å°ï¼èå¶ä½åç´ é½å·²æåºï¼åæ´ä¸ªæ°ç»é½å·²æåº:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\ns[1..]æ¯å°åºååçãå®çæææ¯ä»ç¬¬ä¸ä¸ªåç´ å¼å§ï¼ååç´ ç´å°åºåæ«å°¾ãè¿ä¸ä¼ä¿®æ¹såºåï¼å ä¸ºåºåæ¯ä¸å¯åçãç¸åï¼å®åå»ºäºä¸ä¸ªæ°çåºåï¼é¤äºç¬¬ä¸ä¸ªåç´ ä¹å¤ï¼ææåç´ é½æç¸åçé¡ºåºæåãè¿ç±»ä¼¼äºæ´æ°çå æ³ï¼å ä¸ºåå§å¼æ²¡ææ¹åï¼åªæ¯åå»ºäºæ°çå¼ãåçè¡¨ç¤ºä¸º:s[i..j]\n\nä¹å°±æ¯å¨0 <= i <= j <= |s|ä¸­Dafnyå°å¼ºå¶æ§è¡è¿äºç´¢å¼è¾¹çãæç»åºåå°æ°å¥½æj-iä¸ªåç´ ï¼å¹¶ä¸å°ä»åç´ s[i]å¼å§ï¼å¦æç»æéç©ºï¼åå°è¿ç»­å°éååºåãè¿æå³çç´¢å¼jå¤çåç´ è¢«æé¤å¨åçä¹å¤ï¼è¿åæ äºç¨äºå¸¸è§ç´¢å¼çç¸åçåå¼åºé´ã åºåä¹å¯ä»¥ä½¿displayæ³¨éä»èªå·±çåç´ ä¸­æé :\n\n  var s := [1, 2, 3];\n\n\n1\n\n\nå¨è¿éï¼æä»¬å¨ä¸äºå½ä»¤å¼ä»£ç ä¸­æä¸ä¸ªæ´æ°åºååéï¼å¶ä¸­åå«åç´ 1ã2å3ãè¿éä½¿ç¨äºç±»åæ¨æ­å¾ç¥åºåæ¯å¶ä¸­çä¸äºæ´æ°ãè¿ç§è¡¨ç¤ºæ³åè®¸æä»¬æé ç©ºåºåååä¾åºå:\n\n [] //ç©ºåºåï¼å¯ä»¥æä¸ºä»»ä½ç±»å\n [true] // boolç±»åçåä¾åºå\t\n\n\n1\n2\n\n\nåçè¡¨ç¤ºæ³slice notationåæ¾ç¤ºè¡¨ç¤ºæ³display notationå¯ä»¥ç¨æ¥æ£æ¥åºåçå±æ§:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //è®¿é®åºåæåä¸ä¸ªåç´ \n   assert s[|s|-1..|s|] == [5]; //åçæåä¸ä¸ªåç´ ä½ä¸ºåä¾åºå\n   assert s[1..] == [2, 3, 4, 5]; // é¤äºç¬¬ä¸ä¸ªåç´ çåºå\n   assert s[..|s|-1] == [1, 2, 3, 4]; // é¤äºæåä¸ä¸ªåç´ çåºå\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // æ´ä¸ªåºå\n}\n\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nå°ç®åä¸ºæ­¢ï¼å¯¹åºåæå¸¸è§çæä½æ¯è·åç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ï¼ä»¥åè·åé¤ç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ä»¥å¤çææåç´ ï¼å ä¸ºè¿äºéå¸¸ç¨äºéå½å½æ°ï¼å¦ä¸é¢çsorted2ãé¤äºéè¿è®¿é®æåçæ¥è§£æåºåå¤ï¼åºåè¿å¯ä»¥ä½¿ç¨å å·(+)è¿è¡è¿æ¥:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n}\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç¬¬äºä¸ªæ­è¨ç»åºäºè¿æ¥ååçä¹é´çå³ç³»ãå ä¸ºåçæä½å¨ä¸è¾¹æ¯æä»çï¼å¨å¦ä¸è¾¹æ¯åå«çï¼æä»¥åç´ å¨è¿æ¥ä¸­åªåºç°ä¸æ¬¡ãæ³¨æï¼è¿æ¥æä½æ¯æå³èç:\n\nmethod m()\n{\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n}\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä½æ¯Z3å®çè¯æèä¸ä¼æè¯å°è¿ä¸ç¹ï¼é¤éå®è¢«ä¸ä¸ªå£°æäºå®çæ­è¨æç¤º(å³äºä¸ºä»ä¹è¿æ¯å¿è¦çæ´å¤ä¿¡æ¯ï¼è¯·åéå¼ç/å½çº³æ³)ã\n\nåºåè¿æ¯æinå!inæä½ç¬¦ï¼ç¨äºæµè¯åºåä¸­çåå«æåµ:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¿è¿åè®¸æä»¬å¨ä¸å³å¿ç´¢å¼çæåµä¸ï¼å¯¹åºåä¸­çåç´ è¿è¡éåãä¾å¦ï¼æä»¬å¯ä»¥è¦æ±ä¸ä¸ªåºååªåå«è¯¥åºåçä¸æ åç´ :\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿æ¯åºåä¸­æ¯ä¸ªåç¬åç´ çå±æ§ãå¦ææä»¬æ³è®©å¤ä¸ªåç´ ç¸äºå³èï¼å°±éè¦éåææ ï¼å¦ç¬¬ä¸ä¸ªä¾å­æç¤ºã ææ¶æä»¬æ³ä½¿ç¨åºåæ¥æ¨¡ææ°ç»çå¯æ´æ°ç¹æ§ãè½ç¶æä»¬ä¸è½æ¹ååæ¥çåºåï¼ä½æä»¬å¯ä»¥åå»ºä¸ä¸ªæ°åºåï¼å¶ä¸­é¤äºæ´æ°çåç´ å¤ï¼ææåç´ é½æ¯ç¸åç:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\nå½ç¶ï¼ä¸æ iå¿é¡»æ¯æ°ç»çä¸æ ãè¿ä¸ªè¯­æ³åªæ¯å¯ä»¥éè¿å¸¸è§åçåè®¿é®æä½å®æçæä½ç¬¦çå¿«æ·æ¹å¼ãä½ è½å¡«åä¸é¢çä»£ç å?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // This works by concatenating everything that doesn\'t\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ ä¹å¯ä»¥ç¨æ°ç»çåç´ ç»æä¸ä¸ªåºåãè¿æ¯ä½¿ç¨ä¸ä¸é¢ç¸åçâsliceâè¡¨ç¤ºæ³å®æç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè·å¾æ°ç»çä¸é¨åï¼å¯ä»¥åå¸¸è§åçæä½ä¸æ ·ç»åºè¾¹ç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå ä¸ºåºåæ¯æinå!inï¼è¿ä¸ªæä½ä¸ºæä»¬æä¾äºä¸ç§ç®åçæ¹æ³æ¥è¡¨è¾¾" element not in array "å±æ§ï¼å³å°ä¸é¢è¿ä¸ª:forall k :: 0 <= k < a.Length ==> elem != a[k] è½¬åä¸ºï¼elem !in a[..]\n\næ­¤å¤ï¼è¾¹çå¾å®¹æåæ¬:forall k :: 0 <= k < i ==> elem != a[k] åè¿ä¸ªä¸æ ·elem !in a[..i]\n\n\n# å¤ééå\n\nå¤ééåå ä¹å¨æææ¹é¢é½ä¸éåç¸ä¼¼ï¼é¤äºå®ä»¬è·è¸ªæ¯ä¸ªåç´ çæ·è´æ°ãè¿ä½¿å¾å®ä»¬å¨å­å¨æ°ç»ä¸­çåç´ éåæ¶ç¹å«æç¨ï¼ä¾å¦ï¼å½æ¯ä¸ªåç´ çæ·è´æ°éç¸åæ¶ãmultisetç±»åå ä¹ä¸setç±»åç¸å:\n\n   multiset<int>\n\n\n1\n\n\nç±»ä¼¼å°ï¼è¦ç»åºä¸ä¸ªmultisetå­é¢å¼ï¼ä½ è¦åè±æ¬å·ï¼é¤éåé¢æmultisetå³é®å­:\n\n  multiset{3,5,7,3}\n\n\n1\n\n\nå°å¿!Multiset({3,3})ä¸æ¯å¸¦æä¸¤ä¸ª3çå¤éåå­é¢å¼ãå¤§æ¬å·å¿é¡»ä¸å³é®å­ç¸é»ï¼ä»¥ä½¿å¶å¦ææé£æ ·è¿è¡ã\n\nåéåä¸æ ·ï¼å¤éåä¹æ¯æ åºçãç¶èï¼å ä¸ºå®ä»¬è·è¸ªæ¯ä¸ªåç´ çæ°éï¼ä¸é¢çæå­å®éä¸æä¸¤ä¸ª3ã\n\nå¨éåä¸å®ä¹çè®¸å¤æä½ä¹å¯ç¨äºå¤éåãæ¨å¯ä»¥ä½¿ç¨inæ¥æµè¯æä¸ªåç´ æ¯å¦å¨multisetä¸­(inè¡¨ç¤ºå®è³å°å·æç»å®å¼çä¸ä¸ªæå)ãå¤éå¹¶é(+)æå³çä»ä¸¤èä¸­ååç´ ï¼å¹¶å°å®ä»¬ç¸å ãå¦æä¸ä¸ªå¤éæä¸¤ä¸ª3èå¦ä¸ä¸ªæä¸ä¸ª3ï¼é£ä¹å®ä»¬çå¤éå¹¶éå°±ä¼æä¸ä¸ª3ãå¤éå·®å¼(-)çå·¥ä½åçç±»ä¼¼ï¼å ä¸ºåç´ çåéæ§(å³æ¯ä¸ªåç´ å¨å¤éä¸­æå¤å°ä¸ª)å¾éè¦ãæä»¥ä»¥ä¸:\n\nmethod test()\n{\n   assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n}\n  assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n\n\næç«ï¼å ä¸ºæä»¬å¼å§æä¸ä¸ª1ï¼ç¶åæ¿èµ°ä¸¤ä¸ªï¼å©ä¸ä¸ä¸ªã Multiset disjoint(!!)æé¢æå·¥ä½ï¼å½ä¸ä»å½ä¸¤ä¸ªå¤éæ²¡æå±åæåæ¶ä¸ºçãåæ ·ï¼å¦æä¸¤ä¸ªå¤éçæ¯ä¸ªåç´ çè®¡æ°å®å¨ç¸åï¼é£ä¹å®ä»¬æ¯ç¸ç­çã æåï¼éè¿ä½¿ç¨å¸¦æ¬å·çmultisetå¯ä»¥ä»åºååéåä¸­åå»ºå¤é:\n\nmethod test()\n{\n   assert multiset([1,1]) == multiset{1,1};\n   assert multiset({1,1}) == multiset{1};\n}\n  assert multiset([1,1]) == multiset{1,1};\n  assert multiset({1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿ä¸¤ä¸ªæ­è¨é½æ¯æ­£ç¡®çï¼å ä¸ºåºåçmultisetåå«èèæ¯ä¸ªåç´ ï¼èsetæå¤åªèèæ¯ä¸ªåç´ ä¸­çä¸ä¸ªãDafnyåè®¸æ¨ç¼å{1,1}ï¼ä½è¿ä¸{1}ç¸åï¼å ä¸ºéå¤çä»£ç ä¼è¢«å¿½ç¥ãå æ­¤ï¼å½ä»ä¸ä¸ªéåçæä¸ä¸ªå¤éåæ¶ï¼å¤éåä¸­çæ¯ä¸ªåç´ é½å°å·æç²¾ç¡®çåéæ§ãä»åºåçæå¤éç¹å«æç¨ï¼å ä¸ºå½ä¸æ°ç»åçç»åæ¶ï¼åè®¸æ¨è®¨è®ºæ°ç»ä¸­çåç´ é(å¦multiset(a[..]))ï¼è¿å¯¹éªè¯æåºç®æ³åä¸äºæ°æ®ç»æéå¸¸æå¸®å©ã\n\n\n# æ å°\n\nDafnyä¸­çæ å°è¡¨ç¤ºå³èæ°ç»ãä¸ç®åä¸ºæ­¢çå¶ä»ç±»åä¸åï¼å®ä»¬æä¸¤ç§ç±»å:é®ç±»ååå¼ç±»åãå¯ä»¥æ ¹æ®é®æ£ç´¢ææ¥æ¾å¼ãæ å°ç±»åå¦ä¸:\n\n  map<U, V>\n\n\n1\n\n\nå¶ä¸­Uæ¯é®ç±»åï¼Væ¯å¼ç±»åãä¾å¦ï¼æä»¬å¯ä»¥æä¸ä¸ªä»æ´æ°å°æ´æ°çæ å°map<int, int>ãè¿ç§ç±»åçå­é¢å¼å¯è½æ¯map[4 := 5, 5 := 6]ãè¿å¼ å°å¾æ4å5èç³»èµ·æ¥ï¼æ5å6èç³»èµ·æ¥ãæ¨å¯ä»¥ä½¿ç¨m[key]è®¿é®ç»å®é®çå¼ï¼å¦æmæ¯ä¸ä¸ªmapèkeyæ¯ä¸ä¸ªé®ãæä»¥æä»¬å¯ä»¥è¿æ ·å:\n\nmethod test() {\n  var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n}\n var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿æ¯å ä¸º4ä½ä¸ºmçé®å¼ï¼ä¼äº§ç5ãæä»¬è¿ç¥ém[5] == 6ï¼å ä¸ºè¿æ¯å¦ä¸ä¸ªæ å°ã æ¯ä¸ªæ å°é½æä¸ä¸ªåï¼åæ¯è¯¥æ å°å·æå¼çææé®ãåå°å¾è¯·æ±å¶åå¤çé®æ¯ä¸æ­£ç¡®çãæä»¥m[7]æ²¡æä»»ä½æä¹ï¼å ä¸ºmæ²¡æç»7å®ä¹ä»»ä½å¼ãè¦æµè¯ä¸ä¸ªé®æ¯å¦å¨æ å°çåä¸­ï¼å¯ä»¥ä½¿ç¨inæä½ç¬¦ãä¾å¦ï¼4å¨mä¸­ï¼5å¨mä¸­ï¼ä½æ¯7 ä¸å¨mä¸­ãæäºéè¯ï¼ä½ å¯ä»¥è¯´å®ä¹åæ¯æä¸ªéåï¼å¦forall i :: i in m <==> 0 <= i < 100(å½mçå®ä¹åæ°å¥½æ¯æ°å­0-99æ¶ï¼ç»æä¸ºç)ãå¦å¤ï¼å¦æä¸¤ä¸ªæ å°çåä½ä¸ºéåæ¯ä¸ç¸äº¤çï¼é£ä¹å®ä»¬å°±æ¯ä¸ç¸äº¤ç(!!) å¦æmæ¯ä¸ä¸ªmapï¼é£ä¹m[i:= j]æ¯ä¸ä¸ªæ°çmapï¼å®æ¯å°iå å°mçåä¸­ï¼ç¶åå°é®iä¸å¼jå³èèµ·æ¥çç»æãå¦æiå·²ç»æä¸ä¸ªå¼ï¼é£ä¹å®å°å¨æ°çmapä¸­è¢«è¦çãè¿ä¹æå³çå½ä½¿ç¨mapå­é¢å¼æ¶ï¼åè®¸éå¤ä¸ä¸ªé®ï¼ä½éåç¬¬ä¸ä¸ªå¼å°è¢«éåãæä»¥map[3 := 5, 3 := 4] == map[3 := 4]ãæ³¨æï¼å¦æä¸¤ä¸ªæ å°å·æç¸åçåï¼åå®ä»¬æ¯ç¸ç­çï¼å¹¶ä¸å®ä»¬å°ç¸åçé®æ å°ä¸ºç¸åçå¼ãåæ ·ï¼æ å°çåå¿é¡»æ»æ¯æéçã åéåä¸æ ·ï¼mapæmapçcomprehensionãè¯­æ³å ä¹åsetä¸æ ·:\n\nmap i: T | p(i) :: f(i)\n\n\n1\n\n\nåºå«å¨äºï¼iæ¯é®ï¼å®è¢«æ å°å°f(i),P(i)ç¨æ¥ç¡®å®æ°æ å°çå®ä¹åæ¯ä»ä¹ãæä»¥:\n\nmethod test() {\n  var m := map i | 0 <= i < 10 :: 2*i;\n}\n  map i | 0 <= i < 10 :: 2*i\n\n\n1\n2\n3\n4\n\n\nå°±æ¯æ0-9çæ°å­åæåææ°å­çå°å¾ãè¿ä¹æ¯ä»æ å°ä¸­å é¤é®çæ¹æ³ãä¾å¦ï¼è¿ä¸ªè¡¨è¾¾å¼å°é®3ä»ä¸ä¸ªintå°intçæ å°mä¸­å é¤:\n\nmethod test() {\n  var m := map[3 := 5, 4 := 6, 1 := 4];\n  var l := map i | i in m && i != 3 :: m[i];\n  assert l == map[4:= 6, 1 := 4];\n}\n  map i | i in m && i != 3 :: m[i]\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# éåç±»å\n\nå¼ç±»åè¡¨ç¤ºä¸ä¾èµäºå ç¶æçæäºä¿¡æ¯ãè¿äºå¼å·ææ°å­¦ç¹æ§:ä¸æ¦åå»ºï¼å°±æ æ³ä¿®æ¹ãæ¯å¦å¨åºåæèéåä¸­ï¼ä½ ä¸è½åå°æ°ç»æ´æ¹ç´¢å¼é£æ ·æ´æ¹éåãç¸åï¼è¦å¨setéåä¸­æå¥åç´ ï¼éè¦åå»ºä¸ä¸ªåå§setéåååå«æ°åç´ çåä¾éçå¹¶éãå½ç¶ï¼åå§setéåè¿å¨ãéåå¯¹å çç¬ç«æ§ä½¿å¾å¼ç±»åå¨è§èä¸­ç¹å«å¥½ç¨ã\n\nè¿å¹¶ä¸æ¯è¯´ä½ å½æå¼ç±»åå¨éé¢æ¶ä¸è½æ´æ°éåãåå«å¼ç±»åçåéå¯ä»¥æ´æ°ä¸ºåæ ·å¼ç±»åçæ°æ°å¼ãèä»»ä½å¶ä»å·æç¸åsetéåçåéæå­æ®µå°ä¿æå®ä»¬çæ§å¼ãå¼ç±»åå¨è¶ç±»set<object>ä¸­å¯ä»¥åå«å¯¹å çå¼ç¨ãå¨æ¬ä¾ä¸­ï¼å¼ç±»åä¸­çä¿¡æ¯æ¯éåä¸­çå¯¹è±¡ï¼èä¸ä¾èµäºå­å¨å¨è¿äºå¯¹è±¡ä¸­çä»»ä½å­æ®µçå¼ãèä¸ï¼æædafnyçå¼ç±»åé½å¯ä»¥å­å¨å¨å ä¸çå­æ®µä¸­ï¼é¤äºå¨è§èä¸­ï¼è¿å¯ä»¥å¨å®éä»£ç ä¸­ä½¿ç¨ãdafnyçåå»ºå¼ç±»åæéåãåºåãå¤éååæ å°ã\n\næå³åç§éåç±»ååå¶æä½çå®æ´æåï¼è¯·åédafny type systemææ¡£ãæ³¨æï¼å¦ææ¨æ³å¨æ§è¡ç¨åºä¸­ä½¿ç¨è¿äºç±»åï¼å¹¶ä¸è¿è¦èèæ§è½çè¯ï¼è¯·å¨ç¼è¯æ¶ä½¿ç¨dafnyç/optimizeéé¡¹ã\n\n\n# éå\n\nåç§ç±»åçéåææäºdafnyéªè¯çæ ¸å¿å·¥å·ä¹ä¸ãéåè¡¨ç¤ºæ²¡æéå¤åç´ çæ åºéåãä¸åºåä¸æ ·ï¼éåä¹æ¯ä¸å¯åçå¼ç±»åãè¿ä½¿å¾å®ä»¬å¯ä»¥å¾è½»æ¾å°å¨ä¸æ¶åå çæåµä¸å¨æ³¨éä¸­ä½¿ç¨ï¼å ä¸ºsetä¸æ¦åå»ºå°±æ æ³ä¿®æ¹ãéåçç±»åä¸º:\n\n set<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ç»æ´æ°ãéå¸¸ï¼éåå ä¹å¯ä»¥æ¯ä»»ä½ç±»åï¼åæ¬å¯¹è±¡ãå·ä½éåå¯ä»¥éè¿ä½¿ç¨æ¾ç¤ºç¬¦å·æ¥æå®:\n\nmethod()\n{\n   var s1 := {}; // the empty set ç©ºé\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 åå«éå1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before è·ä¸ä¸ªä¸æ ·\n   var s3, s4 := {1,2}, {1,4};// å¹³è¡èµå¼\n}\n  \n   var s1 := {}; // the empty set ç©ºé\n   var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 åå«éå1,2,3\n   assert s2 == {1,1,2,3,3,3,3}; // same as before è·ä¸ä¸ªä¸æ ·\n   var s3, s4 := {1,2}, {1,4}; //å¹³è¡èµå¼\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nä¾å­æ¼ç¤ºä¸­å±ç¤ºçsetæ­£æ¯æä»¬æ³è¦çï¼åªåå«æå®åç´ ãä¸é¢æä»¬è¿çå°ä¸ºéåå®ä¹äºç¸ç­ç¬¦å·ï¼å¦æä¸¤ä¸ªéåæå®å¨ç¸åçåç´ ï¼é£ä¹å®ä»¬å°±æ¯ç¸ç­çãä¹å¯ä»¥ä½¿ç¨éåè¿ç®ç¬¦ä»ç°æçéåå»ºæ°çé:\n\nmethod m ()\n{\n   var s1 := {};\n   var s2 := {1, 2, 3};\n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; // éåç¸å  å¹¶é\n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; // éåç¸äº¤ äº¤é\n   assert s2 - s3 == {3}; // éåç¸å å·®é\n}\n\nassert s2 + s4 == {1,2,3,4}; // éåç¸å  å¹¶é\nassert s2 * s3 == {1,2} && s2 * s4 == {1}; // éåç¸äº¤ äº¤é\nassert s2 - s3 == {3}; // éåç¸å å·®é\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\næ³¨æï¼å ä¸ºéåä¸­çæå¤åªæä¸ä¸ªï¼ä¸è½éå¤ãæä»¥å¾å°çå¹¶éåªä¼è®°å½ä¸æ¬¡éå¤åç´ ãå¦æä¸¤ä¸ªéåé½æ¯æéçï¼é£ä¹éè¿è¿äºæä½ç¬¦å°å¾å°ä¸ä¸ªæééï¼ä¸è½çæä¸ä¸ªæ ééãä¸ç®æ¯è¿ç®ç¬¦ä¸åï¼éåè¿ç®ç¬¦é½æ¯æå±äºèªå·±çå®ä¹ãé¤äºéå¸¸çéåæä½ç¬¦å¤ï¼è¿æä¸äºæ¯è¾æä½ç¬¦ï¼å®ä»¬ä¸è¬å·æä»¥ä¸å«ä¹:\n\nmethod m()\n{\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // å­é\n   assert {} < {1, 2} && !({1} < {1}); //çå­é\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // æ å³éå\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // ç¸ç­ä¸ä¸ç¸ç­\n}\n\n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // å­é\n   assert {} < {1, 2} && !({1} < {1}); // çå­é\n   assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // æ å³éå\n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // ç¸ç­ä¸ä¸ç¸ç­\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\néåä¸åºåä¸æ ·ï¼éåä¹æ¯æinå!inæä½ç¬¦æ¥æµè¯åç´ çæåå³ç³»ãä¾å¦:\n\nmethod m()\n{\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n}\t\n\n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\néåç¨äºä¸äºæ³¨éï¼åæ¬è¯»ååä¿®æ¹å­å¥ãå¨æ¬ä¾ä¸­ï¼å®ä»¬å¯ä»¥æ¯ç¹å®å¯¹è±¡ç±»åçéå(å¦é¾è¡¨ä¸­çnodes)ï¼ä¹å¯ä»¥æ¯æ³åå¼ç¨ç±»åå¯¹è±¡çéåãå°½ç®¡å®çåå­æ¯è¿æ ·çï¼ä½å®å¯ä»¥æåä»»ä½å¯¹è±¡ææ°ç»ãè¿å¯¹äºå°å½æ°ææ¹æ³å¯è½è¯»åæåå¥çææä¸åç±»åçä½ç½®æç»å¨ä¸èµ·éå¸¸æç¨ã å¨éåå­å¥ä¸­ä½¿ç¨æ¶ï¼éåsetsæå­éæåºãè¿ä¸ä»æé¿åº¦æåºçåºåsequencesä¸åãä¸ºäºå¨éåå­å¥decreasesä¸­ä½¿ç¨éåï¼è¿ç»­å¼å¨æç§æä¹ä¸å¿é¡»æ¯âç¸å³çâï¼è¿éå¸¸è¡¨ç¤ºå®ä»¬æ¯éå½è®¡ç®ãè¿ä¸ªâç¸å³âè¦æ±æ¯å ä¸ºå¨dafnyä¸­ï¼æä»¬æ æ³è·å¾éåçåºæ°(å¤§å°)ãä»çå°å¤§å°æ¯æä¸ªæéçèªç¶æ°ç»åºçï¼ä½å®ä¸å¯è¢«è®¿é®ãæ¨å¯ä»¥éè¿å°éåä¸ç©ºéåè¿è¡æ¯è¾æ¥æµè¯å®æ¯å¦ä¸ºç©º(å½ä¸ä»å½sæ²¡æåç´ æ¶ï¼s =={}ä¸ºç)ã åå»ºéåçä¸ä¸ªæç¨æ¹æ³æ¯ä½¿ç¨set comprehensionï¼åå«éï¼ï¼ãéè¿å°æææ»¡è¶³p(x)çtç±»åçxåå«å°f(x)ä¸­ï¼å®å®ä¹äºä¸ä¸ªæ°éå:\n\n   set x: t | p(x) :: f(x)\n\n\n1\n\n\nå®ä»¥ä¸ç§è®©äººæ³èµ·å¨ç§°éè¯(forall)çæ¹å¼æ¥å®ä¹éåãä¸éè¯quanifiersç¸åçæ¯ï¼è¯¥ç±»åéå¸¸å¯ä»¥æ¨æ­åºæ¥ãä¸éè¯ç¸åï¼ç¬¦å·(|)å°è°è¯(p)ä¸åé(x)åç¦»ãè¿åçéååç´ ç±»åæ¯f(x)éåçè¿åå¼ç±»åãè¿åéåçå¼æ¯f(x)çè¿åå¼ï¼xæ¬èº«åªåå½påå½æ°fä¹é´çæ¡¥æ¢ãå®éå¸¸å·æä¸è¿åéç¸åçæ°å¼ç±»åï¼ä½ä¹ä¸ä¸å®ã\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2} :: x * 1) == {0,1,2};// assertion violation\n\n\n1\n2\n3\n4\n5\n6\n\n\nå¦æå½æ°æ¯æç­å¼ï¼é£ä¹è½ä»¥å¾ä¼ç¾çå½¢å¼ååºè¡¨è¾¾å¼\n\nmethod m()\n{\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};\n}\n\n   assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};//å¯¹ç\n\n\n1\n2\n3\n4\n5\n6\n\n\nä¸è¬çéåæ¨å¯¼ä¸­çéæç­å½æ°å®¹ææ··æ·dafnyãä¾å¦ï¼ä»¥ä¸å¼å­æ¯æ­£ç¡®çï¼ä½dafnyæ æ³è¯æå®:\n\nmethod m()\n{\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};\n}\n   assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};// assertion violation\n\n\n1\n2\n3\n4\n5\n\n\nè¿ç§åæ³æå¯è½åå»ºæ ééï¼è¿å¨dafnyä¸­æ¯ä¸åè®¸çãä¸ºäºé²æ­¢è¿ç§æåµåçï¼dafnyä½¿ç¨å¯åå¼æ¹æ³è¯å¾è¯æç»æéæ¯æéçãå½åå»ºæ´æ°éæ¶ï¼å¯ä»¥éè¿å°æ´æ°éå®å¨è°è¯çè³å°ä¸ä¸ªå­å¥ä¸­(ç±»ä¼¼äº0 <= x < n)æ¥å®ç°,å°±åå¨ååå·::åé¢å°±è¡ãè¦æ±éå®åéå¨ç°æçéåä¸­ä¹å¯ä»¥ï¼å¦ä¸é¢çx in {0,1,2}ãè¿åªå¨åå«é¨åä¸è°è¯çå¶ä½é¨åè¿æ¥(&&ç­)æ¶èµ·ä½ç¨ï¼å ä¸ºå®éè¦éå¶è¦èèçå¯è½å¼ã\n\n\n# åºå\n\nåºåæ¯ä¸ç§è¡¨ç¤ºæåºåè¡¨çdafnyåç½®æ°æ®ç±»åãå®ä»¬å¯ä»¥ç¨æ¥è¡¨ç¤ºè®¸å¤æåºéåï¼åæ¬åè¡¨ãéåãå æ ç­ãåºåæ¯ä¸ç§ä¸å¯åçå¼ç±»å:å®ä»¬ä¸æ¦åå»ºå°±ä¸è½è¢«ä¿®æ¹ãä»è¿ä¸ªæä¹ä¸è¯´ï¼å®ä»¬ç±»ä¼¼äºjavaåpythonç­è¯­è¨ä¸­çstringå­ç¬¦ä¸²ï¼åªæ¯å®ä»¬å¯ä»¥æ¯ä»»æç±»åçåºåï¼èä¸ä»ä»æ¯å­ç¬¦ãåºåç±»åå¦ä¸:\n\nseq<int>\n\n\n1\n\n\nä¾å¦ï¼å¯¹äºä¸ä¸ªæ´æ°åºåã(æ³¨æï¼å¨dafnyä¸­æä¸ä¸ªå·²ç¥çéè¯¯ï¼å®é»æ­¢ä½ åå»ºèªç¶çåºånatã)ä¾å¦ï¼è¿ä¸ªå½æ°å°ä¸ä¸ªåºåä½ä¸ºä¼ å¥åæ°:\n\npredicate sorted(s: seq<int>)\n{\n   forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\n\n1\n2\n3\n4\n\n\nåºåçé¿åº¦åæ|s|ï¼å¦ä¸éè¯æç¤ºãä½¿ç¨ä¸æ°ç»ç¸åçæ¹æ¬å·è¯­æ³è®¿é®åºåçç¹å®åç´ ãæ³¨æï¼è¯¥å½æ°ä¸éè¦è¯»åå­å¥æ¥è®¿é®åºåãè¿æ¯å ä¸ºåºåä¸æ¯å­å¨å¨å ä¸ç;å®ä»¬æ¯å¼ï¼å æ­¤å½æ°å¨è®¿é®å®ä»¬æ¶ä¸éè¦å£°æãåºåæå¼ºå¤§çå±æ§æ¯æ³¨éannotationsåå½æ°functionså¯ä»¥åå»ºåæä½åºåãä¾å¦ï¼å¦ä¸ç§è¡¨ç¤ºæåºæ§çæ¹æ³æ¯éå½:å¦æç¬¬ä¸ä¸ªåç´ æ¯å¶ä»åç´ å°ï¼èå¶ä½åç´ é½å·²æåºï¼åæ´ä¸ªæ°ç»é½å·²æåº:\n\npredicate sorted2(s: seq<int>)\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\n\n\n1\n2\n3\n4\n5\n\n\ns[1..]æ¯å°åºååçãå®çæææ¯ä»ç¬¬ä¸ä¸ªåç´ å¼å§ï¼ååç´ ç´å°åºåæ«å°¾ãè¿ä¸ä¼ä¿®æ¹såºåï¼å ä¸ºåºåæ¯ä¸å¯åçãç¸åï¼å®åå»ºäºä¸ä¸ªæ°çåºåï¼é¤äºç¬¬ä¸ä¸ªåç´ ä¹å¤ï¼ææåç´ é½æç¸åçé¡ºåºæåãè¿ç±»ä¼¼äºæ´æ°çå æ³ï¼å ä¸ºåå§å¼æ²¡ææ¹åï¼åªæ¯åå»ºäºæ°çå¼ãåçè¡¨ç¤ºä¸º:s[i..j]\n\nä¹å°±æ¯å¨0 <= i <= j <= |s|ä¸­dafnyå°å¼ºå¶æ§è¡è¿äºç´¢å¼è¾¹çãæç»åºåå°æ°å¥½æj-iä¸ªåç´ ï¼å¹¶ä¸å°ä»åç´ s[i]å¼å§ï¼å¦æç»æéç©ºï¼åå°è¿ç»­å°éååºåãè¿æå³çç´¢å¼jå¤çåç´ è¢«æé¤å¨åçä¹å¤ï¼è¿åæ äºç¨äºå¸¸è§ç´¢å¼çç¸åçåå¼åºé´ã åºåä¹å¯ä»¥ä½¿displayæ³¨éä»èªå·±çåç´ ä¸­æé :\n\n  var s := [1, 2, 3];\n\n\n1\n\n\nå¨è¿éï¼æä»¬å¨ä¸äºå½ä»¤å¼ä»£ç ä¸­æä¸ä¸ªæ´æ°åºååéï¼å¶ä¸­åå«åç´ 1ã2å3ãè¿éä½¿ç¨äºç±»åæ¨æ­å¾ç¥åºåæ¯å¶ä¸­çä¸äºæ´æ°ãè¿ç§è¡¨ç¤ºæ³åè®¸æä»¬æé ç©ºåºåååä¾åºå:\n\n [] //ç©ºåºåï¼å¯ä»¥æä¸ºä»»ä½ç±»å\n [true] // boolç±»åçåä¾åºå\t\n\n\n1\n2\n\n\nåçè¡¨ç¤ºæ³slice notationåæ¾ç¤ºè¡¨ç¤ºæ³display notationå¯ä»¥ç¨æ¥æ£æ¥åºåçå±æ§:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //è®¿é®åºåæåä¸ä¸ªåç´ \n   assert s[|s|-1..|s|] == [5]; //åçæåä¸ä¸ªåç´ ä½ä¸ºåä¾åºå\n   assert s[1..] == [2, 3, 4, 5]; // é¤äºç¬¬ä¸ä¸ªåç´ çåºå\n   assert s[..|s|-1] == [1, 2, 3, 4]; // é¤äºæåä¸ä¸ªåç´ çåºå\n   assert s == s[0..] == s[..|s|] == s[0..|s|]; // æ´ä¸ªåºå\n}\n\n   var s := [1, 2, 3, 4, 5];\n   assert s[|s|-1] == 5; //access the last element\n   assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton\n   assert s[1..] == [2, 3, 4, 5]; // everything but the first\n   assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last\n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nå°ç®åä¸ºæ­¢ï¼å¯¹åºåæå¸¸è§çæä½æ¯è·åç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ï¼ä»¥åè·åé¤ç¬¬ä¸ä¸ªåæåä¸ä¸ªåç´ ä»¥å¤çææåç´ ï¼å ä¸ºè¿äºéå¸¸ç¨äºéå½å½æ°ï¼å¦ä¸é¢çsorted2ãé¤äºéè¿è®¿é®æåçæ¥è§£æåºåå¤ï¼åºåè¿å¯ä»¥ä½¿ç¨å å·(+)è¿è¡è¿æ¥:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n}\n   assert [1,2,3] == [1] + [2,3];\n   assert s == s + [];\n   assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç¬¬äºä¸ªæ­è¨ç»åºäºè¿æ¥ååçä¹é´çå³ç³»ãå ä¸ºåçæä½å¨ä¸è¾¹æ¯æä»çï¼å¨å¦ä¸è¾¹æ¯åå«çï¼æä»¥åç´ å¨è¿æ¥ä¸­åªåºç°ä¸æ¬¡ãæ³¨æï¼è¿æ¥æä½æ¯æå³èç:\n\nmethod m()\n{\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n}\n   assert forall a: seq<int>, b: seq<int>, c: seq<int> ::\n      (a + b) + c == a + (b + c);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nä½æ¯z3å®çè¯æèä¸ä¼æè¯å°è¿ä¸ç¹ï¼é¤éå®è¢«ä¸ä¸ªå£°æäºå®çæ­è¨æç¤º(å³äºä¸ºä»ä¹è¿æ¯å¿è¦çæ´å¤ä¿¡æ¯ï¼è¯·åéå¼ç/å½çº³æ³)ã\n\nåºåè¿æ¯æinå!inæä½ç¬¦ï¼ç¨äºæµè¯åºåä¸­çåå«æåµ:\n\nmethod m()\n{\n   var s := [1, 2, 3, 4, 5];\n   assert 5 in s;\n   assert 0 !in s;\n}\n   assert 5 in s; // using s from before\n   assert 0 !in s;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nè¿è¿åè®¸æä»¬å¨ä¸å³å¿ç´¢å¼çæåµä¸ï¼å¯¹åºåä¸­çåç´ è¿è¡éåãä¾å¦ï¼æä»¬å¯ä»¥è¦æ±ä¸ä¸ªåºååªåå«è¯¥åºåçä¸æ åç´ :\n\nmethod m()\n{\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n}\n   var p := [2,3,1,0];\n   assert forall i :: i in p ==> 0 <= i < |s|;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿æ¯åºåä¸­æ¯ä¸ªåç¬åç´ çå±æ§ãå¦ææä»¬æ³è®©å¤ä¸ªåç´ ç¸äºå³èï¼å°±éè¦éåææ ï¼å¦ç¬¬ä¸ä¸ªä¾å­æç¤ºã ææ¶æä»¬æ³ä½¿ç¨åºåæ¥æ¨¡ææ°ç»çå¯æ´æ°ç¹æ§ãè½ç¶æä»¬ä¸è½æ¹ååæ¥çåºåï¼ä½æä»¬å¯ä»¥åå»ºä¸ä¸ªæ°åºåï¼å¶ä¸­é¤äºæ´æ°çåç´ å¤ï¼ææåç´ é½æ¯ç¸åç:\n\nmethod m()\n{\n   var s := [1,2,3,4];\n   assert s[2 := 6] == [1,2,6,4];\n}\n   s[i := v] // replace index i by v in seq s\n\n\n1\n2\n3\n4\n5\n6\n\n\nå½ç¶ï¼ä¸æ iå¿é¡»æ¯æ°ç»çä¸æ ãè¿ä¸ªè¯­æ³åªæ¯å¯ä»¥éè¿å¸¸è§åçåè®¿é®æä½å®æçæä½ç¬¦çå¿«æ·æ¹å¼ãä½ è½å¡«åä¸é¢çä»£ç å?\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n   // this works by concatenating everything that doesn\'t\n   // change with the singleton of the new value.\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= index < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   // open in the editor to see the answer.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä½ ä¹å¯ä»¥ç¨æ°ç»çåç´ ç»æä¸ä¸ªåºåãè¿æ¯ä½¿ç¨ä¸ä¸é¢ç¸åçâsliceâè¡¨ç¤ºæ³å®æç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n}\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   var s := a[..];\n   assert s == [0, 3, -1];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè·å¾æ°ç»çä¸é¨åï¼å¯ä»¥åå¸¸è§åçæä½ä¸æ ·ç»åºè¾¹ç:\n\nmethod m()\n{\n   var a := new int[3]; // 3 element array of ints\n   a[0], a[1], a[2] := 0, 3, -1;\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n}\n   assert a[1..] == [3, -1];\n   assert a[..1] == [0];\n   assert a[1..2] == [3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå ä¸ºåºåæ¯æinå!inï¼è¿ä¸ªæä½ä¸ºæä»¬æä¾äºä¸ç§ç®åçæ¹æ³æ¥è¡¨è¾¾" element not in array "å±æ§ï¼å³å°ä¸é¢è¿ä¸ª:forall k :: 0 <= k < a.length ==> elem != a[k] è½¬åä¸ºï¼elem !in a[..]\n\næ­¤å¤ï¼è¾¹çå¾å®¹æåæ¬:forall k :: 0 <= k < i ==> elem != a[k] åè¿ä¸ªä¸æ ·elem !in a[..i]\n\n\n# å¤ééå\n\nå¤ééåå ä¹å¨æææ¹é¢é½ä¸éåç¸ä¼¼ï¼é¤äºå®ä»¬è·è¸ªæ¯ä¸ªåç´ çæ·è´æ°ãè¿ä½¿å¾å®ä»¬å¨å­å¨æ°ç»ä¸­çåç´ éåæ¶ç¹å«æç¨ï¼ä¾å¦ï¼å½æ¯ä¸ªåç´ çæ·è´æ°éç¸åæ¶ãmultisetç±»åå ä¹ä¸setç±»åç¸å:\n\n   multiset<int>\n\n\n1\n\n\nç±»ä¼¼å°ï¼è¦ç»åºä¸ä¸ªmultisetå­é¢å¼ï¼ä½ è¦åè±æ¬å·ï¼é¤éåé¢æmultisetå³é®å­:\n\n  multiset{3,5,7,3}\n\n\n1\n\n\nå°å¿!multiset({3,3})ä¸æ¯å¸¦æä¸¤ä¸ª3çå¤éåå­é¢å¼ãå¤§æ¬å·å¿é¡»ä¸å³é®å­ç¸é»ï¼ä»¥ä½¿å¶å¦ææé£æ ·è¿è¡ã\n\nåéåä¸æ ·ï¼å¤éåä¹æ¯æ åºçãç¶èï¼å ä¸ºå®ä»¬è·è¸ªæ¯ä¸ªåç´ çæ°éï¼ä¸é¢çæå­å®éä¸æä¸¤ä¸ª3ã\n\nå¨éåä¸å®ä¹çè®¸å¤æä½ä¹å¯ç¨äºå¤éåãæ¨å¯ä»¥ä½¿ç¨inæ¥æµè¯æä¸ªåç´ æ¯å¦å¨multisetä¸­(inè¡¨ç¤ºå®è³å°å·æç»å®å¼çä¸ä¸ªæå)ãå¤éå¹¶é(+)æå³çä»ä¸¤èä¸­ååç´ ï¼å¹¶å°å®ä»¬ç¸å ãå¦æä¸ä¸ªå¤éæä¸¤ä¸ª3èå¦ä¸ä¸ªæä¸ä¸ª3ï¼é£ä¹å®ä»¬çå¤éå¹¶éå°±ä¼æä¸ä¸ª3ãå¤éå·®å¼(-)çå·¥ä½åçç±»ä¼¼ï¼å ä¸ºåç´ çåéæ§(å³æ¯ä¸ªåç´ å¨å¤éä¸­æå¤å°ä¸ª)å¾éè¦ãæä»¥ä»¥ä¸:\n\nmethod test()\n{\n   assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n}\n  assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n\n\næç«ï¼å ä¸ºæä»¬å¼å§æä¸ä¸ª1ï¼ç¶åæ¿èµ°ä¸¤ä¸ªï¼å©ä¸ä¸ä¸ªã multiset disjoint(!!)æé¢æå·¥ä½ï¼å½ä¸ä»å½ä¸¤ä¸ªå¤éæ²¡æå±åæåæ¶ä¸ºçãåæ ·ï¼å¦æä¸¤ä¸ªå¤éçæ¯ä¸ªåç´ çè®¡æ°å®å¨ç¸åï¼é£ä¹å®ä»¬æ¯ç¸ç­çã æåï¼éè¿ä½¿ç¨å¸¦æ¬å·çmultisetå¯ä»¥ä»åºååéåä¸­åå»ºå¤é:\n\nmethod test()\n{\n   assert multiset([1,1]) == multiset{1,1};\n   assert multiset({1,1}) == multiset{1};\n}\n  assert multiset([1,1]) == multiset{1,1};\n  assert multiset({1,1}) == multiset{1};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿ä¸¤ä¸ªæ­è¨é½æ¯æ­£ç¡®çï¼å ä¸ºåºåçmultisetåå«èèæ¯ä¸ªåç´ ï¼èsetæå¤åªèèæ¯ä¸ªåç´ ä¸­çä¸ä¸ªãdafnyåè®¸æ¨ç¼å{1,1}ï¼ä½è¿ä¸{1}ç¸åï¼å ä¸ºéå¤çä»£ç ä¼è¢«å¿½ç¥ãå æ­¤ï¼å½ä»ä¸ä¸ªéåçæä¸ä¸ªå¤éåæ¶ï¼å¤éåä¸­çæ¯ä¸ªåç´ é½å°å·æç²¾ç¡®çåéæ§ãä»åºåçæå¤éç¹å«æç¨ï¼å ä¸ºå½ä¸æ°ç»åçç»åæ¶ï¼åè®¸æ¨è®¨è®ºæ°ç»ä¸­çåç´ é(å¦multiset(a[..]))ï¼è¿å¯¹éªè¯æåºç®æ³åä¸äºæ°æ®ç»æéå¸¸æå¸®å©ã\n\n\n# æ å°\n\ndafnyä¸­çæ å°è¡¨ç¤ºå³èæ°ç»ãä¸ç®åä¸ºæ­¢çå¶ä»ç±»åä¸åï¼å®ä»¬æä¸¤ç§ç±»å:é®ç±»ååå¼ç±»åãå¯ä»¥æ ¹æ®é®æ£ç´¢ææ¥æ¾å¼ãæ å°ç±»åå¦ä¸:\n\n  map<u, v>\n\n\n1\n\n\nå¶ä¸­uæ¯é®ç±»åï¼væ¯å¼ç±»åãä¾å¦ï¼æä»¬å¯ä»¥æä¸ä¸ªä»æ´æ°å°æ´æ°çæ å°map<int, int>ãè¿ç§ç±»åçå­é¢å¼å¯è½æ¯map[4 := 5, 5 := 6]ãè¿å¼ å°å¾æ4å5èç³»èµ·æ¥ï¼æ5å6èç³»èµ·æ¥ãæ¨å¯ä»¥ä½¿ç¨m[key]è®¿é®ç»å®é®çå¼ï¼å¦æmæ¯ä¸ä¸ªmapèkeyæ¯ä¸ä¸ªé®ãæä»¥æä»¬å¯ä»¥è¿æ ·å:\n\nmethod test() {\n  var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n}\n var m := map[4 := 5, 5 := 6];\n  assert m[4] == 5;\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿æ¯å ä¸º4ä½ä¸ºmçé®å¼ï¼ä¼äº§ç5ãæä»¬è¿ç¥ém[5] == 6ï¼å ä¸ºè¿æ¯å¦ä¸ä¸ªæ å°ã æ¯ä¸ªæ å°é½æä¸ä¸ªåï¼åæ¯è¯¥æ å°å·æå¼çææé®ãåå°å¾è¯·æ±å¶åå¤çé®æ¯ä¸æ­£ç¡®çãæä»¥m[7]æ²¡æä»»ä½æä¹ï¼å ä¸ºmæ²¡æç»7å®ä¹ä»»ä½å¼ãè¦æµè¯ä¸ä¸ªé®æ¯å¦å¨æ å°çåä¸­ï¼å¯ä»¥ä½¿ç¨inæä½ç¬¦ãä¾å¦ï¼4å¨mä¸­ï¼5å¨mä¸­ï¼ä½æ¯7 ä¸å¨mä¸­ãæäºéè¯ï¼ä½ å¯ä»¥è¯´å®ä¹åæ¯æä¸ªéåï¼å¦forall i :: i in m <==> 0 <= i < 100(å½mçå®ä¹åæ°å¥½æ¯æ°å­0-99æ¶ï¼ç»æä¸ºç)ãå¦å¤ï¼å¦æä¸¤ä¸ªæ å°çåä½ä¸ºéåæ¯ä¸ç¸äº¤çï¼é£ä¹å®ä»¬å°±æ¯ä¸ç¸äº¤ç(!!) å¦æmæ¯ä¸ä¸ªmapï¼é£ä¹m[i:= j]æ¯ä¸ä¸ªæ°çmapï¼å®æ¯å°iå å°mçåä¸­ï¼ç¶åå°é®iä¸å¼jå³èèµ·æ¥çç»æãå¦æiå·²ç»æä¸ä¸ªå¼ï¼é£ä¹å®å°å¨æ°çmapä¸­è¢«è¦çãè¿ä¹æå³çå½ä½¿ç¨mapå­é¢å¼æ¶ï¼åè®¸éå¤ä¸ä¸ªé®ï¼ä½éåç¬¬ä¸ä¸ªå¼å°è¢«éåãæä»¥map[3 := 5, 3 := 4] == map[3 := 4]ãæ³¨æï¼å¦æä¸¤ä¸ªæ å°å·æç¸åçåï¼åå®ä»¬æ¯ç¸ç­çï¼å¹¶ä¸å®ä»¬å°ç¸åçé®æ å°ä¸ºç¸åçå¼ãåæ ·ï¼æ å°çåå¿é¡»æ»æ¯æéçã åéåä¸æ ·ï¼mapæmapçcomprehensionãè¯­æ³å ä¹åsetä¸æ ·:\n\nmap i: t | p(i) :: f(i)\n\n\n1\n\n\nåºå«å¨äºï¼iæ¯é®ï¼å®è¢«æ å°å°f(i),p(i)ç¨æ¥ç¡®å®æ°æ å°çå®ä¹åæ¯ä»ä¹ãæä»¥:\n\nmethod test() {\n  var m := map i | 0 <= i < 10 :: 2*i;\n}\n  map i | 0 <= i < 10 :: 2*i\n\n\n1\n2\n3\n4\n\n\nå°±æ¯æ0-9çæ°å­åæåææ°å­çå°å¾ãè¿ä¹æ¯ä»æ å°ä¸­å é¤é®çæ¹æ³ãä¾å¦ï¼è¿ä¸ªè¡¨è¾¾å¼å°é®3ä»ä¸ä¸ªintå°intçæ å°mä¸­å é¤:\n\nmethod test() {\n  var m := map[3 := 5, 4 := 6, 1 := 4];\n  var l := map i | i in m && i != 3 :: m[i];\n  assert l == map[4:= 6, 1 := 4];\n}\n  map i | i in m && i != 3 :: m[i]\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"èªå¨å½çº³",frontmatter:{title:"èªå¨å½çº³",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/718207/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/1.%E8%87%AA%E5%8A%A8%E5%BD%92%E7%BA%B3.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/1.èªå¨å½çº³.md",key:"v-7a49265a",path:"/pages/718207/",headers:[{level:2,title:"è¿è¡å®ä¾",slug:"è¿è¡å®ä¾",normalizedTitle:"è¿è¡å®ä¾",charIndex:274},{level:3,title:"åè¡¨åå½æ°å®ä¹",slug:"åè¡¨åå½æ°å®ä¹",normalizedTitle:"åè¡¨åå½æ°å®ä¹",charIndex:283},{level:3,title:"å¼çåè¯æ",slug:"å¼çåè¯æ",normalizedTitle:"å¼çåè¯æ",charIndex:712},{level:3,title:"ç»æ­¢çç»è",slug:"ç»æ­¢çç»è",normalizedTitle:"ç»æ­¢çç»è",charIndex:2263},{level:3,title:"RangeLengthçå¶ä»ç»æ­¢åº¦é",slug:"rangelengthçå¶ä»ç»æ­¢åº¦é",normalizedTitle:"rangelengthçå¶ä»ç»æ­¢åº¦é",charIndex:3416},{level:3,title:"ä¸ä¸ªè¾ç­çè¯æ",slug:"ä¸ä¸ªè¾ç­çè¯æ",normalizedTitle:"ä¸ä¸ªè¾ç­çè¯æ",charIndex:4534},{level:3,title:"å¼ºæåº",slug:"å¼ºæåº",normalizedTitle:"å¼ºæåº",charIndex:5182},{level:2,title:"èªå¨å½çº³",slug:"èªå¨å½çº³-2",normalizedTitle:"èªå¨å½çº³",charIndex:2},{level:3,title:"èªå¨å½çº³çè¯¦ç»æåµ",slug:"èªå¨å½çº³çè¯¦ç»æåµ",normalizedTitle:"èªå¨å½çº³çè¯¦ç»æåµ",charIndex:6522},{level:3,title:"ä¾å¦:ç¼ºå°decreases",slug:"ä¾å¦-ç¼ºå°decreases",normalizedTitle:"ä¾å¦:ç¼ºå°decreases",charIndex:7369},{level:3,title:"ä¾å¦:åªå¯¹ len è¿è¡éå",slug:"ä¾å¦-åªå¯¹lenè¿è¡éå",normalizedTitle:"ä¾å¦:åªå¯¹ len è¿è¡éå",charIndex:null},{level:4,title:"è´è°¢",slug:"è´è°¢",normalizedTitle:"è´è°¢",charIndex:8537},{level:2,title:"åèæç®",slug:"åèæç®",normalizedTitle:"åèæç®",charIndex:8597}],headersStr:"è¿è¡å®ä¾ åè¡¨åå½æ°å®ä¹ å¼çåè¯æ ç»æ­¢çç»è RangeLengthçå¶ä»ç»æ­¢åº¦é ä¸ä¸ªè¾ç­çè¯æ å¼ºæåº èªå¨å½çº³ èªå¨å½çº³çè¯¦ç»æåµ ä¾å¦:ç¼ºå°decreases ä¾å¦:åªå¯¹ len è¿è¡éå è´è°¢ åèæç®",content:'# èªå¨å½çº³\n\n> K. Rustan M. Leino Manuscript KRML 269, 31 May 2019\n\næè¦\n\nå¯¹äºç®åçä¾å­ï¼Dafnyçèªå¨å½çº³æ³è¶³å¤å¼ºå¤§ï¼å¯ä»¥å¨ä¸éè¦äººå·¥è¾å¥çæåµä¸è¯æä¸äºå¼çï¼å¹¶å¸®å©åå°è¯æå¶ä»å¼çæéçäººå·¥è¾å¥ãæ¬è¯´æè§£éäºèªå¨æåºæ¯å¦ä½åºç¨çï¼ä»¥åå¦ä½ä½¿ç¨ä¸¤ä¸ªä¸»è¦æé®æ¥è°æ´èªå¨åçåè½ã\n\n> Dafnyä¸ä»æ¯ææå·¥ç¼åçå¼çï¼èä¸è¿æä¾äºä¸äºèªå¨ååè½ï¼å¸®å©éè¿å½çº³æ¥è¯æå¼ç[0]ãè®©æä»¬ä»æå¨è¯æçååå¼å§ï¼ç¶åççèªå¨æåºå¦ä½æä¾ææ æ³æä¾è¯æï¼æåççå¦ä½è°æ´èªå¨åçåè½ã\n\n\n# è¿è¡å®ä¾\n\n\n# åè¡¨åå½æ°å®ä¹\n\nèèä»¥ä¸éå½å®ä¹åè¡¨çæ åå®ä¹ï¼ä»¥åä¸ä¸ªLengthå½æ°åä¸ä¸ªæé éå¢æ´æ°åè¡¨çå½æ°ã\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Range(start: int, len: nat): List<int>\n  decreases len\n{\n  if len == 0 then Nil else Cons(start, Range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\næäºè¿äºå®ä¹ï¼æä»¬å¼å§è¯æåè¡¨Range(start, len)çé¿åº¦æ¯lenã\n\n\n# å¼çåè¯æ\n\næä»¬è¦è¯ælist Range(start, len)çé¿åº¦æ¯lenãæä»¬ä»æå·¥éªè¯å¼å§ãä¸ºäºç¡®ä¿å¨ç¬¬ä¸ä¸ªç¤ºä¾ä¸­èªå¨å½çº³ä¸ä¼å¯¹æä»¬æå¸®å©ï¼æç¨å±æ§{:induction false}æ è®°äºå¼çã\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      Length(Range(start, len));\n    ==  // def. Range, since len > 0\n      Length(Cons(start, Range(start+1, len-1)));\n    ==  // def. Length on Cons\n      1 + Length(Range(start+1, len-1));\n    ==  { RangeLength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\næç¤º\n\nåºäºæ¬æçç®çï¼æåè®¾æ¨å·²ç»åºæ¬äºè§£å¦ä½æå¨ç¼åè¿æ ·çè¯æï¼æ è®ºæ¯å¨Dafnyè¿æ¯å¨çº¸ä¸ãæå°å¨è¿éæè¿°è¯æçè¦ç´ ï¼ä½ä¸ä¼è¯å¾è§£éææå¯è½çèèå ç´ ã\n\nå¼çç§°ä¸ºRangeLengthï¼ç±startålenåæ°åï¼å°±åRangeå½æ°ä¸æ ·ãå¼çè¯æçå±æ§å¨ensureså­å¥ä¸­éè¿°ãå®ä¹è¢«ç§°ä¸ºâè¯æç®æ âã\n\nå¼ççç­¾åé¨åè¿å®ä¹äºä¸ä¸ªdecreaseså­å¥ï¼è¯¥å­å¥è¡¨ç¤ºè¡¨è¾¾å¼lenå°è¢«ç¨ä½å¼ççä»»ä½éå½è°ç¨çç»æ­¢åº¦éãè¿ä¸ªç»æ­¢åº¦è§ä¸âèå´âå½æ°çç»æ­¢åº¦è§ç¸åãè¿å¾å¸¸è§ï¼å ä¸ºå¨å¼ççè¯æç®æ ä¸­ï¼è¯æçç»æéå¸¸éµå¾ªå½æ°çç»æã\n\nå¼çä¸»ä½åä¸ºä¸¤ç§æåµï¼éµå¾ªâèå´âå®ä¹ä¸­çæåµãç¬¬ä¸ä¸ªä¾å­æ¯len == 0ï¼å®ç»åºäºä¸ä¸ªéå¸¸ç®åçè¯æ:å½len == 0æ¶ï¼Rangeè¿åé¿åº¦ä¸º0çNilã\n\nå¦ä¸ç§æåµæ¯ä½¿ç¨å·²éªè¯çè®¡ç®ï¼éå¸¸ç§°ä¸ºcalcè¯­å¥[1]ãè¿ä¸ªè®¡ç®ä»è¡¨è¾¾å¼Length(Range(start, len))å¼å§ï¼å¹¶ä½¿ç¨ä¿æç­å¼çè½¬æ¢æ¥å¾å°lenï¼è¿æ­£æ¯è¯æç®æ æè¯´çå¼çå¿é¡»è¯æçãè®¡ç®çåä¸¤ä¸ªæ­¥éª¤åºç¨RangeåLengthçå®ä¹ï¼å°è¡¨è¾¾å¼éåä¸ºæä»¬å¯ä»¥çå°è¡¨è¾¾å¼çå½¢å¼\n\nLength(Range(start+1, len-1))\n\n\n1\n\n\nè¿å°±æ¯è¯æè¿ç¨ä¸­æè¶£çä¸æ­¥ãæä»¬æ³ç¨len - 1æ¿æ¢è¿ä¸ªè¡¨è¾¾å¼ï¼è¿éè¦è¯æè¡¨è¾¾å¼ç¡®å®ç­äºlen - 1ãç¨æ­£ç¡®çåæ°ï¼è¿å°±æ¯æä»¬è¦è¯æçå¼çãå æ­¤ï¼æä»¬ä½¿ç¨calcè¯­å¥æç¤ºå¹¶è°ç¨å¼ç:\n\nRangeLength(start+1, len-1);\n\n\n1\n\n\nå ä¸ºè¿æ¯å¯¹æä»¬è¦è¯æçå¼ççéå½è°ç¨ï¼æä»¬å¿é¡»è¯æç»æ­¢ãå¯¹å¼ççéå½è°ç¨éå¸¸è¢«ç§°ä¸ºâå½çº³åè®¾âçåºç¨ãè¿æ ·ï¼æä»¬çç»æ­¢æ£æ¥å¯¹åºäºç¡®ä¿å½çº³æ¯âææ ¹æ®çâãå¨Dafnyä¸­ï¼éè¿æ¾ç¤ºæ¯ä¸ªéå½è°ç¨é½ä¼åå°ä¸äºç»æ­¢åº¦éæ¥è¯æç»æ­¢ï¼ä¹å°±æ¯è¯´ï¼éå½è°ç¨çæä¸ªè¡¨è¾¾å¼çè®¡ç®å¼æ¯è°ç¨èçå¼è¦å°ãè¿ä¸ªæ´å°çç»æ­¢åº¦è§è¡¨è¾¾å¼æ¯ä»ä¹âæ´å°âæ¯ä»ä¹ææ?è¡¨è¾¾å¼æ¯lenï¼ç±decreaseså­å¥ç»åºï¼ç±äºlenæ¯ä¸ä¸ªæ´æ°ï¼Dafnyä½¿ç¨âå°äºï¼ä»¥0ä¸ºççæ´æ°âä½ä¸ºé¡ºåºã\n\n\n# ç»æ­¢çç»è\n\nè¿å¤ªæå£äºãè®©æä»¬ååé¡¾ä¸ä¸æåä¸é¨åï¼å³äºç»æ­¢çé¨åã\n\nä¸ºäºè¯æå¯¹ä¸ä¸ª(å½æ°ãæ¹æ³æ)å¼ççéå½è°ç¨ä¼ç»æ­¢ï¼æä»¬å°å¼ççæ¯æ¬¡è°ç¨æç§åççé¡ºåºä¸ä¸ä¸ªå¼å³èèµ·æ¥ãæååççç±æå³çä¸å­å¨æ éçéåºé¾ãä¹å°±æ¯è¯´ï¼å­å¨åºå®çæåºï¼å¹¶ä¸å¨è¯¥æåºä¸­ï¼æ¯ä¸ä¸ªè¿ç»­çå°å¼åºåé½æ¯æéçãä¾å¦ï¼å¨âå°äºï¼ä»¥â0âä¸ºççæ´æ°âæåºä¸­ï¼ä¸ä¸ªéåºé¾æ¯\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nè¿ä¸ªé¾æ¯æéçãæ è®ºæ¨åä¸çéåºé¾æ¯ä»ä¹ï¼å®é½æ¯æéç(å¦åï¼æ¨æç»ä¼å¾å°ä¸ä¸ªè´æ°ï¼ä½è¯·è®°ä½æä»¬è¯´è¿âä»¥â0âä¸ºçâ0)ã\n\nDafnyä¸ºæ¯ç§ç±»åæå»ºäºä¸ä¸ªåºå®çãåºäºè¯å¥½åºç¡çé¡ºåºã1å®è¿æ¯æå¼çå­å¸åç»ï¼è¿ç§åç»çè¯å¥½åºç¡é¡ºåºæ¯æ¯ä¸ªç»ä»¶ä¸ç±»åçå­å¸é¡ºåºã\n\næä»¬å°å¼çè°ç¨ä¸è¿ä¸ªåºå®çãææ ¹æ®çé¡ºåºçå¼å³èçæ¹å¼æ¯å£°æä¸ä¸ªdecreaseså­å¥ãå®çåæ°æ¯ä¸ä¸ªè¡¨è¾¾å¼åè¡¨ï¼è¿äºè¡¨è¾¾å¼ææä¸ä¸ªå­å¸åç»ãå¯¹äºâRangeLengthâå¼çï¼æä»¬ä½¿ç¨äºâåå°lenâãè¿æå³çæ¯æ¬¡å¯¹å¼ççè°ç¨é½å°ä¸ä¼ å¥åæ°lençç¸åå¼ç¸å³èã\n\nå½æ°Rangeä¹æ¯éå½çï¼å¯¹äºå®çè°ç¨ï¼æä»¬è¿ä½¿ç¨lenä½ä¸ºç»æ­¢åº¦éãå½æ°Lengthä¹æ¯éå½çï¼ä½æ¾ç¶æä»¬æ²¡æç»å®ä¸ä¸ªdecreaseså­å¥ãå¨ç¼ºå°decreaseså­å¥çæåµä¸ï¼Dafnyä¸ºæä»¬æä¾äºä¸ä¸ªå­å¥ï¼å³æç»å®é¡ºåºç±å½æ°/æ¹æ³/å¼è¯çåæ°ç»æçå­å¸åç»ã2Lengthçç»æ­¢åº¦éæ¯list(Dafnyçæçææ®çå½çº³æ°æ®ç±»åçé¡ºåºæ¯ç»æåå«)ãDafnyçideæä¾äºä¸ä¸ªå·¥å·æç¤º(ä½ å¯ä»¥å¨å½æ°/æ¹æ³/å¼çå£°æä¸çå°)ï¼åè¯ä½ å®ä¸ºéå½å½æ°/æ¹æ³/å¼çéæ©äºåªä¸ªâåå°âå­å¥ã\n\nå°ç®åä¸ºæ­¢ï¼æå·²ç»è¯´è¿Dafnyå®ä¹äºä¸ä¸ªåºå®çãææ ¹æ®çæåºï¼èå°å¼çè°ç¨ä¸è¯¥æåºä¸­çå¼å³èçæ¹æ³æ¯å£°æä¸ä¸ªâåå°âå­å¥ãéªè¯èå¦ä½ä½¿ç¨è¿äºä¸è¥¿æ¥è¯æç»æ­¢?å®è¯æäºä¸è¢«è°ç¨æ¹å³èçå¼ä¸¥æ ¼ä½äºä¸è°ç¨æ¹å³èçå¼ãæ¢å¥è¯è¯´ï¼å®è¯æäºæ¯ä¸ªéå½è°ç¨é½å¨éåé¾ä¸­éåäºä¸æ­¥ãå ä¸ºæ¯ä¸ªé¾é½æ¯æéçï¼æä»¥ä¸å­å¨æ ééå½ãæ¢å¥è¯è¯´ï¼éå½è°ç¨ç»æ­¢ã\n\nå¨è¿ä¸ªä¾å­ä¸­ï¼æä¸ä¸ªä»RangeLength(start, len)å°RangeLength(start+1, len-1)çéå½è°ç¨ãå¼çä½¿ç¨äºdecreases lenï¼æä»¥éªè¯å¨æ£æ¥len-1 < lenï¼è¿è¯æäºç»æ­¢ã\n\nç±»ä¼¼å°ï¼æä¸ä¸ªä»Range(start, len)å°Range(start+1, len-1)çéå½è°ç¨ãéªè¯å¨æ£æ¥len-1 < lenï¼è¿è¯æäºç»æ­¢ã\n\næåï¼æä¸ä¸ªä»Length(list)å°Length(tail)çéå½è°ç¨ï¼å¶ä¸­tailå¨ç»æä¸åå«å¨listä¸­ãå æ­¤ï¼éªè¯èä¹å¯ä»¥å¨è¿éè¯æç»æ­¢ã\n\n\n# RangeLengthçå¶ä»ç»æ­¢åº¦é\n\nèèä¸ä¸å¦ææä»¬ä¸ºâRangeLengthâéæ©ä¸åçç»æ­¢åº¦éä¼åçä»ä¹æ¯ææå¯¼æä¹çãå¯¹äºæä»¬èèçæ¯ä¸ä¸ªåç´ ï¼è¯æä¹å¡çæé æ¹å¼é½æ¯ç¸åç:RangeLength(start+1, len-1)çå¼å¿é¡»å°äºRangeLength(start, len)çå¼ã\n\nåè®¾æä»¬å£°æRangeLengthå¸¦ædecreases 10*len + 28ãæ¯çï¼è¿ä¸ªç»æ­¢åº¦è§è¶³ä»¥è¯æç»æ­¢ï¼å ä¸º10*len + 18å°äº10*len + 28ã\n\ndecreases len - 6å¢?ä¸ï¼Dafnyä¼æ±æ¨ä¸è½è¯æç»æ­¢ï¼å¦æä½ ç»å®è¿ä¸ªç»æ­¢åº¦éãå®å°æ æ³è¯æå¨æ´æ°æåºä¸­lens -7ä½äºlens -6ï¼å ä¸ºå®ä»¬å¯è½æ¯è´çã3\n\nè®©æä»¬è¯è¯decreases start + lenãä¸ï¼å ä¸ºstart+1 + len-1ä¸å°äºstart+ lenã\n\ndecreases start + 2*lenæä¹æ ·?æ¯çï¼è¿è¯æäºç»æ­¢ï¼å ä¸ºstart+1 + 2*(len-1)å°äºstart+ 2*lenã\n\nä½¿ç¨å­å¸åç»start, lenæä¹æ ·?ä¸ï¼è¿ä¸ä¼è¯æç»æ­¢ï¼å ä¸ºstart+1, len-1å¨å­å¸ä¸å¹¶ä¸å°äºstart, len(äºå®ä¸ï¼å®å¨å­å¸ä¸æ´å¤§)ãå¦ææä»¬æâRangeLengthâä¸­çâåå°âå»æï¼Dafnyä¼ä¸ºæä»¬çæä¸ä¸ªãå®çæçå¼æ¯decreases start, lenï¼å ä¸ºRangeLengthçåæ°æ¯startålenï¼æè¿ä¸ªé¡ºåºãå æ­¤ï¼å¦ææ²¡ææç¡®çâåå°âæ¡æ¬¾ï¼Dafnyä¼æ±æ¨æ æ³è¯æç»æ­¢ååã\n\nå¦ä½åæ¢åæ°çé¡ºåºï¼æ¯å¦len, start ?æ¯çï¼è¿è¯æäºç»æ­¢ï¼å ä¸ºlen-1, start+1å°äºlen, startã\n\nå¦æä½ æ¹åRangeLengthæ¥äº¤æ¢å®çåæ°startålen(å¹¶ä¸å¯¹RangeLengthååæ ·çäº¤æ¢éå½è°ç¨)ï¼é£ä¹ä½ å¯ä»¥å¿½ç¥decreaseså­å¥ãå¨æ¬ä¾ä¸­ï¼Dafnyå°çædecreases len, startï¼è¿è¯æäºç»æ­¢ãç¶èï¼éå¸¸å»ºè®®åæåæ°é¡ºåºï¼è¿æ¯æè¾¹å½æ°/æ¹æ³/å¼çæèªç¶çé¡ºåºã\n\næåï¼è¿ä¸ªå¥æªçç»æ­¢ææ decreases 7,lenæä¹æ ·?å½ä½ ç¬¬ä¸æ¬¡å¤§å£°è¯»å°è¿ä¸ªçæ¶åï¼ä½ å¯è½ä¼è¯´\n\n> åå°7 ?ä»ä¹ä¸è¥¿è½åå°å¢?7æ¯ææ¾ç¥ç¶æ¯å¨ä¸æ¶çæ°å­ï¼7å°æ°¸è¿æ¯è¿ä¸ªæ°å­ãæ²¡æåæ³éä½!\n\nä½ æ¯å¯¹çï¼ä½âåå°âæ¡æ¬¾ä¸æ¯è¿ä¹è¯´çãâåå°âå­å¥åªæ¯ç®åå°è¯´æäºå¦ä½å°æ¯ä¸ªå¼çè°ç¨ä»¥åççé¡ºåºæ å°å°ä¸ä¸ªå¼ãæä»¥ï¼æäºè¿ä¸ªå¥æªçç»æ­¢åº¦éï¼è¯æçä¹å¡æ¯æ£æ¥7,len-1å¨å­å¸ä¸å°äº7,lenï¼å®ç¡®å®æ¯ãå¶å®ä¹æ²¡é£ä¹å¤æªã\n\n\n# ä¸ä¸ªè¾ç­çè¯æ\n\nè®©æä»¬ç®åæä»¬ä¸ºRangeLengthç¼åçæå¨è¯æãå½æä»¬åä¸ä¸ªè¯æçæ¶åï¼calcè¯­å¥æ¯å¾æç¨çï¼å®ä¹æä¾äºä¸ä¸ªå¯è¯»çè¯æãä½ä¸æ¦æä»¬æ¾å°äºä¸ä¸ªè¯æï¼æä»¬ææ¶ä¼éæ©ç¼©ç­å®ï¼ä¹è®¸æ¯å ä¸ºåæ³èµ·æ¥ï¼æä»¬åç°èªå·±å¤ªæè°¨äºï¼å³ä½¿æ¯å¯¹æä»¬èªå·±çå£å³æ¥è¯´ã\n\næä»¬ä¸é¢åçcalcéè¿°å®éä¸åªæä¸ä¸ªéè¦æ­¥éª¤ï¼å³å½çº³åè®¾çåºç¨ãäºå®ä¸ï¼æä»¬å¯ä»¥ç¨ä¸ä¸ªè°ç¨æ¥æ¿æ¢æ´ä¸ªcalcè¯­å¥:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå ä¸ºifç" then "åæ¯æ¯ç©ºçï¼æä»¬å½ç¶ä¹å¯ä»¥å¦å®å®å«ï¼äº¤æ¢åæ¯ï¼å¹¶çç¥ç©ºçelse:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# å¼ºæåº\n\næä»¬è¿è½æ¯è¿ä¸ªifè¯­å¥åå¾æ´å¥½å?é£è¦çä½ è§å¾ä»ä¹æ´å¥½äºï¼ä½å¨è¾¾èå¦®æåæ³æ¶é¤è¿ä¸ªåæ¯ãæä»¬å¯ä»¥éè¿æ¿æ¢æ´ä¸ªifè¯­å¥åå®å¯¹RangeLengthçä¸æ¬¡è°ç¨ï¼ç¨forallè¯­å¥è°ç¨RangeLengthæ¥è·åä¸å¤§å å¼ã\n\né¦åï¼åè®¾æä»¬å°è¯ä½¿ç¨ä»¥ä¸ä»£ç ä½ä¸ºRangeLengthçä¸»ä½:\n\nforall start`, len` {\n  RangeLength(start`, len`);\n}\n\n\n1\n2\n3\n\n\nè¿ä¸ªæ¼«ä¸ç»å¿çè¯­å¥å¯¹ææå¯è½çstartålenå¼è°ç¨RangeLengthãè¿æ¯è¡ä¸éçï¼å ä¸ºå¾å¤éå½è°ç¨é½ä¸ä¼ç»æ­¢ãæä»¬éè¦éå¶èªå·±çå¼ä¸ºstartålenï¼ä»¥åå°ç»æ­¢åº¦éã\n\né£ä¹ï¼è®©æä»¬è¯è¯è¿ä¸ª:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  forall start`, len` | 0 <= len` < len {\n    RangeLength(start`, len`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¯¹äºææçstartå¼åææå°äºlenå¼ï¼è°ç¨RangeLengthãä¹å°±æ¯è¯´ï¼è¿ä¸ªforallè¯­å¥ä¸æ¬¡æ§å¯¹RangeLengthè¿è¡äºæ æ°æ¬¡éå½è°ç¨ãç±äºlen çå¼å°äºlenï¼è¿æ æ°æ¬¡è°ç¨ä¸­çæ¯ä¸æ¬¡é½ä¼ç»æ­¢ã4\n\nè¿ä¸ªçæ¬çRangeLengthè¿è¡éªè¯ãå¯¹äºææè¿æ ·çå°å¼çå½çº³åè®¾çæ°å­¦åç§°å«åâå¼ºå½çº³âã\n\nå¥½çï¼startçå¼å¯ä»¥å¤§äºstart(å¨è¿ä¸ç¹ä¸ï¼å®å¯¹äºè¯æstart + 1æ¯å¶ä¸­ä¸ä¸ªå¼æ¯è³å³éè¦ç)ãæä»¥ï¼ä½ å¯è½è®¤ä¸ºä¸é¢çâä¸ºææäººâçéè¿°ä¸ä»ä»æ¯å¼ºå½çº³ãäºå®ä¸ï¼æäºäººå¯è½ä¼äºè¾©è¯´ï¼è¿ä¸ªforallè¯­å¥ä¹æ§è¡äºæè°çâæ³åâå¼çå°ææçstartå¼ãä½æ¯å¦æä½ è®¤ä¸ºå³å®smallerçæåºåªæ¯æ¯è¾lenç»ä»¶ï¼é£ä¹startï¼ len decreasesç¡®å®æ¯start, len å°ï¼åªè¦len å°äºlenãä¸ç®¡ä½ æ³æä¹æ³ï¼æèä½ æ³ç»å®èµ·ä»ä¹æ°å­¦åå­ï¼Dafnyé½æ¥åä¸é¢çâææäººâçè¯´æ³ä½ä¸ºè¯æãå¨ç¼ç¨æ¯è¯­ä¸­ï¼æä»¬æåçå°±æ¯è¯ææ¯ä¸ªéå½è°ç¨é½ä¼ç»æ­¢ï¼è¿ä¸æä»¬å®ä¹ç»æ­¢åº¦è§çæ¹å¼æ¯ä¸æ ·çï¼å³decreases lenã\n\n\n# èªå¨å½çº³\n\næäºè¿äºèæ¯ç¥è¯ï¼æä»¬ç»äºå¯ä»¥äºè§£Dafnyæ¯å¦ä½å®ç°èªå¨æåºçäºãç®èè¨ä¹:å¦æä½ å é¤å±æ§{:inducerfalse}(æå¼å¥è¿ä¸ªå±æ§åªæ¯ä¸ºäºç¦ç¨èªå¨æåºï¼èæä»¬å¨ä¸å¼å§è®¨è®ºä»ä¹æ¯è¯æ)ï¼é£ä¹Dafnyå¨é»è®¤æåµä¸æåçå°±æ¯æå¥æä»¬åæçå°çforallè¯­å¥ãè¿æå³çä½ å¯ä»¥å é¤æå¨æå¥çforallè¯­å¥ï¼å ä¸ºDafnyä¼ä¸ºä½ æ·»å å®ãæ¢å¥è¯è¯´ï¼Dafnyæ¥åäºä¸é¢è¿ä¸ªå¼ççè¯æ:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nç®æ´æäº\n\n\n# èªå¨å½çº³çè¯¦ç»æåµ\n\nDafnyèªå¨å½çº³æ³å½æ ¹ç»åºå°±æ¯å¨æ¯ä¸ªå¼ççå¼å¤´èªå¨çæä¸ä¸ªforallè¯­å¥ãè¿å¹¶ä¸è½è§£å³ææçå½çº³æ³é®é¢ï¼ä½æå¾æè®¶ï¼è¿ä¸ªç®åçæ¹æ³ç¡®å®è§£å³äºè¿ä¹å¤ç®åçå½çº³æ³é®é¢ãè®©æä»¬æ¥ççè¿ä¸ªå¨ä½çç»æé¨åã\n\nå¯¹äºå¸¦æå½¢å¼åæ°argsãåç½®æ¡ä»¶P(args)ã5åç»æ­¢åº¦éT(args)çå¼çLï¼ Dafnyèªå¨å½çº³å¨Lçä¸»ä½å¼å¤´æå¥ä»¥ä¸forallè¯­å¥:\n\nforall aa` | P(args`) && T(args`) < T(args) {\n  L(args`);\n}\n\n\n1\n2\n3\n\n\næ­¤å¤\n\n * aaæ¯å½¢å¼åæ°argsçå­éï¼\n * aa âæ¯aaï¼éå½å°éå½åææ°çåå­ï¼\n * argsâè¡¨ç¤ºargsï¼ä½æ¯aa âä¸­çæ¯ä¸ªåéé½è¢«aaä¸­çç¸åºåéæ¿æ¢ï¼å¹¶ä¸\n * <è¡¨ç¤ºDafnyçå­å¸é¡ºåºæ¯ææ ¹æ®çã\n\nåéargsçå­éaaå¯ä»¥éè¿å¨å¼çä¸æ¾ç½®å±æ§{:induction aa}æ¥å®å¶ãå¦ææ²¡æç»åºè¿æ ·çå±æ§ï¼é£ä¹Dafnyå¯åå¼å°éæ©aaãå½æ¨å°é¼ æ æ¬åå¨å¼ççåç§°ä¸æ¶ï¼Dafnyä¼å¨å·¥å·æç¤ºä¸­æ¥åå®æéæ©çåå®¹ã\n\næä»¬å¯ä»¥æ{:induction x}çä½æ¯âå¯¹xè¿è¡å½çº³æ³âï¼ä½æ¯è¦å°å¿ä¸ç¹ãæåç°âå½çº³æ³èè¿â¦â¦âè¿ä¸ªç­è¯­å¨æ°å­¦ä¸çå¸¸ç¨ç¨æ³åå¹¶äºå ä¸ªæ¦å¿µãå æ­¤ï¼åç¡®å°è¯´ï¼{:induction aa}å±æ§æå®çæ¯åªäºåæ°è¦å¨ä¸ç»ä¸éåã\n\nè¿æä¸ä¸ªå¾å®¹æå¿è®°çå¾®å¦ä¹å¤:âåå°âæ¡æ¬¾å¾éè¦ãå½æä»¬åä¸ä¸ªç±»ä¼¼äºRangeLengthçå¼çæ¶ï¼æä»¬å¯è½ææè¯æè¶³å¤ç®åï¼ä»¥è³äºDafnyçèªå¨å½çº³æ³ä¼èªå¨å¤çå®ãå¦ææ¯è¿æ ·ï¼æä»¬å¯ä»¥åä¸å¼ççç±»åç­¾åå(åç½®ååç½®æ¡ä»¶)ãè¿éå¸¸æ¯ææéè¦çï¼ä½å¨RangeLengthçæåµä¸ï¼è¿éè¦æä¾åå°å­å¥ãéå¸¸ï¼å¦æå¼çææ¶åçä¸»å½æ°(è¿è¡ç¤ºä¾ä¸­çRange)éè¦ä¸ä¸ªæ¾å¼çåå°å­å¥ï¼é£ä¹å¼çä¹éè¦ãåï¼è¿å¾å®¹æè¢«å¿è®°ã\n\næ¥ä¸æ¥ï¼è®©æä»¬èèä¸äºèªå®ä¹RangeLengthèªå¨å½çº³çæ¹æ³ã\n\n\n# ä¾å¦:ç¼ºå°decreases\n\nå¦æä½ å¿è®°äºâRangeLengthâçâåå°âå­å¥ä¼åçä»ä¹?å¼ççèµ·æ¥æ¯è¿æ ·ç:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nå¯¹äºè¿ä¸ªå¼çï¼Dafnyæåºäº{:induction startï¼len}ådecreases startï¼len.6è¿æå³çè¯±å¯¼æä½æå¥éå«çforallè¯­å¥\n\nforall start`: nat, len`: nat |\n  start` < start || (start` == start && len` < len)\n{\n  RangeLength(start`, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\næ­£å¦æä»¬å¨åä¸èä¸­ææ¢è®¨çï¼è¿å¹¶ä¸è½è¯æè¿ä¸ªå¼çï¼å ä¸ºå³é®çè°ç¨RangeLength(start+1, len-1)ä¸å¨æ§è¡çè°ç¨ä¸­ã\n\n\n# ä¾å¦:åªå¯¹lenè¿è¡éå\n\nå¦ææä»¬æå¨è¦çéååéï¼åªååºlenä¼æä¹æ ·?\n\nlemma {:induction len} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nç¶åæä»¬å¾å°ä¸é¢çforallè¯­å¥:\n\nforall len`: nat |\n  start < start || (start == start && len` < len)\n{\n  RangeLength(start, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\næ³¨æï¼è¿ä¸ªä¾å­ä¸­æ²¡æstartãç¸åï¼åå§çå½¢å¼åæ°startç¨äºå¬å¼åçèå´è¡¨è¾¾å¼\n\nP(start, len`) && T(start, len`) < T(start, len)\n\n\n1\n\n\nå¨è¿ä¸ªä¾å­ä¸­æ²¡æåå³æ¡ä»¶ï¼æä»¥Pé¨åæ¯trueãå ä¸ºæä»¬æ²¡ææä¾ä¸ä¸ªæç¡®çåå°æ¡æ¬¾ï¼Dafnyçæäºdecreases startï¼lenãå æ­¤ï¼éå¶å¨å±éååé(å³len â)çèå´è¡¨è¾¾å¼æ¯\n\nstart < start || (start == start && len` < len)\n\n\n1\n\n\nç®åä¸ºlen â < len\n\nåæ ·ï¼ç±äºforallè¯­å¥æåå«çéå½è°ç¨ä¸åæ¬å³é®çè°ç¨RangeLength(start+1, len-1)ï¼Dafnyå°æ¥åä¸ä¸ªéè¯¯ï¼å¼ççåç½®æ¡ä»¶å¯è½ä¸æç«ã\n\nå³ä½¿æä»¬æå¨æä¾äºä¸ä¸ªâåå°âæ¡æ¬¾ï¼ç»æä¹æ¯ä¸æ ·çãè¿ä»ç¶ä¼å°len âéå¶ä¸ºå°äºlençå¼ï¼è¿æ¯å¯ä»¥çï¼ä½é®é¢ä»ç¶æ¯å½çº³åè®¾åªèèç»å®çstartå¼ã\n\n# è´è°¢\n\næå¾æè°¢Sean McLaughlinï¼ä»æä¾äºè·æ­¥çä¾å­åå³äºRangeLengthèªå¨æåºçé®é¢ã\n\n\n# åèæç®\n\n[0]K. Rustan M. Leino. Automating induction with an SMT solver. In Viktor Kuncak and Andrey Rybalchenko, editors, Verification, Model Checking, and Abstract Interpretation â 13th International Conference, VMCAI 2012, volume 7148 of Lecture Notes in Computer Science, pages 315â331. Springer, January 2012. ð\n\n[1]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments â 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170â190. Springer, 2014. ð\n\n----------------------------------------\n\n0.æåç®äºä¸ä¸ãDafnyå¯¹æ´æ°çåçæåºå®éä¸æ¯âå°äºï¼ä¸ä¸è¶è¿ä¸ä¸ªè´æ°çæ´æ°âãæä»¥ï¼ä¸æ¡é¾åè®¸ä¸éå°0ä»¥ä¸ï¼ä½ä¸æ¦å®åå«ä¸ä¸ªè´æ°ï¼å®å°±å¿é¡»åæ­¢ãè¿ä¸ªæ©å±æ¯ä¸ä¸ªææ ¹æ®çé¡ºåºï¼å ä¸ºä»ç¶æ²¡æåæ³ååºä¸ä¸ªæ ééåé¾ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-int-order)\n\n1.æåç®äºä¸ä¸ãDafnyçåºå®çææ ¹æ®çé¡ºåºä¹å¯¹ä¸åç±»åçå¼è¿è¡æåºã[â©](http://leino.science/papers/krml269.html # back-fn-fn-across-types)\n\n2.è¿æ¯ä¸ä¸ªè½»å¾®çç®åãDafnyä¸ºéå½å½æ°/æ¹æ³/å¼çæåºâåå°âå­å¥çå¯åå¼æ¹æ³çç¥äºç±»åå¯¹è¯æç»æ­¢æ²¡æå¸®å©çåæ°ãä¾å¦ï¼ç±»åä¸ºç±»ååæ°çåæ°ä¼å¨èªå¨çæçâåå°âå­å¥ä¸­è¢«çç¥ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-auto-decr)\n\n3.å¨åé¢çä¾å­ä¸­ï¼æææ¡å¾å¾åï¼å ä¸ºæä¹åºè¯¥æåº10*len + 18æ¯éè´çã)ä½èç³»\n\n4.âæ æ°ä¸ªçµè¯?!âä½ å¯¹èªå·±è¯´ã"å³ä½¿æ¯ä¸ªè°ç¨é½ç»æ­¢äºï¼ç»æ­¢æ¯æä¹åäº? "æä¸ä¼å¨è¿éæ·±å¥ç ç©¶ï¼ä½æè³å°è¦æåºï¼æä»¬è°ç¨çæ¯ä¸ä¸ªå¼çï¼èä¸æ¯ä¸ä¸ªç¼è¯çæ¹æ³ãå æ­¤ï¼æ¨ä¸éè¦æå¿æ¯å¦æè¶³å¤çè®¡ç®èµæºæ¥è¿è¡æ éæ¬¡è°ç¨ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-inf-calls)\n\n5.å¼ççåææ¡ä»¶æ¯ä½¿ç¨å³é®å­requireså£°æçãå®å°±åå¼ççä¸ä¸ªåè¡è¯ï¼å¨æ¯ä¸ªå¼å«ç¹é½è¦æ£æ¥å®æ¯å¦æç«ãè¿è¡çç¤ºä¾ä¸åå«åç½®æ¡ä»¶ãä¸ä¸ªç®åçæ¹æ³æ¯å°startçç±»åä»natæ´æ¹ä¸ºintï¼å¹¶æ·»å require 0 <= startã[â©](http://leino.science/papers/krml269.html # back-fn-fn-pre)\n\n6.ææå°è¿Dafny ideä¸­çå·¥å·æç¤ºä¼åè¯ä½ Dafnyéæ©äºåªäºâåå°âæ¡æ¬¾ãå¨æ°åæ¬ææ¶ï¼åªæå½å½æ°/æ¹æ³/å¼ççä¸»ä½åå«æ¾å¼éå½è°ç¨æ¶ï¼æä¼æ¾ç¤ºè¿æ ·çå·¥å·æç¤ºãç¹å«æ¯ï¼å¦æå¼ççä¸»ä½æ¯ç©ºçï¼åæ²¡æå·¥å·æç¤ºæ¾ç¤ºçæäºä»ä¹âåå°âå­å¥ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-no-decr-tooltip)',normalizedContent:'# èªå¨å½çº³\n\n> k. rustan m. leino manuscript krml 269, 31 may 2019\n\næè¦\n\nå¯¹äºç®åçä¾å­ï¼dafnyçèªå¨å½çº³æ³è¶³å¤å¼ºå¤§ï¼å¯ä»¥å¨ä¸éè¦äººå·¥è¾å¥çæåµä¸è¯æä¸äºå¼çï¼å¹¶å¸®å©åå°è¯æå¶ä»å¼çæéçäººå·¥è¾å¥ãæ¬è¯´æè§£éäºèªå¨æåºæ¯å¦ä½åºç¨çï¼ä»¥åå¦ä½ä½¿ç¨ä¸¤ä¸ªä¸»è¦æé®æ¥è°æ´èªå¨åçåè½ã\n\n> dafnyä¸ä»æ¯ææå·¥ç¼åçå¼çï¼èä¸è¿æä¾äºä¸äºèªå¨ååè½ï¼å¸®å©éè¿å½çº³æ¥è¯æå¼ç[0]ãè®©æä»¬ä»æå¨è¯æçååå¼å§ï¼ç¶åççèªå¨æåºå¦ä½æä¾ææ æ³æä¾è¯æï¼æåççå¦ä½è°æ´èªå¨åçåè½ã\n\n\n# è¿è¡å®ä¾\n\n\n# åè¡¨åå½æ°å®ä¹\n\nèèä»¥ä¸éå½å®ä¹åè¡¨çæ åå®ä¹ï¼ä»¥åä¸ä¸ªlengthå½æ°åä¸ä¸ªæé éå¢æ´æ°åè¡¨çå½æ°ã\n\ndatatype list<a> = nil | cons(a, list<a>)\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method range(start: int, len: nat): list<int>\n  decreases len\n{\n  if len == 0 then nil else cons(start, range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\næäºè¿äºå®ä¹ï¼æä»¬å¼å§è¯æåè¡¨range(start, len)çé¿åº¦æ¯lenã\n\n\n# å¼çåè¯æ\n\næä»¬è¦è¯ælist range(start, len)çé¿åº¦æ¯lenãæä»¬ä»æå·¥éªè¯å¼å§ãä¸ºäºç¡®ä¿å¨ç¬¬ä¸ä¸ªç¤ºä¾ä¸­èªå¨å½çº³ä¸ä¼å¯¹æä»¬æå¸®å©ï¼æç¨å±æ§{:induction false}æ è®°äºå¼çã\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      length(range(start, len));\n    ==  // def. range, since len > 0\n      length(cons(start, range(start+1, len-1)));\n    ==  // def. length on cons\n      1 + length(range(start+1, len-1));\n    ==  { rangelength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\næç¤º\n\nåºäºæ¬æçç®çï¼æåè®¾æ¨å·²ç»åºæ¬äºè§£å¦ä½æå¨ç¼åè¿æ ·çè¯æï¼æ è®ºæ¯å¨dafnyè¿æ¯å¨çº¸ä¸ãæå°å¨è¿éæè¿°è¯æçè¦ç´ ï¼ä½ä¸ä¼è¯å¾è§£éææå¯è½çèèå ç´ ã\n\nå¼çç§°ä¸ºrangelengthï¼ç±startålenåæ°åï¼å°±årangeå½æ°ä¸æ ·ãå¼çè¯æçå±æ§å¨ensureså­å¥ä¸­éè¿°ãå®ä¹è¢«ç§°ä¸ºâè¯æç®æ âã\n\nå¼ççç­¾åé¨åè¿å®ä¹äºä¸ä¸ªdecreaseså­å¥ï¼è¯¥å­å¥è¡¨ç¤ºè¡¨è¾¾å¼lenå°è¢«ç¨ä½å¼ççä»»ä½éå½è°ç¨çç»æ­¢åº¦éãè¿ä¸ªç»æ­¢åº¦è§ä¸âèå´âå½æ°çç»æ­¢åº¦è§ç¸åãè¿å¾å¸¸è§ï¼å ä¸ºå¨å¼ççè¯æç®æ ä¸­ï¼è¯æçç»æéå¸¸éµå¾ªå½æ°çç»æã\n\nå¼çä¸»ä½åä¸ºä¸¤ç§æåµï¼éµå¾ªâèå´âå®ä¹ä¸­çæåµãç¬¬ä¸ä¸ªä¾å­æ¯len == 0ï¼å®ç»åºäºä¸ä¸ªéå¸¸ç®åçè¯æ:å½len == 0æ¶ï¼rangeè¿åé¿åº¦ä¸º0çnilã\n\nå¦ä¸ç§æåµæ¯ä½¿ç¨å·²éªè¯çè®¡ç®ï¼éå¸¸ç§°ä¸ºcalcè¯­å¥[1]ãè¿ä¸ªè®¡ç®ä»è¡¨è¾¾å¼length(range(start, len))å¼å§ï¼å¹¶ä½¿ç¨ä¿æç­å¼çè½¬æ¢æ¥å¾å°lenï¼è¿æ­£æ¯è¯æç®æ æè¯´çå¼çå¿é¡»è¯æçãè®¡ç®çåä¸¤ä¸ªæ­¥éª¤åºç¨rangeålengthçå®ä¹ï¼å°è¡¨è¾¾å¼éåä¸ºæä»¬å¯ä»¥çå°è¡¨è¾¾å¼çå½¢å¼\n\nlength(range(start+1, len-1))\n\n\n1\n\n\nè¿å°±æ¯è¯æè¿ç¨ä¸­æè¶£çä¸æ­¥ãæä»¬æ³ç¨len - 1æ¿æ¢è¿ä¸ªè¡¨è¾¾å¼ï¼è¿éè¦è¯æè¡¨è¾¾å¼ç¡®å®ç­äºlen - 1ãç¨æ­£ç¡®çåæ°ï¼è¿å°±æ¯æä»¬è¦è¯æçå¼çãå æ­¤ï¼æä»¬ä½¿ç¨calcè¯­å¥æç¤ºå¹¶è°ç¨å¼ç:\n\nrangelength(start+1, len-1);\n\n\n1\n\n\nå ä¸ºè¿æ¯å¯¹æä»¬è¦è¯æçå¼ççéå½è°ç¨ï¼æä»¬å¿é¡»è¯æç»æ­¢ãå¯¹å¼ççéå½è°ç¨éå¸¸è¢«ç§°ä¸ºâå½çº³åè®¾âçåºç¨ãè¿æ ·ï¼æä»¬çç»æ­¢æ£æ¥å¯¹åºäºç¡®ä¿å½çº³æ¯âææ ¹æ®çâãå¨dafnyä¸­ï¼éè¿æ¾ç¤ºæ¯ä¸ªéå½è°ç¨é½ä¼åå°ä¸äºç»æ­¢åº¦éæ¥è¯æç»æ­¢ï¼ä¹å°±æ¯è¯´ï¼éå½è°ç¨çæä¸ªè¡¨è¾¾å¼çè®¡ç®å¼æ¯è°ç¨èçå¼è¦å°ãè¿ä¸ªæ´å°çç»æ­¢åº¦è§è¡¨è¾¾å¼æ¯ä»ä¹âæ´å°âæ¯ä»ä¹ææ?è¡¨è¾¾å¼æ¯lenï¼ç±decreaseså­å¥ç»åºï¼ç±äºlenæ¯ä¸ä¸ªæ´æ°ï¼dafnyä½¿ç¨âå°äºï¼ä»¥0ä¸ºççæ´æ°âä½ä¸ºé¡ºåºã\n\n\n# ç»æ­¢çç»è\n\nè¿å¤ªæå£äºãè®©æä»¬ååé¡¾ä¸ä¸æåä¸é¨åï¼å³äºç»æ­¢çé¨åã\n\nä¸ºäºè¯æå¯¹ä¸ä¸ª(å½æ°ãæ¹æ³æ)å¼ççéå½è°ç¨ä¼ç»æ­¢ï¼æä»¬å°å¼ççæ¯æ¬¡è°ç¨æç§åççé¡ºåºä¸ä¸ä¸ªå¼å³èèµ·æ¥ãæååççç±æå³çä¸å­å¨æ éçéåºé¾ãä¹å°±æ¯è¯´ï¼å­å¨åºå®çæåºï¼å¹¶ä¸å¨è¯¥æåºä¸­ï¼æ¯ä¸ä¸ªè¿ç»­çå°å¼åºåé½æ¯æéçãä¾å¦ï¼å¨âå°äºï¼ä»¥â0âä¸ºççæ´æ°âæåºä¸­ï¼ä¸ä¸ªéåºé¾æ¯\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nè¿ä¸ªé¾æ¯æéçãæ è®ºæ¨åä¸çéåºé¾æ¯ä»ä¹ï¼å®é½æ¯æéç(å¦åï¼æ¨æç»ä¼å¾å°ä¸ä¸ªè´æ°ï¼ä½è¯·è®°ä½æä»¬è¯´è¿âä»¥â0âä¸ºçâ0)ã\n\ndafnyä¸ºæ¯ç§ç±»åæå»ºäºä¸ä¸ªåºå®çãåºäºè¯å¥½åºç¡çé¡ºåºã1å®è¿æ¯æå¼çå­å¸åç»ï¼è¿ç§åç»çè¯å¥½åºç¡é¡ºåºæ¯æ¯ä¸ªç»ä»¶ä¸ç±»åçå­å¸é¡ºåºã\n\næä»¬å°å¼çè°ç¨ä¸è¿ä¸ªåºå®çãææ ¹æ®çé¡ºåºçå¼å³èçæ¹å¼æ¯å£°æä¸ä¸ªdecreaseså­å¥ãå®çåæ°æ¯ä¸ä¸ªè¡¨è¾¾å¼åè¡¨ï¼è¿äºè¡¨è¾¾å¼ææä¸ä¸ªå­å¸åç»ãå¯¹äºârangelengthâå¼çï¼æä»¬ä½¿ç¨äºâåå°lenâãè¿æå³çæ¯æ¬¡å¯¹å¼ççè°ç¨é½å°ä¸ä¼ å¥åæ°lençç¸åå¼ç¸å³èã\n\nå½æ°rangeä¹æ¯éå½çï¼å¯¹äºå®çè°ç¨ï¼æä»¬è¿ä½¿ç¨lenä½ä¸ºç»æ­¢åº¦éãå½æ°lengthä¹æ¯éå½çï¼ä½æ¾ç¶æä»¬æ²¡æç»å®ä¸ä¸ªdecreaseså­å¥ãå¨ç¼ºå°decreaseså­å¥çæåµä¸ï¼dafnyä¸ºæä»¬æä¾äºä¸ä¸ªå­å¥ï¼å³æç»å®é¡ºåºç±å½æ°/æ¹æ³/å¼è¯çåæ°ç»æçå­å¸åç»ã2lengthçç»æ­¢åº¦éæ¯list(dafnyçæçææ®çå½çº³æ°æ®ç±»åçé¡ºåºæ¯ç»æåå«)ãdafnyçideæä¾äºä¸ä¸ªå·¥å·æç¤º(ä½ å¯ä»¥å¨å½æ°/æ¹æ³/å¼çå£°æä¸çå°)ï¼åè¯ä½ å®ä¸ºéå½å½æ°/æ¹æ³/å¼çéæ©äºåªä¸ªâåå°âå­å¥ã\n\nå°ç®åä¸ºæ­¢ï¼æå·²ç»è¯´è¿dafnyå®ä¹äºä¸ä¸ªåºå®çãææ ¹æ®çæåºï¼èå°å¼çè°ç¨ä¸è¯¥æåºä¸­çå¼å³èçæ¹æ³æ¯å£°æä¸ä¸ªâåå°âå­å¥ãéªè¯èå¦ä½ä½¿ç¨è¿äºä¸è¥¿æ¥è¯æç»æ­¢?å®è¯æäºä¸è¢«è°ç¨æ¹å³èçå¼ä¸¥æ ¼ä½äºä¸è°ç¨æ¹å³èçå¼ãæ¢å¥è¯è¯´ï¼å®è¯æäºæ¯ä¸ªéå½è°ç¨é½å¨éåé¾ä¸­éåäºä¸æ­¥ãå ä¸ºæ¯ä¸ªé¾é½æ¯æéçï¼æä»¥ä¸å­å¨æ ééå½ãæ¢å¥è¯è¯´ï¼éå½è°ç¨ç»æ­¢ã\n\nå¨è¿ä¸ªä¾å­ä¸­ï¼æä¸ä¸ªä»rangelength(start, len)å°rangelength(start+1, len-1)çéå½è°ç¨ãå¼çä½¿ç¨äºdecreases lenï¼æä»¥éªè¯å¨æ£æ¥len-1 < lenï¼è¿è¯æäºç»æ­¢ã\n\nç±»ä¼¼å°ï¼æä¸ä¸ªä»range(start, len)å°range(start+1, len-1)çéå½è°ç¨ãéªè¯å¨æ£æ¥len-1 < lenï¼è¿è¯æäºç»æ­¢ã\n\næåï¼æä¸ä¸ªä»length(list)å°length(tail)çéå½è°ç¨ï¼å¶ä¸­tailå¨ç»æä¸åå«å¨listä¸­ãå æ­¤ï¼éªè¯èä¹å¯ä»¥å¨è¿éè¯æç»æ­¢ã\n\n\n# rangelengthçå¶ä»ç»æ­¢åº¦é\n\nèèä¸ä¸å¦ææä»¬ä¸ºârangelengthâéæ©ä¸åçç»æ­¢åº¦éä¼åçä»ä¹æ¯ææå¯¼æä¹çãå¯¹äºæä»¬èèçæ¯ä¸ä¸ªåç´ ï¼è¯æä¹å¡çæé æ¹å¼é½æ¯ç¸åç:rangelength(start+1, len-1)çå¼å¿é¡»å°äºrangelength(start, len)çå¼ã\n\nåè®¾æä»¬å£°ærangelengthå¸¦ædecreases 10*len + 28ãæ¯çï¼è¿ä¸ªç»æ­¢åº¦è§è¶³ä»¥è¯æç»æ­¢ï¼å ä¸º10*len + 18å°äº10*len + 28ã\n\ndecreases len - 6å¢?ä¸ï¼dafnyä¼æ±æ¨ä¸è½è¯æç»æ­¢ï¼å¦æä½ ç»å®è¿ä¸ªç»æ­¢åº¦éãå®å°æ æ³è¯æå¨æ´æ°æåºä¸­lens -7ä½äºlens -6ï¼å ä¸ºå®ä»¬å¯è½æ¯è´çã3\n\nè®©æä»¬è¯è¯decreases start + lenãä¸ï¼å ä¸ºstart+1 + len-1ä¸å°äºstart+ lenã\n\ndecreases start + 2*lenæä¹æ ·?æ¯çï¼è¿è¯æäºç»æ­¢ï¼å ä¸ºstart+1 + 2*(len-1)å°äºstart+ 2*lenã\n\nä½¿ç¨å­å¸åç»start, lenæä¹æ ·?ä¸ï¼è¿ä¸ä¼è¯æç»æ­¢ï¼å ä¸ºstart+1, len-1å¨å­å¸ä¸å¹¶ä¸å°äºstart, len(äºå®ä¸ï¼å®å¨å­å¸ä¸æ´å¤§)ãå¦ææä»¬æârangelengthâä¸­çâåå°âå»æï¼dafnyä¼ä¸ºæä»¬çæä¸ä¸ªãå®çæçå¼æ¯decreases start, lenï¼å ä¸ºrangelengthçåæ°æ¯startålenï¼æè¿ä¸ªé¡ºåºãå æ­¤ï¼å¦ææ²¡ææç¡®çâåå°âæ¡æ¬¾ï¼dafnyä¼æ±æ¨æ æ³è¯æç»æ­¢ååã\n\nå¦ä½åæ¢åæ°çé¡ºåºï¼æ¯å¦len, start ?æ¯çï¼è¿è¯æäºç»æ­¢ï¼å ä¸ºlen-1, start+1å°äºlen, startã\n\nå¦æä½ æ¹årangelengthæ¥äº¤æ¢å®çåæ°startålen(å¹¶ä¸å¯¹rangelengthååæ ·çäº¤æ¢éå½è°ç¨)ï¼é£ä¹ä½ å¯ä»¥å¿½ç¥decreaseså­å¥ãå¨æ¬ä¾ä¸­ï¼dafnyå°çædecreases len, startï¼è¿è¯æäºç»æ­¢ãç¶èï¼éå¸¸å»ºè®®åæåæ°é¡ºåºï¼è¿æ¯æè¾¹å½æ°/æ¹æ³/å¼çæèªç¶çé¡ºåºã\n\næåï¼è¿ä¸ªå¥æªçç»æ­¢ææ decreases 7,lenæä¹æ ·?å½ä½ ç¬¬ä¸æ¬¡å¤§å£°è¯»å°è¿ä¸ªçæ¶åï¼ä½ å¯è½ä¼è¯´\n\n> åå°7 ?ä»ä¹ä¸è¥¿è½åå°å¢?7æ¯ææ¾ç¥ç¶æ¯å¨ä¸æ¶çæ°å­ï¼7å°æ°¸è¿æ¯è¿ä¸ªæ°å­ãæ²¡æåæ³éä½!\n\nä½ æ¯å¯¹çï¼ä½âåå°âæ¡æ¬¾ä¸æ¯è¿ä¹è¯´çãâåå°âå­å¥åªæ¯ç®åå°è¯´æäºå¦ä½å°æ¯ä¸ªå¼çè°ç¨ä»¥åççé¡ºåºæ å°å°ä¸ä¸ªå¼ãæä»¥ï¼æäºè¿ä¸ªå¥æªçç»æ­¢åº¦éï¼è¯æçä¹å¡æ¯æ£æ¥7,len-1å¨å­å¸ä¸å°äº7,lenï¼å®ç¡®å®æ¯ãå¶å®ä¹æ²¡é£ä¹å¤æªã\n\n\n# ä¸ä¸ªè¾ç­çè¯æ\n\nè®©æä»¬ç®åæä»¬ä¸ºrangelengthç¼åçæå¨è¯æãå½æä»¬åä¸ä¸ªè¯æçæ¶åï¼calcè¯­å¥æ¯å¾æç¨çï¼å®ä¹æä¾äºä¸ä¸ªå¯è¯»çè¯æãä½ä¸æ¦æä»¬æ¾å°äºä¸ä¸ªè¯æï¼æä»¬ææ¶ä¼éæ©ç¼©ç­å®ï¼ä¹è®¸æ¯å ä¸ºåæ³èµ·æ¥ï¼æä»¬åç°èªå·±å¤ªæè°¨äºï¼å³ä½¿æ¯å¯¹æä»¬èªå·±çå£å³æ¥è¯´ã\n\næä»¬ä¸é¢åçcalcéè¿°å®éä¸åªæä¸ä¸ªéè¦æ­¥éª¤ï¼å³å½çº³åè®¾çåºç¨ãäºå®ä¸ï¼æä»¬å¯ä»¥ç¨ä¸ä¸ªè°ç¨æ¥æ¿æ¢æ´ä¸ªcalcè¯­å¥:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå ä¸ºifç" then "åæ¯æ¯ç©ºçï¼æä»¬å½ç¶ä¹å¯ä»¥å¦å®å®å«ï¼äº¤æ¢åæ¯ï¼å¹¶çç¥ç©ºçelse:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# å¼ºæåº\n\næä»¬è¿è½æ¯è¿ä¸ªifè¯­å¥åå¾æ´å¥½å?é£è¦çä½ è§å¾ä»ä¹æ´å¥½äºï¼ä½å¨è¾¾èå¦®æåæ³æ¶é¤è¿ä¸ªåæ¯ãæä»¬å¯ä»¥éè¿æ¿æ¢æ´ä¸ªifè¯­å¥åå®å¯¹rangelengthçä¸æ¬¡è°ç¨ï¼ç¨forallè¯­å¥è°ç¨rangelengthæ¥è·åä¸å¤§å å¼ã\n\né¦åï¼åè®¾æä»¬å°è¯ä½¿ç¨ä»¥ä¸ä»£ç ä½ä¸ºrangelengthçä¸»ä½:\n\nforall start`, len` {\n  rangelength(start`, len`);\n}\n\n\n1\n2\n3\n\n\nè¿ä¸ªæ¼«ä¸ç»å¿çè¯­å¥å¯¹ææå¯è½çstartålenå¼è°ç¨rangelengthãè¿æ¯è¡ä¸éçï¼å ä¸ºå¾å¤éå½è°ç¨é½ä¸ä¼ç»æ­¢ãæä»¬éè¦éå¶èªå·±çå¼ä¸ºstartålenï¼ä»¥åå°ç»æ­¢åº¦éã\n\né£ä¹ï¼è®©æä»¬è¯è¯è¿ä¸ª:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  forall start`, len` | 0 <= len` < len {\n    rangelength(start`, len`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¯¹äºææçstartå¼åææå°äºlenå¼ï¼è°ç¨rangelengthãä¹å°±æ¯è¯´ï¼è¿ä¸ªforallè¯­å¥ä¸æ¬¡æ§å¯¹rangelengthè¿è¡äºæ æ°æ¬¡éå½è°ç¨ãç±äºlen çå¼å°äºlenï¼è¿æ æ°æ¬¡è°ç¨ä¸­çæ¯ä¸æ¬¡é½ä¼ç»æ­¢ã4\n\nè¿ä¸ªçæ¬çrangelengthè¿è¡éªè¯ãå¯¹äºææè¿æ ·çå°å¼çå½çº³åè®¾çæ°å­¦åç§°å«åâå¼ºå½çº³âã\n\nå¥½çï¼startçå¼å¯ä»¥å¤§äºstart(å¨è¿ä¸ç¹ä¸ï¼å®å¯¹äºè¯æstart + 1æ¯å¶ä¸­ä¸ä¸ªå¼æ¯è³å³éè¦ç)ãæä»¥ï¼ä½ å¯è½è®¤ä¸ºä¸é¢çâä¸ºææäººâçéè¿°ä¸ä»ä»æ¯å¼ºå½çº³ãäºå®ä¸ï¼æäºäººå¯è½ä¼äºè¾©è¯´ï¼è¿ä¸ªforallè¯­å¥ä¹æ§è¡äºæè°çâæ³åâå¼çå°ææçstartå¼ãä½æ¯å¦æä½ è®¤ä¸ºå³å®smallerçæåºåªæ¯æ¯è¾lenç»ä»¶ï¼é£ä¹startï¼ len decreasesç¡®å®æ¯start, len å°ï¼åªè¦len å°äºlenãä¸ç®¡ä½ æ³æä¹æ³ï¼æèä½ æ³ç»å®èµ·ä»ä¹æ°å­¦åå­ï¼dafnyé½æ¥åä¸é¢çâææäººâçè¯´æ³ä½ä¸ºè¯æãå¨ç¼ç¨æ¯è¯­ä¸­ï¼æä»¬æåçå°±æ¯è¯ææ¯ä¸ªéå½è°ç¨é½ä¼ç»æ­¢ï¼è¿ä¸æä»¬å®ä¹ç»æ­¢åº¦è§çæ¹å¼æ¯ä¸æ ·çï¼å³decreases lenã\n\n\n# èªå¨å½çº³\n\næäºè¿äºèæ¯ç¥è¯ï¼æä»¬ç»äºå¯ä»¥äºè§£dafnyæ¯å¦ä½å®ç°èªå¨æåºçäºãç®èè¨ä¹:å¦æä½ å é¤å±æ§{:inducerfalse}(æå¼å¥è¿ä¸ªå±æ§åªæ¯ä¸ºäºç¦ç¨èªå¨æåºï¼èæä»¬å¨ä¸å¼å§è®¨è®ºä»ä¹æ¯è¯æ)ï¼é£ä¹dafnyå¨é»è®¤æåµä¸æåçå°±æ¯æå¥æä»¬åæçå°çforallè¯­å¥ãè¿æå³çä½ å¯ä»¥å é¤æå¨æå¥çforallè¯­å¥ï¼å ä¸ºdafnyä¼ä¸ºä½ æ·»å å®ãæ¢å¥è¯è¯´ï¼dafnyæ¥åäºä¸é¢è¿ä¸ªå¼ççè¯æ:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nç®æ´æäº\n\n\n# èªå¨å½çº³çè¯¦ç»æåµ\n\ndafnyèªå¨å½çº³æ³å½æ ¹ç»åºå°±æ¯å¨æ¯ä¸ªå¼ççå¼å¤´èªå¨çæä¸ä¸ªforallè¯­å¥ãè¿å¹¶ä¸è½è§£å³ææçå½çº³æ³é®é¢ï¼ä½æå¾æè®¶ï¼è¿ä¸ªç®åçæ¹æ³ç¡®å®è§£å³äºè¿ä¹å¤ç®åçå½çº³æ³é®é¢ãè®©æä»¬æ¥ççè¿ä¸ªå¨ä½çç»æé¨åã\n\nå¯¹äºå¸¦æå½¢å¼åæ°argsãåç½®æ¡ä»¶p(args)ã5åç»æ­¢åº¦ét(args)çå¼çlï¼ dafnyèªå¨å½çº³å¨lçä¸»ä½å¼å¤´æå¥ä»¥ä¸forallè¯­å¥:\n\nforall aa` | p(args`) && t(args`) < t(args) {\n  l(args`);\n}\n\n\n1\n2\n3\n\n\næ­¤å¤\n\n * aaæ¯å½¢å¼åæ°argsçå­éï¼\n * aa âæ¯aaï¼éå½å°éå½åææ°çåå­ï¼\n * argsâè¡¨ç¤ºargsï¼ä½æ¯aa âä¸­çæ¯ä¸ªåéé½è¢«aaä¸­çç¸åºåéæ¿æ¢ï¼å¹¶ä¸\n * <è¡¨ç¤ºdafnyçå­å¸é¡ºåºæ¯ææ ¹æ®çã\n\nåéargsçå­éaaå¯ä»¥éè¿å¨å¼çä¸æ¾ç½®å±æ§{:induction aa}æ¥å®å¶ãå¦ææ²¡æç»åºè¿æ ·çå±æ§ï¼é£ä¹dafnyå¯åå¼å°éæ©aaãå½æ¨å°é¼ æ æ¬åå¨å¼ççåç§°ä¸æ¶ï¼dafnyä¼å¨å·¥å·æç¤ºä¸­æ¥åå®æéæ©çåå®¹ã\n\næä»¬å¯ä»¥æ{:induction x}çä½æ¯âå¯¹xè¿è¡å½çº³æ³âï¼ä½æ¯è¦å°å¿ä¸ç¹ãæåç°âå½çº³æ³èè¿â¦â¦âè¿ä¸ªç­è¯­å¨æ°å­¦ä¸çå¸¸ç¨ç¨æ³åå¹¶äºå ä¸ªæ¦å¿µãå æ­¤ï¼åç¡®å°è¯´ï¼{:induction aa}å±æ§æå®çæ¯åªäºåæ°è¦å¨ä¸ç»ä¸éåã\n\nè¿æä¸ä¸ªå¾å®¹æå¿è®°çå¾®å¦ä¹å¤:âåå°âæ¡æ¬¾å¾éè¦ãå½æä»¬åä¸ä¸ªç±»ä¼¼äºrangelengthçå¼çæ¶ï¼æä»¬å¯è½ææè¯æè¶³å¤ç®åï¼ä»¥è³äºdafnyçèªå¨å½çº³æ³ä¼èªå¨å¤çå®ãå¦ææ¯è¿æ ·ï¼æä»¬å¯ä»¥åä¸å¼ççç±»åç­¾åå(åç½®ååç½®æ¡ä»¶)ãè¿éå¸¸æ¯ææéè¦çï¼ä½å¨rangelengthçæåµä¸ï¼è¿éè¦æä¾åå°å­å¥ãéå¸¸ï¼å¦æå¼çææ¶åçä¸»å½æ°(è¿è¡ç¤ºä¾ä¸­çrange)éè¦ä¸ä¸ªæ¾å¼çåå°å­å¥ï¼é£ä¹å¼çä¹éè¦ãåï¼è¿å¾å®¹æè¢«å¿è®°ã\n\næ¥ä¸æ¥ï¼è®©æä»¬èèä¸äºèªå®ä¹rangelengthèªå¨å½çº³çæ¹æ³ã\n\n\n# ä¾å¦:ç¼ºå°decreases\n\nå¦æä½ å¿è®°äºârangelengthâçâåå°âå­å¥ä¼åçä»ä¹?å¼ççèµ·æ¥æ¯è¿æ ·ç:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nå¯¹äºè¿ä¸ªå¼çï¼dafnyæåºäº{:induction startï¼len}ådecreases startï¼len.6è¿æå³çè¯±å¯¼æä½æå¥éå«çforallè¯­å¥\n\nforall start`: nat, len`: nat |\n  start` < start || (start` == start && len` < len)\n{\n  rangelength(start`, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\næ­£å¦æä»¬å¨åä¸èä¸­ææ¢è®¨çï¼è¿å¹¶ä¸è½è¯æè¿ä¸ªå¼çï¼å ä¸ºå³é®çè°ç¨rangelength(start+1, len-1)ä¸å¨æ§è¡çè°ç¨ä¸­ã\n\n\n# ä¾å¦:åªå¯¹lenè¿è¡éå\n\nå¦ææä»¬æå¨è¦çéååéï¼åªååºlenä¼æä¹æ ·?\n\nlemma {:induction len} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nç¶åæä»¬å¾å°ä¸é¢çforallè¯­å¥:\n\nforall len`: nat |\n  start < start || (start == start && len` < len)\n{\n  rangelength(start, len`);\n}\n\n\n1\n2\n3\n4\n5\n\n\næ³¨æï¼è¿ä¸ªä¾å­ä¸­æ²¡æstartãç¸åï¼åå§çå½¢å¼åæ°startç¨äºå¬å¼åçèå´è¡¨è¾¾å¼\n\np(start, len`) && t(start, len`) < t(start, len)\n\n\n1\n\n\nå¨è¿ä¸ªä¾å­ä¸­æ²¡æåå³æ¡ä»¶ï¼æä»¥pé¨åæ¯trueãå ä¸ºæä»¬æ²¡ææä¾ä¸ä¸ªæç¡®çåå°æ¡æ¬¾ï¼dafnyçæäºdecreases startï¼lenãå æ­¤ï¼éå¶å¨å±éååé(å³len â)çèå´è¡¨è¾¾å¼æ¯\n\nstart < start || (start == start && len` < len)\n\n\n1\n\n\nç®åä¸ºlen â < len\n\nåæ ·ï¼ç±äºforallè¯­å¥æåå«çéå½è°ç¨ä¸åæ¬å³é®çè°ç¨rangelength(start+1, len-1)ï¼dafnyå°æ¥åä¸ä¸ªéè¯¯ï¼å¼ççåç½®æ¡ä»¶å¯è½ä¸æç«ã\n\nå³ä½¿æä»¬æå¨æä¾äºä¸ä¸ªâåå°âæ¡æ¬¾ï¼ç»æä¹æ¯ä¸æ ·çãè¿ä»ç¶ä¼å°len âéå¶ä¸ºå°äºlençå¼ï¼è¿æ¯å¯ä»¥çï¼ä½é®é¢ä»ç¶æ¯å½çº³åè®¾åªèèç»å®çstartå¼ã\n\n# è´è°¢\n\næå¾æè°¢sean mclaughlinï¼ä»æä¾äºè·æ­¥çä¾å­åå³äºrangelengthèªå¨æåºçé®é¢ã\n\n\n# åèæç®\n\n[0]k. rustan m. leino. automating induction with an smt solver. in viktor kuncak and andrey rybalchenko, editors, verification, model checking, and abstract interpretation â 13th international conference, vmcai 2012, volume 7148 of lecture notes in computer science, pages 315â331. springer, january 2012. ð\n\n[1]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments â 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170â190. springer, 2014. ð\n\n----------------------------------------\n\n0.æåç®äºä¸ä¸ãdafnyå¯¹æ´æ°çåçæåºå®éä¸æ¯âå°äºï¼ä¸ä¸è¶è¿ä¸ä¸ªè´æ°çæ´æ°âãæä»¥ï¼ä¸æ¡é¾åè®¸ä¸éå°0ä»¥ä¸ï¼ä½ä¸æ¦å®åå«ä¸ä¸ªè´æ°ï¼å®å°±å¿é¡»åæ­¢ãè¿ä¸ªæ©å±æ¯ä¸ä¸ªææ ¹æ®çé¡ºåºï¼å ä¸ºä»ç¶æ²¡æåæ³ååºä¸ä¸ªæ ééåé¾ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-int-order)\n\n1.æåç®äºä¸ä¸ãdafnyçåºå®çææ ¹æ®çé¡ºåºä¹å¯¹ä¸åç±»åçå¼è¿è¡æåºã[â©](http://leino.science/papers/krml269.html # back-fn-fn-across-types)\n\n2.è¿æ¯ä¸ä¸ªè½»å¾®çç®åãdafnyä¸ºéå½å½æ°/æ¹æ³/å¼çæåºâåå°âå­å¥çå¯åå¼æ¹æ³çç¥äºç±»åå¯¹è¯æç»æ­¢æ²¡æå¸®å©çåæ°ãä¾å¦ï¼ç±»åä¸ºç±»ååæ°çåæ°ä¼å¨èªå¨çæçâåå°âå­å¥ä¸­è¢«çç¥ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-auto-decr)\n\n3.å¨åé¢çä¾å­ä¸­ï¼æææ¡å¾å¾åï¼å ä¸ºæä¹åºè¯¥æåº10*len + 18æ¯éè´çã)ä½èç³»\n\n4.âæ æ°ä¸ªçµè¯?!âä½ å¯¹èªå·±è¯´ã"å³ä½¿æ¯ä¸ªè°ç¨é½ç»æ­¢äºï¼ç»æ­¢æ¯æä¹åäº? "æä¸ä¼å¨è¿éæ·±å¥ç ç©¶ï¼ä½æè³å°è¦æåºï¼æä»¬è°ç¨çæ¯ä¸ä¸ªå¼çï¼èä¸æ¯ä¸ä¸ªç¼è¯çæ¹æ³ãå æ­¤ï¼æ¨ä¸éè¦æå¿æ¯å¦æè¶³å¤çè®¡ç®èµæºæ¥è¿è¡æ éæ¬¡è°ç¨ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-inf-calls)\n\n5.å¼ççåææ¡ä»¶æ¯ä½¿ç¨å³é®å­requireså£°æçãå®å°±åå¼ççä¸ä¸ªåè¡è¯ï¼å¨æ¯ä¸ªå¼å«ç¹é½è¦æ£æ¥å®æ¯å¦æç«ãè¿è¡çç¤ºä¾ä¸åå«åç½®æ¡ä»¶ãä¸ä¸ªç®åçæ¹æ³æ¯å°startçç±»åä»natæ´æ¹ä¸ºintï¼å¹¶æ·»å require 0 <= startã[â©](http://leino.science/papers/krml269.html # back-fn-fn-pre)\n\n6.ææå°è¿dafny ideä¸­çå·¥å·æç¤ºä¼åè¯ä½ dafnyéæ©äºåªäºâåå°âæ¡æ¬¾ãå¨æ°åæ¬ææ¶ï¼åªæå½å½æ°/æ¹æ³/å¼ççä¸»ä½åå«æ¾å¼éå½è°ç¨æ¶ï¼æä¼æ¾ç¤ºè¿æ ·çå·¥å·æç¤ºãç¹å«æ¯ï¼å¦æå¼ççä¸»ä½æ¯ç©ºçï¼åæ²¡æå·¥å·æç¤ºæ¾ç¤ºçæäºä»ä¹âåå°âå­å¥ã[â©](http://leino.science/papers/krml269.html # back-fn-fn-no-decr-tooltip)',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"èªå¨è°ç¨å¼ç",frontmatter:{title:"èªå¨è°ç¨å¼ç",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1f579f/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/2.%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%BC%95%E7%90%86.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/2.èªå¨è°ç¨å¼ç.md",key:"v-1b6b0b30",path:"/pages/1f579f/",headers:[{level:2,title:"è¶çº§å¼ç",slug:"è¶çº§å¼ç",normalizedTitle:"è¶çº§å¼ç",charIndex:998},{level:2,title:"èåå¼çè°ç¨",slug:"èåå¼çè°ç¨",normalizedTitle:"èåå¼çè°ç¨",charIndex:1349},{level:2,title:"å½æ°åç½®æ¡ä»¶",slug:"å½æ°åç½®æ¡ä»¶",normalizedTitle:"å½æ°åç½®æ¡ä»¶",charIndex:1863},{level:2,title:"åºæ¬/é«çº§å½æ°å¯¹",slug:"åºæ¬-é«çº§å½æ°å¯¹",normalizedTitle:"åºæ¬/é«çº§å½æ°å¯¹",charIndex:2555},{level:2,title:"è´è°¢",slug:"è´è°¢",normalizedTitle:"è´è°¢",charIndex:3123}],headersStr:"è¶çº§å¼ç èåå¼çè°ç¨ å½æ°åç½®æ¡ä»¶ åºæ¬/é«çº§å½æ°å¯¹ è´è°¢",content:"# èªå¨è°ç¨å¼ç\n\n> K. Rustan M. Leino Manuscript KRML 265, 8 June 2019\n\næè¦ å½æ°çæäºæ§è´¨æ¯å¶ä»æ§è´¨æ´æç¨ãå¦æä½ å·²ç»è¯æäºè¿æ ·ä¸ä¸ªæ§è´¨ä½ä¸ºä¸ä¸ªå¼çï¼ä½ å¯è½æ³è®©å®èªå¨åºç¨ãæ¬æå°è®¨è®ºå¨Dafnyä¸­å®ç°è¿ç±»ç®æ çæ¹æ³ã\n\nå¨https://github.com/Microsoft/dafny/issues/231ä¸ï¼ä¸åDafnyç¨æ·é®é:\n\n> æä¸ç§æ¹æ³å¨Dafnyæ è®°ä¸ä¸ªå¼çä¸ºâèªå¨âï¼å¹¶å°å¶æ·»å å°z3çç¥è¯åº?\n> \n> å¯¹äºå­¦ççå®¶åº­ä½ä¸ï¼æä»¬ç»å¸¸ä¼éå°ä¸äºå¯¹äºDafnyæ¥è¯´è¿äºå¤æçè§èï¼å¹¶ä¸éè¦ä¸äºæå·¥å¶ä½çæ­è¨æå¼çã\n> \n> å¦ææä»¬è½å¤å®ä¹é£äºå¼çæ¥ç¨ç¹å®é¢åçç¥è¯æ¥æ©åboogie/z3æç´¢ç©ºé´ï¼é£å°±å¤ªå¥½äºï¼è¿æ ·æä»¬å°±ä¸å¿åå­¦çè§£éå¼çæ¯å¦ä½å·¥ä½çï¼ä»¥åæ¥æ¾åä½¿ç¨æéå¼ççç¹çåå°é¾çä»»å¡ã\n\nç±»ä¼¼äº{:auto}æ³¨éçä¸è¥¿æ¯å¯è¡çå?æä»¬è½å¦å¢å¼ºãbplçå¬çå?\n\nä¸é¢çä¾å­è¯´æäºè¿ä¸ªé®é¢ãåè®¾ä½ å£°æäºä¸ä¸ªå½æ°ï¼å¹¶è¯æäºå®çå±æ§:\n\nfunction FibFib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else FibFib(n-2) + FibFib(n-1)\n}\n\nlemma FibFibIsEven(n: nat)\n  ensures FibFib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¯¹äºæ¨çåºç¨ç¨åºï¼FibFibæ»æ¯è¿åä¸ä¸ªå¶æ°å¯è½æ¯è³å³éè¦çãä½¿ç¨ä¸é¢çå£°æï¼ä½ å°ä¸å¾ä¸å¨æ¯æ¬¡ä½¿ç¨å½æ°æ¶è°ç¨å¼çFibFibIsEvenãè¿æ¯ä¹å³çãæ¯å¦æä¸äºæ¹æ³æ¥æç¤ºDafnyèªå¨åºç¨FibFibIsEvenå½å®éè¦çæ¶å?\n\nä¸ï¼Dafnyæ²¡æè¿æ ·çç¹è²ã(ä¾å¦ï¼VCCå°±æè¿æ ·ä¸ä¸ªåè½ã)å¨æäºæåµä¸ï¼è¿ç§èªå¨åå¯è½å·¥ä½å¾å¾å¥½ãå¨å¶ä»æåµä¸ï¼å®å¯è½ä¼å¯¼è´å¼çè¢«è°ç¨å¤ªå¤æ¬¡(æ¯å¦ï¼æ éæ¬¡)ï¼è¿æ¯æé®é¢çã\n\nå¦ææ¨æå´è¶£å°è¯ä¸äº{:autoLemma}ç¹æ§ï¼è¯·éæä½¿ç¨å¼æ¾çDafnyæºä»£ç ãå¨ç®åçç¶æä¸ï¼ææåä¸ªå»ºè®®ä½ å¯ä»¥å°è¯ï¼è¿äºå»ºè®®å¯è½ä¼åè½»ä½ æ­£å¨ç»åçä¸äºä¹å³ã\n\n\n# è¶çº§å¼ç\n\nä¸ä¸ªå»ºè®®æ¯åå»ºä¸ä¸ªâè¶çº§å¼çâæ¥æ¶éå¶ä»å ä¸ªå¼ççéè¿°ãä¾å¦ï¼å¦æä½ å·²ç»æäº:\n\nlemma Lemma0(x: X) ensures P0(x) { ... }\nlemma Lemma1(x: X) ensures P1(x) { ... }\nlemma Lemma2(x: X) ensures P2(x) { ... }\n\n\n1\n2\n3\n\n\nç¶åä½ å¯ä»¥æå®ä»¬åå¹¶æä¸ä¸ª:\n\nlemma Everything(x: X)\n  ensures P0(x) && P1(x) && P2(x)\n{\n  Lemma0(x: X);\n  Lemma1(x: X);\n  Lemma2(x: X);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿è®©æ¨å¯ä»¥éè¿è°ç¨ä¸ä¸ªå¼çæ¥è·å¾ææ3ä¸ªå±æ§ã\n\n\n# èåå¼çè°ç¨\n\nå¦ä¸ä¸ªå»ºè®®æ¯å¨åä¸æ¶é´å¯¹å¤ä¸ªå¼è°ç¨å¼çãèèå°:\n\nlemma LemmaForOneX(x: X) ensures P(x) { ... }\n\n\n1\n\n\nä½ å¯ä»¥å¯¹Xçææå¼åæ¶è°ç¨è¿ä¸ªå¼ç:\n\nforall x {\n  LemmaForOneX(x);\n}\n\n\n1\n2\n3\n\n\néè¿æè¿ä¸ªforallè¯­å¥æ¾å¨ä½ è¦è¯æçä¸äºä»£ç çå¼å¤´ï¼ä½ å®éä¸å·²ç»ä¸ºæ¯ä¸ä¸ªå¯è½çXå¼è°ç¨äºå®ãå½ç¶ï¼ä½ ä¹å¯ä»¥æè¿ä¸ªè¡¨è¿°æ¾å¥ä¸ä¸ªå¼çä¸­ï¼ç¶åç§°ä¹ä¸ºè¿ä¸ªå¼ç:\n\nlemma LemmaForEveryX()\n  ensures forall x :: P(x)\n{\n  forall x {\n    LemmaForOneX(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è®¸å¤æåµä¸ï¼è¿å°å¾å¥½å°å·¥ä½ãå¨å¶ä»æåµä¸ï¼éªè¯èå¯è½æ²¡ææè¯å°ä½ è°ç¨äºéè¦åä¸ªå¼ççå¼ä¸çå¼çï¼æä»¥ä½ å¯è½ä»ç¶éè¦æå¨è°ç¨LemmaForOneXãæ­¤å¤ï¼Dafnyè¿éåæªæ½é¿åå¨ä¸ºä¸é¢çå¼çè°ç¨çæçéè¯ä¸­åºç°âå¹éå¾ªç¯â(âå¹éå¾ªç¯âä¼å¯¼è´å¼ççæ éæ¬¡ä½¿ç¨)ãç¶èï¼è¿ç§æºå¶å¹¶ä¸å®ç¾ï¼å æ­¤è¿ç§å¢å çèªå¨åå¨æäºæåµä¸å¯è½ä¼å¯¼è´æ§è½ä¸éã\n\n\n# å½æ°åç½®æ¡ä»¶\n\nç¬¬ä¸ä¸ªå»ºè®®æ¯å¨å½æ°çåç½®æ¡ä»¶ä¸­å£°æå½æ°çä¸äºææç¨çå±æ§ï¼èä¸æ¯å¨åç¬çå¼çä¸­å£°æãä¾å¦ï¼ä»£æ¿:\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nä½ å¯ä»¥å£°æä¸ºï¼\n\nfunction F(x: X): int\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nè¦è·å¾å¼çæå£°æçå±æ§ï¼å¿é¡»è°ç¨å¼çãç¸åï¼å¨å½æ°çåç½®æ¡ä»¶ä¸­å£°æçä»»ä½å±æ§é½ä¼å¨æ¯æ¬¡è°ç¨å½æ°æ¶èªå¨åºç¨ã\n\næ­£å¦æææå°çï¼æ´å¤çä¿¡æ¯å¯ä»¥å¸®å©éªè¯èèªå¨å°åæ´å¤çäºæï¼ä½æ¯è¿å¤çä¿¡æ¯ä¹ä¼è®©éªè¯èä¸ç¥ææªãå æ­¤ï¼æçå»ºè®®æ¯åªå¯¹é£äºæ¨è®¤ä¸ºæ¯ä¸ªå½æ°ç¨æ·é½éè¦çå±æ§ä½¿ç¨å½æ°åç½®æ¡ä»¶ãå¾å°éè¦çå±æ§æå¥½å¨å¿é¡»æå¨è°ç¨çå¼çä¸­å£°æã\n\næ­¤å¤ï¼å¨å½æ°åç½®æ¡ä»¶ä¸­å¯ä»¥ç¼åçåå®¹ä¹æéå¶ãç¹å«æ¯ï¼ä½ åçä¸è¥¿å¿é¡»âç»æ­¢âãå¨å®è·µä¸­ï¼è¿æå³çå¨åç½®æ¡ä»¶ä¸­æå°å½æ°åºç¨äºå¶ä»åæ°æ¶å¯è½ä¼éå°é®é¢ãä¾å¦,\n\npredicate R(x: X, y: X)\n  // commutativity:\n  ensures R(x, y) <==> R(y, x)\n  // transitivity:\n  ensures forall z :: R(x, z) && R(z, y) ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¢«åè®¸ï¼å ä¸ºåç½®æ¡ä»¶ä¸­å­å¨èªå¼ç¨éç»æ­¢(å³æ ééå½)è°ç¨ãå æ­¤ï¼åäº¤æ¢æ§ååç©æ§è¿æ ·çæ§è´¨æ»æ¯éè¦è¡¨è¿°ä¸ºç¬ç«çå¼çã\n\n\n# åºæ¬/é«çº§å½æ°å¯¹\n\nå½æ°åç½®æ¡ä»¶æ¹ä¾¿å°ä¸ºå½æ°çææç¨æ·æä¾å®æå£°æçå±æ§ï¼ä»èåå°äºæ¾å¼è°ç¨å¼ççéè¦ãå¦æä¸æ¯ææç¨æ·é½å¯¹è¯¥å±æ§æå´è¶£ï¼é£ä¹ç¬¬åä¸ªå»ºè®®æ¯å£°æä¸¤ä¸ªå½æ°ãåºæ¬å½æ°ç»åºäºå½æ°çå®éå®ä¹ï¼éå¸¦çå¼çè¯´æäºå®çæ§è´¨ãpremiumå½æ°è°ç¨åºæ¬å½æ°å¹¶å°å±æ§å£°æä¸ºåç½®æ¡ä»¶ï¼è¿æ¯éè¿è°ç¨å¼çæ¥è¯æçã\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\nfunction F_premium(x: X): int\n  ensures F_premium(x) % 2 == 0\n{ AboutF(x); F(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç¨æ·ç°å¨å¯ä»¥éæ©:è°ç¨F_premiumå¯ä»¥è·å¾å½æ°çå¼åè¢«è¯æçå±æ§ï¼èè°ç¨Fåªè½è·å¾å½æ°çå¼ãå¦æä½ å¸æé«çº§çæ¬æ¯åºç¡çæ¬æ´åæ¬¢è¿ï¼ä½ å½ç¶å¯ä»¥å°FåF_premiumåå«éå½åä¸ºF_basicåFã\n\né¤äºåç½®æ¡ä»¶ä¹å¤ï¼è¿ä¸¤ä¸ªå½æ°æ¯åä¹è¯ãè¯­ä¹ãéè¦æ³¨æçæ¯ï¼éªè¯å¨ç¨æ¥æå¯¼å¶éè¯ä½¿ç¨çæºå¶æ¯è¯­æ³ä¸çãå æ­¤ï¼å½éªè¯èå³å®å®ä¾åéè¯æ¶ï¼ä½ å¨éè¯ä¸»ä½ä¸­ä½¿ç¨çä¸¤ä¸ªå½æ°ä¸­çåªä¸ä¸ªå¯ä»¥äº§çå·®å¼ãåºäºè¿ä¸ªåå ï¼æå»ºè®®æ¨å¨ç¼åçä»»ä½éè¯ä¸­ä½¿ç¨å½æ°çåºæ¬çæ¬ã\n\n\n# è´è°¢\n\nBryan Parnoæåºäºç¬¬åä¸ªå»ºè®®ï¼å°å½æ°çåºæ¬çæ¬åå¶å¼çåè£æå½æ°çé«çº§çæ¬ã",normalizedContent:"# èªå¨è°ç¨å¼ç\n\n> k. rustan m. leino manuscript krml 265, 8 june 2019\n\næè¦ å½æ°çæäºæ§è´¨æ¯å¶ä»æ§è´¨æ´æç¨ãå¦æä½ å·²ç»è¯æäºè¿æ ·ä¸ä¸ªæ§è´¨ä½ä¸ºä¸ä¸ªå¼çï¼ä½ å¯è½æ³è®©å®èªå¨åºç¨ãæ¬æå°è®¨è®ºå¨dafnyä¸­å®ç°è¿ç±»ç®æ çæ¹æ³ã\n\nå¨https://github.com/microsoft/dafny/issues/231ä¸ï¼ä¸ådafnyç¨æ·é®é:\n\n> æä¸ç§æ¹æ³å¨dafnyæ è®°ä¸ä¸ªå¼çä¸ºâèªå¨âï¼å¹¶å°å¶æ·»å å°z3çç¥è¯åº?\n> \n> å¯¹äºå­¦ççå®¶åº­ä½ä¸ï¼æä»¬ç»å¸¸ä¼éå°ä¸äºå¯¹äºdafnyæ¥è¯´è¿äºå¤æçè§èï¼å¹¶ä¸éè¦ä¸äºæå·¥å¶ä½çæ­è¨æå¼çã\n> \n> å¦ææä»¬è½å¤å®ä¹é£äºå¼çæ¥ç¨ç¹å®é¢åçç¥è¯æ¥æ©åboogie/z3æç´¢ç©ºé´ï¼é£å°±å¤ªå¥½äºï¼è¿æ ·æä»¬å°±ä¸å¿åå­¦çè§£éå¼çæ¯å¦ä½å·¥ä½çï¼ä»¥åæ¥æ¾åä½¿ç¨æéå¼ççç¹çåå°é¾çä»»å¡ã\n\nç±»ä¼¼äº{:auto}æ³¨éçä¸è¥¿æ¯å¯è¡çå?æä»¬è½å¦å¢å¼ºãbplçå¬çå?\n\nä¸é¢çä¾å­è¯´æäºè¿ä¸ªé®é¢ãåè®¾ä½ å£°æäºä¸ä¸ªå½æ°ï¼å¹¶è¯æäºå®çå±æ§:\n\nfunction fibfib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else fibfib(n-2) + fibfib(n-1)\n}\n\nlemma fibfibiseven(n: nat)\n  ensures fibfib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¯¹äºæ¨çåºç¨ç¨åºï¼fibfibæ»æ¯è¿åä¸ä¸ªå¶æ°å¯è½æ¯è³å³éè¦çãä½¿ç¨ä¸é¢çå£°æï¼ä½ å°ä¸å¾ä¸å¨æ¯æ¬¡ä½¿ç¨å½æ°æ¶è°ç¨å¼çfibfibisevenãè¿æ¯ä¹å³çãæ¯å¦æä¸äºæ¹æ³æ¥æç¤ºdafnyèªå¨åºç¨fibfibisevenå½å®éè¦çæ¶å?\n\nä¸ï¼dafnyæ²¡æè¿æ ·çç¹è²ã(ä¾å¦ï¼vccå°±æè¿æ ·ä¸ä¸ªåè½ã)å¨æäºæåµä¸ï¼è¿ç§èªå¨åå¯è½å·¥ä½å¾å¾å¥½ãå¨å¶ä»æåµä¸ï¼å®å¯è½ä¼å¯¼è´å¼çè¢«è°ç¨å¤ªå¤æ¬¡(æ¯å¦ï¼æ éæ¬¡)ï¼è¿æ¯æé®é¢çã\n\nå¦ææ¨æå´è¶£å°è¯ä¸äº{:autolemma}ç¹æ§ï¼è¯·éæä½¿ç¨å¼æ¾çdafnyæºä»£ç ãå¨ç®åçç¶æä¸ï¼ææåä¸ªå»ºè®®ä½ å¯ä»¥å°è¯ï¼è¿äºå»ºè®®å¯è½ä¼åè½»ä½ æ­£å¨ç»åçä¸äºä¹å³ã\n\n\n# è¶çº§å¼ç\n\nä¸ä¸ªå»ºè®®æ¯åå»ºä¸ä¸ªâè¶çº§å¼çâæ¥æ¶éå¶ä»å ä¸ªå¼ççéè¿°ãä¾å¦ï¼å¦æä½ å·²ç»æäº:\n\nlemma lemma0(x: x) ensures p0(x) { ... }\nlemma lemma1(x: x) ensures p1(x) { ... }\nlemma lemma2(x: x) ensures p2(x) { ... }\n\n\n1\n2\n3\n\n\nç¶åä½ å¯ä»¥æå®ä»¬åå¹¶æä¸ä¸ª:\n\nlemma everything(x: x)\n  ensures p0(x) && p1(x) && p2(x)\n{\n  lemma0(x: x);\n  lemma1(x: x);\n  lemma2(x: x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿è®©æ¨å¯ä»¥éè¿è°ç¨ä¸ä¸ªå¼çæ¥è·å¾ææ3ä¸ªå±æ§ã\n\n\n# èåå¼çè°ç¨\n\nå¦ä¸ä¸ªå»ºè®®æ¯å¨åä¸æ¶é´å¯¹å¤ä¸ªå¼è°ç¨å¼çãèèå°:\n\nlemma lemmaforonex(x: x) ensures p(x) { ... }\n\n\n1\n\n\nä½ å¯ä»¥å¯¹xçææå¼åæ¶è°ç¨è¿ä¸ªå¼ç:\n\nforall x {\n  lemmaforonex(x);\n}\n\n\n1\n2\n3\n\n\néè¿æè¿ä¸ªforallè¯­å¥æ¾å¨ä½ è¦è¯æçä¸äºä»£ç çå¼å¤´ï¼ä½ å®éä¸å·²ç»ä¸ºæ¯ä¸ä¸ªå¯è½çxå¼è°ç¨äºå®ãå½ç¶ï¼ä½ ä¹å¯ä»¥æè¿ä¸ªè¡¨è¿°æ¾å¥ä¸ä¸ªå¼çä¸­ï¼ç¶åç§°ä¹ä¸ºè¿ä¸ªå¼ç:\n\nlemma lemmaforeveryx()\n  ensures forall x :: p(x)\n{\n  forall x {\n    lemmaforonex(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è®¸å¤æåµä¸ï¼è¿å°å¾å¥½å°å·¥ä½ãå¨å¶ä»æåµä¸ï¼éªè¯èå¯è½æ²¡ææè¯å°ä½ è°ç¨äºéè¦åä¸ªå¼ççå¼ä¸çå¼çï¼æä»¥ä½ å¯è½ä»ç¶éè¦æå¨è°ç¨lemmaforonexãæ­¤å¤ï¼dafnyè¿éåæªæ½é¿åå¨ä¸ºä¸é¢çå¼çè°ç¨çæçéè¯ä¸­åºç°âå¹éå¾ªç¯â(âå¹éå¾ªç¯âä¼å¯¼è´å¼ççæ éæ¬¡ä½¿ç¨)ãç¶èï¼è¿ç§æºå¶å¹¶ä¸å®ç¾ï¼å æ­¤è¿ç§å¢å çèªå¨åå¨æäºæåµä¸å¯è½ä¼å¯¼è´æ§è½ä¸éã\n\n\n# å½æ°åç½®æ¡ä»¶\n\nç¬¬ä¸ä¸ªå»ºè®®æ¯å¨å½æ°çåç½®æ¡ä»¶ä¸­å£°æå½æ°çä¸äºææç¨çå±æ§ï¼èä¸æ¯å¨åç¬çå¼çä¸­å£°æãä¾å¦ï¼ä»£æ¿:\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nä½ å¯ä»¥å£°æä¸ºï¼\n\nfunction f(x: x): int\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nè¦è·å¾å¼çæå£°æçå±æ§ï¼å¿é¡»è°ç¨å¼çãç¸åï¼å¨å½æ°çåç½®æ¡ä»¶ä¸­å£°æçä»»ä½å±æ§é½ä¼å¨æ¯æ¬¡è°ç¨å½æ°æ¶èªå¨åºç¨ã\n\næ­£å¦æææå°çï¼æ´å¤çä¿¡æ¯å¯ä»¥å¸®å©éªè¯èèªå¨å°åæ´å¤çäºæï¼ä½æ¯è¿å¤çä¿¡æ¯ä¹ä¼è®©éªè¯èä¸ç¥ææªãå æ­¤ï¼æçå»ºè®®æ¯åªå¯¹é£äºæ¨è®¤ä¸ºæ¯ä¸ªå½æ°ç¨æ·é½éè¦çå±æ§ä½¿ç¨å½æ°åç½®æ¡ä»¶ãå¾å°éè¦çå±æ§æå¥½å¨å¿é¡»æå¨è°ç¨çå¼çä¸­å£°æã\n\næ­¤å¤ï¼å¨å½æ°åç½®æ¡ä»¶ä¸­å¯ä»¥ç¼åçåå®¹ä¹æéå¶ãç¹å«æ¯ï¼ä½ åçä¸è¥¿å¿é¡»âç»æ­¢âãå¨å®è·µä¸­ï¼è¿æå³çå¨åç½®æ¡ä»¶ä¸­æå°å½æ°åºç¨äºå¶ä»åæ°æ¶å¯è½ä¼éå°é®é¢ãä¾å¦,\n\npredicate r(x: x, y: x)\n  // commutativity:\n  ensures r(x, y) <==> r(y, x)\n  // transitivity:\n  ensures forall z :: r(x, z) && r(z, y) ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¢«åè®¸ï¼å ä¸ºåç½®æ¡ä»¶ä¸­å­å¨èªå¼ç¨éç»æ­¢(å³æ ééå½)è°ç¨ãå æ­¤ï¼åäº¤æ¢æ§ååç©æ§è¿æ ·çæ§è´¨æ»æ¯éè¦è¡¨è¿°ä¸ºç¬ç«çå¼çã\n\n\n# åºæ¬/é«çº§å½æ°å¯¹\n\nå½æ°åç½®æ¡ä»¶æ¹ä¾¿å°ä¸ºå½æ°çææç¨æ·æä¾å®æå£°æçå±æ§ï¼ä»èåå°äºæ¾å¼è°ç¨å¼ççéè¦ãå¦æä¸æ¯ææç¨æ·é½å¯¹è¯¥å±æ§æå´è¶£ï¼é£ä¹ç¬¬åä¸ªå»ºè®®æ¯å£°æä¸¤ä¸ªå½æ°ãåºæ¬å½æ°ç»åºäºå½æ°çå®éå®ä¹ï¼éå¸¦çå¼çè¯´æäºå®çæ§è´¨ãpremiumå½æ°è°ç¨åºæ¬å½æ°å¹¶å°å±æ§å£°æä¸ºåç½®æ¡ä»¶ï¼è¿æ¯éè¿è°ç¨å¼çæ¥è¯æçã\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\nfunction f_premium(x: x): int\n  ensures f_premium(x) % 2 == 0\n{ aboutf(x); f(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nç¨æ·ç°å¨å¯ä»¥éæ©:è°ç¨f_premiumå¯ä»¥è·å¾å½æ°çå¼åè¢«è¯æçå±æ§ï¼èè°ç¨fåªè½è·å¾å½æ°çå¼ãå¦æä½ å¸æé«çº§çæ¬æ¯åºç¡çæ¬æ´åæ¬¢è¿ï¼ä½ å½ç¶å¯ä»¥å°fåf_premiumåå«éå½åä¸ºf_basicåfã\n\né¤äºåç½®æ¡ä»¶ä¹å¤ï¼è¿ä¸¤ä¸ªå½æ°æ¯åä¹è¯ãè¯­ä¹ãéè¦æ³¨æçæ¯ï¼éªè¯å¨ç¨æ¥æå¯¼å¶éè¯ä½¿ç¨çæºå¶æ¯è¯­æ³ä¸çãå æ­¤ï¼å½éªè¯èå³å®å®ä¾åéè¯æ¶ï¼ä½ å¨éè¯ä¸»ä½ä¸­ä½¿ç¨çä¸¤ä¸ªå½æ°ä¸­çåªä¸ä¸ªå¯ä»¥äº§çå·®å¼ãåºäºè¿ä¸ªåå ï¼æå»ºè®®æ¨å¨ç¼åçä»»ä½éè¯ä¸­ä½¿ç¨å½æ°çåºæ¬çæ¬ã\n\n\n# è´è°¢\n\nbryan parnoæåºäºç¬¬åä¸ªå»ºè®®ï¼å°å½æ°çåºæ¬çæ¬åå¶å¼çåè£æå½æ°çé«çº§çæ¬ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD",frontmatter:{title:"å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/f6638c/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/3.%E5%AE%9A%E4%B9%89%E3%80%81%E8%AF%81%E6%98%8E%E3%80%81%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6GCD.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/3.å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD.md",key:"v-ad783cd0",path:"/pages/f6638c/",headers:[{level:2,title:"é®é¢æè¿°",slug:"é®é¢æè¿°",normalizedTitle:"é®é¢æè¿°",charIndex:167},{level:2,title:"æ­£æ´æ°",slug:"æ­£æ´æ°",normalizedTitle:"æ­£æ´æ°",charIndex:474},{level:2,title:"å ç´ ",slug:"å ç´ ",normalizedTitle:"å ç´ ",charIndex:902},{level:2,title:"éåçæå¤§å¼",slug:"éåçæå¤§å¼",normalizedTitle:"éåçæå¤§å¼",charIndex:2214},{level:2,title:"GCD",slug:"gcd",normalizedTitle:"gcd",charIndex:19},{level:2,title:"GCDçæ§è´¨",slug:"gcdçæ§è´¨",normalizedTitle:"gcdçæ§è´¨",charIndex:4858},{level:2,title:"æ¬§å éå¾·ç®æ³",slug:"æ¬§å éå¾·ç®æ³",normalizedTitle:"æ¬§å éå¾·ç®æ³",charIndex:6436},{level:2,title:"GCDåæ§è´¨",slug:"gcdåæ§è´¨",normalizedTitle:"gcdåæ§è´¨",charIndex:8181},{level:2,title:"æ´å¤çå¯¹ç§°",slug:"æ´å¤çå¯¹ç§°",normalizedTitle:"æ´å¤çå¯¹ç§°",charIndex:9359},{level:2,title:"ä¸»æ¹æ³",slug:"ä¸»æ¹æ³",normalizedTitle:"ä¸»æ¹æ³",charIndex:10320},{level:2,title:"ç»è®º",slug:"ç»è®º",normalizedTitle:"ç»è®º",charIndex:10706},{level:2,title:"è´è°¢",slug:"è´è°¢",normalizedTitle:"è´è°¢",charIndex:10998},{level:2,title:"åèæç®",slug:"åèæç®",normalizedTitle:"åèæç®",charIndex:11039}],headersStr:"é®é¢æè¿° æ­£æ´æ° å ç´  éåçæå¤§å¼ GCD GCDçæ§è´¨ æ¬§å éå¾·ç®æ³ GCDåæ§è´¨ æ´å¤çå¯¹ç§° ä¸»æ¹æ³ ç»è®º è´è°¢ åèæç®",content:'# å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶:GCD\n\n> K. Rustan M. Leino Manuscript KRML 279, 22 June 2021\n\næè¦ æ¬æçç®çæ¯å±ç¤ºä¸ä¸ªç¨åºå¼åçç¤ºä¾ï¼ä»ç»æ¯æç¨åºè§èçå®ä¹ï¼éè¿°åè¯æé£äºå®ä¹çå¼çï¼å¹¶ä½¿ç¨å¼çæ¥è¯æç¨åºçæ­£ç¡®æ§ãä»¥æ¬§å éå¾çè®¡ç®æå¤§å¬çº¦æ°çåæ³ç®æ³ä¸ºä¾ã\n\n\n# é®é¢æè¿°\n\nè®©æä»¬æå®å¹¶éªè¯ä¸ä¸ªç®æ³æ¥è®¡ç®ä¸¤ä¸ªæ°çæå¤§å¬çº¦æ°(GCD)ãå¨è§èä¸­ï¼æä»¬å°å¼å¥ä¸ä¸ªå½æ°ï¼å®çå®ä¹âæ¾ç¶æ¯æ­£ç¡®çâãæä»¬ä¸ä¼ä½¿ç¨è¿ä¸ªå½æ°æ¥è®¡ç®GCDï¼å ä¸ºå¦æç´æ¥ç¼è¯çè¯ï¼âææ¾æ­£ç¡®âçå®ä¹ä¼ç»åºéå¸¸ä½æçä»£ç ãç¸åï¼æä»¬å°ä½¿ç¨Euclidç®æ³æ¥è®¡ç®âææ¾æ­£ç¡®âå½æ°å®ä¹çå¼ãæä»¬å°è¯æè¿ä¸ªç®æ³ç¡®å®è®¡ç®åºäºè¿ä¸ªå¼ã\n\næ¬è´¨ä¸ï¼æä»¬æ\n\nfunction Gcd(x: pos, y: pos): pos\n\nmethod EuclidGcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­posè¡¨ç¤ºæ­£æ´æ°çç±»åã\n\n\n# æ­£æ´æ°\n\næä»¬æåçä¸åé½ä¸æ­£æ´æ°æå³ãDafnyä¸ºèªç¶æ°(å³éè´æ´æ°)èéæ­£æ´æ°æå»ºäºä¸ç§ç±»åãæä»¬å¯ä»¥å¨Dafnyä¸­ä½¿ç¨å­éç±»åæ¥å®ä¹å®ä»¬:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\nDafnyæ³ç¥éè¿ç§ç±»åæ¯å¦æå±æ°ï¼ä½å®èªå·±ä¸ç¥éãå¯¹äºæä»¬çç¤ºä¾æ¥è¯´ï¼è¿æ å³ç´§è¦ï¼ä½æ¯æä»¬ç¡®å®éè¦å¤çæä»¬å¾å°çéè¯¯ãä¸ºæ­¤ï¼æä»¬æä¾äºwitnessæ¡æ¬¾:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nå¦ææä»¬ççä¸æ¿ææ¾ç¤ºæ¾ç¤ºè¯¥ç±»åä¸ºéç©ºçwitnessï¼æä»¬å¯ä»¥åwitness *ï¼è¿å¯¼è´Dafnyå°posç±»åè§ä¸ºå¯è½ä¸ºç©ºãå¯¹äºæä»¬çä¾å­ï¼ä½ å¯ä»¥éæ©å¶ä¸­ä¸ç§ï¼ä½å ä¸ºæä¾ä¸ä¸ªå®éçè¯äººå¾å®¹æï¼æä»¥æä»¬å°±è¿ä¹åã\n\nå¨ç»­éä¸­ï¼å½ææçæ¯æ­£æ´æ°æ¶ï¼æä¼è¯´numberã\n\n\n# å ç´ \n\nä¸ä¸ªæ°çé¤æ°æ¯å®çå æ°ãæä»¬å®ä¹äºä¸ä¸ªè°è¯ï¼å®è¯´æäºæ°å­pæ¯æ°å­xçå æ°æ¯ä»ä¹ææ:\n\npredicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\næ¢å¥è¯è¯´ï¼pæ¯xçå å­ï¼å¦æå­å¨ä¸ä¸ªè¢«ä¹æ°qï¼é£ä¹xå°±æ¯p * qçä¹ç§¯ã\n\nä¸ºäºè®¨è®ºä¸ä¸ªæ°å­çææå å­ï¼æä»¬å¼å¥äºä¸ä¸ªå½æ°factorsï¼æä»¬ä½¿ç¨éåçè§£æ¥å®ä¹å®ãä¸ä¸ªç®åçå®ä¹æ¯:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | IsFactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\nå¨Dafnyä¸­ï¼setè¡¨ç¤ºä¸ä¸ªæéçéå(å¯¹äºå¯è½çæ ééåï¼ä½¿ç¨isset)ãå¨è¿ç§æåµä¸ï¼Dafnyå¹¶æ²¡æç«å³åç°è¿ä¸ªçè§£ä¼çæä¸ä¸ªæééãå¹¸è¿çæ¯ï¼æä»¬å¯ä»¥ç®åå°å¨çè§£ä¸­æ·»å å¦ä¸ä¸ªè¿è¯ï¼è®©Dafnyçå°éåæ¯æéç:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\n\n\n1\n2\n3\n\n\nå¨æ·»å è¿ä¸ªè¿è¯æ¶ï¼æä»¬å¯è½ä¼ç¯ä¸ä¸ªéè¯¯ï¼å ä¸ºæ°çéåå¯è½æ²¡æåå«æä»¬æ³è¦çææå ç´ ãæä»¬çç»åç¹p <= xå½ç¶çèµ·æ¥å¾ç®åï¼ä½ä¸ºä»ä¹ä¸è¯æå ä¸å®ä¸ä¼æå¤éæ¼ä»»ä½å å­å¢?æä»¬å¯ä»¥è¯æè¿ä¸ªéåçåç´ ä¸å¯è½æ ééç¸å:\n\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nå¼ççè¯ææ¯å¨å¼çä¸»ä½ä¸­ç»åºç(ä¹å°±æ¯è¯´ï¼å¨å¼çè§èåé¢çä¸å¯¹è±æ¬å·ä¹é´)ãå¨è¿ç§æåµä¸ï¼è¯ææ¯ç©ºçï¼å ä¸ºDafnyèªå¨å°è¯æäºå¼çï¼èä¸éè¦æä»¬æä¾ä»»ä½è¿ä¸æ­¥çå¸®å©ã\n\nå¨ç¦»å¼å å­çå®ä¹ä¹åï¼è®©æä»¬è¯´æåè¯æä¸¤ä¸ªç®åçå¼çãè¿äºå¼çå¯ä»¥ä½ä¸ºå¯¹æä»¬å®ä¹çæ£æ¥ï¼å®ä»¬å¨ä»¥åçå¼åä¸­ä¹ä¼å¾æå¸®å©ã\n\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè¯æä¸ä¸ªæ°å­n(è¿éæ¯1æx)å¨éåFactors(x)ä¸­ï¼æä»¬éè¦ç¡®å®næ»¡è¶³éåçè§£çæ¡ä»¶(å¨Factors(x)ä¸»ä½ä¸­)ãè¿è¯n <= xè¢«èªå¨è¯æï¼ä½IsFactor(n, x)ä¸æ¯ãæ ¹æ®IsFactorçå®ä¹ï¼æä»¬éè¦è¯æn * q == xçè¢«ä¹æ°qçå­å¨æ§ãè¿ç§è¯æéå¸¸åæ¬è¯æè¯äººï¼è¿å°±æ¯ä¸é¢ä¸¤ä¸ªå¼çä¸­çæ­è¨éè¿°æåçãç±è¿äºæ­è¨ï¼éªè¯èå®æäºå¼ççè¯æã\n\n\n# éåçæå¤§å¼\n\nä¸ºäºè®¨è®ºæå¤§å¬çº¦æ°ï¼æä»¬éè¦ä¸ä¸ªå½æ°æ¥æééåä¸­æå¤§çæ°ãä¸ç§æç¹å£°ææ§çæ¹æ³æ¯ä½¿ç¨such-thatç»æãç¹å«å°ï¼å¯¹äºéås, let-such-thatè¡¨è¾¾å¼\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nè¡¨ç¤ºå°xç»å®å°æ»¡è¶³æ¡ä»¶xå¨s &&ä¸­çææy:: yå¨s ==> y <= xçå¼ï¼ç¶åè¿åè¡¨è¾¾å¼xçå¼ãè¿ä¸ªæ¡ä»¶è¯´xå¨éåsä¸­ï¼å¹¶ä¸å¨éåsä¸­ï¼xæ¯æå¤§çã\n\nä½¿ç¨such-thatç»ææä¸ä¸ªè¯æä¹å¡ï¼å³æ»¡è¶³ç»å®æ¡ä»¶çå¼å­å¨ãå¦ææä»¬è¦æ±sä¸ºéç©ºï¼é£ä¹x in sæ¡ä»¶å¾å®¹ææ»¡è¶³ï¼ä½å®éè¦æ´å¤çå·¥ä½æ¥è¯´æéªè¯èxçå¼æ»¡è¶³éè¯ãä¸ºæ­¤ï¼æä»¬å°å®ä¹ä¸ä¸ªå¼çãæä»¬å°å¼çå½åä¸ºMaxExistsï¼ç¶åæä»¬å¯ä»¥è¿æ ·åæä»¬çå½æ°Max:\n\nfunction Max(s: set<pos>): pos\n  requires s != {}\n{\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafnyä½¿ç¨å¼çè°ç¨MaxExists(s)æ¥å»ºç«åç»­è¡¨è¾¾å¼çæ ¼å¼è¯å¥½æ§ãé¡ºä¾¿è¯´ä¸ä¸ï¼æ³¨æMax(ä»¥åå¼çMaxExists)æä¸ä¸ªåç½®æ¡ä»¶s !={}(å³é®å­requires)ãè¿æå³çå½æ°(ä»¥åå¼ç)åªè½å¨éç©ºéåä¸­è°ç¨ã\n\né£ä¹æä»¬å¦ä½è¯æMaxExistså¢?è¯æè¿æ ·ä¸ä¸ªxå­å¨çæç´æ¥çæ¹æ³æ¯è®¡ç®ä¸ä¸ªæ»¡è¶³æéæ§è´¨çxãæä»¬å°å¼å¥å¦ä¸ä¸ªè®¡ç®æå¤§å¼çå½æ°ï¼ç§°ä¸ºFindMaxï¼å¹¶å¨MaxExistså¼ççè¯æä¸­ä½¿ç¨å®ãå½æ°FindMaxå°è¢«éå½å®ç°ã\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := FindMax(s);\n}\n \nfunction FindMax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= FindMax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\næä»¬ç°å¨ä¸æ¯å¨ååå­å?æ¯çï¼å¨æäºæ¹é¢ï¼æä»¬è®©çæ´»åå¾æ¯å¿è¦çæ´å°é¾ãå¦ææä»¬æFindMaxï¼æä»¬ä¸éè¦Maxï¼ç¶åæä»¬ä¹ä¸éè¦å¼çMaxExistsãäºå®ä¸ï¼æä»¬å¯ä»¥åªç¼ååä½¿ç¨FindMaxï¼èä¸å¼å¥MaxæMaxExistsãä½å¨è¿ä¸ªä¾å­ä¸­ï¼æå¸æä¸»è¦çå®ä¹å°½å¯è½æ¸æ°ï¼èä¸èèå¦ä½è®¡ç®ãä»è¿ä¸ªæä¹ä¸è¯´ï¼Maxçä¸»ä½æ¯æä»¬å°è¦ä¸ºFindMaxç¼åçä¸»ä½æ´å·å£°ææ§ã\n\nä»¥ä¸æ¯FindMaxçå®æ´å®ä¹:\n\nfunction FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s\' := s - {x};\n    assert s == s\' + {x};\n    var y := FindMax(s\');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå½å½æ°çåç½®æ¡ä»¶æ³è¦æå°å½æ°çç»æå¼æ¶ï¼ä½ å¯ä»¥ä½¿ç¨å½æ°æ¬èº«ï¼ç»åºåæ°:FindMax(s)ãæå¨ä¸é¢ç¬¬ä¸æ¬¡ä»ç»FindMaxæ¶å°±è¿æ ·åäºãå¨å®æ´çå®ä¹ä¸­ï¼æå±ç¤ºäºå¦ä¸ç§æ¹æ³ï¼å³ä¸ºç»æå¼å¼å¥ä¸ä¸ªåç§°:maxãè¯¥åç§°åªè½å¨å½æ°çåç½®æ¡ä»¶ä¸­ä½¿ç¨ãå¾å¤æ¶åï¼ä¸ºç»æå¼å¥è¿æ ·çåç§°ä¼å¯¼è´æ´ç­çè§èã\n\n\n# GCD\n\næäºæä»¬å®ä¹çå½æ°ï¼ç°å¨å°±å¯ä»¥å®ä¹GCDäºãåxçå å­ä¸yçå å­ï¼ä¸ä¹ç¸äº¤ï¼å¾å°å®ä»¬çå¬å å¼ï¼åå¶æå¤§å¼:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  Max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nå¯¹äºè¿ä¸ªç®åçå®ä¹ï¼éªè¯èæ¥åäºä¸ä¸ªåææ¡ä»¶çè¿åï¼å ä¸ºå®æ æ³è¯æcommonæ»¡è¶³Maxçåææ¡ä»¶ãæä»¬ç¥éå¬å æ°æ¯éç©ºçï¼å ä¸ºæä»¬ç¥é1æ¯ä»»æä¸¤ä¸ªæ°xåyçå¬å æ°ãä¸ºäºå¼èµ·éªè¯èçæ³¨æï¼æä»¬åäºä¸ä¸ªæ­è¨:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common;  // error: assertion violation\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nåï¼éªè¯èä¸è½è¯æè¿ä¸ªæ­è¨ãä½æä»¬å¯ä»¥çå°ï¼è¿ä¸ä¸»å¼ çå­å¨è¶³ä»¥æ¶é¤åå³æ¡ä»¶çè¿åãç°å¨æä»¬æ¥è¯æè¿ä¸ªæ­è¨ãè¿å°±æ¯æä»¬ä½¿ç¨åé¢ä»ç»çFactorsContains1å¼ççå°æ¹ãå¯¹è¯¥å¼ççä¸¤æ¬¡è°ç¨å°è¯ææ­è¨ï¼å¨ç¨åºææ¬ä¸­æå¥½çæè·æ¹æ³æ¯å°assertæ´æ¹ä¸ºassert byï¼å¹¶å¨byåä¸­ç»åºæ­è¨çè¯æ:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¤äº!æä»¬ç°å¨å·²ç»ç»åºäºGcdçä¸ä¸ªæ ¼å¼è¯å¥½çå®ä¹ã\n\n\n# GCDçæ§è´¨\n\næä»¬å°è¯ææä»¬çGcdå½æ°çä¸ä¸ªå±æ§ââå¦æä½ æ¿æï¼å¯ä»¥ç§°ä¹ä¸ºå¥å¨æ£æ¥ã(æä»¬è¿éè¦ç¬¬åä¸ªå±æ§ï¼ç¨ååä»ç»ã)\n\nä½ä¸ºç¬¬ä¸ä¸ªå®æ´æ§æ£æ¥ï¼æä»¬ææGcd(x, y)è¿åä¸ä¸ªåæ¶æ¯xåyå å­çæ°å­ãæ­¤å¤ï¼å¨ææåæ¶æ¯xåyå æ°çæ°å­ä¸­ï¼Gcd(x, y)çæ¶çåºè¯¥æ¯æå¤§çã\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nè¿ä¸ªå¼ççåä¸¤ä¸ªåç½®æ¡ä»¶æ¯èªå¨è¯æçï¼ä½ç¬¬ä¸ä¸ªä¸æ¯ãæä»¬å¦ä½è¯æä¸ä¸ªå¨ç§°éè¯(ä¹å°±æ¯forallè¡¨è¾¾å¼)æ¯æç«ç?æä»¬ä½¿ç¨è¾¾å¤«å°¼çforallè¯­å¥ãå½ç¨äºè¯ææ¶ï¼forallå½é¢å¯¹åºäºé»è¾ä¸­çâæ®éå¼å¥âè§åãè¿ä¸ªè§åè¯´çæ¯"å¦æä½ æ³è¦è¯æå¯¹äºææçx:: P(x)ï¼é£ä¹ä½ æéè¦åçå°±æ¯ä»»æéæ©ä¸ä¸ªxï¼ç¶åå¯¹é£ä¸ªxè¯æP(x)ã\n\næä»¬åè¿æ ·å¼å¥forallè¯­å¥:\n\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n\n\n1\n2\n\n\nä¸ºäºè¯æå®ï¼æä»¬åªéè¦æåºè¿æ ·ä¸ä¸ªäºå®ï¼å³pï¼æ¢æ¯xåyçå å­ï¼åæ¯xåyçå å­çäº¤éãéªè¯èå°±è½å¤å®æè¯æã\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafnyéªè¯å¨ç»å¸¸éè¦è¿æ ·çå±æ§å¸®å©ãè¦è¯æå®ä»¬ï¼å°±æå®ä»¬åææ­è¨ãæ¢å¥è¯è¯´ï¼éªè¯èç¥ééåäº¤éçè¿ä¸ªæ§è´¨ï¼ä½å®æ²¡æè¶³å¤çåæå°è¿ä¸ªæ§è´¨å¼å¥è¯æä¸­ãéè¿æ­è¨è¯¥å±æ§ï¼æä»¬è¦æ±éªè¯èç¡®è®¤è¯¥å±æ§(å®è½å¤è¿æ ·å)ï¼ç¶åå¨å¶ä½çè¯æä¸­ä½¿ç¨è¯¥å±æ§(å¨æ¬ä¾ä¸­ï¼è¿å°±å®æäºè¯æ)ã\n\nä½ä¸ºç¬¬äºä¸ªå®æ´æ§æ£æ¥ï¼æä»¬è¯æäºGcdæ¯å¯¹ç§°çã\n\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nè¿ä¸ªè¯æå½ç»å°éåäº¤ç¹æ¯å¯¹ç§°çè¿ä¸ªäºå®ï¼æä»¬æå®åæå¼çæ¥å¼èµ·éªè¯èçæ³¨æã\n\nä½ä¸ºç¬¬ä¸ä¸ªå¥å¨çæ£éªï¼æä»¬è¯æGcdæ¯å¹ç­çãä¹å°±æ¯è¯´ï¼å¦æä½ ç»å®ç¸åçåæ°ä¸¤æ¬¡ï¼å®ä¼è¿åé£ä¸ªåæ°ã\n\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿ä¸ªæ§è´¨çè¯æå¯ä»¥å½ç»ä¸ºéåäº¤ç¹æ¯å¹ç­çï¼ä»¥åä¸ä¸ªæ°æ¯å®èªå·±çå å­ä¹ä¸çæ§è´¨ã\n\n\n# æ¬§å éå¾·ç®æ³\n\næ¬§å éå¾çæ±åä¸¤ä¸ªæ°çGCDçåæ³ç®æ³æ¯å°ä¸¤ä¸ªæ°ä¸­çè¾å¤§æ°åå¤åå»è¾å°çæ°ï¼ç´å°å®ä»¬ç¸ç­ãæ¯ä¸ä¸ªè¿æ ·çåæ³é½ä¿çäºGCDââä¸ä¸ªæä»¬éè¦è¯æçä¸åéââä¸¤ä¸ªç¸ç­çæ°çGCDå°±æ¯é£ä¸ªæ°ââè¿ä¸ªæ°æ¯æä»¬éè¿ä¸é¢çâGCDå¹ç­âå¼çå»ºç«çã\n\nè¯¥ç®æ³å·æå¾ªç¯ä¸åéåå¹ç­å¼çï¼å¶ç»æå¦ä¸:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\næ­¤æ¹æ³ä½¿ç¨while - caseå¾ªç¯ã(å¦ææ¨çæDijkstraçä¿æ¤å½ä»¤[1]ï¼è¿æ¯do-odå¾ªç¯ã)è¿ä¸ªå¾ªç¯çæ¯æ¬¡è¿­ä»£é½ä¼éæ©ä¸ä¸ªcaseæ¥æ§è¡ãæéçcaseå¿é¡»æ¯ä¸ä¸ªå¶å®æ¤æ¡ä»¶æ±å¼ä¸ºtrueçå¯¹è±¡(å¦æå ä¸ªcaseçå®æ¤æ¡ä»¶æ±å¼ä¸ºtrueï¼åå¾ªç¯å¨è¿äºcaseä¹é´ä»»æéæ©)ãå¦ææ²¡æè¿æ ·çä¿æ¤æ¡ä»¶ï¼åå¾ªç¯åæ­¢è¿­ä»£ãEuclidGcdä¸­çå¾ªç¯å½ç¶å¯ä»¥æ¯ä¸ä¸ªæ®éçwhile x != yå¾ªç¯ï¼ä½while - caseå¾ªç¯æä¾çä¸¤ç§æåµçå¯¹ç§°æ§ä½¿å¶ç¾è§ã\n\né¤äºä¸ä¸ªå¾ªç¯ä¸åå¼å¤ï¼å¾ªç¯è¿å£°æäºä¸ä¸ªç»æ­¢åº¦é(å³é®å­decreases)ãè¯æå¾ªç¯ç»æ­¢å½ç»ä¸ºè¯ææ¯æ¬¡è¿­ä»£ä½¿ç»æ­¢åº¦éçå¼åå°(æç§Dafnyåç½®çåºäºè¯å¥½åºç¡çæ´æ°é¡ºåº)ã\n\nä¸é¢çEuclidGcdæ¹æ³æ²¡æéªè¯ï¼å ä¸ºéªè¯å¨æ æ³è¯ææ¯æ¬¡è¿­ä»£é½ä¿æå¾ªç¯ä¸åãä¸ºæ­¤ï¼æä»¬éè¦æå¨ä¸é¢æå°çGCDçç¬¬åä¸ªæ§è´¨:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n\n\n1\n2\n3\n\n\nå©ç¨è¿ä¸ªå¼çåGCDçå¯¹ç§°æ§ï¼æä»¬å¯ä»¥å®æGCDçè¯æ:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nè¿ä¸ªçæ¬å¨å¾ªç¯çç¬¬ä¸ä¸ªåæ¯ä¸­æ·»å äºå¯¹GcdSubtractçè°ç¨ãå¨å¾ªç¯çç¬¬äºä¸ªåæ¯ä¸­ï¼è¯æè®¡ç®ä½¿ç¨ä¿æç­å¼çæ­¥éª¤å°è¡¨è¾¾å¼Gcd(x, y)è½¬æ¢ä¸ºGcd(x - y, y)ãæ­¥éª¤ä¸­ç»åºçæç¤ºæ±å©äºGcdSubtractåGcdSymmetricå¼çã\n\n\n# GCDåæ§è´¨\n\nå¨è¿ä¸ªæ¡ä¾ä¸­ï¼GcdSubtractçè¯ææ¯å¶ä»ä»»ä½å®ä¹åå¼çé½è¦å¤æã\n\nè¯æé¦åå¼å¥Gcd(x, y)çåç§°:\n\n  var p := Gcd(x, y);\n\n\n1\n\n\nç±Gcdçå®ä¹å¯ç¥ï¼pæ¯xåyçå å­ï¼æä»¬å¯ä»¥è¯æpä¹æ¯y - xçå å­:\n\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè¯æIsFactor(p, y - x)ï¼æä»¬å¯¹IsFactorçå®ä¹åè¯æä»¬å­å¨çè¢«ä¹æ°å¼å¥aåbåç§°(å ä¸ºpæ¯xåyçå å­)ãç¨åºæ¬çç®æ¯æ­¥éª¤è¿è¡ç®åçè®¡ç®ï¼æä»¬å°±å¯ä»¥å¾å°på¯ä»¥ä¹ä¸å¦ä¸ä¸ªæ°(å³b - A)å¾å°y - xã\n\nå ä¸ºpåæ¶æ¯xåy - xçå å­ï¼æä»¥å®æ¯xåy - xçå¬å å¼ãæä»¬åäºä¸¤è¡ä»£ç æ¥ç¡®ä¿éªè¯å¨ä½¿ç¨äºè¿ä¸ªå±æ§ï¼ç¨éåäº¤éæ¥è¡¨è¾¾:\n\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\næåï¼æä»¬éè¦è¯æpæ¯è¿ä¸ªå¬å å¼çæå¤§ãæä»¬ä½¿ç¨forallè¯­å¥æ¥å£°æè¿ä¸ªå±æ§:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nä¸ºäºè¯æè¿ä¸ªæ§è´¨ï¼æä»¬å¡«åäºforallè¯­å¥ä½ãå¯¹äºè¡¨ç¤ºâå¬å±æ§âéåä¸­çä»»ææ°å­qï¼æä»¬åå«å°çæxåy - xä¹ç§¯çè¢«ä¹æ°å½åä¸º:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nä½¿ç¨ç®åçç®æ¯æ­¥éª¤ï¼æä»¬å¯ä»¥ç¨ä¸ä¸ªè¯æè®¡ç®æ¥ç¡®å®qä¹æ¯yçå å­:\n\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\næä»¥ï¼å ä¸ºqæ¢æ¯xåæ¯yçå å­ï¼æä»¥Gcd(x, y)çå®ä¹åè¯æä»¬q <= Gcd(x, y)éè¿ç»åºå¦ä¸ä¸ªå³äºéåäº¤éçæç¤º:\n\n    assert q in Factors(x) * Factors(y);\n  }\n\n\n1\n2\n\n\néªè¯èå®æéªè¯ã\n\n\n# æ´å¤çå¯¹ç§°\n\nè½ç¶æä»¬ç°å¨å·²ç»æäºGCDç®æ³çå®æ´è¯æï¼ä½æ¨çç¾æå¯è½ä¼å ä¸ºæä»¬å¨ä¸¤ç§æåµä¸æä¾è¯æçæ¹å¼çä¸å¯¹ç§°æ§èåå°å½±åãæ¢ç¶while - caseå¾ªç¯ä¸ºæä»¬æä¾äºè¿ä¸¤ç§æåµçå¯¹ç§°è¡¨è¿°ï¼å¦ææä»¬ä¹è½ä½¿è¿ä¸¤ç§æåµçè¯ææ´å ç¸ä¼¼å°±å¥½äºã\n\næå ç§æ¹æ³å¯ä»¥æ¹åè¿ç§æåµãä¸ç§æ¯éæç¬¬äºä¸ªcaseçè¯æè®¡ç®å°å®èªå·±çå¼çä¸­ãç¶åï¼æ¯ä¸ªâæ¡ä¾âé½æä¸è¡è¯æã\n\nä¸ºäºå¥½ç©ï¼è®©ææ¥æè¿°å¦ä¸ä¸ªâæå·§âï¼è®©è¿ä¸¤ç§æåµ(ä¸å®å¨å¯¹ç§°ï¼ä½è³å°)æ´ç¸ä¼¼ãè¯çªå¨äºä½¿(å·²ç»ä¸å¯¹ç§°ç)GcdSubtractå¼çä¹æåæ°è½¬æ¢ä¸ºGcdãæä»¬å°å¶æ¹åä¸º:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x)\n{\n  GcdSymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næ³¨æåç½®æ¡ä»¶çå·¦è¾¹ç°å¨æ¯Gcd(y, x)ï¼èä¸æ¯Gcd(x, y)å°±åæä»¬å¨è¿ä¸ªå¼ççç¬¬ä¸ä¸ªçæ¬ä¸­ä¸æ ·ãè¿ä¸ªè¯ææéè¦çå¯ä¸æ¹åå°±æ¯è¯è¯¸äºGcdçå¯¹ç§°æ§ï¼æä»¬å¯ä»¥éè¿å¼çåé¨çä¸ä¸ªå¼çæ¥åå°è¿ä¸ç¹ãè¿ç»äºæä»¬ä¸ä¸ªéæ°è¡¨è¿°çâGcdSubtractâå¼ççè¯æã\n\néè¿è¿ç§éæ°è¡¨è¿°ï¼æä»¬å¯ä»¥ç®åEuclidGcdçç¬¬äºä¸ªâæå½¢âï¼ä»¥ä½¿ç¬¬ä¸ä¸ªâæå½¢âæ´å å¤æä¸ºä»£ä»·ãæ¬è´¨ä¸ï¼æä»¬æä¸ä¸ªå¼çè°ç¨ä»ç¬¬äºç§æåµç§»å°ç¬¬ä¸ç§æåµï¼æä»¥ä¸æ¯æ1å3ä¸ªå¼çè°ç¨å¨ä¸¤ç§æåµä¸ï¼æä»¬ä¼æ2å2ã\n\n    case x < y =>\n      GcdSubtract(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå®ä¸æ¯å®å¨å¯¹ç§°çï¼ä½ä¹è®¸ä½ è¿æ¯åæ¬¢å®ãæèä½ å¯è½ä¼å¨å¦ä¸ç§æåµä¸è®°ä½è¿ä¸ªæå·§ï¼å½éå­éå¸¸åéçæ¶åãå¦ææ²¡æå«çï¼æ¨å¯ä»¥åæä½¿ç¨æä»¬å¨ä¸é¢å¼åçç¬¬ä¸ä¸ªå®æ´çè¯æã\n\n\n# ä¸»æ¹æ³\n\nå¦æè¯ææ¬èº«ä¸æ»¡è¶³ä½ ï¼ä½ ä»ç¶æ³çå°ç®æ³çè¿è¡ï¼ä½ å¯ä»¥åä¸ä¸ªMainæ¹æ³ï¼ç¼è¯å¹¶è¿è¡ç¨åºã(å¨å½ä»¤è¡ä¸­ä½¿ç¨dafnyå·¥å·ç/compile:3éé¡¹æ¯ä¸ç§ç®åçæ¹æ³ãå®å°éªè¯ç¶åè¿è¡ç¨åºã)\n\nä¸é¢æ¯ä¸ä¸ªMainçä¾å­:\n\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\n\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, " gcd ", y, "  =  ", gcd, "\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ç»è®º\n\nè¿ä¸ªæ¡ä¾ç ç©¶å±ç¤ºäºå¦ä½å®ä¹ä¸ä¸ªæå´è¶£çé¢å(è¿éæ¯æ°å­å å­ï¼å¯¼è´äºGCDçå®ä¹)ï¼éè¿°åè¯æå³äºè¿äºå®ä¹çä¸äºå¼çï¼ç¶åå¨ä¸ä¸ªå°ç¨åºçè¯æä¸­ä½¿ç¨è¿äºå¼çã\n\nè¯¥ç¨åºï¼åæ¬ææå¼çåå¶ä»ä¸å®ä¹ç¸å³çè¯æä¹å¡ï¼åªéè¦å°äº3ç§çDafnyéªè¯å¨éªè¯ãæ¨å¯ä»¥å¨Dafnyæµè¯å¥ä»¶[3]ä¸­æ¾å°æ´ä¸ªç¨åºã\n\næ¬§å éå¾·çGCDç®æ³æ¯ä¸ä¸ªå¸¸è§çæç§ä¹¦ä¾å­ãå®å¨ä¸åçéªè¯å¨ä¸­ä»¥ä¸åçå½¢å¼è¢«è¯æãä¾å¦ï¼TLA+æç¨ä»¥è¿ä¸ªç¨åºä¸ºä¾[0]ãå®åè®¾äºæä»¬å¨è¿éè¯æçGCDçæ°å­¦æ§è´¨ãWhy3ç¨åºåºåå«æ¬§å éå¾·GCDç®æ³çä¸ä¸ªçæ¬ï¼å®å¨æ¯ä¸æ­¥ä¸­ä½¿ç¨æ¨¡èä¸æ¯åæ³ï¼è¿æ ·å¯ä»¥åå°è¿­ä»£æ¬¡æ°[2]ã\n\n\n# è´è°¢\n\nææè°¢Reto Krameræåºè¿ä¸ªé®é¢ä½ä¸ºä¸ä¸ªæç¨çæ¡ä¾ç ç©¶ã\n\n\n# åèæç®\n\n[0]TLA proof system. https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html. ð\n\n[1]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. ð\n\n[2]Jean-Christophe FilliÃ¢tre and Claude MarchÃ©. Greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. ð\n\n[3]K. Rustan M. Leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy, June 2021. ð',normalizedContent:'# å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶:gcd\n\n> k. rustan m. leino manuscript krml 279, 22 june 2021\n\næè¦ æ¬æçç®çæ¯å±ç¤ºä¸ä¸ªç¨åºå¼åçç¤ºä¾ï¼ä»ç»æ¯æç¨åºè§èçå®ä¹ï¼éè¿°åè¯æé£äºå®ä¹çå¼çï¼å¹¶ä½¿ç¨å¼çæ¥è¯æç¨åºçæ­£ç¡®æ§ãä»¥æ¬§å éå¾çè®¡ç®æå¤§å¬çº¦æ°çåæ³ç®æ³ä¸ºä¾ã\n\n\n# é®é¢æè¿°\n\nè®©æä»¬æå®å¹¶éªè¯ä¸ä¸ªç®æ³æ¥è®¡ç®ä¸¤ä¸ªæ°çæå¤§å¬çº¦æ°(gcd)ãå¨è§èä¸­ï¼æä»¬å°å¼å¥ä¸ä¸ªå½æ°ï¼å®çå®ä¹âæ¾ç¶æ¯æ­£ç¡®çâãæä»¬ä¸ä¼ä½¿ç¨è¿ä¸ªå½æ°æ¥è®¡ç®gcdï¼å ä¸ºå¦æç´æ¥ç¼è¯çè¯ï¼âææ¾æ­£ç¡®âçå®ä¹ä¼ç»åºéå¸¸ä½æçä»£ç ãç¸åï¼æä»¬å°ä½¿ç¨euclidç®æ³æ¥è®¡ç®âææ¾æ­£ç¡®âå½æ°å®ä¹çå¼ãæä»¬å°è¯æè¿ä¸ªç®æ³ç¡®å®è®¡ç®åºäºè¿ä¸ªå¼ã\n\næ¬è´¨ä¸ï¼æä»¬æ\n\nfunction gcd(x: pos, y: pos): pos\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­posè¡¨ç¤ºæ­£æ´æ°çç±»åã\n\n\n# æ­£æ´æ°\n\næä»¬æåçä¸åé½ä¸æ­£æ´æ°æå³ãdafnyä¸ºèªç¶æ°(å³éè´æ´æ°)èéæ­£æ´æ°æå»ºäºä¸ç§ç±»åãæä»¬å¯ä»¥å¨dafnyä¸­ä½¿ç¨å­éç±»åæ¥å®ä¹å®ä»¬:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\ndafnyæ³ç¥éè¿ç§ç±»åæ¯å¦æå±æ°ï¼ä½å®èªå·±ä¸ç¥éãå¯¹äºæä»¬çç¤ºä¾æ¥è¯´ï¼è¿æ å³ç´§è¦ï¼ä½æ¯æä»¬ç¡®å®éè¦å¤çæä»¬å¾å°çéè¯¯ãä¸ºæ­¤ï¼æä»¬æä¾äºwitnessæ¡æ¬¾:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nå¦ææä»¬ççä¸æ¿ææ¾ç¤ºæ¾ç¤ºè¯¥ç±»åä¸ºéç©ºçwitnessï¼æä»¬å¯ä»¥åwitness *ï¼è¿å¯¼è´dafnyå°posç±»åè§ä¸ºå¯è½ä¸ºç©ºãå¯¹äºæä»¬çä¾å­ï¼ä½ å¯ä»¥éæ©å¶ä¸­ä¸ç§ï¼ä½å ä¸ºæä¾ä¸ä¸ªå®éçè¯äººå¾å®¹æï¼æä»¥æä»¬å°±è¿ä¹åã\n\nå¨ç»­éä¸­ï¼å½ææçæ¯æ­£æ´æ°æ¶ï¼æä¼è¯´numberã\n\n\n# å ç´ \n\nä¸ä¸ªæ°çé¤æ°æ¯å®çå æ°ãæä»¬å®ä¹äºä¸ä¸ªè°è¯ï¼å®è¯´æäºæ°å­pæ¯æ°å­xçå æ°æ¯ä»ä¹ææ:\n\npredicate isfactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\næ¢å¥è¯è¯´ï¼pæ¯xçå å­ï¼å¦æå­å¨ä¸ä¸ªè¢«ä¹æ°qï¼é£ä¹xå°±æ¯p * qçä¹ç§¯ã\n\nä¸ºäºè®¨è®ºä¸ä¸ªæ°å­çææå å­ï¼æä»¬å¼å¥äºä¸ä¸ªå½æ°factorsï¼æä»¬ä½¿ç¨éåçè§£æ¥å®ä¹å®ãä¸ä¸ªç®åçå®ä¹æ¯:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | isfactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\nå¨dafnyä¸­ï¼setè¡¨ç¤ºä¸ä¸ªæéçéå(å¯¹äºå¯è½çæ ééåï¼ä½¿ç¨isset)ãå¨è¿ç§æåµä¸ï¼dafnyå¹¶æ²¡æç«å³åç°è¿ä¸ªçè§£ä¼çæä¸ä¸ªæééãå¹¸è¿çæ¯ï¼æä»¬å¯ä»¥ç®åå°å¨çè§£ä¸­æ·»å å¦ä¸ä¸ªè¿è¯ï¼è®©dafnyçå°éåæ¯æéç:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | p <= x && isfactor(p, x)\n}\n\n\n1\n2\n3\n\n\nå¨æ·»å è¿ä¸ªè¿è¯æ¶ï¼æä»¬å¯è½ä¼ç¯ä¸ä¸ªéè¯¯ï¼å ä¸ºæ°çéåå¯è½æ²¡æåå«æä»¬æ³è¦çææå ç´ ãæä»¬çç»åç¹p <= xå½ç¶çèµ·æ¥å¾ç®åï¼ä½ä¸ºä»ä¹ä¸è¯æå ä¸å®ä¸ä¼æå¤éæ¼ä»»ä½å å­å¢?æä»¬å¯ä»¥è¯æè¿ä¸ªéåçåç´ ä¸å¯è½æ ééç¸å:\n\nlemma factorshasallfactors(x: pos)\n  ensures forall n :: n in factors(x) <==> n in iset p: pos | isfactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nå¼ççè¯ææ¯å¨å¼çä¸»ä½ä¸­ç»åºç(ä¹å°±æ¯è¯´ï¼å¨å¼çè§èåé¢çä¸å¯¹è±æ¬å·ä¹é´)ãå¨è¿ç§æåµä¸ï¼è¯ææ¯ç©ºçï¼å ä¸ºdafnyèªå¨å°è¯æäºå¼çï¼èä¸éè¦æä»¬æä¾ä»»ä½è¿ä¸æ­¥çå¸®å©ã\n\nå¨ç¦»å¼å å­çå®ä¹ä¹åï¼è®©æä»¬è¯´æåè¯æä¸¤ä¸ªç®åçå¼çãè¿äºå¼çå¯ä»¥ä½ä¸ºå¯¹æä»¬å®ä¹çæ£æ¥ï¼å®ä»¬å¨ä»¥åçå¼åä¸­ä¹ä¼å¾æå¸®å©ã\n\nlemma factorscontains1(x: pos)\n  ensures 1 in factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma factorscontainsself(x: pos)\n  ensures x in factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè¯æä¸ä¸ªæ°å­n(è¿éæ¯1æx)å¨éåfactors(x)ä¸­ï¼æä»¬éè¦ç¡®å®næ»¡è¶³éåçè§£çæ¡ä»¶(å¨factors(x)ä¸»ä½ä¸­)ãè¿è¯n <= xè¢«èªå¨è¯æï¼ä½isfactor(n, x)ä¸æ¯ãæ ¹æ®isfactorçå®ä¹ï¼æä»¬éè¦è¯æn * q == xçè¢«ä¹æ°qçå­å¨æ§ãè¿ç§è¯æéå¸¸åæ¬è¯æè¯äººï¼è¿å°±æ¯ä¸é¢ä¸¤ä¸ªå¼çä¸­çæ­è¨éè¿°æåçãç±è¿äºæ­è¨ï¼éªè¯èå®æäºå¼ççè¯æã\n\n\n# éåçæå¤§å¼\n\nä¸ºäºè®¨è®ºæå¤§å¬çº¦æ°ï¼æä»¬éè¦ä¸ä¸ªå½æ°æ¥æééåä¸­æå¤§çæ°ãä¸ç§æç¹å£°ææ§çæ¹æ³æ¯ä½¿ç¨such-thatç»æãç¹å«å°ï¼å¯¹äºéås, let-such-thatè¡¨è¾¾å¼\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nè¡¨ç¤ºå°xç»å®å°æ»¡è¶³æ¡ä»¶xå¨s &&ä¸­çææy:: yå¨s ==> y <= xçå¼ï¼ç¶åè¿åè¡¨è¾¾å¼xçå¼ãè¿ä¸ªæ¡ä»¶è¯´xå¨éåsä¸­ï¼å¹¶ä¸å¨éåsä¸­ï¼xæ¯æå¤§çã\n\nä½¿ç¨such-thatç»ææä¸ä¸ªè¯æä¹å¡ï¼å³æ»¡è¶³ç»å®æ¡ä»¶çå¼å­å¨ãå¦ææä»¬è¦æ±sä¸ºéç©ºï¼é£ä¹x in sæ¡ä»¶å¾å®¹ææ»¡è¶³ï¼ä½å®éè¦æ´å¤çå·¥ä½æ¥è¯´æéªè¯èxçå¼æ»¡è¶³éè¯ãä¸ºæ­¤ï¼æä»¬å°å®ä¹ä¸ä¸ªå¼çãæä»¬å°å¼çå½åä¸ºmaxexistsï¼ç¶åæä»¬å¯ä»¥è¿æ ·åæä»¬çå½æ°max:\n\nfunction max(s: set<pos>): pos\n  requires s != {}\n{\n  maxexists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafnyä½¿ç¨å¼çè°ç¨maxexists(s)æ¥å»ºç«åç»­è¡¨è¾¾å¼çæ ¼å¼è¯å¥½æ§ãé¡ºä¾¿è¯´ä¸ä¸ï¼æ³¨æmax(ä»¥åå¼çmaxexists)æä¸ä¸ªåç½®æ¡ä»¶s !={}(å³é®å­requires)ãè¿æå³çå½æ°(ä»¥åå¼ç)åªè½å¨éç©ºéåä¸­è°ç¨ã\n\né£ä¹æä»¬å¦ä½è¯æmaxexistså¢?è¯æè¿æ ·ä¸ä¸ªxå­å¨çæç´æ¥çæ¹æ³æ¯è®¡ç®ä¸ä¸ªæ»¡è¶³æéæ§è´¨çxãæä»¬å°å¼å¥å¦ä¸ä¸ªè®¡ç®æå¤§å¼çå½æ°ï¼ç§°ä¸ºfindmaxï¼å¹¶å¨maxexistså¼ççè¯æä¸­ä½¿ç¨å®ãå½æ°findmaxå°è¢«éå½å®ç°ã\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := findmax(s);\n}\n \nfunction findmax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= findmax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\næä»¬ç°å¨ä¸æ¯å¨ååå­å?æ¯çï¼å¨æäºæ¹é¢ï¼æä»¬è®©çæ´»åå¾æ¯å¿è¦çæ´å°é¾ãå¦ææä»¬æfindmaxï¼æä»¬ä¸éè¦maxï¼ç¶åæä»¬ä¹ä¸éè¦å¼çmaxexistsãäºå®ä¸ï¼æä»¬å¯ä»¥åªç¼ååä½¿ç¨findmaxï¼èä¸å¼å¥maxæmaxexistsãä½å¨è¿ä¸ªä¾å­ä¸­ï¼æå¸æä¸»è¦çå®ä¹å°½å¯è½æ¸æ°ï¼èä¸èèå¦ä½è®¡ç®ãä»è¿ä¸ªæä¹ä¸è¯´ï¼maxçä¸»ä½æ¯æä»¬å°è¦ä¸ºfindmaxç¼åçä¸»ä½æ´å·å£°ææ§ã\n\nä»¥ä¸æ¯findmaxçå®æ´å®ä¹:\n\nfunction findmax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s\' := s - {x};\n    assert s == s\' + {x};\n    var y := findmax(s\');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nå½å½æ°çåç½®æ¡ä»¶æ³è¦æå°å½æ°çç»æå¼æ¶ï¼ä½ å¯ä»¥ä½¿ç¨å½æ°æ¬èº«ï¼ç»åºåæ°:findmax(s)ãæå¨ä¸é¢ç¬¬ä¸æ¬¡ä»ç»findmaxæ¶å°±è¿æ ·åäºãå¨å®æ´çå®ä¹ä¸­ï¼æå±ç¤ºäºå¦ä¸ç§æ¹æ³ï¼å³ä¸ºç»æå¼å¼å¥ä¸ä¸ªåç§°:maxãè¯¥åç§°åªè½å¨å½æ°çåç½®æ¡ä»¶ä¸­ä½¿ç¨ãå¾å¤æ¶åï¼ä¸ºç»æå¼å¥è¿æ ·çåç§°ä¼å¯¼è´æ´ç­çè§èã\n\n\n# gcd\n\næäºæä»¬å®ä¹çå½æ°ï¼ç°å¨å°±å¯ä»¥å®ä¹gcdäºãåxçå å­ä¸yçå å­ï¼ä¸ä¹ç¸äº¤ï¼å¾å°å®ä»¬çå¬å å¼ï¼åå¶æå¤§å¼:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nå¯¹äºè¿ä¸ªç®åçå®ä¹ï¼éªè¯èæ¥åäºä¸ä¸ªåææ¡ä»¶çè¿åï¼å ä¸ºå®æ æ³è¯æcommonæ»¡è¶³maxçåææ¡ä»¶ãæä»¬ç¥éå¬å æ°æ¯éç©ºçï¼å ä¸ºæä»¬ç¥é1æ¯ä»»æä¸¤ä¸ªæ°xåyçå¬å æ°ãä¸ºäºå¼èµ·éªè¯èçæ³¨æï¼æä»¬åäºä¸ä¸ªæ­è¨:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common;  // error: assertion violation\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nåï¼éªè¯èä¸è½è¯æè¿ä¸ªæ­è¨ãä½æä»¬å¯ä»¥çå°ï¼è¿ä¸ä¸»å¼ çå­å¨è¶³ä»¥æ¶é¤åå³æ¡ä»¶çè¿åãç°å¨æä»¬æ¥è¯æè¿ä¸ªæ­è¨ãè¿å°±æ¯æä»¬ä½¿ç¨åé¢ä»ç»çfactorscontains1å¼ççå°æ¹ãå¯¹è¯¥å¼ççä¸¤æ¬¡è°ç¨å°è¯ææ­è¨ï¼å¨ç¨åºææ¬ä¸­æå¥½çæè·æ¹æ³æ¯å°assertæ´æ¹ä¸ºassert byï¼å¹¶å¨byåä¸­ç»åºæ­è¨çè¯æ:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common by {\n    factorscontains1(x);\n    factorscontains1(y);\n  }\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¤äº!æä»¬ç°å¨å·²ç»ç»åºäºgcdçä¸ä¸ªæ ¼å¼è¯å¥½çå®ä¹ã\n\n\n# gcdçæ§è´¨\n\næä»¬å°è¯ææä»¬çgcdå½æ°çä¸ä¸ªå±æ§ââå¦æä½ æ¿æï¼å¯ä»¥ç§°ä¹ä¸ºå¥å¨æ£æ¥ã(æä»¬è¿éè¦ç¬¬åä¸ªå±æ§ï¼ç¨ååä»ç»ã)\n\nä½ä¸ºç¬¬ä¸ä¸ªå®æ´æ§æ£æ¥ï¼æä»¬æægcd(x, y)è¿åä¸ä¸ªåæ¶æ¯xåyå å­çæ°å­ãæ­¤å¤ï¼å¨ææåæ¶æ¯xåyå æ°çæ°å­ä¸­ï¼gcd(x, y)çæ¶çåºè¯¥æ¯æå¤§çã\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nè¿ä¸ªå¼ççåä¸¤ä¸ªåç½®æ¡ä»¶æ¯èªå¨è¯æçï¼ä½ç¬¬ä¸ä¸ªä¸æ¯ãæä»¬å¦ä½è¯æä¸ä¸ªå¨ç§°éè¯(ä¹å°±æ¯forallè¡¨è¾¾å¼)æ¯æç«ç?æä»¬ä½¿ç¨è¾¾å¤«å°¼çforallè¯­å¥ãå½ç¨äºè¯ææ¶ï¼forallå½é¢å¯¹åºäºé»è¾ä¸­çâæ®éå¼å¥âè§åãè¿ä¸ªè§åè¯´çæ¯"å¦æä½ æ³è¦è¯æå¯¹äºææçx:: p(x)ï¼é£ä¹ä½ æéè¦åçå°±æ¯ä»»æéæ©ä¸ä¸ªxï¼ç¶åå¯¹é£ä¸ªxè¯æp(x)ã\n\næä»¬åè¿æ ·å¼å¥forallè¯­å¥:\n\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n\n\n1\n2\n\n\nä¸ºäºè¯æå®ï¼æä»¬åªéè¦æåºè¿æ ·ä¸ä¸ªäºå®ï¼å³pï¼æ¢æ¯xåyçå å­ï¼åæ¯xåyçå å­çäº¤éãéªè¯èå°±è½å¤å®æè¯æã\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n{\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n  {\n    assert p in factors(x) * factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafnyéªè¯å¨ç»å¸¸éè¦è¿æ ·çå±æ§å¸®å©ãè¦è¯æå®ä»¬ï¼å°±æå®ä»¬åææ­è¨ãæ¢å¥è¯è¯´ï¼éªè¯èç¥ééåäº¤éçè¿ä¸ªæ§è´¨ï¼ä½å®æ²¡æè¶³å¤çåæå°è¿ä¸ªæ§è´¨å¼å¥è¯æä¸­ãéè¿æ­è¨è¯¥å±æ§ï¼æä»¬è¦æ±éªè¯èç¡®è®¤è¯¥å±æ§(å®è½å¤è¿æ ·å)ï¼ç¶åå¨å¶ä½çè¯æä¸­ä½¿ç¨è¯¥å±æ§(å¨æ¬ä¾ä¸­ï¼è¿å°±å®æäºè¯æ)ã\n\nä½ä¸ºç¬¬äºä¸ªå®æ´æ§æ£æ¥ï¼æä»¬è¯æäºgcdæ¯å¯¹ç§°çã\n\nlemma gcdsymmetric(x: pos, y: pos)\n  ensures gcd(x, y) == gcd(y, x)\n{\n  assert factors(x) * factors(y) == factors(y) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nè¿ä¸ªè¯æå½ç»å°éåäº¤ç¹æ¯å¯¹ç§°çè¿ä¸ªäºå®ï¼æä»¬æå®åæå¼çæ¥å¼èµ·éªè¯èçæ³¨æã\n\nä½ä¸ºç¬¬ä¸ä¸ªå¥å¨çæ£éªï¼æä»¬è¯ægcdæ¯å¹ç­çãä¹å°±æ¯è¯´ï¼å¦æä½ ç»å®ç¸åçåæ°ä¸¤æ¬¡ï¼å®ä¼è¿åé£ä¸ªåæ°ã\n\nlemma gcdidempotent(x: pos)\n  ensures gcd(x, x) == x\n{\n  factorscontainsself(x);\n  assert x in factors(x) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿ä¸ªæ§è´¨çè¯æå¯ä»¥å½ç»ä¸ºéåäº¤ç¹æ¯å¹ç­çï¼ä»¥åä¸ä¸ªæ°æ¯å®èªå·±çå å­ä¹ä¸çæ§è´¨ã\n\n\n# æ¬§å éå¾·ç®æ³\n\næ¬§å éå¾çæ±åä¸¤ä¸ªæ°çgcdçåæ³ç®æ³æ¯å°ä¸¤ä¸ªæ°ä¸­çè¾å¤§æ°åå¤åå»è¾å°çæ°ï¼ç´å°å®ä»¬ç¸ç­ãæ¯ä¸ä¸ªè¿æ ·çåæ³é½ä¿çäºgcdââä¸ä¸ªæä»¬éè¦è¯æçä¸åéââä¸¤ä¸ªç¸ç­çæ°çgcdå°±æ¯é£ä¸ªæ°ââè¿ä¸ªæ°æ¯æä»¬éè¿ä¸é¢çâgcdå¹ç­âå¼çå»ºç«çã\n\nè¯¥ç®æ³å·æå¾ªç¯ä¸åéåå¹ç­å¼çï¼å¶ç»æå¦ä¸:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\næ­¤æ¹æ³ä½¿ç¨while - caseå¾ªç¯ã(å¦ææ¨çædijkstraçä¿æ¤å½ä»¤[1]ï¼è¿æ¯do-odå¾ªç¯ã)è¿ä¸ªå¾ªç¯çæ¯æ¬¡è¿­ä»£é½ä¼éæ©ä¸ä¸ªcaseæ¥æ§è¡ãæéçcaseå¿é¡»æ¯ä¸ä¸ªå¶å®æ¤æ¡ä»¶æ±å¼ä¸ºtrueçå¯¹è±¡(å¦æå ä¸ªcaseçå®æ¤æ¡ä»¶æ±å¼ä¸ºtrueï¼åå¾ªç¯å¨è¿äºcaseä¹é´ä»»æéæ©)ãå¦ææ²¡æè¿æ ·çä¿æ¤æ¡ä»¶ï¼åå¾ªç¯åæ­¢è¿­ä»£ãeuclidgcdä¸­çå¾ªç¯å½ç¶å¯ä»¥æ¯ä¸ä¸ªæ®éçwhile x != yå¾ªç¯ï¼ä½while - caseå¾ªç¯æä¾çä¸¤ç§æåµçå¯¹ç§°æ§ä½¿å¶ç¾è§ã\n\né¤äºä¸ä¸ªå¾ªç¯ä¸åå¼å¤ï¼å¾ªç¯è¿å£°æäºä¸ä¸ªç»æ­¢åº¦é(å³é®å­decreases)ãè¯æå¾ªç¯ç»æ­¢å½ç»ä¸ºè¯ææ¯æ¬¡è¿­ä»£ä½¿ç»æ­¢åº¦éçå¼åå°(æç§dafnyåç½®çåºäºè¯å¥½åºç¡çæ´æ°é¡ºåº)ã\n\nä¸é¢çeuclidgcdæ¹æ³æ²¡æéªè¯ï¼å ä¸ºéªè¯å¨æ æ³è¯ææ¯æ¬¡è¿­ä»£é½ä¿æå¾ªç¯ä¸åãä¸ºæ­¤ï¼æä»¬éè¦æå¨ä¸é¢æå°çgcdçç¬¬åä¸ªæ§è´¨:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(x, y) == gcd(x, y - x)\n\n\n1\n2\n3\n\n\nå©ç¨è¿ä¸ªå¼çågcdçå¯¹ç§°æ§ï¼æä»¬å¯ä»¥å®ægcdçè¯æ:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)\n    decreases x + y\n  {\n    case x < y =>\n      gcdsubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        gcd(x, y);\n      ==  { gcdsymmetric(x, y); }\n        gcd(y, x);\n      ==  { gcdsubtract(y, x); }\n        gcd(y, x - y);\n      ==  { gcdsymmetric(y, x - y); }\n        gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nè¿ä¸ªçæ¬å¨å¾ªç¯çç¬¬ä¸ä¸ªåæ¯ä¸­æ·»å äºå¯¹gcdsubtractçè°ç¨ãå¨å¾ªç¯çç¬¬äºä¸ªåæ¯ä¸­ï¼è¯æè®¡ç®ä½¿ç¨ä¿æç­å¼çæ­¥éª¤å°è¡¨è¾¾å¼gcd(x, y)è½¬æ¢ä¸ºgcd(x - y, y)ãæ­¥éª¤ä¸­ç»åºçæç¤ºæ±å©äºgcdsubtractågcdsymmetricå¼çã\n\n\n# gcdåæ§è´¨\n\nå¨è¿ä¸ªæ¡ä¾ä¸­ï¼gcdsubtractçè¯ææ¯å¶ä»ä»»ä½å®ä¹åå¼çé½è¦å¤æã\n\nè¯æé¦åå¼å¥gcd(x, y)çåç§°:\n\n  var p := gcd(x, y);\n\n\n1\n\n\nç±gcdçå®ä¹å¯ç¥ï¼pæ¯xåyçå å­ï¼æä»¬å¯ä»¥è¯æpä¹æ¯y - xçå å­:\n\n  assert isfactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nä¸ºäºè¯æisfactor(p, y - x)ï¼æä»¬å¯¹isfactorçå®ä¹åè¯æä»¬å­å¨çè¢«ä¹æ°å¼å¥aåbåç§°(å ä¸ºpæ¯xåyçå å­)ãç¨åºæ¬çç®æ¯æ­¥éª¤è¿è¡ç®åçè®¡ç®ï¼æä»¬å°±å¯ä»¥å¾å°på¯ä»¥ä¹ä¸å¦ä¸ä¸ªæ°(å³b - a)å¾å°y - xã\n\nå ä¸ºpåæ¶æ¯xåy - xçå å­ï¼æä»¥å®æ¯xåy - xçå¬å å¼ãæä»¬åäºä¸¤è¡ä»£ç æ¥ç¡®ä¿éªè¯å¨ä½¿ç¨äºè¿ä¸ªå±æ§ï¼ç¨éåäº¤éæ¥è¡¨è¾¾:\n\n  var common := factors(x) * factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\næåï¼æä»¬éè¦è¯æpæ¯è¿ä¸ªå¬å å¼çæå¤§ãæä»¬ä½¿ç¨forallè¯­å¥æ¥å£°æè¿ä¸ªå±æ§:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nä¸ºäºè¯æè¿ä¸ªæ§è´¨ï¼æä»¬å¡«åäºforallè¯­å¥ä½ãå¯¹äºè¡¨ç¤ºâå¬å±æ§âéåä¸­çä»»ææ°å­qï¼æä»¬åå«å°çæxåy - xä¹ç§¯çè¢«ä¹æ°å½åä¸º:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nä½¿ç¨ç®åçç®æ¯æ­¥éª¤ï¼æä»¬å¯ä»¥ç¨ä¸ä¸ªè¯æè®¡ç®æ¥ç¡®å®qä¹æ¯yçå å­:\n\n    assert isfactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\næä»¥ï¼å ä¸ºqæ¢æ¯xåæ¯yçå å­ï¼æä»¥gcd(x, y)çå®ä¹åè¯æä»¬q <= gcd(x, y)éè¿ç»åºå¦ä¸ä¸ªå³äºéåäº¤éçæç¤º:\n\n    assert q in factors(x) * factors(y);\n  }\n\n\n1\n2\n\n\néªè¯èå®æéªè¯ã\n\n\n# æ´å¤çå¯¹ç§°\n\nè½ç¶æä»¬ç°å¨å·²ç»æäºgcdç®æ³çå®æ´è¯æï¼ä½æ¨çç¾æå¯è½ä¼å ä¸ºæä»¬å¨ä¸¤ç§æåµä¸æä¾è¯æçæ¹å¼çä¸å¯¹ç§°æ§èåå°å½±åãæ¢ç¶while - caseå¾ªç¯ä¸ºæä»¬æä¾äºè¿ä¸¤ç§æåµçå¯¹ç§°è¡¨è¿°ï¼å¦ææä»¬ä¹è½ä½¿è¿ä¸¤ç§æåµçè¯ææ´å ç¸ä¼¼å°±å¥½äºã\n\næå ç§æ¹æ³å¯ä»¥æ¹åè¿ç§æåµãä¸ç§æ¯éæç¬¬äºä¸ªcaseçè¯æè®¡ç®å°å®èªå·±çå¼çä¸­ãç¶åï¼æ¯ä¸ªâæ¡ä¾âé½æä¸è¡è¯æã\n\nä¸ºäºå¥½ç©ï¼è®©ææ¥æè¿°å¦ä¸ä¸ªâæå·§âï¼è®©è¿ä¸¤ç§æåµ(ä¸å®å¨å¯¹ç§°ï¼ä½è³å°)æ´ç¸ä¼¼ãè¯çªå¨äºä½¿(å·²ç»ä¸å¯¹ç§°ç)gcdsubtractå¼çä¹æåæ°è½¬æ¢ä¸ºgcdãæä»¬å°å¶æ¹åä¸º:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(y, x) == gcd(x, y - x)\n{\n  gcdsymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næ³¨æåç½®æ¡ä»¶çå·¦è¾¹ç°å¨æ¯gcd(y, x)ï¼èä¸æ¯gcd(x, y)å°±åæä»¬å¨è¿ä¸ªå¼ççç¬¬ä¸ä¸ªçæ¬ä¸­ä¸æ ·ãè¿ä¸ªè¯ææéè¦çå¯ä¸æ¹åå°±æ¯è¯è¯¸äºgcdçå¯¹ç§°æ§ï¼æä»¬å¯ä»¥éè¿å¼çåé¨çä¸ä¸ªå¼çæ¥åå°è¿ä¸ç¹ãè¿ç»äºæä»¬ä¸ä¸ªéæ°è¡¨è¿°çâgcdsubtractâå¼ççè¯æã\n\néè¿è¿ç§éæ°è¡¨è¿°ï¼æä»¬å¯ä»¥ç®åeuclidgcdçç¬¬äºä¸ªâæå½¢âï¼ä»¥ä½¿ç¬¬ä¸ä¸ªâæå½¢âæ´å å¤æä¸ºä»£ä»·ãæ¬è´¨ä¸ï¼æä»¬æä¸ä¸ªå¼çè°ç¨ä»ç¬¬äºç§æåµç§»å°ç¬¬ä¸ç§æåµï¼æä»¥ä¸æ¯æ1å3ä¸ªå¼çè°ç¨å¨ä¸¤ç§æåµä¸ï¼æä»¬ä¼æ2å2ã\n\n    case x < y =>\n      gcdsubtract(x, y);\n      gcdsymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      gcdsymmetric(x - y, y);\n      gcdsubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå®ä¸æ¯å®å¨å¯¹ç§°çï¼ä½ä¹è®¸ä½ è¿æ¯åæ¬¢å®ãæèä½ å¯è½ä¼å¨å¦ä¸ç§æåµä¸è®°ä½è¿ä¸ªæå·§ï¼å½éå­éå¸¸åéçæ¶åãå¦ææ²¡æå«çï¼æ¨å¯ä»¥åæä½¿ç¨æä»¬å¨ä¸é¢å¼åçç¬¬ä¸ä¸ªå®æ´çè¯æã\n\n\n# ä¸»æ¹æ³\n\nå¦æè¯ææ¬èº«ä¸æ»¡è¶³ä½ ï¼ä½ ä»ç¶æ³çå°ç®æ³çè¿è¡ï¼ä½ å¯ä»¥åä¸ä¸ªmainæ¹æ³ï¼ç¼è¯å¹¶è¿è¡ç¨åºã(å¨å½ä»¤è¡ä¸­ä½¿ç¨dafnyå·¥å·ç/compile:3éé¡¹æ¯ä¸ç§ç®åçæ¹æ³ãå®å°éªè¯ç¶åè¿è¡ç¨åºã)\n\nä¸é¢æ¯ä¸ä¸ªmainçä¾å­:\n\nmethod main() {\n  test(15, 9);\n  test(14, 22);\n  test(371, 1);\n  test(1, 2);\n  test(1, 1);\n  test(13, 13);\n  test(60, 60);\n}\n\nmethod test(x: pos, y: pos) {\n  var gcd := euclidgcd(x, y);\n  print x, " gcd ", y, "  =  ", gcd, "\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ç»è®º\n\nè¿ä¸ªæ¡ä¾ç ç©¶å±ç¤ºäºå¦ä½å®ä¹ä¸ä¸ªæå´è¶£çé¢å(è¿éæ¯æ°å­å å­ï¼å¯¼è´äºgcdçå®ä¹)ï¼éè¿°åè¯æå³äºè¿äºå®ä¹çä¸äºå¼çï¼ç¶åå¨ä¸ä¸ªå°ç¨åºçè¯æä¸­ä½¿ç¨è¿äºå¼çã\n\nè¯¥ç¨åºï¼åæ¬ææå¼çåå¶ä»ä¸å®ä¹ç¸å³çè¯æä¹å¡ï¼åªéè¦å°äº3ç§çdafnyéªè¯å¨éªè¯ãæ¨å¯ä»¥å¨dafnyæµè¯å¥ä»¶[3]ä¸­æ¾å°æ´ä¸ªç¨åºã\n\næ¬§å éå¾·çgcdç®æ³æ¯ä¸ä¸ªå¸¸è§çæç§ä¹¦ä¾å­ãå®å¨ä¸åçéªè¯å¨ä¸­ä»¥ä¸åçå½¢å¼è¢«è¯æãä¾å¦ï¼tla+æç¨ä»¥è¿ä¸ªç¨åºä¸ºä¾[0]ãå®åè®¾äºæä»¬å¨è¿éè¯æçgcdçæ°å­¦æ§è´¨ãwhy3ç¨åºåºåå«æ¬§å éå¾·gcdç®æ³çä¸ä¸ªçæ¬ï¼å®å¨æ¯ä¸æ­¥ä¸­ä½¿ç¨æ¨¡èä¸æ¯åæ³ï¼è¿æ ·å¯ä»¥åå°è¿­ä»£æ¬¡æ°[2]ã\n\n\n# è´è°¢\n\nææè°¢reto krameræåºè¿ä¸ªé®é¢ä½ä¸ºä¸ä¸ªæç¨çæ¡ä¾ç ç©¶ã\n\n\n# åèæç®\n\n[0]tla proof system. https://tla.msr-inria.inria.fr/tlaps/content/documentation/tutorial/the_example.html. ð\n\n[1]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. ð\n\n[2]jean-christophe filliatre and claude marche. greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. ð\n\n[3]k. rustan m. leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/test/dafny4/gcd.dfy, june 2021. ð',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"åç§æ¨å¯¼å¼",frontmatter:{title:"åç§æ¨å¯¼å¼",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1d2420/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/4.%E5%90%84%E7%A7%8D%E6%8E%A8%E5%AF%BC%E5%BC%8F.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/4.åç§æ¨å¯¼å¼.md",key:"v-fbc707cc",path:"/pages/1d2420/",headers:[{level:2,title:"éè¯",slug:"éè¯",normalizedTitle:"éè¯",charIndex:239},{level:3,title:"åºæ¬çéè¯çè¯­æ³",slug:"åºæ¬çéè¯çè¯­æ³",normalizedTitle:"åºæ¬çéè¯çè¯­æ³",charIndex:472},{level:3,title:"ç»å®åéçç±»å",slug:"ç»å®åéçç±»å",normalizedTitle:"ç»å®åéçç±»å",charIndex:1066},{level:3,title:"å¤ä¸ªç»å®åé",slug:"å¤ä¸ªç»å®åé",normalizedTitle:"å¤ä¸ªç»å®åé",charIndex:1415},{level:3,title:"éè¯ä¸»ä½çå¸åå½¢å¼",slug:"éè¯ä¸»ä½çå¸åå½¢å¼",normalizedTitle:"éè¯ä¸»ä½çå¸åå½¢å¼",charIndex:1815},{level:3,title:"èå´è°è¯",slug:"èå´è°è¯",normalizedTitle:"èå´è°è¯",charIndex:2726},{level:2,title:"ç¨äºéè¯æ¨ççç¨åºè¯­å¥",slug:"ç¨äºéè¯æ¨ççç¨åºè¯­å¥",normalizedTitle:"ç¨äºéè¯æ¨ççç¨åºè¯­å¥",charIndex:4116},{level:3,title:"èåè¯­å¥",slug:"èåè¯­å¥",normalizedTitle:"èåè¯­å¥",charIndex:4185},{level:3,title:"å­å¨å¼å¥ä¸æé¤",slug:"å­å¨å¼å¥ä¸æé¤",normalizedTitle:"å­å¨å¼å¥ä¸æé¤",charIndex:5116},{level:3,title:"å¸¦å¤åæ°çå¼ç",slug:"å¸¦å¤åæ°çå¼ç",normalizedTitle:"å¸¦å¤åæ°çå¼ç",charIndex:6897},{level:3,title:"ç»å®è­¦å«",slug:"ç»å®è­¦å«",normalizedTitle:"ç»å®è­¦å«",charIndex:7487},{level:2,title:"éååæ å°",slug:"éååæ å°",normalizedTitle:"éååæ å°",charIndex:7976},{level:3,title:"éåçè§£",slug:"éåçè§£",normalizedTitle:"éåçè§£",charIndex:8023},{level:3,title:"ç®åçéåçè§£",slug:"ç®åçéåçè§£",normalizedTitle:"ç®åçéåçè§£",charIndex:9377},{level:3,title:"æ å°çè§£",slug:"æ å°çè§£",normalizedTitle:"æ å°çè§£",charIndex:8028},{level:3,title:"Lambda expressions",slug:"lambda-expressions",normalizedTitle:"lambda expressions",charIndex:10599},{level:2,title:"æ»ç»",slug:"æ»ç»",normalizedTitle:"æ»ç»",charIndex:10884},{level:2,title:"è´è°¢",slug:"è´è°¢",normalizedTitle:"è´è°¢",charIndex:11186},{level:2,title:"åèæç®",slug:"åèæç®",normalizedTitle:"åèæç®",charIndex:11224}],headersStr:"éè¯ åºæ¬çéè¯çè¯­æ³ ç»å®åéçç±»å å¤ä¸ªç»å®åé éè¯ä¸»ä½çå¸åå½¢å¼ èå´è°è¯ ç¨äºéè¯æ¨ççç¨åºè¯­å¥ èåè¯­å¥ å­å¨å¼å¥ä¸æé¤ å¸¦å¤åæ°çå¼ç ç»å®è­¦å« éååæ å° éåçè§£ ç®åçéåçè§£ æ å°çè§£ Lambda expressions æ»ç» è´è°¢ åèæç®",content:'# åç§æ¨å¯¼å¼\n\n> K. Rustan M. Leino Manuscript KRML 267, 27 May 2019\n\næè¦ Dafnyæè®¸å¤ç±»ä¼¼æ¨å¯¼å¼çç»æãæ¬ææè¿°å¹¶æ¯è¾äºè¿äºç»æï¼å±ç¤ºäºå®ä»¬å¨è¯­æ³åè¯­ä¹ä¸çæ¯è¾ã\n\nDafnyæ¯ææ®ééååå­å¨éåï¼ä»¥åç¨äºâè¯æâæ®ééåè¡¨è¾¾å¼æâå©ç¨âå­å¨éåè¡¨è¾¾å¼çç»æã[0]è(http://leino.science/papers/krml267.html#sec-quantifiers)æè¿°äºDafnyä¸­çè¿äºé»è¾éè¯ãç¬¬[1]è(http://leino.science/papers/krml267.html#sec-proof-features)æ¾ç¤ºäºå¨æ¨çéè¯æ¶å¯ä»¥ä½¿ç¨çç¨åºè¯­å¥ï¼å¹¶æåºäºåç§è¯­æ³å½¢å¼çå·®å¼ã\n\néåæ¨å¯¼å¼åæ å°æ¨å¯¼å¼ç±»ä¼¼äºéè¯ï¼å ä¸ºå®ä»¬å¼å¥äºèå´è¶è¿ç¹å®å¼çç»å®åéã[2]è(http://leino.science/papers/krml267.html#sec-sets-and-maps)å±ç¤ºäºè¿äºçè§£çä¸è¬åå¸¸è§å½¢å¼ã\n\n\n# éè¯\n\n\n# åºæ¬çéè¯çè¯­æ³\n\nå¨æ°å­¦æç§ä¹¦åè®ºæä¸­ï¼æä»¬çæçå¨ç§°éè¯éç¨äºç±»ä¼¼çç¬¦å·ãå®è¯´è°è¯å¯¹ææçå¼é½æç«ãå¨ç¼ç¨è¯­è¨è¡è¯ä¸­ï¼æä»¬è¯´å®æ¯ä¸ä¸ªç»å®åéï¼å¶ä½ç¨åæ¯éè¯çä¸»ä½ãä¹å°±æ¯è¯´ï¼ä»»ä½èªç±åºç°çiné½è¢«ç»å®å°éè¯æå¼å¥çã\n\nå¨Dafnyä¸­ï¼åä¸ä¸ªå¨ç§°éè¯è¢«åæforall x:: Pãä»è§£æçè§åº¦æ¥çï¼éè¯çä¸»ä½âå°½å¯è½å°âæ©å±ãå æ­¤ï¼ç¨åºçæ®µ\n\nforall x :: R ==> Q\n\n\n1\n\n\nè§£æä¸º\n\n(forall x :: (R ==> Q))\n\n\n1\n\n\nèä¸æ¯\n\n(forall x :: R) ==> Q\n\n\n1\n\n\nè¯·æ³¨æï¼âå°½å¯è½âä¸éäºè¡å°¾ãä¾å¦ï¼ä¸ä¸ªå¸¸è§çé·é±æ¯ç¼å(è¿éæ¾ç¤ºçæ¯ä¸ä¸ªåç½®æ¡ä»¶)\n\nrequires\n  forall x :: R ==> Q &&\n  S\n\n\n1\n2\n3\n\n\næå¾æ¯forall x:: R ==> QåSæ¯ä¸¤ä¸ªç¬ç«çåææ¡ä»¶ãä¸æ­¤ç¸åçæ¯ï¼è¿éæåçå£°æçæä¹æ¯\n\nrequires (forall x :: (R ==> (Q && S)))\n\n\n1\n\n\nå¦æä½ æç®åéè¯åSçè¿è¯ï¼é£ä¹æ­£ç¡®çè¯­æ³æ¯\n\nrequires\n  (forall x :: R ==> Q) &&\n  S\n\n\n1\n2\n3\n\n\nå­å¨éè¯çä¸ä¸ªçæçæ°å­¦ç¬¦å·æ¯ãå®è¯´è°è¯å¯¹äºæä¸ªå¼æç«ãå¨Dafnyä¸­ï¼è¯­æ³æ¯exists x:: P .0\n\n\n# ç»å®åéçç±»å\n\nDafnyä¸­çæ¯ä¸ªåéé½æä¸ä¸ªç±»åãéå¸¸ï¼ç»å®åéçç±»åæ¯æ¨æ­çï¼ä½Dafnyä¹åè®¸æ¾å¼å£°æè¯¥ç±»åãä¾å¦,\n\nforall x: X :: P\n\n\n1\n\n\nå£°æxçç±»åä¸ºxãä¸ºäºç®æ´ï¼å¹¶å±ç¤ºç¼åéè¯åæ¨æ­çå¸åæ¹æ³ï¼æå°å¨æ¬æä¸­çç¥ç±»åï¼ä½è¯·è®°ä½ï¼å¦ææ¿æï¼æ¨å¯ä»¥éæ¶åå«å®ä»¬ã\n\nå½çº¦æåéä»æä¸ªéåä¸­æåæ¶ï¼éè¯çå¸¸ç¨æ°å­¦ç¬¦å·æ¯ãè¿ä¸ªè¡¨è¾¾å¼çdafnyå¼è¡¨ç¤ºä¸º\n\nforall x in S :: P  // error: syntax error\n\n\n1\n\n\nç¶èï¼è¿æ¯ä¸æ­£ç¡®çDafnyè¯­æ³ï¼å ä¸ºå®ä½¿ç¨äºä¸ä¸ªéåæåè°è¯ï¼å¶ä¸­åªææç»å®åé(å¯éçï¼å¸¦æç±»å)ãå¨Dafnyä¸­è¿æ ·ä¸ä¸ªéè¯çæ­£ç¡®åæ³æ¯\n\nforall x :: x in S ==> P\n\n\n1\n\n\n\n# å¤ä¸ªç»å®åé\n\nä¸ä¸ªéå®ç¬¦å¯ä»¥æä¸ä¸ªä»¥ä¸çç»å®åéãä¾å¦,\n\nforall x, y :: P\n\n\n1\n\n\nPå¯¹äºææçxåyé½æç«ãå®å¨é»è¾ä¸ç­åäºåµå¥çéè¯\n\nforall x :: forall y :: P\n\n\n1\n\n\nå°±æ­¤èè¨ï¼å®å¨é»è¾ä¸ä¹ç­ä»·äº\n\nforall y :: forall x :: P\n\n\n1\n\n\nDafnyçå¸¸è§åæ³æ¯ä½¿ç¨å¤ä¸ªåéçéè¯ï¼èä¸æ¯åµå¥çå½¢å¼ï¼å¦ææ²¡æå¶ä»åå ï¼åªæ¯ä¸ºäºæ´ç®æ´ã1\n\nå¦ææ¨ç¼åäºä¸ä¸ªç»å®åéåè¡¨å¹¶æ¾å¼å°ç»åºäºç±»åï¼è¯·æ³¨æï¼æ¯ä¸ªç»å®çç±»ååªéç¨äºå®ä¹åçåéãä¾å¦,\n\nforall x: X, y: Y :: P\n\n\n1\n\n\nxçç±»åæ¯x, yçç±»åæ¯yãå¦æåªåå«yç±»åï¼å¦\n\nforall x, y: Y :: P\n\n\n1\n\n\né£ä¹ä½ è¯´yçç±»åæ¯yèxçç±»åæ¯å¯ä»¥æ¨æ­çãæ¢å¥è¯è¯´ï¼ä½ å¯ä»¥è®¤ä¸ºè¿ä¸ªâ:âæ¯âï¼âå·ææ´å¼ºççº¦æåã\n\n\n# éè¯ä¸»ä½çå¸åå½¢å¼\n\nå¨ç§°éè¯çä¸»ä½éå¸¸æ¯ä¸ç§å«ä¹ï¼å¦in\n\nforall x :: R ==> P\n\n\n1\n\n\nä½ å¯ä»¥ä»ä»¥ä¸å ä¸ªæ¹é¢æ¥è§£è¯»:\n\n> "å¯¹äºææçxï¼æå³çR ==> Pæç«"\n> \n> "å¯¹äºææçxï¼ Ræå³çP "\n> \n> "å¯¹äºææçxï¼å¦æRæç«ï¼é£ä¹Pä¹æç«"\n\nç¶èï¼è¿ä¸ªå«ä¹çåè¡è¯(R)éå¸¸èµ·å°éå¶(ä¸ä»ä»æ¯xçç±»å)æèèçxçå¼çä½ç¨ãæ¢å¥è¯è¯´ï¼âRâåè¯ä½ âxâçèå´ãå¨è¿ç§æåµä¸ï¼ä½ å¯ä»¥ä»ä¸é¢çä¸ç§æ¹å¼æ¥è§£è¯»ä¸é¢çéè¯:\n\n> "å¯¹äºæææ»¡è¶³Rçxï¼ Pæç«\n> \n> "å¯¹äºææçxï¼ä½¿Ræç«ï¼P "\n> \n> "å¯¹äºææçx(å¶ä¸­xæ»¡è¶³R)ï¼ Pä¿æ"\n> \n> âå¯¹äºææçx[ä¸ºRæå¥ä½ èªå·±çæè¿°æ§é¶æ®µ]ï¼Pâ\n\nä½ä¸ºæåä¸ä¸ªç­è¯­çå·ä½å®ä¾ï¼ä½ å¯ä»¥è¯»å°forall x:: x in S ==> x % 2 == 0 As\n\n> "å¯¹äºSä¸­çææxï¼ xæ¯å¶æ°"\n\nä½ å¯ä»¥è¯»å°forall i:: 0 <= i < a. length ==> a[i] == 5 as\n\n> "å¯¹äºæ°ç»açæ¯ä¸ªä¸æ iï¼ a -sub- iæ¯5 "\n\nåæåæè¯´çå¨ç§°éè¯ç±»ä¼¼ï¼å­å¨éè¯çå¸åå½¢å¼æ¯è¿è¯ï¼æ¯å¦\n\nexists x :: R && P\n\n\n1\n\n\nä¾å¦ï¼\n\nexists x :: x in S && x % 2 == 0\n\nexists i :: 0 <= i < a.Length && a[i] == 5\n\n\n1\n2\n3\n\n\nåæRçææ¯åè¯ä½ xçèå´ï¼ä½ å¯ä»¥æè¿äºå­å¨éè¯çæ\n\n> "å¨Sä¸­æä¸ä¸ªxï¼å¶ä¸­x % 2 == 0éç¨"\n> \n> "å¨aä¸­æä¸ä¸ªç´¢å¼iï¼ä½¿a -sub- iç­äº5 "\n\nå¨Why3 [1]ä¹åï¼å¦æä½ å°R ==> Pä½ä¸ºå­å¨éè¯çä¸»ä½ï¼Dafnyä¼ååºè­¦åï¼å ä¸ºè¿å ä¹æ»æ¯ä¸ä¸ªç¨æ·éè¯¯(ä¸ä¸ªæå­éè¯¯æä¸ä¸ªæè-o)ãå¦æè¿ççæ¯ä½ æ³è¦åçï¼ä½ å¯ä»¥éè¿ç¼åä»¥ä¸ä»»ä½è¡¨è¾¾å¼æ¥æå¶è­¦å:\n\nexists x :: (R ==> P)\nexists x :: !R || P\nexists x :: P <== R\n\n\n1\n2\n3\n\n\n\n# èå´è°è¯\n\nä¸ºä»ä¹æè¦è±ä¸é¡µæ¥åè¯ä½ éè¯çåé³?å ä¸ºè¿ä¸ªè®¨è®ºå¼ºè°äºä¸ä¸ªäºå®ï¼æ¡ä»¶Rï¼å¨ä»»ä½ä¸ä¸ª\n\nforall x :: R ==> P\nexists x :: R && P\n\n\n1\n2\n\n\næ®æ¼çç¹æ®çè§è²ï¼å°½ç®¡âRâå®éä¸åªæ¯è¿äºéè¯ä¸»ä½çä¸é¨åãäºå®ä¸ï¼å¶ä»äººå·²ç»ä¸ºéè¯éç¨äºä¸ç§è¡¨ç¤ºæ³ï¼è¯¥è¡¨ç¤ºæ³ä¸ºè¿ä¸ªèå´è°è¯ Rè®¾ç½®äºä¸ä¸ªç¹æ®çä½ç½®ãä¸é¢æ¯ä¸äºä¾å­:\n\n                                                \nUniversal quantifier   Existential quantifier   Source\n                                                \n                                                Dijkstra [3]\n                                                Chandy and Misra [2]\n                                                Gries and Schneider [4]\n\\forall X x; R; P      \\exists X x; R; P        JML [5]\n                                                \n\n(å¨ä¸é¢çJMLä¸­ï¼Xè¡¨ç¤ºXçç±»åã)å¨ä½¿ç¨è¿äºç¬¦å·çæç§ä¹¦ä¸­ï¼ç»å¸¸æäººè¯´:âä¸ºäºç®æ´ï¼å¦æâRâæ¯âæ­£ç¡®âçï¼æèæ¯æ ¹æ®ä¸ä¸æçè§£çï¼é£ä¹å®(å¯¹äºä¸é¢çä¸äºä½èæ¥è¯´ï¼ä¸äºç¸é»çæ ç¹ç¬¦å·)å°±è¢«çç¥äºãâè¿äºç¼©åå½¢å¼æ¯:\n\n                                                  \nRange listed separately   Range true or omitted   Source\n                                                  \n                                                  Dijkstra [3]\n                                                  Chandy and Misra [2]\n                                                  Gries and Schneider [4]\n\\forall X x; R; P         \\forall X x;; P         JML [5]\n                                                  \n\nè¿ææ´å¤çãéè¿ä½¿ç¨ä¸äºåºåâRâåâPâçç¬¦å·ï¼éè¯çå¾·æ©æ ¹å®å¾çèµ·æ¥ç¹å«å¥½:\n\nåå°Dafnyãå¦ææ¨åæ¬¢å°ç»å®åéçèå´ä»éè¯ä¸»ä½çå¶ä½é¨ååéå¼çç¬¦å·ï¼é£ä¹æ¨å°å¾é«å´å°äºè§£å°ï¼æ¨ä¹å¯ä»¥å¨Dafnyä¸­è¿æ ·åãè¯­æ³æ¯:\n\nforall x | R :: P\nexists x | R :: P\n\n\n1\n2\n\n\n\n# ç¨äºéè¯æ¨ççç¨åºè¯­å¥\n\nDafnyåå«äºä¸äºå¨æ¨çæ¶åéè¯çç¨åºæå®çæ¶éå¸¸æç¨çè¯æç¹æ§ãå®ä»¬çè¯­æ³ä¸éè¯ç¸ä¼¼ï¼ä½ä¹æåºå«ã\n\n\n# èåè¯­å¥\n\nDafnyä¸­çforallè¯­å¥æ¯ä¸ä¸ªèåè¯­å¥:å®å·ææ§è¡å¤ä¸ªåæ¶æä½çææãå½è¿å¥è¯ç¨äºè¯ææ¶ï¼å¶å½¢å¼å¦ä¸:\n\nforall x | R\n  ensures P\n{\n  S;\n}\n\n\n1\n2\n3\n4\n5\n\n\nå®ç¨äºå»ºç«å±æ§forall x | R:: Pï¼å³forall x:: R == >pãå®æ¯éè¿æ£éªå½é¢Sä¸ºä»»ä½æ»¡è¶³Rçxå»ºç«Pæ¥å®ç°çãå¨é»è¾ä¸­ï¼è¿ä¸ªå½é¢çç»æè¢«ç§°ä¸ºâæ®éå¼å¥âã\n\nä¸¾ä¸ªç®åçä¾å­ï¼åè®¾ä½ æä¸ä¸ªå¼çå¯ä»¥è¯æn <= Fib(n)å¯¹äºä»»ä½nè³å°æ¯5ï¼å¶ä¸­Fibæ¯éå¸¸çFibonacciå½æ°:\n\nfunction Fib(n: nat): nat {\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\nlemma FibProperty(n: nat)\n  requires 5 <= n\n  ensures n <= Fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nè¿ä¸ªå¼çç»åºäºä¸ä¸ªç»å®nçå±æ§n <= Fib(n)ãä½åè®¾ä½ æ³è®©è¿ä¸ªæ§è´¨ä»¥æ®ééå­åçå½¢å¼å­å¨ãä¹å°±æ¯è¯´ï¼ä½ è¦è¯æä¸é¢çå¼ç:\n\nlemma FibPropertyAll()\n  ensures forall n :: 5 <= n ==> n <= Fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬æä¹åè¿ä¸ªè¯æå¢?2\n\nç­æ¡æ¯å¯¹æ¯ä¸ªnè°ç¨FibPropertyä¸æ¬¡ãä¸æ¬¡ãå¯¹äºânâææ æ°ä¸ªä¸åçå¼ãè¿å°±æ¯ä½ å¯¹èåè¯­å¥forallæåç:\n\nforall n | 5 <= n\n  ensures n <= Fib(n)\n{\n  FibProperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¬æ¥è¯´ï¼forallè¯­å¥çä¸»ä½è¦æ¯åä¸ªå¼çè°ç¨å¤æå¾å¤ãä½æ¯å½ä¸»ä½æ¯åªæ¯ä¸ä¸ªå¼çè°ç¨æåªæ¯ä¸ä¸ªcalcè¯­å¥æ¶ï¼Dafnyä¼èªå¨æ¨æ­ensureå­å¥ï¼æä»¥ä½ å¯ä»¥çç¥å®:\n\nforall n | 5 <= n {\n  FibProperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# å­å¨å¼å¥ä¸æé¤\n\nä½¿ç¨å­å¨éåè¿ä½¿ç¨äºä¸ç³»åçè¯æç¹å¾ãæå°éè¿åä¸ä¸ªè¯ææ¥è¯æææ³¢é£å¥æ°å¯ä»¥æ¯ä»»æå¤§ç:\n\nlemma EverBigger(k: nat)\n  ensures exists n :: k <= Fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nè®©æä»¬ä»ä¸äºç®åçä¾å­å¼å§è¯æï¼æ¯å¦å½kå¾å°çæ¶åï¼æ¯å¦0æ1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\nDafnyä¸è½èªå¨è¯æè¿ä¸¤ç§æåµï¼æä»¥æä»¬éè¦èªå·±ç»åºæ´å¤çè¯æã\n\nä¸ºäºè¯æè¿ä¸ªå¼çå¨ç®åçæåµä¸ï¼å®è¶³ä»¥åéªè¯èè¯æå­å¨éè¯ææçä¸ä¸ªç¹å®çnãä¹å°±æ¯è¯´ï¼æä»¬æ³ç»å­å¨éè¯ä¸ä¸ªè§è¯ãä¸ä¸ªè¿æ ·çè§è¯æ¯1ï¼å ä¸ºk <= 1 == Fib(1)ãå¦ä¸ä¸ªè¿æ ·çè§è¯æ¯12ï¼å ä¸ºk <= 144 == Fib(12)ãå¦ä¸ä¸ªè¿æ ·çè§è¯æ¯kï¼å ä¸ºå¨æä»¬çç®åä¾å­ä¸­k <= k == Fib(k)ãè®©æä»¬ç»§ç»­è¿ä¸ªï¼æä»¥æä»¬å¨å¼çä¸»ä½çâifâè¯­å¥çâthenâåæ¯ä¸­æ·»å ä¸ä¸ªæ­è¨:\n\nassert k <= Fib(k);\n\n\n1\n\n\nDafnyå°è¯æè¿ä¸ªæ­è¨3ï¼ç¶åä¼æ³¨æå°kæ¯ä¸ä¸ªè¯æåç½®æ¡ä»¶çå­å¨è§è¯ãå¨é»è¾ä¸­ï¼è¿è¢«ç§°ä¸ºâå­å¨è®ºå¯¼è¨âãè¿æå³çï¼å¦æä½ æä¸ä¸ªæ»¡è¶³ç¹å®å±æ§çå¼ï¼é£ä¹è¿ä¸ªå¼å°±å­å¨ãæ¢å¥è¯è¯´ï¼å¦æä½ æä¸ä¸ªâå¨ä½ æä¸­âçä»·å¼ï¼é£ä¹è¿ä¸ªä»·å¼å°±å­å¨äºââè¿ä¼¼ä¹æ¯å¦æ­¤ææ¾ï¼ä»¥è³äºæä»¬è°èµ·å®æ¶å ä¹ä¼æå°å°´å°¬(ä½ çé»å±å¬å°ä½ ä»¥è¿ä¸ªä¸ºçè¯å®ä¼è®¤ä¸ºä½ ç¯äº)ã\n\né£ä¹è¿ä¸ªæ£æçæ¡ä¾å¢?æä»¬å¯ä»¥éè¿å½çº³æ³æ¥è¯æï¼é¦åå¾å°ä¸ä¸ªnï¼å®çææ³¢é£å¥å¼è³å°ä¸ºk-1ï¼ç¶ååä»ä¸­æå»ºä¸ä¸ªæ´å¤§çææ³¢é£å¥å¼ãé¦åï¼æä»¬å¨âk-1âä¸éå½å°è°ç¨å¼ç:\n\nEverBigger(k-1);\n\n\n1\n\n\nè¿è®©æä»¬è·å¾äºEverBigger(k-1)çåç½®æ¡ä»¶ãä¸ºäºå¨æä»¬çè¯æä¸­æç¡®å°åä¸è¿ä¸ç¹ââä¸ºäºæ£æ¥éªè¯èæ¯å¦å¾åºäºæä»¬ææä»å¼çè°ç¨ä¸­å¾å°çç»è®ºï¼å¹¶æéæä»¬èªå·±ä»ä¹å±æ§ââæä»¬å¯ä»¥åä¸ä¸ªæ­è¨:\n\nassert exists n` :: k-1 <= Fib(n`);\n\n\n1\n\n\nå¥½å°ç®åä¸ºæ­¢ãæ¥ä¸æ¥ï¼æä»¬æ³æé ä¸ä¸ªè³å°æ¯Fib(n)å¤§1çææ³¢é£å¥æ°ï¼å ä¸ºè¿æ ·å¯ä»¥å®æè¯æãä½æ¯æåææå°çnæ¯ä»ä¹?ä¸é¢çæææ­è¨é½åè¯æä»¬å­å¨è¿æ ·çânâãæä»¬å¸ææè¿æ ·ä¸ä¸ªânâå¨æä»¬æä¸­ï¼è¿æ ·æä»¬å°±å¯ä»¥ä½¿ç¨å®ã\n\nä»æä»¬ç¥éå­å¨çä¸è¥¿å°âå¨æä»¬æä¸­âçä¸è¥¿è¢«ç§°ä¸ºâSkolemizationâæâexisteneliminationâãä½ å¨Dafnyä¸­éè¿assign-such-thatè¯­å¥å®ç°:\n\nvar m: nat :| k-1 <= Fib(m);\n\n\n1\n\n\nè¿ä¸ªè¯­å¥å¼å¥äºä¸ä¸ªå±é¨åémï¼å¹¶ç»å®ä¸ä¸ªä»»æå¼ï¼æ»¡è¶³k-1 <= Fib(m)ãå½ç¶ï¼å¦æä¸å­å¨è¿æ ·çå¼ï¼è¿æ¯ä¸å¯è½çï¼æä»¥èµå¼-such-thatè¯­å¥å¼èµ·äºä¸ä¸ªè¯æä¹å¡ï¼è¯æè¿æ ·çmå­å¨ãè¿ä¸ªè¯æä¹å¡æ¥èªäºæä»¬ä¸é¢æ­è¨çå±æ§ã\n\nå·®ä¸å¤äºãä¸ºäºå»ºç«å¼ççåç½®æ¡ä»¶ï¼æä»¬å©ä¸çè®¡åå°±æ¯æé ä¸ä¸ªä¸¥æ ¼å¤§äºFib(m)çææ³¢é£å¥æ°ãæä»¬è§å¯å°Fib(m) + Fib(m+1)ä¸¥æ ¼å¤§äºFib(m)ï¼å æ­¤æä»¬æFib(m+2)ä¸¥æ ¼å¤§äºFib(m)ã\n\nå¥½å§ï¼æä»¬ç´è¯´äºå§ãä¹è®¸æä»¬å¹¶æ²¡æâè§å¯âå°è¿ä¸ç¹ï¼èæ¯âå¸æâãâçæ³âæâæ¾æ£å°è®¤ä¸ºâå®å¯è½æç«ãå¥½å§ï¼ç¡®å®å¦æ­¤ã(å·!)æä»¬å¯ä»¥éè¿è¯¢é®éªè¯èå®æ¯å¦è½ä¸ºæä»¬è¯ææ¥éªè¯:\n\nassert k <= Fib(m) + Fib(m + 1) == Fib(m + 2);\n\n\n1\n\n\néªè¯èç«å³è¯æäºè¿ä¸ªæ­è¨ã4æ­¤å¤ï¼éè¿åä¸è¿ä¸ªæ­è¨ï¼æä»¬ä¹åéªè¯èå±ç¤ºäºè§è¯m+2ï¼å®è¯æäºå¼ççåç½®æ¡ä»¶ä¸­çå­å¨éè¯ã\n\næç¨è¿ä¸ªä¾å­æ¥è¯´æçéç¹æ¯ï¼ä½ å¯ä»¥ç¨Skolemizeä¸ä¸ªéè¯\n\nexists x :: P\n\n\n1\n\n\néè¿assign-such-thatè¯­å¥\n\nvar x :| P;\n\n\n1\n\n\næ³¨ææ ç¹ç¬¦å·çåºå«ã\n\n\n# å¸¦å¤åæ°çå¼ç\n\næååç»ä½ ä»¬çäºä¸ä¸ªæ¶åå­å¨éè¯çä¾å­ãè¿ä¸ªä¾å­è¡¨æï¼âEverBiggerâå¼ççâè¯æâä¸¤æ¬¡ä½¿ç¨äºå­å¨æ§ä»ç»(å¨ç®åæåµä¸ä¸ºFib(k)ï¼å¨å°é¾æåµä¸ä¸ºFib(m+2))ï¼ä»èå°âæä»¬æä¸­âçkåm+2è½¬æ¢ä¸ºå­å¨æ§éåãè¿ä¸ªä¾å­è¿å±ç¤ºäº(éå½è°ç¨)å¼ççè°ç¨ä½¿ç¨å­å¨æ¶é¤æ¥å°å¼ççåç½®æ¡ä»¶ä¸­çå­å¨éåè½¬æ¢ä¸ºâæä»¬æä¸­çâä¸ä¸ªmãè®©äººå°è±¡æ·±å»çæ¯ï¼Dafnyæè¿æ ·çç¹æ§ï¼å®è¿æä¸ä¸ªæ´æç¨çç¹æ§ï¼å¯ä»¥è®©ä½ å¨ä¸å¼å§å°±é¿åè¿äºå­å¨-éè¯è½¬æ¢:å¼ç-åæ°ã\n\nå¨æ°å­¦ä¸­ï¼å¼çæ¯ç±å®ä»¬ææå°çåéåæ°åçãè¿äºé½æ¯åæ°ãä¸ä¸ªæ°å­¦å¼çå¾å°ææ°¸è¿ä¸ä¼è¢«è®¤ä¸ºå·æå¤åæ°ãå¨Dafnyä¸­ï¼å¼çå®éä¸å°±æ¯ä¸ä¸ªå¹½çµæ¹æ³ï¼ä¸ä¸ªæ¹æ³å¯ä»¥åæ¶å·æè¾å¥åæ°åè¾åºåæ°ãè¿æ¯éå¸¸æç¨çãä¸å¶ç¨å¼çæ¥è¯ææä¸ªå¼çâå­å¨âï¼è¿ä¸å¦ç´æ¥âè¿åâæä¸ªè¿æ ·çå¼ã\n\nä¸é¢æ¯ä¸é¢çâEverBiggerâå¼çï¼ä½å°nå£°æä¸ºoutå½¢å:\n\nlemma EverBigger(k: nat) returns (n: nat)\n  ensures k <= Fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := EverBigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ç»å®è­¦å«\n\nDafnyè¿åå«äºå¦ä¸ä¸ªç¹æ§ï¼ä½¿éè¯çä½¿ç¨æ´å æµç:å¸¦æ*binding guard *çifè¯­å¥ãè¿æ ·çè¯­å¥åç­äºâå¦ææä¸ä¸ªï¼ç»æä¸ä¸ªå¨ææéâçå½ä»¤ã\n\nåè®¾æä»¬åä¸ä¸ªè¯æï¼æ ¹æ®yæ¯å¦ä¸ºææ³¢é£å¥æ°åæä¸¤ç§æåµãç¶åæä»¬å¯ä»¥è¿æ ·å:\n\nif exists n :: y == Fib(n) {\n  var n :| y == Fib(n);\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿è¡¨è¾¾äºæä»¬æ³è¦çï¼ä½æè§æç¹ç¬¨æï¼å ä¸ºæä»¬éå¤äºæ¡ä»¶y == Fib(n)ãæä»¬å¯ä»¥å°è¿ä¸ªâifâè¯­å¥åæ\n\nif n :| y == Fib(n) {\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\n:|ä¸èµå¼such-thatè¯­å¥ä¸­çæ ç¹ç¸åï¼èä¸æ¯å­å¨éè¯ä¸­ç±»ä¼¼ä½ç½®ç::ã\n\n\n# éååæ å°\n\né»è¾éè¯åå¶ä»ç»æå¼å¥äºä¸äºç»å®åéï¼å¹¶ä»¥æç§æ¹å¼éå¶äºè¿äºç»å®åéçåå¼èå´ãéåçè§£åæ å°çè§£ä¹æ¯å¦æ­¤ã\n\n\n# éåçè§£\n\nå¾å®¹æå¨Dafnyåä¸ä¸ç»ãä¾å¦,\n\n{ 2, 3, 5 }\n\n\n1\n\n\næ¯ä¸ä¸ªæå°ç´ æ°çéåãè¿æ ·çè¡¨è¾¾å¼ï¼å¶ä¸­éåçåç´ è¢«æ¾å¼ååºï¼ç§°ä¸ºset displayãä½æ¯ï¼å¦ææ¨æ³è¦å®ä¹çéåä¸è½åæéåæ¾ç¤ºï¼è¯¥æä¹å?\n\néåçè§£ä»¥å¾è§£çæ¹å¼å®ä¹äºä¸ç»åç´ ãå¨æ®éæ°å­¦ç¬¦å·ä¸­éåçè§£çä¸ä¸ªä¾å­æ¯\n\nå®ä¹äºæå°ç100ä¸ªèªç¶æ°çéåãå¦ä¸ä¸ªä¾å­æ¯\n\nå®å®ä¹äº100ä¸ªæå°çå®å¨å¹³æ¹æ°ãè¿ä¸¤ä¸ªæ¨å¯¼å¼ä¸­çç»å®åéé½æ¯ï¼æå®rangeçå¼ç±è°è¯å®ä¹ãè®©èå´è¶è¿è¿äºå¼ï¼ç¬¬ä¸ä¸ªéåç¶ååå«è¡¨åçåç´ ï¼èç¬¬äºä¸ªéååå«è¡¨åçåç´ ãä¹å°±æ¯è¯´ï¼å¨ç¬¬ä¸ä¸ªéåä¸­ï¼åç´ æ¯èªèº«çåæ³å¼ï¼èå¨ç¬¬äºä¸ªéåä¸­ï¼åç´ æ¯æ¯ä¸ªåæ³å¼çå¹³æ¹ã\n\næ´ä¸è¬å°è¯´ï¼æ°å­¦ç¬¦å·çå½¢ç¶æ¯è¿æ ·çãè¯»èåºè¯¥çè§£è¿æ¯ç»å®åéãçè§£ä¸ºç»å®åéï¼æä»¬å¯ä»¥éè¿ç²¾ç¡®æè¿°éåä½æ¶åå«ä¸ä¸ªåç´ æ¥å®ä¹éåæ¨å¯¼å¼:\n\næèï¼ä½¿ç¨å­å¨å½æ°çåå¼èå´åç¬ç»åºçç¬¦å·:\n\nå¨Dafnyä¸­ï¼åæ ·çéåçè§£æå¦ä¸å½¢å¼:\n\nset x | R :: f(x)\n\n\n1\n\n\nxæ¯ç»å®åé(æèï¼æ´æ®éå°è¯´ï¼ä¸ä¸ªç»å®åéçåè¡¨)ï¼Ræ¯ç»å®åéçèå´è°è¯ï¼èf(x)æ¯éåæ¨å¯¼çé¡¹è¡¨è¾¾å¼ãç»å®åéè¢«æ¾å¼ååºï¼ä¸åæ®éçæ°å­¦ç¬¦å·ï¼è¯»èå¿é¡»æ¨æ­ç»å®åéæ¯ä»ä¹ãä¸é¢ç»åºçä¸¤ä¸ªç¤ºä¾éå¨Dafnyä¸­åå¦ä¸:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nè½ç¶ä¹ä¸çä¸å¤ªç®æ´ï¼ä½æ¾å¼ååºç»å®åéçè¡¨ç¤ºæ³æä¸äºç»å¾®ä¹å¤ã\n\nä¸ä¸ªç»å¾®ä¹å¤æ¯ï¼å°±åä¸é¢ä¸æ ·ï¼éè¯çå®ä¹æ¾ç¤ºäºç¬¦å·çç¸ä¼¼æ§:\n\ny in (set x | R :: f(x))   <==>   exists x | R :: y == f(x)\n\n\n1\n\n\nå¦ä¸ä¸ªä¼ç¹æ¯å¯ä»¥å¾å®¹æå°ååºéå çç»å®åéãåè®¾Ræ¯xåzçè°è¯ï¼é£ä¹è¿éæä¸¤ä¸ªä¾å­:\n\nset x,n | Fib(n) <= x < Fib(n) + n :: f(x)\nset x,n | Fib(n) <= x < Fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nç¬¬ä¸ä¸ªéååå«f(x)å¯¹äºæ¯ä¸ªå¨nèå´åçxå¯¹äºæäºnçFib(n)ãç¨æ®éçæ°å­¦ç¬¦å·æ¥è¡¨ç¤ºå®çä¸ç§ç­ä»·çæ¹å¼æ¯:\n\nç¬¬äºä¸ªéååå«g(x,n)å¯¹äºæ¯ä¸ªxånï¼ä½¿xå¨Fib(n)çnä¹åãå¨è¿éï¼ç­æçæ°å­¦ç¬¦å·æ´ç¬¨æï¼éè¦ä½¿ç¨å¦ä¸ä¸ªç»å®åé:\n\nDafnyä½¿ç»å®åéæ¾å¼çä¸è¬è¡¨ç¤ºæ³ä¹è¢«è®¸å¤ä½èä½¿ç¨(ä¾å¦ï¼[3ï¼ 4])ãå®ä¹ç±»ä¼¼äºå¶ä»è¯­è¨ä¸­ä½¿ç¨çåè¡¨çè§£è¡¨ç¤ºæ³ãä¾å¦ï¼Dafnyç³»å\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nå®åå«ä¸å¯¹èªç¶æ°ä¹åä¸º100ï¼åå«ä¸Pythonåè¡¨ç¸åçåç´ :\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nHaskellåå:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# ç®åçéåçè§£\n\næååè±äºå¾å¤æå­æ¥æè¿°Dafnyä¸­çä¸è¬éåçè§£ç¬¦å·ãç¶èï¼å¨å®è·µä¸­çè®¸å¤éåæ¨å¯¼ä¸­ï¼åªæä¸ä¸ªçº¦æåéï¼èæ¯è¯­è¡¨è¾¾å¼å°±æ¯é£ä¸ªçº¦æåéãä¾å¦ï¼æä»¬å·²ç»çå°ï¼æå°çâ100âèªç¶æ°çéåæ¯:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nå¯¹äºè¿ç§å¸¸è§çæåµï¼Dafnyåè®¸ä½ çç¥æ¯è¯­è¡¨è¾¾å¼ï¼åªéè¦å:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nè¿ä¸ªè¡¨è¾¾å¼çèµ·æ¥åæ®éçæ°å­¦ç¬¦å·ãäºå®ä¸ï¼å¯¹äºè¿äºç®åçéåæ¨å¯¼å¼ï¼å¾å®¹æâçè§£âæ°å­¦ç¬¦å·æ³è¦è¡¨è¾¾ççº¦æåéæ¯ä»ä¹ã\n\nä½ä¸ºDafnyä¸­éªè¯å¨çä¸ä¸ªæ³¨éï¼èªå¨åå¾åäºæ´å¥½å°å·¥ä½äºç®åçéåæ¨å¯¼å¼ï¼å¶ä¸­æ¯è¯­è¡¨è¾¾å¼å¯ä»¥è¢«çç¥ã\n\n\n# æ å°çè§£\n\nä¸ä¸ªmapæ¬è´¨ä¸æ¯ä¸ç»å¯¹ï¼å¶ä¸­å¯¹çå·¦åç´ æ¯å¯ä¸ç(ä¹å°±æ¯è¯´ï¼æ¯ä¸ªå·¦åç´ å¨åè½ä¸å³å®äºç¸åºçå³åç´ )ãä¸éåçæ¾ç¤ºè¡¨è¾¾å¼ä¸æ ·ï¼mapå¯ä»¥éè¿map displayæ¥å®ä¹ãä¾å¦,\n\nmap[2 := `c`, 137 := `a`]\n\n\n1\n\n\nå°æ´æ°2æ å°å°å­ç¬¦cï¼å°æ´æ°137æ å°å°å­ç¬¦aãæ¯ä¸å¯¹å2:= cå¯ä»¥è¢«ç§°ä¸ºä¸ä¸ªmapletãæ­¤å¤ï¼mapletçå·¦åç´ ç§°ä¸ºa keyï¼å³åç´ è·å¾ä¸å¯æè¿°çåç§°valueã\n\nä¸éåççè§£ä¸æ ·ï¼æ å°å¯ä»¥éè¿mapçè§£æ¥å®ä¹ãå®çå½¢å¼æ¯:\n\nmap x | R :: f(x) := g(x)\n\n\n1\n\n\nä¾å¦ï¼\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\næ¯ä»å100ä¸ªå®å¨å¹³æ¹æ°å°å®ä»¬åèªçå¹³æ¹æ ¹çæ å°ã\n\nå¦ææ¨å°æ å°çè§£çè§£ä¸ºä¸ç»å·æå¯ä¸é®çmapletsï¼é£ä¹æ¨åºæ¬ä¸å·²ç»çè§£äºç¬¦å·ãä¸è¿ï¼æå°æä¾ä¸äºæ³¨éå¹¶æåºæ å°ç¹æçä¸äºç¹æ§ã\n\néè¦æ³¨æçä¸ç¹æ¯ï¼mapletså¿é¡»å·æå¯ä¸çé®ãä¾å¦ï¼éªè¯èä¼æ±æ¨ï¼å¦æä½ è¯çåä¸ä¸ªåè¿æ ·çæ å°çè§£\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nå ä¸ºå®è¯´æ4æ å°å°2å-2ä¸ï¼è¿æ¯æ²¡ç¨çã\n\nä¸è¬çæ å°çè§£è¡¨è¾¾æ¯ç¸å½çµæ´»çãä¾å¦ï¼åè®¾mæ¯ä¸ä¸ªä»æ°å­å°å­ç¬¦çæ å°ï¼å¹¶åè®¾æä»¬æ³è¦åå»ºä¸ä¸ªæ°çæ å°nï¼ä»mä¸­çé®çå­éå°å¶ä»ä¸äºå­ç¬¦ãæ´åç¡®å°è¯´ï¼å½mä¸­çé®å¨å½æ°fçå¾åä¸­ï¼æ¯å¦ä¸ä¸ªé®f(x)å¯¹äºæä¸ªxï¼ç¶åæä»¬æ³è®©nå°è¿ä¸ªé®æ å°å°h(x)ãç¶åæä»¬å°nå®ä¹ä¸º\n\nmap x | f(x) in m.Keys :: f(x) := h(x)\n\n\n1\n\n\nç¶èï¼å¤§å¤æ°æ¶åï¼æä»¬å¾åäºåçæ å°çè§£å·æè¿ç§å½¢å¼\n\nmap x | R :: x := g(x)\n\n\n1\n\n\nå¯¹äºè¿äºå¸¸è§çæ å°ï¼Dafnyåè®¸æä»¬çç¥âx:=âï¼åªå\n\nmap x | R :: g(x)\n\n\n1\n\n\nå¨å®è·µä¸­ï¼å ä¹ææçæ å°çè§£é½å¯ä»¥ç¨è¿ç§ç®åçå½¢å¼æ¥åãä½æ¯å½ç®åå½¢å¼ä¸ååæ¶(å°±åä¸é¢çmaplets f(x):= h(x)çä¾å­ä¸æ ·)ï¼ä¸è¬å½¢å¼æ¯å¯ç¨çã\n\n\n# Lambda expressions\n\næåï¼è¦æ³¨ææ å°åå½æ°ä¹é´çåºå«ãæ¨å¯ä»¥å°mapçä½æ¯ä¸ä¸ªé¢åè®¡ç®å¥½çè¡¨ï¼èå½æ°åæ¯ä»ä¸ä¸ªç»å®çé®ä¸­è®¡ç®åºä¸ä¸ªå¼ãä¸ºäºè¿è¡æ¯è¾ï¼è®©æä»¬èèç¼åæ å°\n\nmap x | R :: g(x)\n\n\n1\n\n\nä½ä¸ºä¸ä¸ªå½æ°ã\n\néå¸¸ï¼å½æ°æ¯ç¨åç§°å£°æçãä¸é¢çæ å°æ¯æ²¿ççº¿åç\n\nfunction F(x: X): Y\n  requires R\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\nå½æ°ä¹å¯ä»¥æ¯å¿åçï¼å¨è¿ç§æåµä¸ï¼å®éå¸¸è¢«ç§°ä¸ºlambdaè¡¨è¾¾å¼ãç¶åç¼åç¤ºä¾æ å°\n\nx requires R => g(x)\n\n\n1\n\n\n\n# æ»ç»\n\nä»¥ä¸æ¯æ¬æä¸­è®¨è®ºçè¯­æ³å½¢å¼:\n\nforall x :: P\nforall x | R :: P\nforall x | R ensures P { S; }\nexists x :: P\nexists x | R :: P\nvar x :| P;\nif x :| P { S; }\nset x | R :: f(x)\nset x | R\nmap x | R :: f(x) := h(x)\nmap x | R :: g(x)\nfunction F(x: X): Y { g(x) }\nx requires R => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# è´è°¢\n\næå¾æè°¢Jay Lorchå¨è¿å¼ ä¾¿æ¡ä¸çè®¸å¤æå¸®å©çè¯è®ºã\n\n\n# åèæç®\n\n[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, Tests and Proofs â 8th International Conference, TAP 2014, volume 8570 of Lecture Notes in Computer Science, pages 20â35. Springer, July 2014. ð\n\n[1]FranÃ§ois Bobot, Jean-Christophe FilliÃ¢tre, Claude MarchÃ©, and Andrei Paskevich. Why3: Shepherd your herd of provers. In Boogie 2011: First International Workshop on Intermediate Verification Languages, pages 53â64, WrocÅaw, Poland, August 2011. https://hal.inria.fr/hal-00790310. ð\n\n[2]K. Mani Chandy and Jayadev Misra. Parallel Program Design: A Foundation. Addison-Wesley, 1988. ð\n\n[3]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. ð\n\n[4]David Gries and Fred B. Schneider. A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. Springer-Verlag, 1994. ð\n\n[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems, pages 175â188. Kluwer Academic Publishers, 1999. ð\n\n[6]K. Rustan M. Leino and ClÃ©ment Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361â381. Springer, 2016. ð\n\n----------------------------------------\n\n0.ç¨äºDafnyæççEmacs IDEæäºDafnyç»æçç¬¦å·ä½ æ´å¯è½å¨è®ºæä¸­çå°ãé»è®¤æåµä¸ï¼å®æ¾ç¤ºforall x:: P asåæ¾ç¤ºexists x:: P asã[â©](http://leino.science/papers/krml267.html # back-fn-fn-emacs)\n\n1.å¨åé¨ï¼Dafnyéªè¯å¨å¯ä»¥æ´ææå°ä½¿ç¨æäºéè¯ãéªè¯èè¯å¾æ£æµä¸ä¸ªç»å®éè¯çå¦ä¸ç§å½¢å¼ä½æ¶å¯è½æ§è¡å¾æ´å¥½ï¼å¹¶å°å¨è¿äºæåµä¸èªå¨éåéè¯[6]ãä¾å¦ï¼å®å¯ä»¥éæ©è§£é¤æäºéè¯çåµå¥ãè¿ç§éåçç®æ æ¯å¨è·å¾è¯å¥½çéªè¯æ§è½çåæ¶æ¯æèªç¶å¤è§çç¨åºã[â©](http://leino.science/papers/krml267.html # back-fn-fn-nested)\n\n2.äºå®è¯æï¼Dafnyçèªå¨å½çº³å°èªå¨è¯æFibPropertyåFibPropertyAllãå¦æè¿æ¯æä»¬å¯ä¸å³å¿çå¼çï¼é£å°±æ²¡æä»ä¹å¥½è¯´æåçäºãå°½ç®¡å¦æ­¤ï¼æè¿æ¯ç¨è¿ä¸ªä¾å­æ¥å±ç¤ºâforallâè¯­å¥ãå¦æä½ æ³è¦ç¡®ä¿æå°è¦è¯´çæ¯ä¸ä¸ªè¯æï¼ä½ å¯ä»¥éè¿ä½¿ç¨å±æ§{:induction false}æ¥å³é­FibPropertyAllçèªå¨æåºã[â©](http://leino.science/papers/krml267.html # back-fn-fn-fibpropertyall)\n\n3.Dafnyä¹å¯ä»¥è¯æç±»ä¼¼æ­è¨assert Fib(12) == 144;ãå¨åé¨ï¼Dafnyä½¿ç¨äºå½æ°çâåè½¨ç¼ç âï¼ä½¿å¶è½å¤è·å¾Fib(12)çå¼(å ä¸º12æ¯ä¸ä¸ªæå­å¸¸é)åFib(k)(å¶ä¸­kæ¯ä¸ä¸ªåé)ãå¦ææ¨å¯¹è¿æ¯å¦ä½å®ç°çæå´è¶£ï¼æå»ºè®®æ¨è®¿é®[0]ã[â©](http://leino.science/papers/krml267.html # back-fn-fn-dual-rail-encoding)\n\n4.è¿éæ¯æ­è¨k <= Fib(m) + Fib(m+1)çä¸ä¸ªè¯æãå¨æä»¬çè¯æä¸­ï¼âå°é¾çæåµâéç¨äºå½kè³å°ä¸º2æ¶ï¼æä»¥k-1è³å°ä¸º1ï¼æä»¥æä»¬ç¥éFib(m)è³å°ä¸º1ãç±æ­¤å¯ä»¥å¾åºç»è®ºï¼å¯¹äºFib(0) == 0ï¼ mä¸è½ä¸º0ãè¿å¾éè¦ï¼å ä¸ºè¿æå³çm+1è³å°ç­äº2ï¼å æ­¤éç¨äºFibå®ä¹çå½çº³æåµãæ¢å¥è¯è¯´ï¼æä»¬æFib(m+1) == Fib(m) + Fib(m-1)ãæä»¬å·²ç»å¾åºï¼Fib(m)è³å°ç­äº1ãä»¥Fibè¿ånatä¸ºä¾ï¼æä»¬ç¥éFib(m-1)è³å°ä¸º0ãæä»¥ï¼Fib(m+1)è³å°ç­äº1ãæ¢å¥è¯è¯´ï¼Fib(m) + Fib(m+1)è³å°æ¯Fib(m)å¤§äº1ï¼èFib(m)è³å°ç­äºk-1ãå æ­¤ï¼Fib(m) + Fib(m+1)è³å°ç­äºkã\n\nå¦ææä»¬æâç®åçæåµâåâå°é¾çæåµâåå¼ï¼ä½¿âç®åçæåµâåªåå«âk == 0âï¼é£ä¹æä»¬ä¸å¯è½å¨ä¸é¢çè®ºè¯ä¸­å¾åºâm != 0âçç»è®ºãå¶ä»äº¤äºå¼è¯æå©æçä¸äºç¨æ·å¯è½ä¼å¯¹æ­¤æå°å°æ°ï¼å ä¸ºä»ä»¬ä¼è¯´kå·ænatç±»åï¼å æ­¤å¯¹kçå½çº³åºè¯¥ä½¿ç¨k == 0ä½ä¸ºåºæ¬æåµãæ°å­¦å¯¹å½çº³æ³æ²¡æè¿æ ·çéå¶ï¼äºå®ä¸ï¼æ­£å¦è¿ä¸ªè¯æææ¾ç¤ºçï¼æä»¬å¯ä»¥ä»å°âEverBiggerâçæåµåæâk < 2âåâ2 <= kâä¸­è·çã[â©](http://leino.science/papers/krml267.html # back-fn-fn-proof)',normalizedContent:'# åç§æ¨å¯¼å¼\n\n> k. rustan m. leino manuscript krml 267, 27 may 2019\n\næè¦ dafnyæè®¸å¤ç±»ä¼¼æ¨å¯¼å¼çç»æãæ¬ææè¿°å¹¶æ¯è¾äºè¿äºç»æï¼å±ç¤ºäºå®ä»¬å¨è¯­æ³åè¯­ä¹ä¸çæ¯è¾ã\n\ndafnyæ¯ææ®ééååå­å¨éåï¼ä»¥åç¨äºâè¯æâæ®ééåè¡¨è¾¾å¼æâå©ç¨âå­å¨éåè¡¨è¾¾å¼çç»æã[0]è(http://leino.science/papers/krml267.html#sec-quantifiers)æè¿°äºdafnyä¸­çè¿äºé»è¾éè¯ãç¬¬[1]è(http://leino.science/papers/krml267.html#sec-proof-features)æ¾ç¤ºäºå¨æ¨çéè¯æ¶å¯ä»¥ä½¿ç¨çç¨åºè¯­å¥ï¼å¹¶æåºäºåç§è¯­æ³å½¢å¼çå·®å¼ã\n\néåæ¨å¯¼å¼åæ å°æ¨å¯¼å¼ç±»ä¼¼äºéè¯ï¼å ä¸ºå®ä»¬å¼å¥äºèå´è¶è¿ç¹å®å¼çç»å®åéã[2]è(http://leino.science/papers/krml267.html#sec-sets-and-maps)å±ç¤ºäºè¿äºçè§£çä¸è¬åå¸¸è§å½¢å¼ã\n\n\n# éè¯\n\n\n# åºæ¬çéè¯çè¯­æ³\n\nå¨æ°å­¦æç§ä¹¦åè®ºæä¸­ï¼æä»¬çæçå¨ç§°éè¯éç¨äºç±»ä¼¼çç¬¦å·ãå®è¯´è°è¯å¯¹ææçå¼é½æç«ãå¨ç¼ç¨è¯­è¨è¡è¯ä¸­ï¼æä»¬è¯´å®æ¯ä¸ä¸ªç»å®åéï¼å¶ä½ç¨åæ¯éè¯çä¸»ä½ãä¹å°±æ¯è¯´ï¼ä»»ä½èªç±åºç°çiné½è¢«ç»å®å°éè¯æå¼å¥çã\n\nå¨dafnyä¸­ï¼åä¸ä¸ªå¨ç§°éè¯è¢«åæforall x:: pãä»è§£æçè§åº¦æ¥çï¼éè¯çä¸»ä½âå°½å¯è½å°âæ©å±ãå æ­¤ï¼ç¨åºçæ®µ\n\nforall x :: r ==> q\n\n\n1\n\n\nè§£æä¸º\n\n(forall x :: (r ==> q))\n\n\n1\n\n\nèä¸æ¯\n\n(forall x :: r) ==> q\n\n\n1\n\n\nè¯·æ³¨æï¼âå°½å¯è½âä¸éäºè¡å°¾ãä¾å¦ï¼ä¸ä¸ªå¸¸è§çé·é±æ¯ç¼å(è¿éæ¾ç¤ºçæ¯ä¸ä¸ªåç½®æ¡ä»¶)\n\nrequires\n  forall x :: r ==> q &&\n  s\n\n\n1\n2\n3\n\n\næå¾æ¯forall x:: r ==> qåsæ¯ä¸¤ä¸ªç¬ç«çåææ¡ä»¶ãä¸æ­¤ç¸åçæ¯ï¼è¿éæåçå£°æçæä¹æ¯\n\nrequires (forall x :: (r ==> (q && s)))\n\n\n1\n\n\nå¦æä½ æç®åéè¯åsçè¿è¯ï¼é£ä¹æ­£ç¡®çè¯­æ³æ¯\n\nrequires\n  (forall x :: r ==> q) &&\n  s\n\n\n1\n2\n3\n\n\nå­å¨éè¯çä¸ä¸ªçæçæ°å­¦ç¬¦å·æ¯ãå®è¯´è°è¯å¯¹äºæä¸ªå¼æç«ãå¨dafnyä¸­ï¼è¯­æ³æ¯exists x:: p .0\n\n\n# ç»å®åéçç±»å\n\ndafnyä¸­çæ¯ä¸ªåéé½æä¸ä¸ªç±»åãéå¸¸ï¼ç»å®åéçç±»åæ¯æ¨æ­çï¼ä½dafnyä¹åè®¸æ¾å¼å£°æè¯¥ç±»åãä¾å¦,\n\nforall x: x :: p\n\n\n1\n\n\nå£°æxçç±»åä¸ºxãä¸ºäºç®æ´ï¼å¹¶å±ç¤ºç¼åéè¯åæ¨æ­çå¸åæ¹æ³ï¼æå°å¨æ¬æä¸­çç¥ç±»åï¼ä½è¯·è®°ä½ï¼å¦ææ¿æï¼æ¨å¯ä»¥éæ¶åå«å®ä»¬ã\n\nå½çº¦æåéä»æä¸ªéåä¸­æåæ¶ï¼éè¯çå¸¸ç¨æ°å­¦ç¬¦å·æ¯ãè¿ä¸ªè¡¨è¾¾å¼çdafnyå¼è¡¨ç¤ºä¸º\n\nforall x in s :: p  // error: syntax error\n\n\n1\n\n\nç¶èï¼è¿æ¯ä¸æ­£ç¡®çdafnyè¯­æ³ï¼å ä¸ºå®ä½¿ç¨äºä¸ä¸ªéåæåè°è¯ï¼å¶ä¸­åªææç»å®åé(å¯éçï¼å¸¦æç±»å)ãå¨dafnyä¸­è¿æ ·ä¸ä¸ªéè¯çæ­£ç¡®åæ³æ¯\n\nforall x :: x in s ==> p\n\n\n1\n\n\n\n# å¤ä¸ªç»å®åé\n\nä¸ä¸ªéå®ç¬¦å¯ä»¥æä¸ä¸ªä»¥ä¸çç»å®åéãä¾å¦,\n\nforall x, y :: p\n\n\n1\n\n\npå¯¹äºææçxåyé½æç«ãå®å¨é»è¾ä¸ç­åäºåµå¥çéè¯\n\nforall x :: forall y :: p\n\n\n1\n\n\nå°±æ­¤èè¨ï¼å®å¨é»è¾ä¸ä¹ç­ä»·äº\n\nforall y :: forall x :: p\n\n\n1\n\n\ndafnyçå¸¸è§åæ³æ¯ä½¿ç¨å¤ä¸ªåéçéè¯ï¼èä¸æ¯åµå¥çå½¢å¼ï¼å¦ææ²¡æå¶ä»åå ï¼åªæ¯ä¸ºäºæ´ç®æ´ã1\n\nå¦ææ¨ç¼åäºä¸ä¸ªç»å®åéåè¡¨å¹¶æ¾å¼å°ç»åºäºç±»åï¼è¯·æ³¨æï¼æ¯ä¸ªç»å®çç±»ååªéç¨äºå®ä¹åçåéãä¾å¦,\n\nforall x: x, y: y :: p\n\n\n1\n\n\nxçç±»åæ¯x, yçç±»åæ¯yãå¦æåªåå«yç±»åï¼å¦\n\nforall x, y: y :: p\n\n\n1\n\n\né£ä¹ä½ è¯´yçç±»åæ¯yèxçç±»åæ¯å¯ä»¥æ¨æ­çãæ¢å¥è¯è¯´ï¼ä½ å¯ä»¥è®¤ä¸ºè¿ä¸ªâ:âæ¯âï¼âå·ææ´å¼ºççº¦æåã\n\n\n# éè¯ä¸»ä½çå¸åå½¢å¼\n\nå¨ç§°éè¯çä¸»ä½éå¸¸æ¯ä¸ç§å«ä¹ï¼å¦in\n\nforall x :: r ==> p\n\n\n1\n\n\nä½ å¯ä»¥ä»ä»¥ä¸å ä¸ªæ¹é¢æ¥è§£è¯»:\n\n> "å¯¹äºææçxï¼æå³çr ==> pæç«"\n> \n> "å¯¹äºææçxï¼ ræå³çp "\n> \n> "å¯¹äºææçxï¼å¦æræç«ï¼é£ä¹pä¹æç«"\n\nç¶èï¼è¿ä¸ªå«ä¹çåè¡è¯(r)éå¸¸èµ·å°éå¶(ä¸ä»ä»æ¯xçç±»å)æèèçxçå¼çä½ç¨ãæ¢å¥è¯è¯´ï¼ârâåè¯ä½ âxâçèå´ãå¨è¿ç§æåµä¸ï¼ä½ å¯ä»¥ä»ä¸é¢çä¸ç§æ¹å¼æ¥è§£è¯»ä¸é¢çéè¯:\n\n> "å¯¹äºæææ»¡è¶³rçxï¼ pæç«\n> \n> "å¯¹äºææçxï¼ä½¿ræç«ï¼p "\n> \n> "å¯¹äºææçx(å¶ä¸­xæ»¡è¶³r)ï¼ pä¿æ"\n> \n> âå¯¹äºææçx[ä¸ºræå¥ä½ èªå·±çæè¿°æ§é¶æ®µ]ï¼pâ\n\nä½ä¸ºæåä¸ä¸ªç­è¯­çå·ä½å®ä¾ï¼ä½ å¯ä»¥è¯»å°forall x:: x in s ==> x % 2 == 0 as\n\n> "å¯¹äºsä¸­çææxï¼ xæ¯å¶æ°"\n\nä½ å¯ä»¥è¯»å°forall i:: 0 <= i < a. length ==> a[i] == 5 as\n\n> "å¯¹äºæ°ç»açæ¯ä¸ªä¸æ iï¼ a -sub- iæ¯5 "\n\nåæåæè¯´çå¨ç§°éè¯ç±»ä¼¼ï¼å­å¨éè¯çå¸åå½¢å¼æ¯è¿è¯ï¼æ¯å¦\n\nexists x :: r && p\n\n\n1\n\n\nä¾å¦ï¼\n\nexists x :: x in s && x % 2 == 0\n\nexists i :: 0 <= i < a.length && a[i] == 5\n\n\n1\n2\n3\n\n\nåærçææ¯åè¯ä½ xçèå´ï¼ä½ å¯ä»¥æè¿äºå­å¨éè¯çæ\n\n> "å¨sä¸­æä¸ä¸ªxï¼å¶ä¸­x % 2 == 0éç¨"\n> \n> "å¨aä¸­æä¸ä¸ªç´¢å¼iï¼ä½¿a -sub- iç­äº5 "\n\nå¨why3 [1]ä¹åï¼å¦æä½ å°r ==> pä½ä¸ºå­å¨éè¯çä¸»ä½ï¼dafnyä¼ååºè­¦åï¼å ä¸ºè¿å ä¹æ»æ¯ä¸ä¸ªç¨æ·éè¯¯(ä¸ä¸ªæå­éè¯¯æä¸ä¸ªæè-o)ãå¦æè¿ççæ¯ä½ æ³è¦åçï¼ä½ å¯ä»¥éè¿ç¼åä»¥ä¸ä»»ä½è¡¨è¾¾å¼æ¥æå¶è­¦å:\n\nexists x :: (r ==> p)\nexists x :: !r || p\nexists x :: p <== r\n\n\n1\n2\n3\n\n\n\n# èå´è°è¯\n\nä¸ºä»ä¹æè¦è±ä¸é¡µæ¥åè¯ä½ éè¯çåé³?å ä¸ºè¿ä¸ªè®¨è®ºå¼ºè°äºä¸ä¸ªäºå®ï¼æ¡ä»¶rï¼å¨ä»»ä½ä¸ä¸ª\n\nforall x :: r ==> p\nexists x :: r && p\n\n\n1\n2\n\n\næ®æ¼çç¹æ®çè§è²ï¼å°½ç®¡ârâå®éä¸åªæ¯è¿äºéè¯ä¸»ä½çä¸é¨åãäºå®ä¸ï¼å¶ä»äººå·²ç»ä¸ºéè¯éç¨äºä¸ç§è¡¨ç¤ºæ³ï¼è¯¥è¡¨ç¤ºæ³ä¸ºè¿ä¸ªèå´è°è¯ rè®¾ç½®äºä¸ä¸ªç¹æ®çä½ç½®ãä¸é¢æ¯ä¸äºä¾å­:\n\n                                                \nuniversal quantifier   existential quantifier   source\n                                                \n                                                dijkstra [3]\n                                                chandy and misra [2]\n                                                gries and schneider [4]\n\\forall x x; r; p      \\exists x x; r; p        jml [5]\n                                                \n\n(å¨ä¸é¢çjmlä¸­ï¼xè¡¨ç¤ºxçç±»åã)å¨ä½¿ç¨è¿äºç¬¦å·çæç§ä¹¦ä¸­ï¼ç»å¸¸æäººè¯´:âä¸ºäºç®æ´ï¼å¦æârâæ¯âæ­£ç¡®âçï¼æèæ¯æ ¹æ®ä¸ä¸æçè§£çï¼é£ä¹å®(å¯¹äºä¸é¢çä¸äºä½èæ¥è¯´ï¼ä¸äºç¸é»çæ ç¹ç¬¦å·)å°±è¢«çç¥äºãâè¿äºç¼©åå½¢å¼æ¯:\n\n                                                  \nrange listed separately   range true or omitted   source\n                                                  \n                                                  dijkstra [3]\n                                                  chandy and misra [2]\n                                                  gries and schneider [4]\n\\forall x x; r; p         \\forall x x;; p         jml [5]\n                                                  \n\nè¿ææ´å¤çãéè¿ä½¿ç¨ä¸äºåºåârâåâpâçç¬¦å·ï¼éè¯çå¾·æ©æ ¹å®å¾çèµ·æ¥ç¹å«å¥½:\n\nåå°dafnyãå¦ææ¨åæ¬¢å°ç»å®åéçèå´ä»éè¯ä¸»ä½çå¶ä½é¨ååéå¼çç¬¦å·ï¼é£ä¹æ¨å°å¾é«å´å°äºè§£å°ï¼æ¨ä¹å¯ä»¥å¨dafnyä¸­è¿æ ·åãè¯­æ³æ¯:\n\nforall x | r :: p\nexists x | r :: p\n\n\n1\n2\n\n\n\n# ç¨äºéè¯æ¨ççç¨åºè¯­å¥\n\ndafnyåå«äºä¸äºå¨æ¨çæ¶åéè¯çç¨åºæå®çæ¶éå¸¸æç¨çè¯æç¹æ§ãå®ä»¬çè¯­æ³ä¸éè¯ç¸ä¼¼ï¼ä½ä¹æåºå«ã\n\n\n# èåè¯­å¥\n\ndafnyä¸­çforallè¯­å¥æ¯ä¸ä¸ªèåè¯­å¥:å®å·ææ§è¡å¤ä¸ªåæ¶æä½çææãå½è¿å¥è¯ç¨äºè¯ææ¶ï¼å¶å½¢å¼å¦ä¸:\n\nforall x | r\n  ensures p\n{\n  s;\n}\n\n\n1\n2\n3\n4\n5\n\n\nå®ç¨äºå»ºç«å±æ§forall x | r:: pï¼å³forall x:: r == >pãå®æ¯éè¿æ£éªå½é¢sä¸ºä»»ä½æ»¡è¶³rçxå»ºç«pæ¥å®ç°çãå¨é»è¾ä¸­ï¼è¿ä¸ªå½é¢çç»æè¢«ç§°ä¸ºâæ®éå¼å¥âã\n\nä¸¾ä¸ªç®åçä¾å­ï¼åè®¾ä½ æä¸ä¸ªå¼çå¯ä»¥è¯æn <= fib(n)å¯¹äºä»»ä½nè³å°æ¯5ï¼å¶ä¸­fibæ¯éå¸¸çfibonacciå½æ°:\n\nfunction fib(n: nat): nat {\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\nlemma fibproperty(n: nat)\n  requires 5 <= n\n  ensures n <= fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nè¿ä¸ªå¼çç»åºäºä¸ä¸ªç»å®nçå±æ§n <= fib(n)ãä½åè®¾ä½ æ³è®©è¿ä¸ªæ§è´¨ä»¥æ®ééå­åçå½¢å¼å­å¨ãä¹å°±æ¯è¯´ï¼ä½ è¦è¯æä¸é¢çå¼ç:\n\nlemma fibpropertyall()\n  ensures forall n :: 5 <= n ==> n <= fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬æä¹åè¿ä¸ªè¯æå¢?2\n\nç­æ¡æ¯å¯¹æ¯ä¸ªnè°ç¨fibpropertyä¸æ¬¡ãä¸æ¬¡ãå¯¹äºânâææ æ°ä¸ªä¸åçå¼ãè¿å°±æ¯ä½ å¯¹èåè¯­å¥forallæåç:\n\nforall n | 5 <= n\n  ensures n <= fib(n)\n{\n  fibproperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nä¸è¬æ¥è¯´ï¼forallè¯­å¥çä¸»ä½è¦æ¯åä¸ªå¼çè°ç¨å¤æå¾å¤ãä½æ¯å½ä¸»ä½æ¯åªæ¯ä¸ä¸ªå¼çè°ç¨æåªæ¯ä¸ä¸ªcalcè¯­å¥æ¶ï¼dafnyä¼èªå¨æ¨æ­ensureå­å¥ï¼æä»¥ä½ å¯ä»¥çç¥å®:\n\nforall n | 5 <= n {\n  fibproperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# å­å¨å¼å¥ä¸æé¤\n\nä½¿ç¨å­å¨éåè¿ä½¿ç¨äºä¸ç³»åçè¯æç¹å¾ãæå°éè¿åä¸ä¸ªè¯ææ¥è¯æææ³¢é£å¥æ°å¯ä»¥æ¯ä»»æå¤§ç:\n\nlemma everbigger(k: nat)\n  ensures exists n :: k <= fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nè®©æä»¬ä»ä¸äºç®åçä¾å­å¼å§è¯æï¼æ¯å¦å½kå¾å°çæ¶åï¼æ¯å¦0æ1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\ndafnyä¸è½èªå¨è¯æè¿ä¸¤ç§æåµï¼æä»¥æä»¬éè¦èªå·±ç»åºæ´å¤çè¯æã\n\nä¸ºäºè¯æè¿ä¸ªå¼çå¨ç®åçæåµä¸ï¼å®è¶³ä»¥åéªè¯èè¯æå­å¨éè¯ææçä¸ä¸ªç¹å®çnãä¹å°±æ¯è¯´ï¼æä»¬æ³ç»å­å¨éè¯ä¸ä¸ªè§è¯ãä¸ä¸ªè¿æ ·çè§è¯æ¯1ï¼å ä¸ºk <= 1 == fib(1)ãå¦ä¸ä¸ªè¿æ ·çè§è¯æ¯12ï¼å ä¸ºk <= 144 == fib(12)ãå¦ä¸ä¸ªè¿æ ·çè§è¯æ¯kï¼å ä¸ºå¨æä»¬çç®åä¾å­ä¸­k <= k == fib(k)ãè®©æä»¬ç»§ç»­è¿ä¸ªï¼æä»¥æä»¬å¨å¼çä¸»ä½çâifâè¯­å¥çâthenâåæ¯ä¸­æ·»å ä¸ä¸ªæ­è¨:\n\nassert k <= fib(k);\n\n\n1\n\n\ndafnyå°è¯æè¿ä¸ªæ­è¨3ï¼ç¶åä¼æ³¨æå°kæ¯ä¸ä¸ªè¯æåç½®æ¡ä»¶çå­å¨è§è¯ãå¨é»è¾ä¸­ï¼è¿è¢«ç§°ä¸ºâå­å¨è®ºå¯¼è¨âãè¿æå³çï¼å¦æä½ æä¸ä¸ªæ»¡è¶³ç¹å®å±æ§çå¼ï¼é£ä¹è¿ä¸ªå¼å°±å­å¨ãæ¢å¥è¯è¯´ï¼å¦æä½ æä¸ä¸ªâå¨ä½ æä¸­âçä»·å¼ï¼é£ä¹è¿ä¸ªä»·å¼å°±å­å¨äºââè¿ä¼¼ä¹æ¯å¦æ­¤ææ¾ï¼ä»¥è³äºæä»¬è°èµ·å®æ¶å ä¹ä¼æå°å°´å°¬(ä½ çé»å±å¬å°ä½ ä»¥è¿ä¸ªä¸ºçè¯å®ä¼è®¤ä¸ºä½ ç¯äº)ã\n\né£ä¹è¿ä¸ªæ£æçæ¡ä¾å¢?æä»¬å¯ä»¥éè¿å½çº³æ³æ¥è¯æï¼é¦åå¾å°ä¸ä¸ªnï¼å®çææ³¢é£å¥å¼è³å°ä¸ºk-1ï¼ç¶ååä»ä¸­æå»ºä¸ä¸ªæ´å¤§çææ³¢é£å¥å¼ãé¦åï¼æä»¬å¨âk-1âä¸éå½å°è°ç¨å¼ç:\n\neverbigger(k-1);\n\n\n1\n\n\nè¿è®©æä»¬è·å¾äºeverbigger(k-1)çåç½®æ¡ä»¶ãä¸ºäºå¨æä»¬çè¯æä¸­æç¡®å°åä¸è¿ä¸ç¹ââä¸ºäºæ£æ¥éªè¯èæ¯å¦å¾åºäºæä»¬ææä»å¼çè°ç¨ä¸­å¾å°çç»è®ºï¼å¹¶æéæä»¬èªå·±ä»ä¹å±æ§ââæä»¬å¯ä»¥åä¸ä¸ªæ­è¨:\n\nassert exists n` :: k-1 <= fib(n`);\n\n\n1\n\n\nå¥½å°ç®åä¸ºæ­¢ãæ¥ä¸æ¥ï¼æä»¬æ³æé ä¸ä¸ªè³å°æ¯fib(n)å¤§1çææ³¢é£å¥æ°ï¼å ä¸ºè¿æ ·å¯ä»¥å®æè¯æãä½æ¯æåææå°çnæ¯ä»ä¹?ä¸é¢çæææ­è¨é½åè¯æä»¬å­å¨è¿æ ·çânâãæä»¬å¸ææè¿æ ·ä¸ä¸ªânâå¨æä»¬æä¸­ï¼è¿æ ·æä»¬å°±å¯ä»¥ä½¿ç¨å®ã\n\nä»æä»¬ç¥éå­å¨çä¸è¥¿å°âå¨æä»¬æä¸­âçä¸è¥¿è¢«ç§°ä¸ºâskolemizationâæâexisteneliminationâãä½ å¨dafnyä¸­éè¿assign-such-thatè¯­å¥å®ç°:\n\nvar m: nat :| k-1 <= fib(m);\n\n\n1\n\n\nè¿ä¸ªè¯­å¥å¼å¥äºä¸ä¸ªå±é¨åémï¼å¹¶ç»å®ä¸ä¸ªä»»æå¼ï¼æ»¡è¶³k-1 <= fib(m)ãå½ç¶ï¼å¦æä¸å­å¨è¿æ ·çå¼ï¼è¿æ¯ä¸å¯è½çï¼æä»¥èµå¼-such-thatè¯­å¥å¼èµ·äºä¸ä¸ªè¯æä¹å¡ï¼è¯æè¿æ ·çmå­å¨ãè¿ä¸ªè¯æä¹å¡æ¥èªäºæä»¬ä¸é¢æ­è¨çå±æ§ã\n\nå·®ä¸å¤äºãä¸ºäºå»ºç«å¼ççåç½®æ¡ä»¶ï¼æä»¬å©ä¸çè®¡åå°±æ¯æé ä¸ä¸ªä¸¥æ ¼å¤§äºfib(m)çææ³¢é£å¥æ°ãæä»¬è§å¯å°fib(m) + fib(m+1)ä¸¥æ ¼å¤§äºfib(m)ï¼å æ­¤æä»¬æfib(m+2)ä¸¥æ ¼å¤§äºfib(m)ã\n\nå¥½å§ï¼æä»¬ç´è¯´äºå§ãä¹è®¸æä»¬å¹¶æ²¡æâè§å¯âå°è¿ä¸ç¹ï¼èæ¯âå¸æâãâçæ³âæâæ¾æ£å°è®¤ä¸ºâå®å¯è½æç«ãå¥½å§ï¼ç¡®å®å¦æ­¤ã(å·!)æä»¬å¯ä»¥éè¿è¯¢é®éªè¯èå®æ¯å¦è½ä¸ºæä»¬è¯ææ¥éªè¯:\n\nassert k <= fib(m) + fib(m + 1) == fib(m + 2);\n\n\n1\n\n\néªè¯èç«å³è¯æäºè¿ä¸ªæ­è¨ã4æ­¤å¤ï¼éè¿åä¸è¿ä¸ªæ­è¨ï¼æä»¬ä¹åéªè¯èå±ç¤ºäºè§è¯m+2ï¼å®è¯æäºå¼ççåç½®æ¡ä»¶ä¸­çå­å¨éè¯ã\n\næç¨è¿ä¸ªä¾å­æ¥è¯´æçéç¹æ¯ï¼ä½ å¯ä»¥ç¨skolemizeä¸ä¸ªéè¯\n\nexists x :: p\n\n\n1\n\n\néè¿assign-such-thatè¯­å¥\n\nvar x :| p;\n\n\n1\n\n\næ³¨ææ ç¹ç¬¦å·çåºå«ã\n\n\n# å¸¦å¤åæ°çå¼ç\n\næååç»ä½ ä»¬çäºä¸ä¸ªæ¶åå­å¨éè¯çä¾å­ãè¿ä¸ªä¾å­è¡¨æï¼âeverbiggerâå¼ççâè¯æâä¸¤æ¬¡ä½¿ç¨äºå­å¨æ§ä»ç»(å¨ç®åæåµä¸ä¸ºfib(k)ï¼å¨å°é¾æåµä¸ä¸ºfib(m+2))ï¼ä»èå°âæä»¬æä¸­âçkåm+2è½¬æ¢ä¸ºå­å¨æ§éåãè¿ä¸ªä¾å­è¿å±ç¤ºäº(éå½è°ç¨)å¼ççè°ç¨ä½¿ç¨å­å¨æ¶é¤æ¥å°å¼ççåç½®æ¡ä»¶ä¸­çå­å¨éåè½¬æ¢ä¸ºâæä»¬æä¸­çâä¸ä¸ªmãè®©äººå°è±¡æ·±å»çæ¯ï¼dafnyæè¿æ ·çç¹æ§ï¼å®è¿æä¸ä¸ªæ´æç¨çç¹æ§ï¼å¯ä»¥è®©ä½ å¨ä¸å¼å§å°±é¿åè¿äºå­å¨-éè¯è½¬æ¢:å¼ç-åæ°ã\n\nå¨æ°å­¦ä¸­ï¼å¼çæ¯ç±å®ä»¬ææå°çåéåæ°åçãè¿äºé½æ¯åæ°ãä¸ä¸ªæ°å­¦å¼çå¾å°ææ°¸è¿ä¸ä¼è¢«è®¤ä¸ºå·æå¤åæ°ãå¨dafnyä¸­ï¼å¼çå®éä¸å°±æ¯ä¸ä¸ªå¹½çµæ¹æ³ï¼ä¸ä¸ªæ¹æ³å¯ä»¥åæ¶å·æè¾å¥åæ°åè¾åºåæ°ãè¿æ¯éå¸¸æç¨çãä¸å¶ç¨å¼çæ¥è¯ææä¸ªå¼çâå­å¨âï¼è¿ä¸å¦ç´æ¥âè¿åâæä¸ªè¿æ ·çå¼ã\n\nä¸é¢æ¯ä¸é¢çâeverbiggerâå¼çï¼ä½å°nå£°æä¸ºoutå½¢å:\n\nlemma everbigger(k: nat) returns (n: nat)\n  ensures k <= fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := everbigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# ç»å®è­¦å«\n\ndafnyè¿åå«äºå¦ä¸ä¸ªç¹æ§ï¼ä½¿éè¯çä½¿ç¨æ´å æµç:å¸¦æ*binding guard *çifè¯­å¥ãè¿æ ·çè¯­å¥åç­äºâå¦ææä¸ä¸ªï¼ç»æä¸ä¸ªå¨ææéâçå½ä»¤ã\n\nåè®¾æä»¬åä¸ä¸ªè¯æï¼æ ¹æ®yæ¯å¦ä¸ºææ³¢é£å¥æ°åæä¸¤ç§æåµãç¶åæä»¬å¯ä»¥è¿æ ·å:\n\nif exists n :: y == fib(n) {\n  var n :| y == fib(n);\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nè¿è¡¨è¾¾äºæä»¬æ³è¦çï¼ä½æè§æç¹ç¬¨æï¼å ä¸ºæä»¬éå¤äºæ¡ä»¶y == fib(n)ãæä»¬å¯ä»¥å°è¿ä¸ªâifâè¯­å¥åæ\n\nif n :| y == fib(n) {\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\n:|ä¸èµå¼such-thatè¯­å¥ä¸­çæ ç¹ç¸åï¼èä¸æ¯å­å¨éè¯ä¸­ç±»ä¼¼ä½ç½®ç::ã\n\n\n# éååæ å°\n\né»è¾éè¯åå¶ä»ç»æå¼å¥äºä¸äºç»å®åéï¼å¹¶ä»¥æç§æ¹å¼éå¶äºè¿äºç»å®åéçåå¼èå´ãéåçè§£åæ å°çè§£ä¹æ¯å¦æ­¤ã\n\n\n# éåçè§£\n\nå¾å®¹æå¨dafnyåä¸ä¸ç»ãä¾å¦,\n\n{ 2, 3, 5 }\n\n\n1\n\n\næ¯ä¸ä¸ªæå°ç´ æ°çéåãè¿æ ·çè¡¨è¾¾å¼ï¼å¶ä¸­éåçåç´ è¢«æ¾å¼ååºï¼ç§°ä¸ºset displayãä½æ¯ï¼å¦ææ¨æ³è¦å®ä¹çéåä¸è½åæéåæ¾ç¤ºï¼è¯¥æä¹å?\n\néåçè§£ä»¥å¾è§£çæ¹å¼å®ä¹äºä¸ç»åç´ ãå¨æ®éæ°å­¦ç¬¦å·ä¸­éåçè§£çä¸ä¸ªä¾å­æ¯\n\nå®ä¹äºæå°ç100ä¸ªèªç¶æ°çéåãå¦ä¸ä¸ªä¾å­æ¯\n\nå®å®ä¹äº100ä¸ªæå°çå®å¨å¹³æ¹æ°ãè¿ä¸¤ä¸ªæ¨å¯¼å¼ä¸­çç»å®åéé½æ¯ï¼æå®rangeçå¼ç±è°è¯å®ä¹ãè®©èå´è¶è¿è¿äºå¼ï¼ç¬¬ä¸ä¸ªéåç¶ååå«è¡¨åçåç´ ï¼èç¬¬äºä¸ªéååå«è¡¨åçåç´ ãä¹å°±æ¯è¯´ï¼å¨ç¬¬ä¸ä¸ªéåä¸­ï¼åç´ æ¯èªèº«çåæ³å¼ï¼èå¨ç¬¬äºä¸ªéåä¸­ï¼åç´ æ¯æ¯ä¸ªåæ³å¼çå¹³æ¹ã\n\næ´ä¸è¬å°è¯´ï¼æ°å­¦ç¬¦å·çå½¢ç¶æ¯è¿æ ·çãè¯»èåºè¯¥çè§£è¿æ¯ç»å®åéãçè§£ä¸ºç»å®åéï¼æä»¬å¯ä»¥éè¿ç²¾ç¡®æè¿°éåä½æ¶åå«ä¸ä¸ªåç´ æ¥å®ä¹éåæ¨å¯¼å¼:\n\næèï¼ä½¿ç¨å­å¨å½æ°çåå¼èå´åç¬ç»åºçç¬¦å·:\n\nå¨dafnyä¸­ï¼åæ ·çéåçè§£æå¦ä¸å½¢å¼:\n\nset x | r :: f(x)\n\n\n1\n\n\nxæ¯ç»å®åé(æèï¼æ´æ®éå°è¯´ï¼ä¸ä¸ªç»å®åéçåè¡¨)ï¼ræ¯ç»å®åéçèå´è°è¯ï¼èf(x)æ¯éåæ¨å¯¼çé¡¹è¡¨è¾¾å¼ãç»å®åéè¢«æ¾å¼ååºï¼ä¸åæ®éçæ°å­¦ç¬¦å·ï¼è¯»èå¿é¡»æ¨æ­ç»å®åéæ¯ä»ä¹ãä¸é¢ç»åºçä¸¤ä¸ªç¤ºä¾éå¨dafnyä¸­åå¦ä¸:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nè½ç¶ä¹ä¸çä¸å¤ªç®æ´ï¼ä½æ¾å¼ååºç»å®åéçè¡¨ç¤ºæ³æä¸äºç»å¾®ä¹å¤ã\n\nä¸ä¸ªç»å¾®ä¹å¤æ¯ï¼å°±åä¸é¢ä¸æ ·ï¼éè¯çå®ä¹æ¾ç¤ºäºç¬¦å·çç¸ä¼¼æ§:\n\ny in (set x | r :: f(x))   <==>   exists x | r :: y == f(x)\n\n\n1\n\n\nå¦ä¸ä¸ªä¼ç¹æ¯å¯ä»¥å¾å®¹æå°ååºéå çç»å®åéãåè®¾ræ¯xåzçè°è¯ï¼é£ä¹è¿éæä¸¤ä¸ªä¾å­:\n\nset x,n | fib(n) <= x < fib(n) + n :: f(x)\nset x,n | fib(n) <= x < fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nç¬¬ä¸ä¸ªéååå«f(x)å¯¹äºæ¯ä¸ªå¨nèå´åçxå¯¹äºæäºnçfib(n)ãç¨æ®éçæ°å­¦ç¬¦å·æ¥è¡¨ç¤ºå®çä¸ç§ç­ä»·çæ¹å¼æ¯:\n\nç¬¬äºä¸ªéååå«g(x,n)å¯¹äºæ¯ä¸ªxånï¼ä½¿xå¨fib(n)çnä¹åãå¨è¿éï¼ç­æçæ°å­¦ç¬¦å·æ´ç¬¨æï¼éè¦ä½¿ç¨å¦ä¸ä¸ªç»å®åé:\n\ndafnyä½¿ç»å®åéæ¾å¼çä¸è¬è¡¨ç¤ºæ³ä¹è¢«è®¸å¤ä½èä½¿ç¨(ä¾å¦ï¼[3ï¼ 4])ãå®ä¹ç±»ä¼¼äºå¶ä»è¯­è¨ä¸­ä½¿ç¨çåè¡¨çè§£è¡¨ç¤ºæ³ãä¾å¦ï¼dafnyç³»å\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nå®åå«ä¸å¯¹èªç¶æ°ä¹åä¸º100ï¼åå«ä¸pythonåè¡¨ç¸åçåç´ :\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nhaskellåå:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# ç®åçéåçè§£\n\næååè±äºå¾å¤æå­æ¥æè¿°dafnyä¸­çä¸è¬éåçè§£ç¬¦å·ãç¶èï¼å¨å®è·µä¸­çè®¸å¤éåæ¨å¯¼ä¸­ï¼åªæä¸ä¸ªçº¦æåéï¼èæ¯è¯­è¡¨è¾¾å¼å°±æ¯é£ä¸ªçº¦æåéãä¾å¦ï¼æä»¬å·²ç»çå°ï¼æå°çâ100âèªç¶æ°çéåæ¯:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nå¯¹äºè¿ç§å¸¸è§çæåµï¼dafnyåè®¸ä½ çç¥æ¯è¯­è¡¨è¾¾å¼ï¼åªéè¦å:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nè¿ä¸ªè¡¨è¾¾å¼çèµ·æ¥åæ®éçæ°å­¦ç¬¦å·ãäºå®ä¸ï¼å¯¹äºè¿äºç®åçéåæ¨å¯¼å¼ï¼å¾å®¹æâçè§£âæ°å­¦ç¬¦å·æ³è¦è¡¨è¾¾ççº¦æåéæ¯ä»ä¹ã\n\nä½ä¸ºdafnyä¸­éªè¯å¨çä¸ä¸ªæ³¨éï¼èªå¨åå¾åäºæ´å¥½å°å·¥ä½äºç®åçéåæ¨å¯¼å¼ï¼å¶ä¸­æ¯è¯­è¡¨è¾¾å¼å¯ä»¥è¢«çç¥ã\n\n\n# æ å°çè§£\n\nä¸ä¸ªmapæ¬è´¨ä¸æ¯ä¸ç»å¯¹ï¼å¶ä¸­å¯¹çå·¦åç´ æ¯å¯ä¸ç(ä¹å°±æ¯è¯´ï¼æ¯ä¸ªå·¦åç´ å¨åè½ä¸å³å®äºç¸åºçå³åç´ )ãä¸éåçæ¾ç¤ºè¡¨è¾¾å¼ä¸æ ·ï¼mapå¯ä»¥éè¿map displayæ¥å®ä¹ãä¾å¦,\n\nmap[2 := `c`, 137 := `a`]\n\n\n1\n\n\nå°æ´æ°2æ å°å°å­ç¬¦cï¼å°æ´æ°137æ å°å°å­ç¬¦aãæ¯ä¸å¯¹å2:= cå¯ä»¥è¢«ç§°ä¸ºä¸ä¸ªmapletãæ­¤å¤ï¼mapletçå·¦åç´ ç§°ä¸ºa keyï¼å³åç´ è·å¾ä¸å¯æè¿°çåç§°valueã\n\nä¸éåççè§£ä¸æ ·ï¼æ å°å¯ä»¥éè¿mapçè§£æ¥å®ä¹ãå®çå½¢å¼æ¯:\n\nmap x | r :: f(x) := g(x)\n\n\n1\n\n\nä¾å¦ï¼\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\næ¯ä»å100ä¸ªå®å¨å¹³æ¹æ°å°å®ä»¬åèªçå¹³æ¹æ ¹çæ å°ã\n\nå¦ææ¨å°æ å°çè§£çè§£ä¸ºä¸ç»å·æå¯ä¸é®çmapletsï¼é£ä¹æ¨åºæ¬ä¸å·²ç»çè§£äºç¬¦å·ãä¸è¿ï¼æå°æä¾ä¸äºæ³¨éå¹¶æåºæ å°ç¹æçä¸äºç¹æ§ã\n\néè¦æ³¨æçä¸ç¹æ¯ï¼mapletså¿é¡»å·æå¯ä¸çé®ãä¾å¦ï¼éªè¯èä¼æ±æ¨ï¼å¦æä½ è¯çåä¸ä¸ªåè¿æ ·çæ å°çè§£\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nå ä¸ºå®è¯´æ4æ å°å°2å-2ä¸ï¼è¿æ¯æ²¡ç¨çã\n\nä¸è¬çæ å°çè§£è¡¨è¾¾æ¯ç¸å½çµæ´»çãä¾å¦ï¼åè®¾mæ¯ä¸ä¸ªä»æ°å­å°å­ç¬¦çæ å°ï¼å¹¶åè®¾æä»¬æ³è¦åå»ºä¸ä¸ªæ°çæ å°nï¼ä»mä¸­çé®çå­éå°å¶ä»ä¸äºå­ç¬¦ãæ´åç¡®å°è¯´ï¼å½mä¸­çé®å¨å½æ°fçå¾åä¸­ï¼æ¯å¦ä¸ä¸ªé®f(x)å¯¹äºæä¸ªxï¼ç¶åæä»¬æ³è®©nå°è¿ä¸ªé®æ å°å°h(x)ãç¶åæä»¬å°nå®ä¹ä¸º\n\nmap x | f(x) in m.keys :: f(x) := h(x)\n\n\n1\n\n\nç¶èï¼å¤§å¤æ°æ¶åï¼æä»¬å¾åäºåçæ å°çè§£å·æè¿ç§å½¢å¼\n\nmap x | r :: x := g(x)\n\n\n1\n\n\nå¯¹äºè¿äºå¸¸è§çæ å°ï¼dafnyåè®¸æä»¬çç¥âx:=âï¼åªå\n\nmap x | r :: g(x)\n\n\n1\n\n\nå¨å®è·µä¸­ï¼å ä¹ææçæ å°çè§£é½å¯ä»¥ç¨è¿ç§ç®åçå½¢å¼æ¥åãä½æ¯å½ç®åå½¢å¼ä¸ååæ¶(å°±åä¸é¢çmaplets f(x):= h(x)çä¾å­ä¸æ ·)ï¼ä¸è¬å½¢å¼æ¯å¯ç¨çã\n\n\n# lambda expressions\n\næåï¼è¦æ³¨ææ å°åå½æ°ä¹é´çåºå«ãæ¨å¯ä»¥å°mapçä½æ¯ä¸ä¸ªé¢åè®¡ç®å¥½çè¡¨ï¼èå½æ°åæ¯ä»ä¸ä¸ªç»å®çé®ä¸­è®¡ç®åºä¸ä¸ªå¼ãä¸ºäºè¿è¡æ¯è¾ï¼è®©æä»¬èèç¼åæ å°\n\nmap x | r :: g(x)\n\n\n1\n\n\nä½ä¸ºä¸ä¸ªå½æ°ã\n\néå¸¸ï¼å½æ°æ¯ç¨åç§°å£°æçãä¸é¢çæ å°æ¯æ²¿ççº¿åç\n\nfunction f(x: x): y\n  requires r\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\nå½æ°ä¹å¯ä»¥æ¯å¿åçï¼å¨è¿ç§æåµä¸ï¼å®éå¸¸è¢«ç§°ä¸ºlambdaè¡¨è¾¾å¼ãç¶åç¼åç¤ºä¾æ å°\n\nx requires r => g(x)\n\n\n1\n\n\n\n# æ»ç»\n\nä»¥ä¸æ¯æ¬æä¸­è®¨è®ºçè¯­æ³å½¢å¼:\n\nforall x :: p\nforall x | r :: p\nforall x | r ensures p { s; }\nexists x :: p\nexists x | r :: p\nvar x :| p;\nif x :| p { s; }\nset x | r :: f(x)\nset x | r\nmap x | r :: f(x) := h(x)\nmap x | r :: g(x)\nfunction f(x: x): y { g(x) }\nx requires r => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# è´è°¢\n\næå¾æè°¢jay lorchå¨è¿å¼ ä¾¿æ¡ä¸çè®¸å¤æå¸®å©çè¯è®ºã\n\n\n# åèæç®\n\n[0]nada amin, k. rustan m. leino, and tiark rompf. computing with an smt solver. in martina seidl and nikolai tillmann, editors, tests and proofs â 8th international conference, tap 2014, volume 8570 of lecture notes in computer science, pages 20â35. springer, july 2014. ð\n\n[1]francois bobot, jean-christophe filliatre, claude marche, and andrei paskevich. why3: shepherd your herd of provers. in boogie 2011: first international workshop on intermediate verification languages, pages 53â64, wrocÅaw, poland, august 2011. https://hal.inria.fr/hal-00790310. ð\n\n[2]k. mani chandy and jayadev misra. parallel program design: a foundation. addison-wesley, 1988. ð\n\n[3]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. ð\n\n[4]david gries and fred b. schneider. a logical approach to discrete math. texts and monographs in computer science. springer-verlag, 1994. ð\n\n[5]gary t. leavens, albert l. baker, and clyde ruby. jml: a notation for detailed design. in haim kilov, bernhard rumpe, and ian simmonds, editors, behavioral specifications of businesses and systems, pages 175â188. kluwer academic publishers, 1999. ð\n\n[6]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361â381. springer, 2016. ð\n\n----------------------------------------\n\n0.ç¨äºdafnyæççemacs ideæäºdafnyç»æçç¬¦å·ä½ æ´å¯è½å¨è®ºæä¸­çå°ãé»è®¤æåµä¸ï¼å®æ¾ç¤ºforall x:: p asåæ¾ç¤ºexists x:: p asã[â©](http://leino.science/papers/krml267.html # back-fn-fn-emacs)\n\n1.å¨åé¨ï¼dafnyéªè¯å¨å¯ä»¥æ´ææå°ä½¿ç¨æäºéè¯ãéªè¯èè¯å¾æ£æµä¸ä¸ªç»å®éè¯çå¦ä¸ç§å½¢å¼ä½æ¶å¯è½æ§è¡å¾æ´å¥½ï¼å¹¶å°å¨è¿äºæåµä¸èªå¨éåéè¯[6]ãä¾å¦ï¼å®å¯ä»¥éæ©è§£é¤æäºéè¯çåµå¥ãè¿ç§éåçç®æ æ¯å¨è·å¾è¯å¥½çéªè¯æ§è½çåæ¶æ¯æèªç¶å¤è§çç¨åºã[â©](http://leino.science/papers/krml267.html # back-fn-fn-nested)\n\n2.äºå®è¯æï¼dafnyçèªå¨å½çº³å°èªå¨è¯æfibpropertyåfibpropertyallãå¦æè¿æ¯æä»¬å¯ä¸å³å¿çå¼çï¼é£å°±æ²¡æä»ä¹å¥½è¯´æåçäºãå°½ç®¡å¦æ­¤ï¼æè¿æ¯ç¨è¿ä¸ªä¾å­æ¥å±ç¤ºâforallâè¯­å¥ãå¦æä½ æ³è¦ç¡®ä¿æå°è¦è¯´çæ¯ä¸ä¸ªè¯æï¼ä½ å¯ä»¥éè¿ä½¿ç¨å±æ§{:induction false}æ¥å³é­fibpropertyallçèªå¨æåºã[â©](http://leino.science/papers/krml267.html # back-fn-fn-fibpropertyall)\n\n3.dafnyä¹å¯ä»¥è¯æç±»ä¼¼æ­è¨assert fib(12) == 144;ãå¨åé¨ï¼dafnyä½¿ç¨äºå½æ°çâåè½¨ç¼ç âï¼ä½¿å¶è½å¤è·å¾fib(12)çå¼(å ä¸º12æ¯ä¸ä¸ªæå­å¸¸é)åfib(k)(å¶ä¸­kæ¯ä¸ä¸ªåé)ãå¦ææ¨å¯¹è¿æ¯å¦ä½å®ç°çæå´è¶£ï¼æå»ºè®®æ¨è®¿é®[0]ã[â©](http://leino.science/papers/krml267.html # back-fn-fn-dual-rail-encoding)\n\n4.è¿éæ¯æ­è¨k <= fib(m) + fib(m+1)çä¸ä¸ªè¯æãå¨æä»¬çè¯æä¸­ï¼âå°é¾çæåµâéç¨äºå½kè³å°ä¸º2æ¶ï¼æä»¥k-1è³å°ä¸º1ï¼æä»¥æä»¬ç¥éfib(m)è³å°ä¸º1ãç±æ­¤å¯ä»¥å¾åºç»è®ºï¼å¯¹äºfib(0) == 0ï¼ mä¸è½ä¸º0ãè¿å¾éè¦ï¼å ä¸ºè¿æå³çm+1è³å°ç­äº2ï¼å æ­¤éç¨äºfibå®ä¹çå½çº³æåµãæ¢å¥è¯è¯´ï¼æä»¬æfib(m+1) == fib(m) + fib(m-1)ãæä»¬å·²ç»å¾åºï¼fib(m)è³å°ç­äº1ãä»¥fibè¿ånatä¸ºä¾ï¼æä»¬ç¥éfib(m-1)è³å°ä¸º0ãæä»¥ï¼fib(m+1)è³å°ç­äº1ãæ¢å¥è¯è¯´ï¼fib(m) + fib(m+1)è³å°æ¯fib(m)å¤§äº1ï¼èfib(m)è³å°ç­äºk-1ãå æ­¤ï¼fib(m) + fib(m+1)è³å°ç­äºkã\n\nå¦ææä»¬æâç®åçæåµâåâå°é¾çæåµâåå¼ï¼ä½¿âç®åçæåµâåªåå«âk == 0âï¼é£ä¹æä»¬ä¸å¯è½å¨ä¸é¢çè®ºè¯ä¸­å¾åºâm != 0âçç»è®ºãå¶ä»äº¤äºå¼è¯æå©æçä¸äºç¨æ·å¯è½ä¼å¯¹æ­¤æå°å°æ°ï¼å ä¸ºä»ä»¬ä¼è¯´kå·ænatç±»åï¼å æ­¤å¯¹kçå½çº³åºè¯¥ä½¿ç¨k == 0ä½ä¸ºåºæ¬æåµãæ°å­¦å¯¹å½çº³æ³æ²¡æè¿æ ·çéå¶ï¼äºå®ä¸ï¼æ­£å¦è¿ä¸ªè¯æææ¾ç¤ºçï¼æä»¬å¯ä»¥ä»å°âeverbiggerâçæåµåæâk < 2âåâ2 <= kâä¸­è·çã[â©](http://leino.science/papers/krml267.html # back-fn-fn-proof)',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"ä¸åç±»åçè¯æ",frontmatter:{title:"ä¸åç±»åçè¯æ",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/20c275/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/5.%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%81%E6%98%8E.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/5.ä¸åç±»åçè¯æ.md",key:"v-93595222",path:"/pages/20c275/",headers:[{level:2,title:"ä¸ä¸ªç¤ºä¾é®é¢",slug:"ä¸ä¸ªç¤ºä¾é®é¢",normalizedTitle:"ä¸ä¸ªç¤ºä¾é®é¢",charIndex:189},{level:2,title:"è¯æè®¡ç®",slug:"è¯æè®¡ç®",normalizedTitle:"è¯æè®¡ç®",charIndex:1026},{level:2,title:"è¿æ¥åçº¿åè®¡ç®",slug:"è¿æ¥åçº¿åè®¡ç®",normalizedTitle:"è¿æ¥åçº¿åè®¡ç®",charIndex:2576},{level:2,title:"æç®è¯æ",slug:"æç®è¯æ",normalizedTitle:"æç®è¯æ",charIndex:3655},{level:2,title:"ç»æåæ­è¨",slug:"ç»æåæ­è¨",normalizedTitle:"ç»æåæ­è¨",charIndex:4198},{level:2,title:"ä½ç¨å",slug:"ä½ç¨å",normalizedTitle:"ä½ç¨å",charIndex:4779},{level:2,title:"æ­è¨",slug:"æ­è¨",normalizedTitle:"æ­è¨",charIndex:1041},{level:2,title:"ååæ¾æ§è¯æ",slug:"ååæ¾æ§è¯æ",normalizedTitle:"ååæ¾æ§è¯æ",charIndex:6556},{level:2,title:"æ»ç»",slug:"æ»ç»",normalizedTitle:"æ»ç»",charIndex:8880},{level:2,title:"åèæç®",slug:"åèæç®",normalizedTitle:"åèæç®",charIndex:9183}],headersStr:"ä¸ä¸ªç¤ºä¾é®é¢ è¯æè®¡ç® è¿æ¥åçº¿åè®¡ç® æç®è¯æ ç»æåæ­è¨ ä½ç¨å æ­è¨ ååæ¾æ§è¯æ æ»ç» åèæç®",content:"# ä¸åç±»åçè¯æ\n\n> K. Rustan M. Leino Manuscript KRML 276, 9 March 2020\n\næè¦ å°±ååä½åå£è¯­ä¸­æä¸åçå¥å­ç»ææ¥è¡¨è¾¾ä¸åçæ³æ³ä¸æ ·ï¼ä¹æä¸åçè¯æç»ææ¥è¡¨è¾¾è¯æãè¿æ¡æ³¨éæ¾ç¤ºäºå¨Dafnyä¸­å¯è½åºç°çä¸äºååã\n\nè®©æä»¬èèä¸åçè¯æåä½é£æ ¼ãä½ä¸ºä¸ä¸ªè¿è¡çä¾å­ï¼æä»¬å°é¦åå®ä¹ä¸ä¸ªå½æ°åå¶è¡ä¸ºçä¸äºå¬çã\n\n\n# ä¸ä¸ªç¤ºä¾é®é¢\n\nèèä¸ä¸ªå¸¦æä¸¤ä¸ªåæ°çæ´æ°å½æ°f:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nå ä¸ºææ²¡æä¸ºè¿ä¸ªå½æ°æä¾ä¸ä¸ªå½æ°ä½ï¼æä»¥Dafnyå°å®è§ä¸ºä¸ä¸ªæªè§£éçå½æ°ãä¹å°±æ¯è¯´æä»¬å¯¹å®ä¸æ æç¥ãæä»¬ç¥éå®æ¯ä¸ä¸ªå½æ°ï¼è¿æå³çå®çç»æå¼å®å¨ç±å®çè¾å¥å³å®ãä¾å¦ï¼æä»¬ä¸ç¥éf(7,3)è®¡ç®çæ¯åªä¸ªæ´æ°ï¼ä½æ¯ç¥éå¦æä½ ç¨ç¸åçåæ°åæ¬¡è°ç¨fï¼ä½ ä¼ç»§ç»­å¾å°ç¸åçå¼ã\n\nä¸ºäºè¯æå³äºfçä¸äºä¸è¥¿ï¼æä»¬æ³ç¥éæ´å¤å³äºfçæ§è´¨ãä¸é¢æ¯ä¸ä¸ªå¼ççå£°æï¼å®ä»¬è¡¨è¾¾äºè¿æ ·çå±æ§:\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå°±åå½æ°æ¬èº«ä¸æ ·ï¼è¿äºå¼çæ²¡æå®ä½ãå®æ¯å¼ççä¸»ä½æ¥è¯æå¼ççåç½®æ¡ä»¶ãæ¢å¥è¯è¯´ï¼ä¸»ä½æ¯è¯æå¼ççä¸è¥¿ãå ä¸ºè¿äºå¼çæ²¡æè¯æï¼æä»¥å®ä»¬å®éä¸æ¯âå¬çâ(ä¹å°±æ¯è¯´ï¼ä½ å¿é¡»å¨æ²¡æè¯æçæåµä¸æ¥åå®)ã\n\nå¦æä½ éè¿Dafny ç¼è¯å¨è¿è¡è¿ä¸ªå½æ°åè¿äºå¼çï¼ä½ ä¼æ¶å°æ±æ¨ï¼è¯´å®ä»¬æ²¡æå®ä½ãä½åºäºæ¬æçç®çï¼æä»¬å¹¶ä¸å³å¿ä»ç¼è¯å¨è·åæ­£å¨æ§è¡çä»£ç ãæä»¬çéç¹æ¯è¯æï¼èDafny éªè¯èå¯¹æ å®ä½å£°ææ²¡æå¼è®®ãå°±éªè¯èèè¨ï¼æ ä¸»ä½å£°æåªæ¯è¯´æ²¡æä»ä¹å¯æ£æ¥çã\n\næä»¬å°ä»¥ä¸åçé£æ ¼æ¥è¯æè¿ä¸ªæ§è´¨:\n\n> a,b, c,åx,å¦æc < = x = = f (a, b),ç¶åf (aãf (b, c)) < = xã\n\nè¿ä¸ªæ§è´¨çè¯æä½¿ç¨äºä¸é¢çä¸ä¸ªå¬çã\n\n\n# è¯æè®¡ç®\n\nææ¶ï¼ä¸ä¸ªç®åçâæ­è¨âè¯­å¥å°±è¶³ä»¥æç¤ºDafnyéªè¯å¨å®æä¸ä¸ªè¯æãå¶ä»æ¶åï¼æ¨éè¦è°ç¨ä¸ä¸ªå¼çãå½æåµæ²¡æè¿ä¹ç®åæ¶ï¼å¨Dafnyä¸­ç¼åè¯æçæå¸¸è§æ¹æ³æ¯è¯æè®¡ç® [0ï¼ 3]ã\n\nè¯æè®¡ç®æ¯ä¸ç³»åçè¯ææ­¥éª¤ãæ¯ä¸æ­¥è¯æä¸ä¸ªç­å¼(ä¾å¦ï¼A == B)ãä¸ç­å¼(ä¾å¦ï¼A <= B)æé»è¾æ¨è®º(ä¾å¦ï¼A ==> B)ã\n\nä¸ä¸ªæ­¥éª¤æ¯åç´ä¹¦åçï¼ä»¥ç»ä¸äºç©ºé´æ¥è¯æä¸ºä»ä¹è¿ä¸ªæ­¥éª¤æ¯æç«çãä¸é¢æ¯ä¸ä¸ªååæ­¥éª¤:\n\n  A;\n==  // explain why A equals B\n  B;\n\n\n1\n2\n3\n\n\nå¦æ¬æ­¥éª¤æç¤ºï¼é¾ä¸­çæ¯ä¸ªå¬å¼é½ä»¥åå·ç»æã\n\nå¨ä¸é¢çååæ­¥éª¤ä¸­ï¼æå°çç±(ä¹ç§°ä¸ºhint)ä½ä¸ºæ³¨éç¼åãè¿æ ·çæ³¨éæ¯æç¨çææ¡£ãå¦æéªè¯èä¸è½å¨æ²¡æå¸®å©çæåµä¸æ£æ¥æ¨çæ­¥éª¤ï¼åæç¤ºéè¦ä¸ä»ä»æ¯æ³¨éãç¶åï¼ç¨è±æ¬å·åä¸æ®µä»£ç ï¼éªè¯èä½¿ç¨ä»ä»£ç ä¸­è·å¾çç¥è¯æ¥è¯æè¿ä¸æ­¥ãä¾å¦,\n\n  A;\n==  { LemmaThatJustifiesABEquality();  }\n  B;\n\n\n1\n2\n3\n\n\næ¯æ¶ååè¯æäºãè¿éæ¯:\n\nlemma CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè®©æä»¬æ¥ççè¿ä¸ªè¯æè®¡ç®ã\n\nç¬¬ä¸æ­¥è¯´ï¼æ ¹æ®ç»åå¾ï¼è¡¨è¾¾å¼f(a, f(b, c))ç­äºf(f(a, b)ï¼ c)æ³¨æï¼è¿ä¸ªæç¤ºä½¿ç¨ç¹å®åæ°aï¼ båcè°ç¨ç»åæ§å¼çã\n\nç¬¬äºæ­¥è¯´f(f(a, b)ï¼ c)åf(x, c)æ¯ä¸æ ·çï¼å ä¸ºæä»¬è¦è¯æçå¼ççåæ(å³åå³æ¡ä»¶)è¯´xç­äºf(a, b)ãéªè¯èæ ¹æ®æä»¬è¦è¯æçå¼ççåæç¥éx == f(a, b)è¿ä¸ªç­å¼ï¼æä»¥éªè¯èå¨è¿ä¸ªè¯ææ­¥éª¤ä¸­ä¸éè¦æç¡®çæç¤ºãä½æ¯ï¼ææ¶åç¨æºå¨æ£æ¥çæ¹å¼æ¥åè¿æ ·çè¯­å¥ä¼å¾å¥½ï¼ä½ å¯ä»¥ç¨âassertâè¯­å¥æ¥åï¼å°±åæå¨è¿éå±ç¤ºçé£æ ·ã\n\nç¬¬ä¸æ­¥è¯æf(x, c) <= f(x, x)ãè¿ä¸æ­¥ççç±æ¯c <= xä¿æä¸å(å®æ¯å¨å¼çåææ¡ä»¶ä¸ç»åºç)ï¼å æ­¤å¯ä»¥å°å¼çç§°ä¸ºåè°æ§(è¿éè¦c <= xä½ä¸ºåææ¡ä»¶)ãè°ç¨åè°æ§(c, x)å¼çç»äºæä»¬\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\néªè¯èæåºï¼ç¨xä¸ºwå®ä¾åè¿ä¸ªéè¯ç»åºäºæä»¬å¨è¿ä¸æ­¥ä¸­è¯å¾è¯æçä¸ç­å¼ã\n\nç¬¬åæ­¥è¯æäºf(x, x) = xãè¿ä¸ªå±æ§ç´æ¥éµå¾ªDiagonalIdentityå¬çï¼ç¨åæ°xè°ç¨ã\n\næä»¬çåä¸ªè¯ææ­¥éª¤è¯æäºä»¥ä¸åä¸ªç¸åºçæ§è´¨:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\néè¿==å<=çä¼ éæ§ï¼è¿åä¸ªæ§è´¨ç»äºæä»¬\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nè¿å°±æ¯æä»¬è¦è¯æçã\n\n\n# è¿æ¥åçº¿åè®¡ç®\n\nä¸è¬æ¥è¯´ï¼æåç°è¯æè®¡ç®æ¯ä»¤äººä¿¡æçï¼å®¹æéè¯»ãæ¨å¯ä»¥åå«æ£æ¥æ¯ä¸æ­¥ï¼å¹¶å¯ä»¥çå°å¬å¼æ¯å¦ä½ä»ä¸è¡âè½¬æ¢âå°ä¸è¡çã\n\nå¾å¤æ¶å(ä½å¹¶éæ»æ¯å¦æ­¤)ï¼æä¹åç°è¯æè®¡ç®å¯¹ä½èæ¥è¯´å¾ç®åãå¨ä¸é¢çä¾å­ä¸­ï¼æä»¬ä»å¬å¼çå·¦è¾¹å¼å§è®¡ç®\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\næä»¬è¦è¯æãç¶åï¼æä»¬çä¸ä¸è¯æçå½åè¡ï¼æ¾åºå³äºè¿ä¸ªè¡¨è¾¾å¼æä»¬ç¥éä»ä¹æ§è´¨ï¼ä»¥åæä»¬æ¥ä¸æ¥å¯ä»¥åºç¨ä»ä¹åæ¢ãä¸ºäºå¨è¿ä¸ªè¿ç¨ä¸­è·å¾æ´å¤çæå¯¼ï¼éå¸¸æå¥½ä»æä»¬è¯å¾è¯æçå¬å¼çæ´å¤æçä¸é¢å¼å§ãä¸¾ä¸ªä¾å­ï¼å¦æä½ ä»\n\ncalc {\n  x;\n\n\n1\n2\n\n\nç°å¨è¿è¿ä¸æ¸æ¥ä¸ä¸æ­¥ä¼ææ ·\n\n==  { DiagonalIdentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\næä»¬å¯ä»¥ç»§ç»­è¿ä¸ªè¯æï¼å°ä¸ä¸èçæ­¥éª¤æç¸åçé¡ºåºåä¸æ¥ï¼å¹¶å¨æ¯ä¸æ­¥ä¸­åè½¬è¿ç®ç¬¦çæ¹å(ä¾å¦ï¼å°<=æ´æ¹ä¸º>=):\n\n>=  { assert c <= x; Monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nä¸ç®¡æä»¬å¾åªä¸ªæ¹åèµ°ï¼å°ç®åä¸ºæ­¢ï¼ææå±ç¤ºçè®¡ç®ä¸­çæ¯ä¸è¡é½æç±»åintãä¹å¯ä»¥å¨æ¯ä¸è¡ç¨ä¸ä¸ªå¸å°å¬å¼æ¥åè¯æãè¿éæä¸ä¸ªè¿æ ·çä¾å­:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { DiagonalIdentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { Associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; Monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\néè¿==çä¼ éæ§ï¼è¯æäºå¬å¼f(a, f(b, c)) <= xçå¼ä¸ºtrueã\n\nå¦ææ¨ä¸ºæ¨çè¯æè®¡ç®è¡éæ©è¿æ ·çå¸å°è¡¨è¾¾å¼ï¼é£ä¹æ¯ä¸æ­¥çæä½ç¬¦éå¸¸æ¯é»è¾æç¤º(==>ï¼å³âé»è¾å¼±åâ)æé»è¾âè§£éâ(<==ï¼âé»è¾å¼ºåâï¼æâä»åâ)ãå½ç¶ï¼ä½ å¿é¡»éæ©è¿ä¸¤ä¸ªæ¹åä¸­çä¸ä¸ªï¼èä¸æ¯åæ¶ä½¿ç¨ï¼å¦åä½ çè¯æè®¡ç®å°±æ²¡ææä¹äºãå¨è¿äºæ¹åä¸­ï¼<==éå¸¸ä¼ç»ä½ ä¸ä¸ªæ´å¥½çèµ·ç¹ï¼å ä¸ºä½ ä¼ä»ä½ è¦è¯æçå¬å¼å¼å§ï¼æåä½ ä¼å¾å°trueãç¶èï¼æ ¹æ®æçç»éªï¼æåç°è®¸å¤åå­¦èè¢«<==çæ¹åæç³æ¶äºï¼ä»ä»¬æè®¡ç®åå¾å¥½åä»ä»¬æ¯å¨==>çæ¹åä¸ãç¨ä»»ä½å¯¹ä½ ææä¹çæ¹åã\n\n\n# æç®è¯æ\n\nè¯æè®¡ç®æ¯ä¸ç§æé è¯ææ­¥éª¤çæ¹æ³ãå®éå¸¸åå«æ¯éªè¯èéè¦çæ´å¤çä¿¡æ¯ï¼ç¹å«æ¯å¦ææ¨ä¸ºäºèªå·±çå©çï¼å°è¯æåå¨å°çæ­¥éª¤ä¸­ãå¦æä½ è®¤ä¸ºä¸ä¸ªè¯ææå¤ªå¤çç»èï¼ä½ å¯ä»¥å é¤ä¸äºä¸éè¦çä¸è¥¿ãè¿æ¯å¦æ¯ä¸ªå¥½ä¸»æââæèï¼ä»ä¹æ¶åæ¯ä¸ªå¥½ä¸»æï¼å é¤å¤å°åå®¹ââä¸»è¦åå³äºä¸ªäººåå¥½ãå¦ææ¨ç¨åååå°è¯æï¼é¢å¤çç»èå¯è½ä¼æä¾æç¨çææ¡£ï¼è¯´æè¯ææåæ¯å¦ä½æé çã\n\nå¦æä½ æ³åå°ä¸é¢çè¯æè®¡ç®ä¸­çæç¤ºï¼ä½ å¯è½è¦åçç¬¬ä¸ä»¶äºæ¯å é¤ä½ä¸ºè¯æçä¸é¨åçä¸¤ä¸ªassertè¯­å¥ï¼æèè³å°å é¤æ­è¨c <= xãä½æ¯ä½ å¯ä»¥åçæ´å¤ã\n\néè¿åé¢çè®¡ç®ï¼æä»¬å¯ä»¥å¾å®¹æå°çå°ä½¿ç¨äºåªäºå¼çï¼æ´éè¦çæ¯ï¼è¿äºå¼çå®ä¾åäºåªäºå¼ãä¸æ¦ä½ ç¥éäºè¿ä¸ç¹ï¼ä½ å°±å¯ä»¥å®å¨ä¸ç¨è®¡ç®è¯æäºãæ´ä¸ªè¯ææ¯è¿æ ·ç:\n\nlemma MinimalProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  Monotonicity(c, x);\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ç»æåæ­è¨\n\nä¸ºäºè¯´æè¿ä¸ç¹ï¼ä¸åcalcè¯­å¥çè®¡ç®è¯ææ¯æççãè¿æ¯å®çèµ·æ¥çæ ·å­:\n\nlemma AssertProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; Monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  DiagonalIdentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿åç»è¯­å¥ä¸­çæ¯ä¸ç»é½å¯¹åºäº[1]è(http://leino.science/papers/krml276.html#sec-calc)è®¡ç®ä¸­çä¸ä¸ªæ­¥éª¤ãå¨è¿ä¸ªæ­¥éª¤è¯æçç­å¼æä¸ç­å¼çæ­è¨ä¹åï¼calcè¯­å¥çæç¤ºæ¯ä»ä¹?éªè¯èç¶åæåä¸ªç»è®ºç²å¨ä¸èµ·æ¥è¯æå¼ççåç½®æ¡ä»¶ã\n\n\n# ä½ç¨å\n\n[1]è(http://leino.science/papers/krml276.html#sec-calc)ä¸­çcalcè¯­å¥ä¸[4]è(http://leino.science/papers/krml276.html#sec-linear-asserts)ä¸­çæåçassertè¯­å¥ä¹é´å­å¨å·®å¼ãä¸åä¹å¤å¨äºï¼è®¡ç®ä¸­çæ¯ä¸ä¸ªæç¤ºå¯¹äºè¯ææ­¥éª¤æ¥è¯´é½æ¯å±é¨çãä¹å°±æ¯è¯´ï¼æç¤ºçä½ç¨åå°±æ¯æ­¥éª¤æ¬èº«ãä¾å¦ï¼åè®¾æ¨å°1é¨åä¸­calcè¯­å¥çæææç¤ºç§»å¨å°ç¬¬ä¸ä¸ªè¯ææ­¥éª¤ãç¶åï¼ä¸¤ä¸ªè¯ææ­¥éª¤å°ä¸åéªè¯:\n\ncalc {\n  f(a, f(b, c));\n==  { Associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; Monotonicity(c, x);\n      DiagonalIdentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nä¹å°±æ¯è¯´ï¼å¨ç¬¬ä¸æ­¥ä¸­è°ç¨æç¤ºä¸­çä¸ä¸ªå¼çæè·å¾çä¿¡æ¯ä¸ä¼å½±åå°å¶ä»æ­¥éª¤ãç¸åï¼å¦æä½ æ¶éå¼çä¸»ä½å¼å§çæç¤ºï¼åä¸ªç­å¼åä¸ç­å¼å°±å¯ä»¥å¾å¥½å°éªè¯:\n\n// hints\nAssociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; Monotonicity(c, x);\nDiagonalIdentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä½ å¯ä»¥æcalcè¡¨è¿°çæ¯ä¸æ­¥é½çä½æ¯ä¸ä¸ªå¼çï¼å¼ççè¯æå°±æ¾å¨è¿ä¸æ­¥çæç¤ºéãè¿å¨ç¼åè¯ææ¶å¾éè¦ï¼ä¸ä»å ä¸ºå®åè¯äººç±»è¯»èæä¸ªæç¤ºéç¨äºç¹å®çè¯ææ­¥éª¤ï¼è¿å ä¸ºå®éå¶äºéªè¯èåºç¨æç¤ºçèå´ãå¯¹äºå¤æçè¯æï¼è¿å¨å®è·µä¸­ä¼äº§çå¾å¤§çä¸åï¼å ä¸ºéªè¯èå¯è½ä¼è¢«å¤ªå¤çä¿¡æ¯âå¼ç³æ¶âââè¿è¡¨ç°ä¸ºéªè¯èçæ§è½å·®ææäºâè´è¶æåºâ[2]ã\n\næ»ä¹ï¼å¨è¯æä¸­åºåæç¤ºæ¯å¾å¥½çãcalcè¯­å¥å¨è¿æ¹é¢åå¾å¾å¥½ï¼ä½ä½ ä¹å¯ä»¥ç¨assertè¯­å¥çå½¢å¼æ¥åãä¸é¢æä»¬æ¥çä¸ä¸ã\n\n\n# æ­è¨\n\nassert E;è¡¨è¿°äºä¸ä»¶äº:\n\n 1. å®è¡¨æä½ æææ¡ä»¶Eæç«\n 2. å®è¦æ±éªè¯èè¯æE 3.å®è®©åé¢çæ­è¨åè®¾E\n\næ¨å¯è½æ²¡æèèè¿å°æ­è¨çè¿ä¸ä¸ªæ¹é¢åå¼ï¼ä½æ¯è¿æ ·åå¾æç¨ï¼å ä¸ºDafnyæä¾äº(1)å(2)çæ¿ä»£æ¹æ¡ã\n\nè¯¥å£°æ\n\nassert E by { Hint }\n\n\n1\n\n\næ¹åæ¹é¢(1)è¯´Eæ¯å¨ç»å®çæç¤ºä¸è¢«è¯æçï¼å¶ä¸­hintæ¯ä¸ä¸ªå½é¢ãæç¤ºçä½ç¨ååªæ¯æ­è¨æ¬èº«ï¼æä»¥å®å¨æ­è¨çä¸æ¸¸ä¸å¯ç¨ãè¿æ ·ï¼assert byè¯­å¥ç­ä»·äº:\n\ncalc {\n  E;\n==  { Hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬å¯ä»¥ä½¿ç¨assert byéå4é¨åçè¯æ:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  Associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; Monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nè¿æä¾äºæ´å¥½çååºï¼ä»èæ´ç´æ¥å°è¡¨è¾¾äºä¸ºä»ä¹æ¯ä¸ªæ­è¨çæ¡ä»¶ä¿æä¸åã\n\n\n# ååæ¾æ§è¯æ\n\n6é¨åä¸­çè¯æåå«ä¸¤ä¸ªæ­è¨ï¼å®ä»¬éç³äºå¨åç½®æ¡ä»¶ä¸­æåçåå®¹ãè¿äºæ­è¨èåçææ³æ¯æç¡®ä½¿ç¨è¿äºåå³æ¡ä»¶çå°æ¹ãç¶èï¼è¿æä¸¤ä¸ªç¼ºç¹ã\n\nä¸ä¸ªç¼ºç¹æ¯ï¼å¿é¡»å°æ­è¨ä¸­çè¡¨è¾¾å¼ä¸è¯æä¸­çå¶ä»è¡¨è¾¾å¼è¿è¡æ¯è¾ï¼æè½æè¯å°æ­è¨åªæ¯å¨éç³ä¸ä¸ªä»¥åå¯ç¨çåè®¾ãå¦ææä»¬å¯ä»¥æ è®°æ¡ä»¶ï¼ç¶åå¼ç¨æ ç­¾ï¼é£å°±å¥½äºã\n\nå¦ä¸ä¸ªç¼ºç¹æ¯ï¼æ è®ºæ¯å¦å¨æ­è¨ä¸­éè¿°æ¡ä»¶ï¼åææ¡ä»¶é½æ¯å¯ç¨çãå¦ææä»¬å¿è®°ç¼åæ­è¨(å¯è½æ¯å ä¸ºæä»¬æ²¡ææè¯å°æä»¬ä¾èµäºè¿ä¸ªæ¡ä»¶)ï¼æèå¦ææä»¬æå¤å°ç¼åäºéè¯¯çåææ¡ä»¶ï¼é£ä¹è¯æä»ç¶ææãä¹å°±æ¯è¯´ï¼éªè¯å¨å·²ç»è½å¤ä½¿ç¨åç½®æ¡ä»¶ï¼æä»¥å®ä¸å³å¿ä½ æ¯éè¿°æ¡ä»¶ï¼è¿æ¯éè¿°ä¸ä¸ªä¸åç(ç)æ¡ä»¶ï¼æèä»ä¹ä¹ä¸éè¿°ãå¦ææä»¬è½æ´æç¡®å°è¯´æè¿äºåè®¾çèå´ï¼é£å°±å¤ªå¥½äºã\n\nè¿æä¸ç§å½¢å¼çæ­è¨byè¯­å¥ãå®æ¾æ¾äº[6]é¨å(http://leino.science/papers/krml276.html#sec-assert-by)çaspect(2)ãè¿ä¸ªè¡¨åçèµ·æ¥åè¿æ ·:\n\nassert Label: E { Hint }\n\n\n1\n\n\nè¿ä¸ªææ è®°çæ­è¨è¯­å¥è¡¨ç¤ºä½ æææ¡ä»¶Eæç«ï¼å®æä¾äºä¸ä¸ªæç¤ºè¯­å¥ä½ä¸ºEçè¯æãå¨æ¡ä»¶åä½¿ç¨æ ç­¾ä¼æå¶âEâä½ä¸ºä¸æ¸¸åè®¾çä½¿ç¨ã\n\nä¾å¦ï¼è¦è¯æf(12,12) == 12ï¼éè¦ä½¿ç¨DiagonalIdentityå¬çãå¦æä½ ä½¿ç¨å¸¦æ ç­¾çassert byæ¥è¯æè¿ä¸ªäºå®ï¼é£ä¹å¨å¸¦æ ç­¾çassertä¹åï¼è¢«è¯æçäºå®ä»ç¶ä¸å¯ç¨:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nå¦æä½ ä¸è½ç¨ä½ è¯æçäºå®ï¼ä¸ºä»ä¹è¦ç¨è¿ç§è¯´æ³å¢?å¥½å§ï¼æåºè¯¥è¯´äºå®å¨æ è®°çæ­è¨ä¹åä¸æ¯âèªå¨âå¯ç¨çãä½æ¯æ¨å¯ä»¥æç¡®å°è¯·æ±å®ãä½ å¯ä»¥ç¨âæ­ç¤ºâå£°ææ¥åå°è¿ä¸ç¹ï¼å¨å£°æä¸­ä½ æå°äºæ ç­¾ã\n\nä¸é¢åæ¯ä¸ä¸ªä¾å­ï¼ä½å¸¦æârevealâè¯­å¥:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nreveal Label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nä½ å¯ä»¥å¨åææ¡ä»¶ä¸ä½¿ç¨åæ ·çæå·§ãä¹å°±æ¯è¯´ï¼éå¸¸å¨å¼ç(ææ¹æ³æå½æ°)ä¸­ï¼æ¯ä¸ä¸ªåå³æ¡ä»¶\n\nrequires E\n\n\n1\n\n\nå¨å¼ççæ´ä¸ªæ­£æä¸­é½æãä½å¦æä½ ç»å®è´´ä¸æ ç­¾ï¼ä½ å°±å¿é¡»ä½¿ç¨âæ­ç¤ºâè¯­å¥æ¥å¼åºè¿ä¸ªåè®¾:\n\nrequires Label: E\n\n\n1\n\n\nå¨æä»¬çå°å®çå®éåºç¨ä¹åï¼è®©æåè°è°æ ç­¾ãDafnyä¸­çæ ç­¾å¯ä»¥æ¯ä»»ä½æ è¯ç¬¦ï¼ä½å®ä¹å¯ä»¥æ¯ææ¬ä¸çèµ·æ¥åæ°å­å­é¢éçä¸è¥¿ãä»¥ä¸æ¯äºä¸ªæ ç­¾ç¤ºä¾:\n\nMyLabel    Label57    L57    57    000_057\n\n\n1\n\n\nè¿æ¯äºä¸ªä¸åçæ ç­¾ââäºå®ä¸ï¼â57âåâ000_057âä½ä¸ºæ°å­å­é¢éè¡¨ç¤ºç¸åçæ°å­ï¼å¹¶ä¸æå³çå®ä»¬æ¯ç¸åçæ ç­¾ãå¦æå®ä»¬å¨å°å·é¡µä¸çèµ·æ¥ä¸ä¸æ ·ï¼å®ä»¬å°±æ¯ä¸åçæ ç­¾ã(å¯¹äºç±»ä¸­çå­æ®µåãæ°æ®ç±»åçææå½æ°åå¶ä»ç±»åæåä¹æ¯å¦æ­¤ï¼å®ä»¬ä¹å·æåè®¸çèµ·æ¥åæå­çæ è¯ç¬¦çæ©å±è¯­æ³ã)\n\nå¥½äºï¼ç°å¨æä»¬åå¤å¨è¿è¡çä¾å­ä¸­ä½¿ç¨å¸¦æ ç­¾çæ­è¨:\n\nlemma DifferentStyleOfProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nå¨è¿ç§ç±»åçè¯æä¸­(å¨ä¸äºé»è¾å­¦ææ¬ä¸­å¾å¸¸è§)ï¼æ¯ä¸ªæ­è¨é½éè¿å¶ç¸å³æ§æ¾å¼å°è¯æãå¦ææ¨è®¤ä¸ºæ­è¨ä¹é´çä¾èµå³ç³»ææäºä¸ä¸ªè¯æDAGï¼é£ä¹è¿ç§è¯æé£æ ¼å°±æ¯å¯¹DAGä¸­çç¥åè¿è¡æ¾å¼çè¯æãæ¨å¯ä»¥ä½¿ç¨åµå¥çassert byè¯­å¥åæ è®°çæ­è¨çå±æ¬¡ç»ææ¥è¿ä¼¼lamporté£æ ¼çè¯æ[1]ã\n\n\n# æ»ç»\n\næ ¡æ ·çåä½é£æ ¼æå¾å¤ç§ãæç®åçè¯ææ¯é£äºèªå¨å®æçï¼ä¸éè¦è¿ä¸æ­¥è¯æçè¯æãå¶ä»ç®åçè¯æéè¦ä¸ä¸ªæ­è¨æå¼çãè¯ææ­¥éª¤å¯ä»¥ä½¿ç¨calcè¯­å¥åassert byè¯­å¥ç»ç»ãéè¿æ è®°ä¸ä¸ªâassert Byâè¯­å¥æä¸ä¸ªåç½®æ¡ä»¶ï¼è¿ä¸ªæ¡ä»¶å¨è¯æä¸­è¢«æå¶äºï¼ç´å°ä½ ä½¿ç¨ä¸ä¸ªârevealâè¯­å¥æç¡®å°è¯·æ±å®åæ¥ã\n\næé è¯ææ¯ä¸ä¸ªå¥½ä¸»æï¼ä¸ºäºå¯è¯»æ§åæ¸æ°åº¦ï¼ä»¥åæ¹åæºæ¢°è¯ææ§è½ãä½ å¯ä»¥æä¸ä¸ªè¯æå½é¢æ³è±¡ææä¸äºè¾å¥æ¡ä»¶ãè¿äºæ¯è¯æè¯­å¥ä¸ä¸æä¸­å¯ç¨çæ¡ä»¶åæ ç­¾ãè¯æè¯­å¥çè¾åºæ¯calcè¯­å¥çç¬¬ä¸è¡åæåä¸è¡çä¼ éè¿æ¥ï¼æ æ è®°çassertæassert byè¯­å¥ä¸­çæ¡ä»¶ï¼ä»¥åææ è®°çæ­è¨çæ ç­¾ã\n\n\n# åèæç®\n\n[0]Edsger W. Dijkstra and W. H. J. Feijen. A Method of Programming. Addison-Wesley, July 1988. ð\n\n[1]Leslie Lamport. How to write a 21st century proof. Technical report, Microsoft Research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. ð\n\n[2]K. Rustan M. Leino and ClÃ©ment Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361â381. Springer, 2016. ð\n\n[3]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments â 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170â190. Springer, 2014. ð",normalizedContent:"# ä¸åç±»åçè¯æ\n\n> k. rustan m. leino manuscript krml 276, 9 march 2020\n\næè¦ å°±ååä½åå£è¯­ä¸­æä¸åçå¥å­ç»ææ¥è¡¨è¾¾ä¸åçæ³æ³ä¸æ ·ï¼ä¹æä¸åçè¯æç»ææ¥è¡¨è¾¾è¯æãè¿æ¡æ³¨éæ¾ç¤ºäºå¨dafnyä¸­å¯è½åºç°çä¸äºååã\n\nè®©æä»¬èèä¸åçè¯æåä½é£æ ¼ãä½ä¸ºä¸ä¸ªè¿è¡çä¾å­ï¼æä»¬å°é¦åå®ä¹ä¸ä¸ªå½æ°åå¶è¡ä¸ºçä¸äºå¬çã\n\n\n# ä¸ä¸ªç¤ºä¾é®é¢\n\nèèä¸ä¸ªå¸¦æä¸¤ä¸ªåæ°çæ´æ°å½æ°f:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nå ä¸ºææ²¡æä¸ºè¿ä¸ªå½æ°æä¾ä¸ä¸ªå½æ°ä½ï¼æä»¥dafnyå°å®è§ä¸ºä¸ä¸ªæªè§£éçå½æ°ãä¹å°±æ¯è¯´æä»¬å¯¹å®ä¸æ æç¥ãæä»¬ç¥éå®æ¯ä¸ä¸ªå½æ°ï¼è¿æå³çå®çç»æå¼å®å¨ç±å®çè¾å¥å³å®ãä¾å¦ï¼æä»¬ä¸ç¥éf(7,3)è®¡ç®çæ¯åªä¸ªæ´æ°ï¼ä½æ¯ç¥éå¦æä½ ç¨ç¸åçåæ°åæ¬¡è°ç¨fï¼ä½ ä¼ç»§ç»­å¾å°ç¸åçå¼ã\n\nä¸ºäºè¯æå³äºfçä¸äºä¸è¥¿ï¼æä»¬æ³ç¥éæ´å¤å³äºfçæ§è´¨ãä¸é¢æ¯ä¸ä¸ªå¼ççå£°æï¼å®ä»¬è¡¨è¾¾äºè¿æ ·çå±æ§:\n\nlemma associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma diagonalidentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nå°±åå½æ°æ¬èº«ä¸æ ·ï¼è¿äºå¼çæ²¡æå®ä½ãå®æ¯å¼ççä¸»ä½æ¥è¯æå¼ççåç½®æ¡ä»¶ãæ¢å¥è¯è¯´ï¼ä¸»ä½æ¯è¯æå¼ççä¸è¥¿ãå ä¸ºè¿äºå¼çæ²¡æè¯æï¼æä»¥å®ä»¬å®éä¸æ¯âå¬çâ(ä¹å°±æ¯è¯´ï¼ä½ å¿é¡»å¨æ²¡æè¯æçæåµä¸æ¥åå®)ã\n\nå¦æä½ éè¿dafny ç¼è¯å¨è¿è¡è¿ä¸ªå½æ°åè¿äºå¼çï¼ä½ ä¼æ¶å°æ±æ¨ï¼è¯´å®ä»¬æ²¡æå®ä½ãä½åºäºæ¬æçç®çï¼æä»¬å¹¶ä¸å³å¿ä»ç¼è¯å¨è·åæ­£å¨æ§è¡çä»£ç ãæä»¬çéç¹æ¯è¯æï¼èdafny éªè¯èå¯¹æ å®ä½å£°ææ²¡æå¼è®®ãå°±éªè¯èèè¨ï¼æ ä¸»ä½å£°æåªæ¯è¯´æ²¡æä»ä¹å¯æ£æ¥çã\n\næä»¬å°ä»¥ä¸åçé£æ ¼æ¥è¯æè¿ä¸ªæ§è´¨:\n\n> a,b, c,åx,å¦æc < = x = = f (a, b),ç¶åf (aãf (b, c)) < = xã\n\nè¿ä¸ªæ§è´¨çè¯æä½¿ç¨äºä¸é¢çä¸ä¸ªå¬çã\n\n\n# è¯æè®¡ç®\n\nææ¶ï¼ä¸ä¸ªç®åçâæ­è¨âè¯­å¥å°±è¶³ä»¥æç¤ºdafnyéªè¯å¨å®æä¸ä¸ªè¯æãå¶ä»æ¶åï¼æ¨éè¦è°ç¨ä¸ä¸ªå¼çãå½æåµæ²¡æè¿ä¹ç®åæ¶ï¼å¨dafnyä¸­ç¼åè¯æçæå¸¸è§æ¹æ³æ¯è¯æè®¡ç® [0ï¼ 3]ã\n\nè¯æè®¡ç®æ¯ä¸ç³»åçè¯ææ­¥éª¤ãæ¯ä¸æ­¥è¯æä¸ä¸ªç­å¼(ä¾å¦ï¼a == b)ãä¸ç­å¼(ä¾å¦ï¼a <= b)æé»è¾æ¨è®º(ä¾å¦ï¼a ==> b)ã\n\nä¸ä¸ªæ­¥éª¤æ¯åç´ä¹¦åçï¼ä»¥ç»ä¸äºç©ºé´æ¥è¯æä¸ºä»ä¹è¿ä¸ªæ­¥éª¤æ¯æç«çãä¸é¢æ¯ä¸ä¸ªååæ­¥éª¤:\n\n  a;\n==  // explain why a equals b\n  b;\n\n\n1\n2\n3\n\n\nå¦æ¬æ­¥éª¤æç¤ºï¼é¾ä¸­çæ¯ä¸ªå¬å¼é½ä»¥åå·ç»æã\n\nå¨ä¸é¢çååæ­¥éª¤ä¸­ï¼æå°çç±(ä¹ç§°ä¸ºhint)ä½ä¸ºæ³¨éç¼åãè¿æ ·çæ³¨éæ¯æç¨çææ¡£ãå¦æéªè¯èä¸è½å¨æ²¡æå¸®å©çæåµä¸æ£æ¥æ¨çæ­¥éª¤ï¼åæç¤ºéè¦ä¸ä»ä»æ¯æ³¨éãç¶åï¼ç¨è±æ¬å·åä¸æ®µä»£ç ï¼éªè¯èä½¿ç¨ä»ä»£ç ä¸­è·å¾çç¥è¯æ¥è¯æè¿ä¸æ­¥ãä¾å¦,\n\n  a;\n==  { lemmathatjustifiesabequality();  }\n  b;\n\n\n1\n2\n3\n\n\næ¯æ¶ååè¯æäºãè¿éæ¯:\n\nlemma calculationalstyleproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; monotonicity(c, x); }\n    f(x, x);\n  ==  { diagonalidentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè®©æä»¬æ¥ççè¿ä¸ªè¯æè®¡ç®ã\n\nç¬¬ä¸æ­¥è¯´ï¼æ ¹æ®ç»åå¾ï¼è¡¨è¾¾å¼f(a, f(b, c))ç­äºf(f(a, b)ï¼ c)æ³¨æï¼è¿ä¸ªæç¤ºä½¿ç¨ç¹å®åæ°aï¼ båcè°ç¨ç»åæ§å¼çã\n\nç¬¬äºæ­¥è¯´f(f(a, b)ï¼ c)åf(x, c)æ¯ä¸æ ·çï¼å ä¸ºæä»¬è¦è¯æçå¼ççåæ(å³åå³æ¡ä»¶)è¯´xç­äºf(a, b)ãéªè¯èæ ¹æ®æä»¬è¦è¯æçå¼ççåæç¥éx == f(a, b)è¿ä¸ªç­å¼ï¼æä»¥éªè¯èå¨è¿ä¸ªè¯ææ­¥éª¤ä¸­ä¸éè¦æç¡®çæç¤ºãä½æ¯ï¼ææ¶åç¨æºå¨æ£æ¥çæ¹å¼æ¥åè¿æ ·çè¯­å¥ä¼å¾å¥½ï¼ä½ å¯ä»¥ç¨âassertâè¯­å¥æ¥åï¼å°±åæå¨è¿éå±ç¤ºçé£æ ·ã\n\nç¬¬ä¸æ­¥è¯æf(x, c) <= f(x, x)ãè¿ä¸æ­¥ççç±æ¯c <= xä¿æä¸å(å®æ¯å¨å¼çåææ¡ä»¶ä¸ç»åºç)ï¼å æ­¤å¯ä»¥å°å¼çç§°ä¸ºåè°æ§(è¿éè¦c <= xä½ä¸ºåææ¡ä»¶)ãè°ç¨åè°æ§(c, x)å¼çç»äºæä»¬\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\néªè¯èæåºï¼ç¨xä¸ºwå®ä¾åè¿ä¸ªéè¯ç»åºäºæä»¬å¨è¿ä¸æ­¥ä¸­è¯å¾è¯æçä¸ç­å¼ã\n\nç¬¬åæ­¥è¯æäºf(x, x) = xãè¿ä¸ªå±æ§ç´æ¥éµå¾ªdiagonalidentityå¬çï¼ç¨åæ°xè°ç¨ã\n\næä»¬çåä¸ªè¯ææ­¥éª¤è¯æäºä»¥ä¸åä¸ªç¸åºçæ§è´¨:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\néè¿==å<=çä¼ éæ§ï¼è¿åä¸ªæ§è´¨ç»äºæä»¬\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nè¿å°±æ¯æä»¬è¦è¯æçã\n\n\n# è¿æ¥åçº¿åè®¡ç®\n\nä¸è¬æ¥è¯´ï¼æåç°è¯æè®¡ç®æ¯ä»¤äººä¿¡æçï¼å®¹æéè¯»ãæ¨å¯ä»¥åå«æ£æ¥æ¯ä¸æ­¥ï¼å¹¶å¯ä»¥çå°å¬å¼æ¯å¦ä½ä»ä¸è¡âè½¬æ¢âå°ä¸è¡çã\n\nå¾å¤æ¶å(ä½å¹¶éæ»æ¯å¦æ­¤)ï¼æä¹åç°è¯æè®¡ç®å¯¹ä½èæ¥è¯´å¾ç®åãå¨ä¸é¢çä¾å­ä¸­ï¼æä»¬ä»å¬å¼çå·¦è¾¹å¼å§è®¡ç®\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\næä»¬è¦è¯æãç¶åï¼æä»¬çä¸ä¸è¯æçå½åè¡ï¼æ¾åºå³äºè¿ä¸ªè¡¨è¾¾å¼æä»¬ç¥éä»ä¹æ§è´¨ï¼ä»¥åæä»¬æ¥ä¸æ¥å¯ä»¥åºç¨ä»ä¹åæ¢ãä¸ºäºå¨è¿ä¸ªè¿ç¨ä¸­è·å¾æ´å¤çæå¯¼ï¼éå¸¸æå¥½ä»æä»¬è¯å¾è¯æçå¬å¼çæ´å¤æçä¸é¢å¼å§ãä¸¾ä¸ªä¾å­ï¼å¦æä½ ä»\n\ncalc {\n  x;\n\n\n1\n2\n\n\nç°å¨è¿è¿ä¸æ¸æ¥ä¸ä¸æ­¥ä¼ææ ·\n\n==  { diagonalidentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\næä»¬å¯ä»¥ç»§ç»­è¿ä¸ªè¯æï¼å°ä¸ä¸èçæ­¥éª¤æç¸åçé¡ºåºåä¸æ¥ï¼å¹¶å¨æ¯ä¸æ­¥ä¸­åè½¬è¿ç®ç¬¦çæ¹å(ä¾å¦ï¼å°<=æ´æ¹ä¸º>=):\n\n>=  { assert c <= x; monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nä¸ç®¡æä»¬å¾åªä¸ªæ¹åèµ°ï¼å°ç®åä¸ºæ­¢ï¼ææå±ç¤ºçè®¡ç®ä¸­çæ¯ä¸è¡é½æç±»åintãä¹å¯ä»¥å¨æ¯ä¸è¡ç¨ä¸ä¸ªå¸å°å¬å¼æ¥åè¯æãè¿éæä¸ä¸ªè¿æ ·çä¾å­:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { diagonalidentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\néè¿==çä¼ éæ§ï¼è¯æäºå¬å¼f(a, f(b, c)) <= xçå¼ä¸ºtrueã\n\nå¦ææ¨ä¸ºæ¨çè¯æè®¡ç®è¡éæ©è¿æ ·çå¸å°è¡¨è¾¾å¼ï¼é£ä¹æ¯ä¸æ­¥çæä½ç¬¦éå¸¸æ¯é»è¾æç¤º(==>ï¼å³âé»è¾å¼±åâ)æé»è¾âè§£éâ(<==ï¼âé»è¾å¼ºåâï¼æâä»åâ)ãå½ç¶ï¼ä½ å¿é¡»éæ©è¿ä¸¤ä¸ªæ¹åä¸­çä¸ä¸ªï¼èä¸æ¯åæ¶ä½¿ç¨ï¼å¦åä½ çè¯æè®¡ç®å°±æ²¡ææä¹äºãå¨è¿äºæ¹åä¸­ï¼<==éå¸¸ä¼ç»ä½ ä¸ä¸ªæ´å¥½çèµ·ç¹ï¼å ä¸ºä½ ä¼ä»ä½ è¦è¯æçå¬å¼å¼å§ï¼æåä½ ä¼å¾å°trueãç¶èï¼æ ¹æ®æçç»éªï¼æåç°è®¸å¤åå­¦èè¢«<==çæ¹åæç³æ¶äºï¼ä»ä»¬æè®¡ç®åå¾å¥½åä»ä»¬æ¯å¨==>çæ¹åä¸ãç¨ä»»ä½å¯¹ä½ ææä¹çæ¹åã\n\n\n# æç®è¯æ\n\nè¯æè®¡ç®æ¯ä¸ç§æé è¯ææ­¥éª¤çæ¹æ³ãå®éå¸¸åå«æ¯éªè¯èéè¦çæ´å¤çä¿¡æ¯ï¼ç¹å«æ¯å¦ææ¨ä¸ºäºèªå·±çå©çï¼å°è¯æåå¨å°çæ­¥éª¤ä¸­ãå¦æä½ è®¤ä¸ºä¸ä¸ªè¯ææå¤ªå¤çç»èï¼ä½ å¯ä»¥å é¤ä¸äºä¸éè¦çä¸è¥¿ãè¿æ¯å¦æ¯ä¸ªå¥½ä¸»æââæèï¼ä»ä¹æ¶åæ¯ä¸ªå¥½ä¸»æï¼å é¤å¤å°åå®¹ââä¸»è¦åå³äºä¸ªäººåå¥½ãå¦ææ¨ç¨åååå°è¯æï¼é¢å¤çç»èå¯è½ä¼æä¾æç¨çææ¡£ï¼è¯´æè¯ææåæ¯å¦ä½æé çã\n\nå¦æä½ æ³åå°ä¸é¢çè¯æè®¡ç®ä¸­çæç¤ºï¼ä½ å¯è½è¦åçç¬¬ä¸ä»¶äºæ¯å é¤ä½ä¸ºè¯æçä¸é¨åçä¸¤ä¸ªassertè¯­å¥ï¼æèè³å°å é¤æ­è¨c <= xãä½æ¯ä½ å¯ä»¥åçæ´å¤ã\n\néè¿åé¢çè®¡ç®ï¼æä»¬å¯ä»¥å¾å®¹æå°çå°ä½¿ç¨äºåªäºå¼çï¼æ´éè¦çæ¯ï¼è¿äºå¼çå®ä¾åäºåªäºå¼ãä¸æ¦ä½ ç¥éäºè¿ä¸ç¹ï¼ä½ å°±å¯ä»¥å®å¨ä¸ç¨è®¡ç®è¯æäºãæ´ä¸ªè¯ææ¯è¿æ ·ç:\n\nlemma minimalproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  monotonicity(c, x);\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ç»æåæ­è¨\n\nä¸ºäºè¯´æè¿ä¸ç¹ï¼ä¸åcalcè¯­å¥çè®¡ç®è¯ææ¯æççãè¿æ¯å®çèµ·æ¥çæ ·å­:\n\nlemma assertproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  diagonalidentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nè¿åç»è¯­å¥ä¸­çæ¯ä¸ç»é½å¯¹åºäº[1]è(http://leino.science/papers/krml276.html#sec-calc)è®¡ç®ä¸­çä¸ä¸ªæ­¥éª¤ãå¨è¿ä¸ªæ­¥éª¤è¯æçç­å¼æä¸ç­å¼çæ­è¨ä¹åï¼calcè¯­å¥çæç¤ºæ¯ä»ä¹?éªè¯èç¶åæåä¸ªç»è®ºç²å¨ä¸èµ·æ¥è¯æå¼ççåç½®æ¡ä»¶ã\n\n\n# ä½ç¨å\n\n[1]è(http://leino.science/papers/krml276.html#sec-calc)ä¸­çcalcè¯­å¥ä¸[4]è(http://leino.science/papers/krml276.html#sec-linear-asserts)ä¸­çæåçassertè¯­å¥ä¹é´å­å¨å·®å¼ãä¸åä¹å¤å¨äºï¼è®¡ç®ä¸­çæ¯ä¸ä¸ªæç¤ºå¯¹äºè¯ææ­¥éª¤æ¥è¯´é½æ¯å±é¨çãä¹å°±æ¯è¯´ï¼æç¤ºçä½ç¨åå°±æ¯æ­¥éª¤æ¬èº«ãä¾å¦ï¼åè®¾æ¨å°1é¨åä¸­calcè¯­å¥çæææç¤ºç§»å¨å°ç¬¬ä¸ä¸ªè¯ææ­¥éª¤ãç¶åï¼ä¸¤ä¸ªè¯ææ­¥éª¤å°ä¸åéªè¯:\n\ncalc {\n  f(a, f(b, c));\n==  { associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; monotonicity(c, x);\n      diagonalidentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nä¹å°±æ¯è¯´ï¼å¨ç¬¬ä¸æ­¥ä¸­è°ç¨æç¤ºä¸­çä¸ä¸ªå¼çæè·å¾çä¿¡æ¯ä¸ä¼å½±åå°å¶ä»æ­¥éª¤ãç¸åï¼å¦æä½ æ¶éå¼çä¸»ä½å¼å§çæç¤ºï¼åä¸ªç­å¼åä¸ç­å¼å°±å¯ä»¥å¾å¥½å°éªè¯:\n\n// hints\nassociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; monotonicity(c, x);\ndiagonalidentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nä½ å¯ä»¥æcalcè¡¨è¿°çæ¯ä¸æ­¥é½çä½æ¯ä¸ä¸ªå¼çï¼å¼ççè¯æå°±æ¾å¨è¿ä¸æ­¥çæç¤ºéãè¿å¨ç¼åè¯ææ¶å¾éè¦ï¼ä¸ä»å ä¸ºå®åè¯äººç±»è¯»èæä¸ªæç¤ºéç¨äºç¹å®çè¯ææ­¥éª¤ï¼è¿å ä¸ºå®éå¶äºéªè¯èåºç¨æç¤ºçèå´ãå¯¹äºå¤æçè¯æï¼è¿å¨å®è·µä¸­ä¼äº§çå¾å¤§çä¸åï¼å ä¸ºéªè¯èå¯è½ä¼è¢«å¤ªå¤çä¿¡æ¯âå¼ç³æ¶âââè¿è¡¨ç°ä¸ºéªè¯èçæ§è½å·®ææäºâè´è¶æåºâ[2]ã\n\næ»ä¹ï¼å¨è¯æä¸­åºåæç¤ºæ¯å¾å¥½çãcalcè¯­å¥å¨è¿æ¹é¢åå¾å¾å¥½ï¼ä½ä½ ä¹å¯ä»¥ç¨assertè¯­å¥çå½¢å¼æ¥åãä¸é¢æä»¬æ¥çä¸ä¸ã\n\n\n# æ­è¨\n\nassert e;è¡¨è¿°äºä¸ä»¶äº:\n\n 1. å®è¡¨æä½ æææ¡ä»¶eæç«\n 2. å®è¦æ±éªè¯èè¯æe 3.å®è®©åé¢çæ­è¨åè®¾e\n\næ¨å¯è½æ²¡æèèè¿å°æ­è¨çè¿ä¸ä¸ªæ¹é¢åå¼ï¼ä½æ¯è¿æ ·åå¾æç¨ï¼å ä¸ºdafnyæä¾äº(1)å(2)çæ¿ä»£æ¹æ¡ã\n\nè¯¥å£°æ\n\nassert e by { hint }\n\n\n1\n\n\næ¹åæ¹é¢(1)è¯´eæ¯å¨ç»å®çæç¤ºä¸è¢«è¯æçï¼å¶ä¸­hintæ¯ä¸ä¸ªå½é¢ãæç¤ºçä½ç¨ååªæ¯æ­è¨æ¬èº«ï¼æä»¥å®å¨æ­è¨çä¸æ¸¸ä¸å¯ç¨ãè¿æ ·ï¼assert byè¯­å¥ç­ä»·äº:\n\ncalc {\n  e;\n==  { hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\næä»¬å¯ä»¥ä½¿ç¨assert byéå4é¨åçè¯æ:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nè¿æä¾äºæ´å¥½çååºï¼ä»èæ´ç´æ¥å°è¡¨è¾¾äºä¸ºä»ä¹æ¯ä¸ªæ­è¨çæ¡ä»¶ä¿æä¸åã\n\n\n# ååæ¾æ§è¯æ\n\n6é¨åä¸­çè¯æåå«ä¸¤ä¸ªæ­è¨ï¼å®ä»¬éç³äºå¨åç½®æ¡ä»¶ä¸­æåçåå®¹ãè¿äºæ­è¨èåçææ³æ¯æç¡®ä½¿ç¨è¿äºåå³æ¡ä»¶çå°æ¹ãç¶èï¼è¿æä¸¤ä¸ªç¼ºç¹ã\n\nä¸ä¸ªç¼ºç¹æ¯ï¼å¿é¡»å°æ­è¨ä¸­çè¡¨è¾¾å¼ä¸è¯æä¸­çå¶ä»è¡¨è¾¾å¼è¿è¡æ¯è¾ï¼æè½æè¯å°æ­è¨åªæ¯å¨éç³ä¸ä¸ªä»¥åå¯ç¨çåè®¾ãå¦ææä»¬å¯ä»¥æ è®°æ¡ä»¶ï¼ç¶åå¼ç¨æ ç­¾ï¼é£å°±å¥½äºã\n\nå¦ä¸ä¸ªç¼ºç¹æ¯ï¼æ è®ºæ¯å¦å¨æ­è¨ä¸­éè¿°æ¡ä»¶ï¼åææ¡ä»¶é½æ¯å¯ç¨çãå¦ææä»¬å¿è®°ç¼åæ­è¨(å¯è½æ¯å ä¸ºæä»¬æ²¡ææè¯å°æä»¬ä¾èµäºè¿ä¸ªæ¡ä»¶)ï¼æèå¦ææä»¬æå¤å°ç¼åäºéè¯¯çåææ¡ä»¶ï¼é£ä¹è¯æä»ç¶ææãä¹å°±æ¯è¯´ï¼éªè¯å¨å·²ç»è½å¤ä½¿ç¨åç½®æ¡ä»¶ï¼æä»¥å®ä¸å³å¿ä½ æ¯éè¿°æ¡ä»¶ï¼è¿æ¯éè¿°ä¸ä¸ªä¸åç(ç)æ¡ä»¶ï¼æèä»ä¹ä¹ä¸éè¿°ãå¦ææä»¬è½æ´æç¡®å°è¯´æè¿äºåè®¾çèå´ï¼é£å°±å¤ªå¥½äºã\n\nè¿æä¸ç§å½¢å¼çæ­è¨byè¯­å¥ãå®æ¾æ¾äº[6]é¨å(http://leino.science/papers/krml276.html#sec-assert-by)çaspect(2)ãè¿ä¸ªè¡¨åçèµ·æ¥åè¿æ ·:\n\nassert label: e { hint }\n\n\n1\n\n\nè¿ä¸ªææ è®°çæ­è¨è¯­å¥è¡¨ç¤ºä½ æææ¡ä»¶eæç«ï¼å®æä¾äºä¸ä¸ªæç¤ºè¯­å¥ä½ä¸ºeçè¯æãå¨æ¡ä»¶åä½¿ç¨æ ç­¾ä¼æå¶âeâä½ä¸ºä¸æ¸¸åè®¾çä½¿ç¨ã\n\nä¾å¦ï¼è¦è¯æf(12,12) == 12ï¼éè¦ä½¿ç¨diagonalidentityå¬çãå¦æä½ ä½¿ç¨å¸¦æ ç­¾çassert byæ¥è¯æè¿ä¸ªäºå®ï¼é£ä¹å¨å¸¦æ ç­¾çassertä¹åï¼è¢«è¯æçäºå®ä»ç¶ä¸å¯ç¨:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nå¦æä½ ä¸è½ç¨ä½ è¯æçäºå®ï¼ä¸ºä»ä¹è¦ç¨è¿ç§è¯´æ³å¢?å¥½å§ï¼æåºè¯¥è¯´äºå®å¨æ è®°çæ­è¨ä¹åä¸æ¯âèªå¨âå¯ç¨çãä½æ¯æ¨å¯ä»¥æç¡®å°è¯·æ±å®ãä½ å¯ä»¥ç¨âæ­ç¤ºâå£°ææ¥åå°è¿ä¸ç¹ï¼å¨å£°æä¸­ä½ æå°äºæ ç­¾ã\n\nä¸é¢åæ¯ä¸ä¸ªä¾å­ï¼ä½å¸¦æârevealâè¯­å¥:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nreveal label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nä½ å¯ä»¥å¨åææ¡ä»¶ä¸ä½¿ç¨åæ ·çæå·§ãä¹å°±æ¯è¯´ï¼éå¸¸å¨å¼ç(ææ¹æ³æå½æ°)ä¸­ï¼æ¯ä¸ä¸ªåå³æ¡ä»¶\n\nrequires e\n\n\n1\n\n\nå¨å¼ççæ´ä¸ªæ­£æä¸­é½æãä½å¦æä½ ç»å®è´´ä¸æ ç­¾ï¼ä½ å°±å¿é¡»ä½¿ç¨âæ­ç¤ºâè¯­å¥æ¥å¼åºè¿ä¸ªåè®¾:\n\nrequires label: e\n\n\n1\n\n\nå¨æä»¬çå°å®çå®éåºç¨ä¹åï¼è®©æåè°è°æ ç­¾ãdafnyä¸­çæ ç­¾å¯ä»¥æ¯ä»»ä½æ è¯ç¬¦ï¼ä½å®ä¹å¯ä»¥æ¯ææ¬ä¸çèµ·æ¥åæ°å­å­é¢éçä¸è¥¿ãä»¥ä¸æ¯äºä¸ªæ ç­¾ç¤ºä¾:\n\nmylabel    label57    l57    57    000_057\n\n\n1\n\n\nè¿æ¯äºä¸ªä¸åçæ ç­¾ââäºå®ä¸ï¼â57âåâ000_057âä½ä¸ºæ°å­å­é¢éè¡¨ç¤ºç¸åçæ°å­ï¼å¹¶ä¸æå³çå®ä»¬æ¯ç¸åçæ ç­¾ãå¦æå®ä»¬å¨å°å·é¡µä¸çèµ·æ¥ä¸ä¸æ ·ï¼å®ä»¬å°±æ¯ä¸åçæ ç­¾ã(å¯¹äºç±»ä¸­çå­æ®µåãæ°æ®ç±»åçææå½æ°åå¶ä»ç±»åæåä¹æ¯å¦æ­¤ï¼å®ä»¬ä¹å·æåè®¸çèµ·æ¥åæå­çæ è¯ç¬¦çæ©å±è¯­æ³ã)\n\nå¥½äºï¼ç°å¨æä»¬åå¤å¨è¿è¡çä¾å­ä¸­ä½¿ç¨å¸¦æ ç­¾çæ­è¨:\n\nlemma differentstyleofproof(a: int, b: int, c: int, x: int)\n  requires a: c <= x\n  requires b: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal b;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal a; }\n    monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    diagonalidentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nå¨è¿ç§ç±»åçè¯æä¸­(å¨ä¸äºé»è¾å­¦ææ¬ä¸­å¾å¸¸è§)ï¼æ¯ä¸ªæ­è¨é½éè¿å¶ç¸å³æ§æ¾å¼å°è¯æãå¦ææ¨è®¤ä¸ºæ­è¨ä¹é´çä¾èµå³ç³»ææäºä¸ä¸ªè¯ædagï¼é£ä¹è¿ç§è¯æé£æ ¼å°±æ¯å¯¹dagä¸­çç¥åè¿è¡æ¾å¼çè¯æãæ¨å¯ä»¥ä½¿ç¨åµå¥çassert byè¯­å¥åæ è®°çæ­è¨çå±æ¬¡ç»ææ¥è¿ä¼¼lamporté£æ ¼çè¯æ[1]ã\n\n\n# æ»ç»\n\næ ¡æ ·çåä½é£æ ¼æå¾å¤ç§ãæç®åçè¯ææ¯é£äºèªå¨å®æçï¼ä¸éè¦è¿ä¸æ­¥è¯æçè¯æãå¶ä»ç®åçè¯æéè¦ä¸ä¸ªæ­è¨æå¼çãè¯ææ­¥éª¤å¯ä»¥ä½¿ç¨calcè¯­å¥åassert byè¯­å¥ç»ç»ãéè¿æ è®°ä¸ä¸ªâassert byâè¯­å¥æä¸ä¸ªåç½®æ¡ä»¶ï¼è¿ä¸ªæ¡ä»¶å¨è¯æä¸­è¢«æå¶äºï¼ç´å°ä½ ä½¿ç¨ä¸ä¸ªârevealâè¯­å¥æç¡®å°è¯·æ±å®åæ¥ã\n\næé è¯ææ¯ä¸ä¸ªå¥½ä¸»æï¼ä¸ºäºå¯è¯»æ§åæ¸æ°åº¦ï¼ä»¥åæ¹åæºæ¢°è¯ææ§è½ãä½ å¯ä»¥æä¸ä¸ªè¯æå½é¢æ³è±¡ææä¸äºè¾å¥æ¡ä»¶ãè¿äºæ¯è¯æè¯­å¥ä¸ä¸æä¸­å¯ç¨çæ¡ä»¶åæ ç­¾ãè¯æè¯­å¥çè¾åºæ¯calcè¯­å¥çç¬¬ä¸è¡åæåä¸è¡çä¼ éè¿æ¥ï¼æ æ è®°çassertæassert byè¯­å¥ä¸­çæ¡ä»¶ï¼ä»¥åææ è®°çæ­è¨çæ ç­¾ã\n\n\n# åèæç®\n\n[0]edsger w. dijkstra and w. h. j. feijen. a method of programming. addison-wesley, july 1988. ð\n\n[1]leslie lamport. how to write a 21st century proof. technical report, microsoft research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. ð\n\n[2]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361â381. springer, 2016. ð\n\n[3]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments â 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170â190. springer, 2014. ð",charsets:{cjk:!0},lastUpdated:"2022/03/27, 00:29:25",lastUpdatedTimestamp:1648312165e3},{title:"éååç´ ä¸çå½æ°",frontmatter:{title:"éååç´ ä¸çå½æ°",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/67167e/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/6.%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%B8%8A%E7%9A%84%E5%87%BD%E6%95%B0.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/6.éååç´ ä¸çå½æ°.md",key:"v-523d0d4e",path:"/pages/67167e/",headers:[{level:2,title:"å¯¹éåçåç´ æ±å",slug:"å¯¹éåçåç´ æ±å",normalizedTitle:"å¯¹éåçåç´ æ±å",charIndex:217},{level:2,title:"æ±åçéå½å®ä¹",slug:"æ±åçéå½å®ä¹",normalizedTitle:"æ±åçéå½å®ä¹",charIndex:570},{level:2,title:"ä¸åæ ¼è¯æ",slug:"ä¸åæ ¼è¯æ",normalizedTitle:"ä¸åæ ¼è¯æ",charIndex:937},{level:2,title:"éæ©å¶ä»ä¸è¥¿",slug:"éæ©å¶ä»ä¸è¥¿",normalizedTitle:"éæ©å¶ä»ä¸è¥¿",charIndex:1410},{level:2,title:"åèéæ©",slug:"åèéæ©",normalizedTitle:"åèéæ©",charIndex:2398},{level:2,title:"Let such that",slug:"let-such-that",normalizedTitle:"let such that",charIndex:3362},{level:2,title:"å¤ç§éæ©",slug:"å¤ç§éæ©",normalizedTitle:"å¤ç§éæ©",charIndex:4620},{level:2,title:"æ»ç»",slug:"æ»ç»",normalizedTitle:"æ»ç»",charIndex:5353}],headersStr:"å¯¹éåçåç´ æ±å æ±åçéå½å®ä¹ ä¸åæ ¼è¯æ éæ©å¶ä»ä¸è¥¿ åèéæ© Let such that å¤ç§éæ© æ»ç»",content:"# éååç´ ä¸çå½æ°\n\n> K. Rustan M. Leino Manuscript KRML 274, 16 February 2020\n\næè¦ å¨èªç¶è¯­è¨ä¸­ï¼åâä¸ç»æ°å­çåâè¿æ ·çç­è¯­å¾å®¹æè¯´åçè§£ãå¨æ­£å¼è®¾ç½®ä¸­å®ä¹åä½¿ç¨è¿äºå½æ°éè¦æ´å¤çå·¥ä½ãè¿ä¸ªé®é¢ä¸éå½å®ä¹çå½æ°å¦ä½ä»éåä¸­éåä¸ä¸ä¸ªåç´ æå³ãæ¬ææè¿°äºä¸ä¸ªå·æä»£è¡¨æ§çä¾å­ï¼å¹¶æè¿°äºå¦ä½ä½¿æ­£å¼çç¹æç¼èåæ¥ä½ç¨ãè¯¥è§£å¯åºç¨äºéåä¸çä»»ä½äº¤æ¢è¿ç®åç»åè¿ç®ã\n\n\n# å¯¹éåçåç´ æ±å\n\nåè®¾æä»¬æä¸ä¸ªå½æ°ï¼å®è¿åéåä¸­æææ´æ°çå:\n\nfunction Sum(s: set<int>): int\n\n\n1\n\n\nå¦ææä»¬æä¸ä¸ªåç´ yå å°ä¸ä¸ªéåä¸­ï¼æä»¬ææå®çåå¢å yãä¹å°±æ¯è¯´ï¼æä»¬å¸ææ­£ç¡®å®ç°ä»¥ä¸æ¹æ³:\n\nmethod AddElement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == Sum(s) && y !in s\n  ensures t == s + {x} && b == Sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\näºå®è¯æï¼è¯æä¸æ¯èªå¨çãè®©æä»¬ççç»èå¹¶å¡«åè¯æã\n\n\n# æ±åçéå½å®ä¹\n\nå½æ°âSumâæ¯éå½å®ä¹çãç©ºéåçåä¸º0ãå¦æéåéç©ºï¼éæ©å¶ä¸­ä¸ä¸ªåç´ ï¼æ¯å¦xãç¶åï¼å¨éå½è®¡ç®çå©ä½åç´ çåä¸å ä¸xã\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nè¿ä¸ªå®ä¹ä½¿ç¨äºä¸ä¸ªå½æ°Pickï¼å®è¿åç»å®éåä¸­çä»»æåç´ ãä»¥ä¸æ¯å®çå®ä¹:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\næå¾ä¼åè®²Pickãæ­¤æ¶æ¨éè¦äºè§£çæ¯ï¼Pickçè°ç¨èæ æ³æ§å¶è¿åsä¸­çåªä¸ªåç´ ã\n\n\n# ä¸åæ ¼è¯æ\n\nä¸ºäºè¯æAddElementï¼æä»¬éè¦è¯æb == Sum(t)å¨å®çæç»ç¶ææ¯æç«çãåé¡¾ä½ä¸ï¼è¿æå³çæä»¬éè¦å±ç¤º\n\na + y == Sum(s + {y})\n\n\n1\n\n\nå¨åå§ç¶æãç±äºaæ¯Sum(s)ï¼æä»¬çè¯æä¹å¡å¯ä»¥å½ç»ä¸º\n\nSum(s) + y == Sum(s + {y})\n\n\n1\n\n\næä»¬å·²ç¥yä¸å¨sä¸­ã\n\nåè®¾Pick(s + {y})è¿åyãç¶å,æä»¬æ\n\n  Sum(s + {y});\n==  // def. Sum\n  var x := Pick(s + {y}); x + Sum(s + {y} - {x});\n==  // using the assumption Pick(s + {y}) == y\n  y + Sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + Sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿å¾ç®åä¹å¾ç´æ¥ãä½å¯¹äºè¿ä¸ªè¯æï¼æä»¬åè®¾å¯¹Pickçç¸å³è°ç¨è¿åäºyãå¦æPickè¿åä¸sä¸åçåç´ æä¹å?\n\n\n# éæ©å¶ä»ä¸è¥¿\n\nå¨ä½ æè¯å°âæéâå¯ä»¥éæ©ä¸ä¸ªä¸åäºä½ ææ³çåç´ ä¹åï¼ä¹äºå¼å§æ£å»ãæä»¬éè¦çæ¯ä¸ä¸ªå¼çï¼å®è¡¨æéæ©æ¯æ å³ç´§è¦çãä¹å°±æ¯è¯´ï¼å¼çä¼è®©æä»¬æâSumâçä½æ¯ï¼å¨åéå½è°ç¨æ¶ï¼æä»¬æå®çä¸ä¸ªåç´ ã\n\nè¿å°±æ¯é£ä¸ªå¼çãè¿ä¸ªè¯æä¸å¼å§ä¹æç¹æ£æãå½æ ¹å°åºå°±æ¯è®©âPickâéæ©å®æéæ©çä»»ä½åç´ ï¼ç¶åå¯¹âSumâéå½çæ´å°çéååºç¨å½çº³åè®¾ã\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x := Pick(s);\n  if y == x {\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\næè¯´è¿ä¸ªå¼ççèµ·æ¥åSumçè¡¨è¾¾å¼ï¼æä»¥Sumçä¸¤ä¸ªåæ°æ¯sås - {y}ãæèï¼æä»¬å¯ä»¥ç¨s + {y}åsæ¥è°ç¨Sumæ¥å£°æè¯¥å±æ§ãè¿ä¸ªéæ©æ¯ä¸è¿°å¼ççä¸ä¸ªç®åæ¨è®º:\n\nlemma AddToSum(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  SumMyWay(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nä½¿ç¨å¼ç\n\næäºè¿ä¸ªæç¨çå¼çï¼å°±å¾å®¹æå¾å°âAddElementâçè¯æ:å°å¶ä¸»ä½æ´æ¹ä¸º\n\nt := s + {y};\nb := a + y;\nAddToSum(s, y);\n\n\n1\n2\n3\n\n\n\n# åèéæ©\n\nå¨ä¸é¢çå¼åä¸­ï¼æå°âPickâå®ä¹ä¸ºä¸ä¸ªåç¬çå½æ°ãéè¯»ç¨åºææ¬ä¸­çåè¯âpickâå¯è½æå©äºçè§£âSumâåâSumMyWayâåä»ä¹ãä½å®æ¯ä¸ä¸ªå¦æ­¤å°çå½æ°ï¼æä»¥ä¸ºä»ä¹ä¸ç´æ¥å¨ä½¿ç¨å®çä¸¤ä¸ªå°æ¹åèå®å¢ãè®©æä»¬è¯ä¸è¯:\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to Pick\n    x + Sum(s - {x})\n}\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to Pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum        // error: this step might not hold\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nç°å¨æä»¬å¾å°ä¸¤ä¸ªéè¯¯!\n\nä¸ºäºè§£éåçäºä»ä¹ï¼è®©æå¤è¯´ä¸ç¹å³äº:|ä»¥åå®çä¸åå¯»å¸¸ä¹å¤ã\n\n\n# Let such that\n\nDafnyä¸­çlet-such-thatç»ææè¿æ ·ä¸ç§å½¢å¼\n\nvar x :| P; E\n\n\n1\n\n\nå®çè®¡ç®ç»ææ¯Eï¼å¶ä¸­xè¢«ç»å®å°æä¸ªæ»¡è¶³Pçå¼ãä¾å¦,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nè®¡ç®ç»æä¸ºâ14âãâ16âæâ18âãä½ä¸ºç¨åºåï¼ä½ æ æ³æ§å¶éæ©xçåªä¸ªå¼ãä½ä½ ä¼ç¥éä¸¤ä»¶éè¦çäºãä¸æ¯xå°è¢«éä¸ºæ»¡è¶³Pçå¼ã(å¦æDafnyéªè¯å¨ä¸è½è¯æè¿æ ·çå¼å­å¨ï¼åä¼ç»åºä¸ä¸ªéè¯¯ã)å¦ä¸ç§æ¹æ³æ¯ï¼æ¯æ¬¡ä½¿ç¨ç¸åçè¾å¥å¯¹è¡¨è¾¾å¼æ±å¼æ¶ï¼é½å°å¾å°ç¸åçå¼ãæ¢å¥è¯è¯´ï¼è¿ä¸ªç®å­æ¯ç¡®å®æ§çã\n\nä¸é¢æ¯å¦ä¸ä¸ªå³äºå³å®è®ºçä¾å­:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nè¿ä¸ªè¡¨è¾¾å¼éæ©xä¸ºæå°çä¸ä¸ªç´ æ°ä¹ä¸(2ã3æ5)ï¼ç¶åè¿åå®ãæ¨ä¸ç¥éæ¨å¾å°çæ¯è¿ä¸ä¸ªå¼ä¸­çåªä¸ä¸ªï¼ä½æ¨å¯ä»¥ä¿è¯æ¯æ¬¡å¨ç¨åºçä¸æ¬¡è¿è¡ä¸­è®¡ç®è¿ä¸ªè¡¨è¾¾å¼æ¶ï¼æ¨å°å¾å°ç¸åçå¼ã\n\nè®©æä»¬æ´åç¡®å°çè§£ææè¯´çâè¿ä¸ªè¡¨è¾¾âãå¨Dafnyä¸­ï¼let-such-thatè¡¨è¾¾å¼çæ¯ä¸ä¸ªâææ¬åºç°âé½å¯ä»¥ååºèªå·±çéæ©ãèèè¿ä¸ªé®é¢çä¸ç§æ¹æ³æ¯éåç¨åºçææ¬ï¼å¹¶ç¨å¯ä¸çé¢è²ä¸ºæ¯ä¸ª:|æä½ç¬¦çè²ãç¶åï¼ä½ å¯ä»¥ä¾èµäºç¸åçéé¡¹ï¼åªæå½å®ä»¬ç±ç¸åé¢è²ç:|æ§è¡æ¶ã\n\nè¿éæä¸ä¸ªè¯´ææ§çä¾å­ã\n\nlemma Choices(s: set<int>)\n  requires s != {}\n{\n  var a := Pick(s);\n  var b := Pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nèµç»aåbçç¬¬ä¸ä¸ªå¼æ¥èªç¸åç:|æä½ç¬¦ãå®ä»¬æ¯ç¸åé¢è²éæ©çç»æãå æ­¤ï¼å®ä»¬è¢«è®¤ä¸ºæ¯ç¸åçãç¸åï¼èµç»aåbçä¸ä¸ä¸ªå¼æ¥èªä¸åç:|æä½ç¬¦ââä¸åé¢è²çæä½ç¬¦ãå æ­¤ï¼æ¨ä¸è½ç¡®å®âaâåâbâæ¯ç¸ç­çã\n\nå®éä¸ï¼å¦æä½ å¤æ³ä¸ç¹(æèå°æ³ä¸ç¹)ï¼ä½ å°±ä¼æè¯å°ï¼æä»¬ç¥éèµç»aåbçç¬¬ä¸ä¸ªå¼æ¯ç¸ç­çï¼å³ä½¿ä¸ç¥éPickçä»»ä½åå®¹ãæ¯ç«ï¼Pickæ¯ä¸ä¸ªå½æ°ï¼å¦æä½ å¯¹ç¸åçåæ°è°ç¨ä¸ä¸ªå½æ°ä¸¤æ¬¡ï¼å®ä¼è¿åç¸åçå¼ãæ°å­¦ä¿è¯äºè¿ä¸ç¹ï¼Dafnyä¹æ¯å¦æ­¤ãé£ä¹ï¼å¯¹aåbçç¬¬äºä¸ªèµå¼å¢;é£äºè¡¨è¾¾å¼ä¸­ç:|æä½ç¬¦ä¸ä¹æ¯å½æ°å?æ¯çï¼å®ä»¬æ¯ï¼ä½å®ä»¬æ¯ä¸åçåè½ãå®ä»¬æ¯ä¸åé¢è²çå½æ°ï¼ä»¥æ­¤ç±»æ¨ãåªè¦ä½ æç¨åºä¸­åºç°çæ¯ä¸ä¸ª:|çä½æ¯ä¸ä¸ªä¸åçå½æ°ï¼é£ä¹ææçæ°å­¦è¿ç®å°±ä¼å¦ä½ æææçé£æ ·ã\n\nè¿å°±æ¯ä¸ºä»ä¹æå¯ä»¥æ´å®¹æå°æè¿°âSumâçæåµï¼å¦ææå¯ä»¥ä½¿ç¨ä¸ä¸ªâðâãä¸ºäºéç¨ç¸åç:|ï¼ææå®æ¾å¨ä¸ä¸ªå½æ°ä¸­ï¼æå½åä¸ºPickãæå»ºè®®ä½ ååæ ·çäºæå¦æä½ å¨å¤çæ¶åå°ä½ æ³è¦è¯æå±æ§çéæ©çå¹½çµå½æ°ã\n\n\n# å¤ç§éæ©\n\nå¨çè§£è¿äºé®é¢ä¹åï¼å¦æä½ è¯å¾å®ä¹âSumâå¹¶å¨âAddElementâä¸­ä½¿ç¨å®ï¼ä½ ä¼æå°å°æãç°å¨ï¼æ¨ç¥éåç¬å°:|æ¾å¥å½æ°ä¸­æ´å®¹æï¼å¹¶ä¸æ¨ç¥éæ¨éè¦ç¼åä¸ä¸ªç±»ä¼¼SumMyWayçå¼çãæ¨å¯è½ä¼å¥½å¥ï¼å¦ææ²¡æPickå½æ°ï¼æ¯å¦å¯ä»¥åå°è¿ä¸ç¹ãä¹å°±æ¯è¯´ï¼ä½ å¯è½æ³ç¥éæ¯å¦æä»»ä½æ¹æ³å¯ä»¥å¨Sumä¸­ä½¿ç¨ä¸ä¸ª:|æä½ç¬¦ï¼å¨SumMyWayä¸­ä½¿ç¨å¦ä¸ä¸ª:|æä½ç¬¦ãæ¯çï¼è¿æ¯å¯è½çãææ¥æä½ æä¹åã\n\nåè®¾æä»¬å¨å½æ°Sumä¸­åèPickãä¹å°±æ¯è¯´ï¼åè®¾æä»¬åä¸é¢4èé£æ ·å®ä¹âSumâãå¨é£ä¸èä¸­ï¼ææå°ï¼å¦æä½ ä¹åèPickå¨SumMyWayï¼ä½ ä¼å¾å°ä¸äºéè¯¯ãè¿ä¸¤ä¸ªéè¯¯é½æ¯å ä¸ºâSumâåâSumMyWayâååºäºä¸åçéæ©ãä½æä»¬å¯ä»¥å¨å¼çä¸­æ´å·ä½ä¸äºï¼å¼ºå¶å®éæ©ä¸Sumä¸­éæ©çåç´ ç¸åçåç´ ã\n\nä½ å¯ä»¥è¿æ ·åï¼ä½ æ³è®©xä¸åªæ¯å¨sä¸­ï¼èæ¯ä¸ä¸ªå¼\n\nSum(s) == x + Sum(s - {x})\n\n\n1\n\n\næ²¡éãåªæä¸ä¸ªè¿æ ·çxå­å¨ï¼å®æ¯ç±âSumâéæ©çãæä»¥ï¼å¦æä½ è¿æ ·åå¼ç:\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s && Sum(s) == x + Sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç¶åéªè¯!ç¥éè¿ä¸ç¹å¾å¥½ï¼ä½æ¯å¨ä½ ç:|å¨å´å¼å¥Pickå½æ°ä¼¼ä¹æ´å¹²åã\n\n\n# æ»ç»\n\næ³¨æï¼ç¨åºä¸­åºç°çæ¯ä¸ä¸ª:|ææ¬é½æ¯ä¸ä¸ªä¸åçå½æ°ãå¦æä½ å°å®æ´åå°ä¸ä¸ªä½ å½åçå½æ°ä¸­ï¼ä½ å°æ´å®¹æä½¿ç¨:|ï¼å ä¸ºè¿æ ·ä½ å°±åå°äºå ä¸ºä¸åç§ç±»(ä¸åâé¢è²â)çéæ©èæå°å°æçæºä¼ã\n\nå¦å¤ï¼è¯·æ³¨æ:|æåçéæ©å¯è½ä¸æ¯æ¨éè¦çéæ©ãä½ å¯è½æ³è¦è¯æä¸ä¸ªå¼çï¼å®è¯´ä»»ä½éæ©æåé½ä¼å¾å°ç¸åçç»æãä½¿ç¨ä¸é¢çâSumMyWayâå¼çä½ä¸ºä½ çè¯ææ¨¡æ¿ã",normalizedContent:"# éååç´ ä¸çå½æ°\n\n> k. rustan m. leino manuscript krml 274, 16 february 2020\n\næè¦ å¨èªç¶è¯­è¨ä¸­ï¼åâä¸ç»æ°å­çåâè¿æ ·çç­è¯­å¾å®¹æè¯´åçè§£ãå¨æ­£å¼è®¾ç½®ä¸­å®ä¹åä½¿ç¨è¿äºå½æ°éè¦æ´å¤çå·¥ä½ãè¿ä¸ªé®é¢ä¸éå½å®ä¹çå½æ°å¦ä½ä»éåä¸­éåä¸ä¸ä¸ªåç´ æå³ãæ¬ææè¿°äºä¸ä¸ªå·æä»£è¡¨æ§çä¾å­ï¼å¹¶æè¿°äºå¦ä½ä½¿æ­£å¼çç¹æç¼èåæ¥ä½ç¨ãè¯¥è§£å¯åºç¨äºéåä¸çä»»ä½äº¤æ¢è¿ç®åç»åè¿ç®ã\n\n\n# å¯¹éåçåç´ æ±å\n\nåè®¾æä»¬æä¸ä¸ªå½æ°ï¼å®è¿åéåä¸­æææ´æ°çå:\n\nfunction sum(s: set<int>): int\n\n\n1\n\n\nå¦ææä»¬æä¸ä¸ªåç´ yå å°ä¸ä¸ªéåä¸­ï¼æä»¬ææå®çåå¢å yãä¹å°±æ¯è¯´ï¼æä»¬å¸ææ­£ç¡®å®ç°ä»¥ä¸æ¹æ³:\n\nmethod addelement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == sum(s) && y !in s\n  ensures t == s + {x} && b == sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\näºå®è¯æï¼è¯æä¸æ¯èªå¨çãè®©æä»¬ççç»èå¹¶å¡«åè¯æã\n\n\n# æ±åçéå½å®ä¹\n\nå½æ°âsumâæ¯éå½å®ä¹çãç©ºéåçåä¸º0ãå¦æéåéç©ºï¼éæ©å¶ä¸­ä¸ä¸ªåç´ ï¼æ¯å¦xãç¶åï¼å¨éå½è®¡ç®çå©ä½åç´ çåä¸å ä¸xã\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := pick(s);\n    x + sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nè¿ä¸ªå®ä¹ä½¿ç¨äºä¸ä¸ªå½æ°pickï¼å®è¿åç»å®éåä¸­çä»»æåç´ ãä»¥ä¸æ¯å®çå®ä¹:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\næå¾ä¼åè®²pickãæ­¤æ¶æ¨éè¦äºè§£çæ¯ï¼pickçè°ç¨èæ æ³æ§å¶è¿åsä¸­çåªä¸ªåç´ ã\n\n\n# ä¸åæ ¼è¯æ\n\nä¸ºäºè¯æaddelementï¼æä»¬éè¦è¯æb == sum(t)å¨å®çæç»ç¶ææ¯æç«çãåé¡¾ä½ä¸ï¼è¿æå³çæä»¬éè¦å±ç¤º\n\na + y == sum(s + {y})\n\n\n1\n\n\nå¨åå§ç¶æãç±äºaæ¯sum(s)ï¼æä»¬çè¯æä¹å¡å¯ä»¥å½ç»ä¸º\n\nsum(s) + y == sum(s + {y})\n\n\n1\n\n\næä»¬å·²ç¥yä¸å¨sä¸­ã\n\nåè®¾pick(s + {y})è¿åyãç¶å,æä»¬æ\n\n  sum(s + {y});\n==  // def. sum\n  var x := pick(s + {y}); x + sum(s + {y} - {x});\n==  // using the assumption pick(s + {y}) == y\n  y + sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nè¿å¾ç®åä¹å¾ç´æ¥ãä½å¯¹äºè¿ä¸ªè¯æï¼æä»¬åè®¾å¯¹pickçç¸å³è°ç¨è¿åäºyãå¦æpickè¿åä¸sä¸åçåç´ æä¹å?\n\n\n# éæ©å¶ä»ä¸è¥¿\n\nå¨ä½ æè¯å°âæéâå¯ä»¥éæ©ä¸ä¸ªä¸åäºä½ ææ³çåç´ ä¹åï¼ä¹äºå¼å§æ£å»ãæä»¬éè¦çæ¯ä¸ä¸ªå¼çï¼å®è¡¨æéæ©æ¯æ å³ç´§è¦çãä¹å°±æ¯è¯´ï¼å¼çä¼è®©æä»¬æâsumâçä½æ¯ï¼å¨åéå½è°ç¨æ¶ï¼æä»¬æå®çä¸ä¸ªåç´ ã\n\nè¿å°±æ¯é£ä¸ªå¼çãè¿ä¸ªè¯æä¸å¼å§ä¹æç¹æ£æãå½æ ¹å°åºå°±æ¯è®©âpickâéæ©å®æéæ©çä»»ä½åç´ ï¼ç¶åå¯¹âsumâéå½çæ´å°çéååºç¨å½çº³åè®¾ã\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x := pick(s);\n  if y == x {\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\næè¯´è¿ä¸ªå¼ççèµ·æ¥åsumçè¡¨è¾¾å¼ï¼æä»¥sumçä¸¤ä¸ªåæ°æ¯sås - {y}ãæèï¼æä»¬å¯ä»¥ç¨s + {y}åsæ¥è°ç¨sumæ¥å£°æè¯¥å±æ§ãè¿ä¸ªéæ©æ¯ä¸è¿°å¼ççä¸ä¸ªç®åæ¨è®º:\n\nlemma addtosum(s: set<int>, y: int)\n  requires y !in s\n  ensures sum(s + {y}) == sum(s) + y\n{\n  summyway(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nä½¿ç¨å¼ç\n\næäºè¿ä¸ªæç¨çå¼çï¼å°±å¾å®¹æå¾å°âaddelementâçè¯æ:å°å¶ä¸»ä½æ´æ¹ä¸º\n\nt := s + {y};\nb := a + y;\naddtosum(s, y);\n\n\n1\n2\n3\n\n\n\n# åèéæ©\n\nå¨ä¸é¢çå¼åä¸­ï¼æå°âpickâå®ä¹ä¸ºä¸ä¸ªåç¬çå½æ°ãéè¯»ç¨åºææ¬ä¸­çåè¯âpickâå¯è½æå©äºçè§£âsumâåâsummywayâåä»ä¹ãä½å®æ¯ä¸ä¸ªå¦æ­¤å°çå½æ°ï¼æä»¥ä¸ºä»ä¹ä¸ç´æ¥å¨ä½¿ç¨å®çä¸¤ä¸ªå°æ¹åèå®å¢ãè®©æä»¬è¯ä¸è¯:\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to pick\n    x + sum(s - {x})\n}\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum        // error: this step might not hold\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nç°å¨æä»¬å¾å°ä¸¤ä¸ªéè¯¯!\n\nä¸ºäºè§£éåçäºä»ä¹ï¼è®©æå¤è¯´ä¸ç¹å³äº:|ä»¥åå®çä¸åå¯»å¸¸ä¹å¤ã\n\n\n# let such that\n\ndafnyä¸­çlet-such-thatç»ææè¿æ ·ä¸ç§å½¢å¼\n\nvar x :| p; e\n\n\n1\n\n\nå®çè®¡ç®ç»ææ¯eï¼å¶ä¸­xè¢«ç»å®å°æä¸ªæ»¡è¶³pçå¼ãä¾å¦,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nè®¡ç®ç»æä¸ºâ14âãâ16âæâ18âãä½ä¸ºç¨åºåï¼ä½ æ æ³æ§å¶éæ©xçåªä¸ªå¼ãä½ä½ ä¼ç¥éä¸¤ä»¶éè¦çäºãä¸æ¯xå°è¢«éä¸ºæ»¡è¶³pçå¼ã(å¦ædafnyéªè¯å¨ä¸è½è¯æè¿æ ·çå¼å­å¨ï¼åä¼ç»åºä¸ä¸ªéè¯¯ã)å¦ä¸ç§æ¹æ³æ¯ï¼æ¯æ¬¡ä½¿ç¨ç¸åçè¾å¥å¯¹è¡¨è¾¾å¼æ±å¼æ¶ï¼é½å°å¾å°ç¸åçå¼ãæ¢å¥è¯è¯´ï¼è¿ä¸ªç®å­æ¯ç¡®å®æ§çã\n\nä¸é¢æ¯å¦ä¸ä¸ªå³äºå³å®è®ºçä¾å­:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nè¿ä¸ªè¡¨è¾¾å¼éæ©xä¸ºæå°çä¸ä¸ªç´ æ°ä¹ä¸(2ã3æ5)ï¼ç¶åè¿åå®ãæ¨ä¸ç¥éæ¨å¾å°çæ¯è¿ä¸ä¸ªå¼ä¸­çåªä¸ä¸ªï¼ä½æ¨å¯ä»¥ä¿è¯æ¯æ¬¡å¨ç¨åºçä¸æ¬¡è¿è¡ä¸­è®¡ç®è¿ä¸ªè¡¨è¾¾å¼æ¶ï¼æ¨å°å¾å°ç¸åçå¼ã\n\nè®©æä»¬æ´åç¡®å°çè§£ææè¯´çâè¿ä¸ªè¡¨è¾¾âãå¨dafnyä¸­ï¼let-such-thatè¡¨è¾¾å¼çæ¯ä¸ä¸ªâææ¬åºç°âé½å¯ä»¥ååºèªå·±çéæ©ãèèè¿ä¸ªé®é¢çä¸ç§æ¹æ³æ¯éåç¨åºçææ¬ï¼å¹¶ç¨å¯ä¸çé¢è²ä¸ºæ¯ä¸ª:|æä½ç¬¦çè²ãç¶åï¼ä½ å¯ä»¥ä¾èµäºç¸åçéé¡¹ï¼åªæå½å®ä»¬ç±ç¸åé¢è²ç:|æ§è¡æ¶ã\n\nè¿éæä¸ä¸ªè¯´ææ§çä¾å­ã\n\nlemma choices(s: set<int>)\n  requires s != {}\n{\n  var a := pick(s);\n  var b := pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nèµç»aåbçç¬¬ä¸ä¸ªå¼æ¥èªç¸åç:|æä½ç¬¦ãå®ä»¬æ¯ç¸åé¢è²éæ©çç»æãå æ­¤ï¼å®ä»¬è¢«è®¤ä¸ºæ¯ç¸åçãç¸åï¼èµç»aåbçä¸ä¸ä¸ªå¼æ¥èªä¸åç:|æä½ç¬¦ââä¸åé¢è²çæä½ç¬¦ãå æ­¤ï¼æ¨ä¸è½ç¡®å®âaâåâbâæ¯ç¸ç­çã\n\nå®éä¸ï¼å¦æä½ å¤æ³ä¸ç¹(æèå°æ³ä¸ç¹)ï¼ä½ å°±ä¼æè¯å°ï¼æä»¬ç¥éèµç»aåbçç¬¬ä¸ä¸ªå¼æ¯ç¸ç­çï¼å³ä½¿ä¸ç¥épickçä»»ä½åå®¹ãæ¯ç«ï¼pickæ¯ä¸ä¸ªå½æ°ï¼å¦æä½ å¯¹ç¸åçåæ°è°ç¨ä¸ä¸ªå½æ°ä¸¤æ¬¡ï¼å®ä¼è¿åç¸åçå¼ãæ°å­¦ä¿è¯äºè¿ä¸ç¹ï¼dafnyä¹æ¯å¦æ­¤ãé£ä¹ï¼å¯¹aåbçç¬¬äºä¸ªèµå¼å¢;é£äºè¡¨è¾¾å¼ä¸­ç:|æä½ç¬¦ä¸ä¹æ¯å½æ°å?æ¯çï¼å®ä»¬æ¯ï¼ä½å®ä»¬æ¯ä¸åçåè½ãå®ä»¬æ¯ä¸åé¢è²çå½æ°ï¼ä»¥æ­¤ç±»æ¨ãåªè¦ä½ æç¨åºä¸­åºç°çæ¯ä¸ä¸ª:|çä½æ¯ä¸ä¸ªä¸åçå½æ°ï¼é£ä¹ææçæ°å­¦è¿ç®å°±ä¼å¦ä½ æææçé£æ ·ã\n\nè¿å°±æ¯ä¸ºä»ä¹æå¯ä»¥æ´å®¹æå°æè¿°âsumâçæåµï¼å¦ææå¯ä»¥ä½¿ç¨ä¸ä¸ªâðâãä¸ºäºéç¨ç¸åç:|ï¼ææå®æ¾å¨ä¸ä¸ªå½æ°ä¸­ï¼æå½åä¸ºpickãæå»ºè®®ä½ ååæ ·çäºæå¦æä½ å¨å¤çæ¶åå°ä½ æ³è¦è¯æå±æ§çéæ©çå¹½çµå½æ°ã\n\n\n# å¤ç§éæ©\n\nå¨çè§£è¿äºé®é¢ä¹åï¼å¦æä½ è¯å¾å®ä¹âsumâå¹¶å¨âaddelementâä¸­ä½¿ç¨å®ï¼ä½ ä¼æå°å°æãç°å¨ï¼æ¨ç¥éåç¬å°:|æ¾å¥å½æ°ä¸­æ´å®¹æï¼å¹¶ä¸æ¨ç¥éæ¨éè¦ç¼åä¸ä¸ªç±»ä¼¼summywayçå¼çãæ¨å¯è½ä¼å¥½å¥ï¼å¦ææ²¡æpickå½æ°ï¼æ¯å¦å¯ä»¥åå°è¿ä¸ç¹ãä¹å°±æ¯è¯´ï¼ä½ å¯è½æ³ç¥éæ¯å¦æä»»ä½æ¹æ³å¯ä»¥å¨sumä¸­ä½¿ç¨ä¸ä¸ª:|æä½ç¬¦ï¼å¨summywayä¸­ä½¿ç¨å¦ä¸ä¸ª:|æä½ç¬¦ãæ¯çï¼è¿æ¯å¯è½çãææ¥æä½ æä¹åã\n\nåè®¾æä»¬å¨å½æ°sumä¸­åèpickãä¹å°±æ¯è¯´ï¼åè®¾æä»¬åä¸é¢4èé£æ ·å®ä¹âsumâãå¨é£ä¸èä¸­ï¼ææå°ï¼å¦æä½ ä¹åèpickå¨summywayï¼ä½ ä¼å¾å°ä¸äºéè¯¯ãè¿ä¸¤ä¸ªéè¯¯é½æ¯å ä¸ºâsumâåâsummywayâååºäºä¸åçéæ©ãä½æä»¬å¯ä»¥å¨å¼çä¸­æ´å·ä½ä¸äºï¼å¼ºå¶å®éæ©ä¸sumä¸­éæ©çåç´ ç¸åçåç´ ã\n\nä½ å¯ä»¥è¿æ ·åï¼ä½ æ³è®©xä¸åªæ¯å¨sä¸­ï¼èæ¯ä¸ä¸ªå¼\n\nsum(s) == x + sum(s - {x})\n\n\n1\n\n\næ²¡éãåªæä¸ä¸ªè¿æ ·çxå­å¨ï¼å®æ¯ç±âsumâéæ©çãæä»¥ï¼å¦æä½ è¿æ ·åå¼ç:\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s && sum(s) == x + sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nç¶åéªè¯!ç¥éè¿ä¸ç¹å¾å¥½ï¼ä½æ¯å¨ä½ ç:|å¨å´å¼å¥pickå½æ°ä¼¼ä¹æ´å¹²åã\n\n\n# æ»ç»\n\næ³¨æï¼ç¨åºä¸­åºç°çæ¯ä¸ä¸ª:|ææ¬é½æ¯ä¸ä¸ªä¸åçå½æ°ãå¦æä½ å°å®æ´åå°ä¸ä¸ªä½ å½åçå½æ°ä¸­ï¼ä½ å°æ´å®¹æä½¿ç¨:|ï¼å ä¸ºè¿æ ·ä½ å°±åå°äºå ä¸ºä¸åç§ç±»(ä¸åâé¢è²â)çéæ©èæå°å°æçæºä¼ã\n\nå¦å¤ï¼è¯·æ³¨æ:|æåçéæ©å¯è½ä¸æ¯æ¨éè¦çéæ©ãä½ å¯è½æ³è¦è¯æä¸ä¸ªå¼çï¼å®è¯´ä»»ä½éæ©æåé½ä¼å¾å°ç¸åçç»æãä½¿ç¨ä¸é¢çâsummywayâå¼çä½ä¸ºä½ çè¯ææ¨¡æ¿ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å¨éåä¸è¿­ä»£",frontmatter:{title:"å¨éåä¸è¿­ä»£",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/be298d/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/00.%E5%AE%9E%E8%B7%B5%E6%8E%A2%E7%B4%A2/7.%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%8A%E8%BF%AD%E4%BB%A3.html",relativePath:"40.èµæº/00.å®è·µæ¢ç´¢/7.å¨éåä¸è¿­ä»£.md",key:"v-5ca082b2",path:"/pages/be298d/",headers:[{level:2,title:"0.âæ å°å°åºå",slug:"_0-æ å°å°åºå",normalizedTitle:"0.âæ å°å°åºå",charIndex:282},{level:2,title:"1.âèå½æ°",slug:"_1-èå½æ°",normalizedTitle:"1.âèå½æ°",charIndex:1147},{level:2,title:"2.âç¼è¯å½æ°",slug:"_2-ç¼è¯å½æ°",normalizedTitle:"2.âç¼è¯å½æ°",charIndex:1500},{level:2,title:"3.âéæ©æå°çæ´æ°",slug:"_3-éæ©æå°çæ´æ°",normalizedTitle:"3.âéæ©æå°çæ´æ°",charIndex:1838},{level:2,title:"4.âè¯æå­å¨æå°å¼",slug:"_4-è¯æå­å¨æå°å¼",normalizedTitle:"4.âè¯æå­å¨æå°å¼",charIndex:2644},{level:2,title:"5.âæ»å½ä»¤",slug:"_5-æ»å½ä»¤",normalizedTitle:"5.âæ»å½ä»¤",charIndex:3799},{level:2,title:"6.âéç¨éåä¸ºåºå",slug:"_6-éç¨éåä¸ºåºå",normalizedTitle:"6.âéç¨éåä¸ºåºå",charIndex:4753},{level:2,title:"7.âæ»å½ä»¤ææå°å¼",slug:"_7-æ»å½ä»¤ææå°å¼",normalizedTitle:"7.âæ»å½ä»¤ææå°å¼",charIndex:5440},{level:2,title:"8.âè¿åæ å°å°åºå",slug:"_8-è¿åæ å°å°åºå",normalizedTitle:"8.âè¿åæ å°å°åºå",charIndex:7315},{level:2,title:"9.âç»è®º",slug:"_9-ç»è®º",normalizedTitle:"9.âç»è®º",charIndex:7812},{level:2,title:"åèæç®",slug:"åèæç®",normalizedTitle:"åèæç®",charIndex:7855}],headersStr:"0.âæ å°å°åºå 1.âèå½æ° 2.âç¼è¯å½æ° 3.âéæ©æå°çæ´æ° 4.âè¯æå­å¨æå°å¼ 5.âæ»å½ä»¤ 6.âéç¨éåä¸ºåºå 7.âæ»å½ä»¤ææå°å¼ 8.âè¿åæ å°å°åºå 9.âç»è®º åèæç®",content:"# å¨éåä¸è¿­ä»£\n\n> K. Rustan M. Leino Manuscript KRML 275, 17 February 2020\n\næè¦ ä»¥ç¡®å®çæ¹å¼å¤çéåææ å°çåå®¹éè¦ä¸äºå·¥ä½ãéè¿ä¸ä¸ªå¸åçä¾å­ï¼æ¬æè¯´æäºä¸ç§æ¹æ³ã\n\næ°å­¦éåç±»ååæ¬éåãå¤éãåºååæ å°ãè¿äºå¯¹äºè§èåç¨åºé½æ¯å¿ä¸å¯å°çãå¨è¿æ ·çéåçåç´ ä¸å®ä¹å½æ°æ¯äººä»¬æ³è±¡çè¦å°é¾(æèè³å°éè¦æ´å¤çå³å¨)ãå¨æ¬æä¸­ï¼æå¼åäºä¸ä¸ªå°æ å°è½¬æ¢ä¸ºæå¯¹åºåçç¤ºä¾çç¨åºåè¯æãè¯¥å·¥ä½çæ ¸å¿é¨åæ¶åè·å¾ä¸ä¸ªå¯ç¼è¯å½æ°ï¼è¯¥å½æ°ä»¥å¯é¢æµçé¡ºåºè¿åéåçåç´ ã\n\næ¬æçç®æ æ¯çæå¯ç¼è¯å½æ°ã\n\n\n# 0.âæ å°å°åºå\n\næ å°æ¯é®å¼å¯¹çéåï¼å¶ä¸­æ²¡æé®éå¤ãæä»¬å¯ä»¥å°ä¸ä¸ªmapè½¬æ¢ä¸ºä¸ä¸ªåºåï¼æ¹æ³æ¯å°å®çé®æ¾å¥ä¸ä¸ªåºåä¸­ï¼ç¶åéè¿è·åæ¯ä¸ªé®çå¼æ¥çæå¯¹:\n\nfunction method MapToSequence<A,B>(m: map<A,B>): seq<(A,B)> {\n  var keys := SetToSequence(m.Keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¯¹äºmap mï¼è¡¨è¾¾å¼mãâKeysâè¡¨ç¤ºä¸ç»é¥åãå½æ° MapToSequence å°è¿ç»é®ä¼ éç» SetToSequence `ä»¥è·å¾è¿äºé®çåºåãç¶åï¼åºåæé å½æ°\n\nseq(n, f)\n\n\n1\n\n\nçæä¸ä¸ªé¿åº¦ä¸ºnçåºåï¼å¶ä¸­ç´¢å¼içåç´ è¢«æå®ä¸ºf(i)ãå¨MapToSequenceä¸­ï¼åºåæ¨å¯¼å¼çç¬¬äºä¸ªåæ°æ¯ç±lambdaè¡¨è¾¾å¼ç»åºçé¨åå½æ°\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nå¯¹äºç»å®èå´åçç´¢å¼ï¼è¯¥å½æ°è¿åç±é®keys[i]åå¯¹åºçå¼mç»æçå¯¹ãå¿é¡»å¨å½æ°çåææ¡ä»¶ä¸­ç»åºiçèå´ï¼å¦åè¡¨è¾¾å¼keys[i]å°å¯¼è´ä¸æ éè¯¯ã\n\nä¸ºäºé¿åè¡¨è¾¾å¼m[keys[i]]ä¸­çkey-is-not-in-mapéè¯¯ï¼æä»¬éè¦ç¥ékeys[i]æ¯mçä¸ä¸ªé®ãè¿éè¦æä»¬ç¥éä»ä»¬ä¹é´çèç³»ãkey å Keys ï¼è¿æ¯å¨(å°æªå®ç°)å½æ° SetToSequence `çåç½®æ¡ä»¶ä¸­å£°æçã\n\næä»¬ç°å¨éè¦å®ç°SetToSequenceã\n\n\n# 1.âèå½æ°\n\nè®©æä»¬ä»ç®åçå¼å§ãæä»¬å°SetToSequenceå®ä¹ä¸ºä¸ä¸ªèå½æ°ãå®ä¹æ¯éå½çãå½ç»å®çéåéç©ºæ¶ï¼è¯¥å½æ°ä½¿ç¨chooseæä½ç¬¦ï¼ä¹å°±æ¯let-such-thatæä½ç¬¦ï¼å¹¶åå¥:|ï¼ä»éåä¸­éåä¸ä¸ªåç´ ã\n\nfunction SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\né£ä¸ç®å¤ªå\n\n\n# 2.âç¼è¯å½æ°\n\nä¸ºäºä½¿æä»¬ä¸é¢åçSetToSequenceå¯ç¼è¯ï¼æä»¬å°å³é®å­functionæ´æ¹ä¸ºå³é®å­ç­è¯­function methodãè¿å°çæä¸ä¸ªéè¯¯æ¶æ¯:\n\nå¦æè¦ä½¿>å¯ç¼è¯ï¼ålet-such-thatè¡¨è¾¾å¼çå¼å¿é¡»å¯ä¸ç¡®å®\n\nå¨Dafnyä¸­ï¼è¡¨è¾¾å¼åå½æ°(å¶ä¸»ä½æ¯è¡¨è¾¾å¼)å¿é¡»æ¯ç¡®å®æ§çãè¿æå³ç\n\nvar x :| x in s;\n\n\n1\n\n\nå½ç»å®ç¸åçsæ¶ï¼æ»æ¯éè¦ä¸ºxåç¸åçå¼ãè¿å°å¨è¿è¡æ¶è¿è¡è®¡ç®ï¼å æ­¤Dafnyå°è¿ä¸ªè´æäº¤ç»äºç¨åºå(åè§[0])ã\n\nä¸ç§æ¹æ³æ¯å¼ºåæ¡ä»¶x in sï¼è®©å®æ»æ¯ä»sä¸­éåæå°å¼ãè¿å°å¯ä¸å°ç¡®å®let-such-thatè¡¨è¾¾å¼çå¼ãä½æ¯âæå°å¼âæ¯ä»ä¹ææå¢?æä»¬ä»å·²ç¥æå°å¼çæ´æ°å¼å§ï¼ç¶åæ±ä¸è¬æåµã\n\n\n# 3.âéæ©æå°çæ´æ°\n\nç°å¨ï¼æä»¬åªå³æ³¨æ´æ°éãè¿è®©æä»¬å å¼ºäºlet-such-thatè¡¨è¾¾å¼ä¸­çæ¡ä»¶ï¼ä»èå¯ä¸å°è®¨è®ºéåä¸­çæå°åç´ :\n\nfunction method SetToSequence(s: set<int>): seq<int>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nâå¯ä¸ç¡®å®çâéæ±ç°å¨å¾å°äºæ»¡è¶³ãç¶èï¼ç±äºæä»¬æ°çsuch-thatè°è¯æ´å å¤æï¼éªè¯å¨æåºäºä¸ä¸ªä¸åçæ±æ¨:\n\n> ä¸è½å»ºç«æ»¡è¶³è¯¥è°è¯çLHSå¼çå­å¨æ§\n\nå¯¹æä»¬æ¥è¯´ï¼ä¸ä¸ªéç©ºéåæä¸ä¸ªæå°åç´ ä¼¼ä¹å¾æ¸æ¥ï¼ä½æä»¬éè¦è¯´æéªè¯èãè®©æä»¬ç¨ä¸ä¸ªåç¬çå¼çæ¥åè¿ä¸ªï¼æä»¬å£°æå¦ä¸:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\næä»¬å°å¨SetToSequenceä¸­çlet-suchè¡¨è¾¾å¼ä¹åæå¥å¯¹è¿ä¸ªå¼ççè°ç¨ãè¿æ ·ï¼å½æ°ä½å°±åæäº\n\nif s == {} then [] else\n  ThereIsAMinimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + SetToSequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4.âè¯æå­å¨æå°å¼\n\næä»¬çä¸ä¸ä¸ªä»»å¡æ¯è¯æâå­å¨æå°âå¼çãä¸é¢æ¯ä¸ä¸ªæ³¨éè¯æ:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // The minimum in s might be x, or it might be the minimum\n    // in s - {x}. If we knew the minimum of the latter, then\n    // we could compare the two.\n    // Let`s start by giving a name to the smaller set:\n    var s` := s - {x};\n    // So, s is the union of s` and {x}:\n    assert s == s` + {x};\n    // The following lemma call establishes that there is a\n    // minimum in s`.\n    ThereIsAMinimum(s`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nè¯æä»ä»sä¸­éåä»»æåç´ xå¼å§ãå¦æå®æ¯sä¸­å¯ä¸çåç´ ï¼å®å°±æ¯æå°å¼ãå¦åï¼è¿ä¸ªè¯æå¼åºäºsæ¯s + {x} `çäºå®ãå¯¹å¼ççéå½è°ç¨ï¼éè¿å®çåç½®æ¡ä»¶ï¼åè¯æä»¬å¨sä¸­å­å¨ä¸ä¸ªæå°åç´ ãéªè¯å¨ä¼èªå¨æä¾å©ä½çéªè¯è¶ï¼è¿æ ·æä»¬å°±å®æäºã\n\nè¯æä¸­çæ­è¨å¯è½çèµ·æ¥å¾æè ¢ãæä»¬åªæ¯å®ä¹sä¸ºs - {x}ãå ä¸ºxå¨sä¸­ï¼æä»¥å±æ§s == s + {x} ç´§è·å¶åãæ¯ç,ç¡®å®ãéªè¯èå¯ä»¥å¾å®¹æå°ç¡®è®¤è¿ä¸ç¹ï¼ä½éªè¯èæ²¡æè¶³å¤çåé åæ¥æè¯å°è¿æ¯ä¸ä¸ªå¼å¾äºè§£çå¥½å±æ§ãè¿æ¯å¤çéåæ¶çå¸åæåµãä¾å¦ï¼å¦æä½ æ­£å¨å¤çä¸ä¸ªåºå q ï¼ä½ å¯ä»¥åç¬èè q[0] ï¼å¹¶å¯¹ q[1..] `è¿è¡éå½è°ç¨ãå¦ææ¯è¿æ ·ï¼æ¨å¯è½éè¦æå¨ä¾åº\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nä¸setå±æ§ä¸æ ·ï¼éªè¯å¨å¾å®¹æè¯æè¿ä¸ªå±æ§ï¼ä½å®èªå·±ä¸ä¼æ³å°å®ã\n\nè¿ä¸ªè¯æçå¯ææ¯ï¼å½ä½ å°ä¸ä¸ªéååå²ææ´å°çåï¼ä½ æ³è¦åå«è¿è¡æ¨çæ¶ï¼æ­è¨æ´ä¸ªéåç­äºæ´å°åçç»åæ¯ä¸ä¸ªå¥½ä¸»æã\n\n\n# 5.âæ»å½ä»¤\n\nä¸é¢å¯¹æ´æ°éçéå¶å¾å¥½ç¨ï¼å ä¸ºæ´æ°éçæå°å¼å¾å®¹æå®ä¹ï¼å¹¶ä¸ç»åºå¯ä¸çåç´ ãè¦å¯¹å¶ä»ç±»ååºç¨ç¸åçæå·§ï¼æä»¬è¿éè¦è½å¤ä¸ºè¿äºç±»åå®ä¹ä¸ä¸ªâæå°å¼âãä¸ºäºå®ä¹æå°å¼ï¼ä½ éè¦ä¸ä¸ªâæ»é¡ºåºâãè®©æä»¬åé¡¾ä¸ä¸è¿æ¯ä»ä¹ææã\n\nç±»åAä¸çå³ç³»æ¯ä¸ä¸ªå½æ°(A, A) -> boolãå½æ»¡è¶³ä»¥ä¸ä¸ä¸ªæ¡ä»¶æ¶ï¼è¿ç§å³ç³»ç§°ä¸ºâRâï¼ç§°ä¸ºâååºâ:\n\n * Ræ¯èªåçï¼ä¹å°±æ¯è¯´ï¼ forall a:: R(a, a) -âRâæ¯åå¯¹ç§°çï¼å³ forall a, b:: R(a, b) && R(b, a) ==> a == b -âRâæ¯å¯ä¼ éçï¼å³ çåå,a, b, c:: R (a, b) & & (b, c) = = > R (a, c) `\n\nA total orderæ¯å¦å¤æ»¡è¶³ä»¥ä¸æ¡ä»¶çé¨åorder:\n\n-âRâæ¯è¿æ¥(ç´§å¯è¿æ¥)ï¼å³: forall a, b:: R(a, b) || R(b, a)\n\nè¯·æ³¨æï¼è¿æ¥æå³çèªåæ§ã\n\nä¸é¢æ¯ä¸ä¸ªè°è¯ï¼å®è¡¨ç¤ºä¸ä¸ªç»å®çå³ç³»æ¯å¦æ¯ä¸ä¸ªå®æ´çé¡ºåº:\n\npredicate IsTotalOrder<A(!new)>(R: (A, A) -> bool) {\n  // connexity\n  && (forall a, b :: R(a, b) || R(b, a))\n  // antisymmetry\n  && (forall a, b :: R(a, b) && R(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nDafnyä¸åè®¸æä»¬å¨è°è¯ä¸­åè¿äºéè¯ï¼é¤éå®å¯¹ç±»åâaâææ´å¤çäºè§£ãå¦æAæ¯ä¸ä¸ªç±»ç±»åï¼é£ä¹å¨Dafnyä¸­çforallæå³çéåç±»Açåéå®ä¾ãè¿æå³çåéå¦ä¸ä¸ªâAâå®ä¾å¯è½ä¼å¯¼è´âIsTotalOrder(R)âæ´æ¹å¼ãä¸ºäºé²æ­¢è¿ç§æåµçåçï¼Dafnyåæè®¤ä¸ºï¼æ éå¶çéåï¼å¦âIsTotalOrderâä¸­çé£äºï¼åºè¯¥å¨ä¸ä¾èµäºåéç¶æçç±»åä¸ãæä»¬ç¨ç±»åç¹å¾ (!new)æ¥è¡¨ç¤ºï¼å®è¢«åæç±»ååæ°å£°æä¸­ç±»ååçåç¼ã\n\n\n# 6.âéç¨éåä¸ºåºå\n\næä»¬ä¿®æ¹äºSetToSequenceï¼ä¹åäºä¸ä¸ªå³ç³»Rï¼æä»¬è¦æ±å®æ¯ä¸ä¸ªå®æ´çé¡ºåºãå¨æ­¤è¿ç¨ä¸­ï¼æä»¬å°æ´æ°çæ»é¡ºåº<=æ´æ¹ä¸ºRï¼å¹¶å°Rä½ä¸ºåæ°æ·»å å°thereisminimumå¼çä¸­:\n\nfunction method SetToSequence<A(!new)>(s: set<A>, R: (A, A) -> bool): seq<A>\n  requires IsTotalOrder(R)\n  ensures var q := SetToSequence(s, R);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    ThereIsAMinimum(s, R);\n    var x :| x in s && forall y :: y in s ==> R(x, y);\n    [x] + SetToSequence(s - {x}, R)\n}\n\nlemma ThereIsAMinimum<A(!new)>(s: set<A>, R: (A, A) -> bool)\n  requires s != {} && IsTotalOrder(R)\n  ensures exists x :: x in s && forall y :: y in s ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä¿®æ¹åçâSetToSequenceâå¼çè¿è¡éªè¯ãæä»¬å©ä¸çä»»å¡æ¯è¯æè¿ä¸ªå¼çã\n\n\n# 7.âæ»å½ä»¤ææå°å¼\n\næä»¬å¼å§è¯ææ³åçthereisminimumï¼ç±»ä¼¼äºä¸é¢å¯¹æ´æ°éçè¯æ:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nä»¥åâæ¾èæè§âçæåµè¿æ¬¡å´ç»éªè¯èå¸¦æ¥äºéº»ç¦ãè®©æä»¬å¸®å©å®ãæä»¬çè¯æä¹å¡æ¯è¯æsä¸­çæä¸ªåç´ åsä¸­çä»»ä½ä¸ä¸ªåç´ ä¸æ ·å°ãå¦æsæ¯åé{x}ï¼é£ä¹æä»¬è¦å¯»æ¾çåç´ åªè½æ¯xãç°å¨ï¼å¦æyæ¯sä¸­çåç´ ï¼æä»¬éè¦è¯æR(x, y)å ä¸ºsæ¯ä¸ä¸ªåä¾ï¼æä»¥æä»¬æy == xï¼ç¶åR(x, y)ç´§è·çè¿éæ§ãéªè¯èä¸¢å¤±äºè¿ä¸¤ä¸ªäºå®ä¸­çä¸ä¸ªãè®©æä»¬å¯¹ç¬¬ä¸ä¸ªäºå®æ·»å ä¸ä¸ªæ­è¨:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nåï¼æ¯çï¼éªè¯èå¯ä»¥è¯æè¿ä¸ªæ­è¨ï¼ç¶åå¯ä»¥è¿è¡å©ä¸çè¯æã\n\nåæ¥ççéåä¾æåµãæä»¬å°åä¸é¢çæ´æ°éè¯æä¸æ ·å¼å§:\n\n  } else {\n    var s` := s - {x};\n    assert s == s` + {x};\n    ThereIsAMinimum(s`, R);\n\n\n1\n2\n3\n4\n\n\néªè¯èæ±æ¨å¼ççåç½®æ¡ä»¶å¯è½ä¸æç«ï¼æä»¥æä»¬å°ç»éªè¯èæ´å¤çå¸®å©ã\n\nå¯¹å¼ççéå½è°ç¨(é¡ºä¾¿è¯´ä¸ä¸ï¼è¿ä¸ªå¼çè¢«ç§°ä¸ºâå½çº³åè¯´â)è¡¨æï¼å¨sä¸­å­å¨ä¸ä¸ªæå°å¼ãè®©æä»¬ç»å®ä¸ä¸ªåå­ï¼æä»¬éè¿å¼å¥ä¸ä¸ªå±é¨åéæ¥çº¦æå®çå¼ï¼ä»¥æ»¡è¶³å¼ççåç½®æ¡ä»¶å­å¨éè¯ä¸­çæ¡ä»¶:\n\n    var z :| z in s` && forall y :: y in s` ==> R(z, y);\n\n\n1\n\n\nå ä¸ºsæ¯s + {x} ï¼æä»¥æä»¬è¦å¯»æ¾çæå°å¼è¦ä¹æ¯ z ï¼è¦ä¹æ¯ x `ãè®©æä»¬åå«å¯¹å¾è¿äºæåµãæä»¬ç¨âifâè¯­å¥æ¥å®ç°è¿ä¸ç¹ãç±äºè¿ä¸¤ç§æåµæ¯å¦æ­¤å¯¹ç§°ï¼æè®¤ä¸ºä½¿ç¨Dafnyçif-caseè¯­å¥çèµ·æ¥å¾å¥½:\n\n    // by connexity, one of the two cases below applies\n    if\n    case R(z, x) =>\n      // prove z is the minimum not just of s`, but of s\n      // ...\n    case R(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\næä»¬åæ¥çR(z, x)çæåµãæé¾çé¨åå¯è½æ¯åç½®æ¡ä»¶ä¸­çéè¯ï¼æä»¥è®©æä»¬ä»å®å¼å§ãè¦è¯æä¸ä¸ªå¨ç§°éè¯ï¼å¯ä»¥ä½¿ç¨âforallâè¯­å¥ã\n\n      forall y | y in s\n        ensures R(z, y)\n      {\n\n\n1\n2\n3\n\n\nä»y in sï¼æä»¬ç¥éè¦ä¹yæ¯xè¦ä¹yæ¯sãå¯¹äºåèï¼è¯ææ¯åºäºå®å«çR(z, x)ãå¯¹äºåèï¼è¯ææ¥èªäºæä»¬ç¨æ¥å¼å¥âzâçè¿ç§æ¡ä»¶ä¸çéåãä¸ç¥ä½æï¼éªè¯èæ²¡ææ³¨æå°è¿ä¸ç¹ï¼æä»¥è®©æä»¬å¸®å©å®ãæä»¬ä»è¿éå¼å§:\n\n        assert x == y || y in s`;\n      }\n\n\n1\n2\n\n\nä½ ç§!è¿å°±æ¯éªè¯èæéè¦çã\n\nå¨R(x, z)çæåµä¸ï¼æä»¬å°ç»åºç±»ä¼¼çforallå½é¢æ¥è¯æå¼ççåç½®æ¡ä»¶ä¸­çéè¯:\n\n      forall y | y in s\n        ensures R(x, y)\n      {\n\n\n1\n2\n3\n\n\nå¦æyæ¯xï¼åR(x, y)ç´§è·å¨è¿éæ§åé¢ãå¦ä¸æ¹é¢ï¼å¦æyå¨sä¸­ï¼é£ä¹å¼å¥zçé£ä¸ªæ¡ä»¶åè¯æä»¬R(z, y)æä»¥æä»¬éè¿ä¼ éæ§å¾å°R(x, y)ä½ å¯ä»¥ç¨ä¸åçæ¹å¼æ·»å è¿äºæç¤ºï¼ä½¿è¯ææ´å ææãè¿éæä¸ç§æ¹æ³:\n\n        assert y in s` ==> R(z, y);\n      }\n\n\n1\n2\n\n\næåä¸ä¸ªè¯è®ºãå½æä»¬è¯ææ´æ°éçæå°å¼æ¶ï¼æè®¤ä¸ºåå«è¿æ ·çæ­è¨éå¸¸æ¯æç¨ç:\n\n    assert s == s` + {x};\n\n\n1\n\n\næä¹æå®åå«å¨éç¨çâthereisminimumâä¸­ãä½äºå®è¯æï¼å®å®éä¸å¹¶ä¸éè¦(å ä¸ºæä»¬å¨ä¸¤ç§æåµä¸æä¾çé¢å¤æç¤ºä¸­å¼¥è¡¥äºå®)ï¼æä»¥å¦æä½ æ¿æï¼ä½ å¯ä»¥å é¤å®ã\n\n\n# 8.âè¿åæ å°å°åºå\n\næä»¬åå°äº!\n\nå¨æä»¬å®£å¸æåä¹åï¼è®©æä»¬ç¡®ä¿æä»¬è½ä½¿ç¨æä»¬çå½æ°åå¼çæ¥åMapToSequenceå½æ°ï¼æä»¬è¦åçå½æ°ãä¸é¢æ¯éç¨çæ¬ï¼å®éè¦ä¸ä¸ªç»å®çæ»é¡ºåº:\n\nfunction method MapToSequence<A(!new),B>(m: map<A,B>, R: (A, A) -> bool): seq<(A,B)>\n  requires IsTotalOrder(R)\n{\n  var keys := SetToSequence(m.Keys, (a,a`) => R(a, a`));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næä»¬ä¹å¯ä»¥å°å®ä¸é¨åä¸ºæ´æ°é:\n\nfunction method IntMapToSequence<B>(m: map<int,B>): seq<(int,B)> {\n  MapToSequence(m, (a, a`) => a <= a`)\n}\n\n\n1\n2\n3\n\n\næä»¬åå°äº\n\n\n# 9.âç»è®º\n\næå¸æè¿æ®µæ¼«é¿çæç¨åæ¨å±ç¤ºäºå¨Dafnyå¤çèåçä¸ä¸¤ä»¶äºã\n\n\n# åèæç®\n\n[0]K. Rustan M. Leino. Compiling Hilbert`s epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning â Short Presentations, volume 35 of EPiC Series in Computing, pages 106â118. EasyChair, 2015. ð",normalizedContent:"# å¨éåä¸è¿­ä»£\n\n> k. rustan m. leino manuscript krml 275, 17 february 2020\n\næè¦ ä»¥ç¡®å®çæ¹å¼å¤çéåææ å°çåå®¹éè¦ä¸äºå·¥ä½ãéè¿ä¸ä¸ªå¸åçä¾å­ï¼æ¬æè¯´æäºä¸ç§æ¹æ³ã\n\næ°å­¦éåç±»ååæ¬éåãå¤éãåºååæ å°ãè¿äºå¯¹äºè§èåç¨åºé½æ¯å¿ä¸å¯å°çãå¨è¿æ ·çéåçåç´ ä¸å®ä¹å½æ°æ¯äººä»¬æ³è±¡çè¦å°é¾(æèè³å°éè¦æ´å¤çå³å¨)ãå¨æ¬æä¸­ï¼æå¼åäºä¸ä¸ªå°æ å°è½¬æ¢ä¸ºæå¯¹åºåçç¤ºä¾çç¨åºåè¯æãè¯¥å·¥ä½çæ ¸å¿é¨åæ¶åè·å¾ä¸ä¸ªå¯ç¼è¯å½æ°ï¼è¯¥å½æ°ä»¥å¯é¢æµçé¡ºåºè¿åéåçåç´ ã\n\næ¬æçç®æ æ¯çæå¯ç¼è¯å½æ°ã\n\n\n# 0.âæ å°å°åºå\n\næ å°æ¯é®å¼å¯¹çéåï¼å¶ä¸­æ²¡æé®éå¤ãæä»¬å¯ä»¥å°ä¸ä¸ªmapè½¬æ¢ä¸ºä¸ä¸ªåºåï¼æ¹æ³æ¯å°å®çé®æ¾å¥ä¸ä¸ªåºåä¸­ï¼ç¶åéè¿è·åæ¯ä¸ªé®çå¼æ¥çæå¯¹:\n\nfunction method maptosequence<a,b>(m: map<a,b>): seq<(a,b)> {\n  var keys := settosequence(m.keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nå¯¹äºmap mï¼è¡¨è¾¾å¼mãâkeysâè¡¨ç¤ºä¸ç»é¥åãå½æ° maptosequence å°è¿ç»é®ä¼ éç» settosequence `ä»¥è·å¾è¿äºé®çåºåãç¶åï¼åºåæé å½æ°\n\nseq(n, f)\n\n\n1\n\n\nçæä¸ä¸ªé¿åº¦ä¸ºnçåºåï¼å¶ä¸­ç´¢å¼içåç´ è¢«æå®ä¸ºf(i)ãå¨maptosequenceä¸­ï¼åºåæ¨å¯¼å¼çç¬¬äºä¸ªåæ°æ¯ç±lambdaè¡¨è¾¾å¼ç»åºçé¨åå½æ°\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nå¯¹äºç»å®èå´åçç´¢å¼ï¼è¯¥å½æ°è¿åç±é®keys[i]åå¯¹åºçå¼mç»æçå¯¹ãå¿é¡»å¨å½æ°çåææ¡ä»¶ä¸­ç»åºiçèå´ï¼å¦åè¡¨è¾¾å¼keys[i]å°å¯¼è´ä¸æ éè¯¯ã\n\nä¸ºäºé¿åè¡¨è¾¾å¼m[keys[i]]ä¸­çkey-is-not-in-mapéè¯¯ï¼æä»¬éè¦ç¥ékeys[i]æ¯mçä¸ä¸ªé®ãè¿éè¦æä»¬ç¥éä»ä»¬ä¹é´çèç³»ãkey å keys ï¼è¿æ¯å¨(å°æªå®ç°)å½æ° settosequence `çåç½®æ¡ä»¶ä¸­å£°æçã\n\næä»¬ç°å¨éè¦å®ç°settosequenceã\n\n\n# 1.âèå½æ°\n\nè®©æä»¬ä»ç®åçå¼å§ãæä»¬å°settosequenceå®ä¹ä¸ºä¸ä¸ªèå½æ°ãå®ä¹æ¯éå½çãå½ç»å®çéåéç©ºæ¶ï¼è¯¥å½æ°ä½¿ç¨chooseæä½ç¬¦ï¼ä¹å°±æ¯let-such-thatæä½ç¬¦ï¼å¹¶åå¥:|ï¼ä»éåä¸­éåä¸ä¸ªåç´ ã\n\nfunction settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\né£ä¸ç®å¤ªå\n\n\n# 2.âç¼è¯å½æ°\n\nä¸ºäºä½¿æä»¬ä¸é¢åçsettosequenceå¯ç¼è¯ï¼æä»¬å°å³é®å­functionæ´æ¹ä¸ºå³é®å­ç­è¯­function methodãè¿å°çæä¸ä¸ªéè¯¯æ¶æ¯:\n\nå¦æè¦ä½¿>å¯ç¼è¯ï¼ålet-such-thatè¡¨è¾¾å¼çå¼å¿é¡»å¯ä¸ç¡®å®\n\nå¨dafnyä¸­ï¼è¡¨è¾¾å¼åå½æ°(å¶ä¸»ä½æ¯è¡¨è¾¾å¼)å¿é¡»æ¯ç¡®å®æ§çãè¿æå³ç\n\nvar x :| x in s;\n\n\n1\n\n\nå½ç»å®ç¸åçsæ¶ï¼æ»æ¯éè¦ä¸ºxåç¸åçå¼ãè¿å°å¨è¿è¡æ¶è¿è¡è®¡ç®ï¼å æ­¤dafnyå°è¿ä¸ªè´æäº¤ç»äºç¨åºå(åè§[0])ã\n\nä¸ç§æ¹æ³æ¯å¼ºåæ¡ä»¶x in sï¼è®©å®æ»æ¯ä»sä¸­éåæå°å¼ãè¿å°å¯ä¸å°ç¡®å®let-such-thatè¡¨è¾¾å¼çå¼ãä½æ¯âæå°å¼âæ¯ä»ä¹ææå¢?æä»¬ä»å·²ç¥æå°å¼çæ´æ°å¼å§ï¼ç¶åæ±ä¸è¬æåµã\n\n\n# 3.âéæ©æå°çæ´æ°\n\nç°å¨ï¼æä»¬åªå³æ³¨æ´æ°éãè¿è®©æä»¬å å¼ºäºlet-such-thatè¡¨è¾¾å¼ä¸­çæ¡ä»¶ï¼ä»èå¯ä¸å°è®¨è®ºéåä¸­çæå°åç´ :\n\nfunction method settosequence(s: set<int>): seq<int>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nâå¯ä¸ç¡®å®çâéæ±ç°å¨å¾å°äºæ»¡è¶³ãç¶èï¼ç±äºæä»¬æ°çsuch-thatè°è¯æ´å å¤æï¼éªè¯å¨æåºäºä¸ä¸ªä¸åçæ±æ¨:\n\n> ä¸è½å»ºç«æ»¡è¶³è¯¥è°è¯çlhså¼çå­å¨æ§\n\nå¯¹æä»¬æ¥è¯´ï¼ä¸ä¸ªéç©ºéåæä¸ä¸ªæå°åç´ ä¼¼ä¹å¾æ¸æ¥ï¼ä½æä»¬éè¦è¯´æéªè¯èãè®©æä»¬ç¨ä¸ä¸ªåç¬çå¼çæ¥åè¿ä¸ªï¼æä»¬å£°æå¦ä¸:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\næä»¬å°å¨settosequenceä¸­çlet-suchè¡¨è¾¾å¼ä¹åæå¥å¯¹è¿ä¸ªå¼ççè°ç¨ãè¿æ ·ï¼å½æ°ä½å°±åæäº\n\nif s == {} then [] else\n  thereisaminimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + settosequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4.âè¯æå­å¨æå°å¼\n\næä»¬çä¸ä¸ä¸ªä»»å¡æ¯è¯æâå­å¨æå°âå¼çãä¸é¢æ¯ä¸ä¸ªæ³¨éè¯æ:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // the minimum in s might be x, or it might be the minimum\n    // in s - {x}. if we knew the minimum of the latter, then\n    // we could compare the two.\n    // let`s start by giving a name to the smaller set:\n    var s` := s - {x};\n    // so, s is the union of s` and {x}:\n    assert s == s` + {x};\n    // the following lemma call establishes that there is a\n    // minimum in s`.\n    thereisaminimum(s`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nè¯æä»ä»sä¸­éåä»»æåç´ xå¼å§ãå¦æå®æ¯sä¸­å¯ä¸çåç´ ï¼å®å°±æ¯æå°å¼ãå¦åï¼è¿ä¸ªè¯æå¼åºäºsæ¯s + {x} `çäºå®ãå¯¹å¼ççéå½è°ç¨ï¼éè¿å®çåç½®æ¡ä»¶ï¼åè¯æä»¬å¨sä¸­å­å¨ä¸ä¸ªæå°åç´ ãéªè¯å¨ä¼èªå¨æä¾å©ä½çéªè¯è¶ï¼è¿æ ·æä»¬å°±å®æäºã\n\nè¯æä¸­çæ­è¨å¯è½çèµ·æ¥å¾æè ¢ãæä»¬åªæ¯å®ä¹sä¸ºs - {x}ãå ä¸ºxå¨sä¸­ï¼æä»¥å±æ§s == s + {x} ç´§è·å¶åãæ¯ç,ç¡®å®ãéªè¯èå¯ä»¥å¾å®¹æå°ç¡®è®¤è¿ä¸ç¹ï¼ä½éªè¯èæ²¡æè¶³å¤çåé åæ¥æè¯å°è¿æ¯ä¸ä¸ªå¼å¾äºè§£çå¥½å±æ§ãè¿æ¯å¤çéåæ¶çå¸åæåµãä¾å¦ï¼å¦æä½ æ­£å¨å¤çä¸ä¸ªåºå q ï¼ä½ å¯ä»¥åç¬èè q[0] ï¼å¹¶å¯¹ q[1..] `è¿è¡éå½è°ç¨ãå¦ææ¯è¿æ ·ï¼æ¨å¯è½éè¦æå¨ä¾åº\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nä¸setå±æ§ä¸æ ·ï¼éªè¯å¨å¾å®¹æè¯æè¿ä¸ªå±æ§ï¼ä½å®èªå·±ä¸ä¼æ³å°å®ã\n\nè¿ä¸ªè¯æçå¯ææ¯ï¼å½ä½ å°ä¸ä¸ªéååå²ææ´å°çåï¼ä½ æ³è¦åå«è¿è¡æ¨çæ¶ï¼æ­è¨æ´ä¸ªéåç­äºæ´å°åçç»åæ¯ä¸ä¸ªå¥½ä¸»æã\n\n\n# 5.âæ»å½ä»¤\n\nä¸é¢å¯¹æ´æ°éçéå¶å¾å¥½ç¨ï¼å ä¸ºæ´æ°éçæå°å¼å¾å®¹æå®ä¹ï¼å¹¶ä¸ç»åºå¯ä¸çåç´ ãè¦å¯¹å¶ä»ç±»ååºç¨ç¸åçæå·§ï¼æä»¬è¿éè¦è½å¤ä¸ºè¿äºç±»åå®ä¹ä¸ä¸ªâæå°å¼âãä¸ºäºå®ä¹æå°å¼ï¼ä½ éè¦ä¸ä¸ªâæ»é¡ºåºâãè®©æä»¬åé¡¾ä¸ä¸è¿æ¯ä»ä¹ææã\n\nç±»åaä¸çå³ç³»æ¯ä¸ä¸ªå½æ°(a, a) -> boolãå½æ»¡è¶³ä»¥ä¸ä¸ä¸ªæ¡ä»¶æ¶ï¼è¿ç§å³ç³»ç§°ä¸ºârâï¼ç§°ä¸ºâååºâ:\n\n * ræ¯èªåçï¼ä¹å°±æ¯è¯´ï¼ forall a:: r(a, a) -ârâæ¯åå¯¹ç§°çï¼å³ forall a, b:: r(a, b) && r(b, a) ==> a == b -ârâæ¯å¯ä¼ éçï¼å³ çåå,a, b, c:: r (a, b) & & (b, c) = = > r (a, c) `\n\na total orderæ¯å¦å¤æ»¡è¶³ä»¥ä¸æ¡ä»¶çé¨åorder:\n\n-ârâæ¯è¿æ¥(ç´§å¯è¿æ¥)ï¼å³: forall a, b:: r(a, b) || r(b, a)\n\nè¯·æ³¨æï¼è¿æ¥æå³çèªåæ§ã\n\nä¸é¢æ¯ä¸ä¸ªè°è¯ï¼å®è¡¨ç¤ºä¸ä¸ªç»å®çå³ç³»æ¯å¦æ¯ä¸ä¸ªå®æ´çé¡ºåº:\n\npredicate istotalorder<a(!new)>(r: (a, a) -> bool) {\n  // connexity\n  && (forall a, b :: r(a, b) || r(b, a))\n  // antisymmetry\n  && (forall a, b :: r(a, b) && r(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ndafnyä¸åè®¸æä»¬å¨è°è¯ä¸­åè¿äºéè¯ï¼é¤éå®å¯¹ç±»åâaâææ´å¤çäºè§£ãå¦æaæ¯ä¸ä¸ªç±»ç±»åï¼é£ä¹å¨dafnyä¸­çforallæå³çéåç±»açåéå®ä¾ãè¿æå³çåéå¦ä¸ä¸ªâaâå®ä¾å¯è½ä¼å¯¼è´âistotalorder(r)âæ´æ¹å¼ãä¸ºäºé²æ­¢è¿ç§æåµçåçï¼dafnyåæè®¤ä¸ºï¼æ éå¶çéåï¼å¦âistotalorderâä¸­çé£äºï¼åºè¯¥å¨ä¸ä¾èµäºåéç¶æçç±»åä¸ãæä»¬ç¨ç±»åç¹å¾ (!new)æ¥è¡¨ç¤ºï¼å®è¢«åæç±»ååæ°å£°æä¸­ç±»ååçåç¼ã\n\n\n# 6.âéç¨éåä¸ºåºå\n\næä»¬ä¿®æ¹äºsettosequenceï¼ä¹åäºä¸ä¸ªå³ç³»rï¼æä»¬è¦æ±å®æ¯ä¸ä¸ªå®æ´çé¡ºåºãå¨æ­¤è¿ç¨ä¸­ï¼æä»¬å°æ´æ°çæ»é¡ºåº<=æ´æ¹ä¸ºrï¼å¹¶å°rä½ä¸ºåæ°æ·»å å°thereisminimumå¼çä¸­:\n\nfunction method settosequence<a(!new)>(s: set<a>, r: (a, a) -> bool): seq<a>\n  requires istotalorder(r)\n  ensures var q := settosequence(s, r);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    thereisaminimum(s, r);\n    var x :| x in s && forall y :: y in s ==> r(x, y);\n    [x] + settosequence(s - {x}, r)\n}\n\nlemma thereisaminimum<a(!new)>(s: set<a>, r: (a, a) -> bool)\n  requires s != {} && istotalorder(r)\n  ensures exists x :: x in s && forall y :: y in s ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nä¿®æ¹åçâsettosequenceâå¼çè¿è¡éªè¯ãæä»¬å©ä¸çä»»å¡æ¯è¯æè¿ä¸ªå¼çã\n\n\n# 7.âæ»å½ä»¤ææå°å¼\n\næä»¬å¼å§è¯ææ³åçthereisminimumï¼ç±»ä¼¼äºä¸é¢å¯¹æ´æ°éçè¯æ:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nä»¥åâæ¾èæè§âçæåµè¿æ¬¡å´ç»éªè¯èå¸¦æ¥äºéº»ç¦ãè®©æä»¬å¸®å©å®ãæä»¬çè¯æä¹å¡æ¯è¯æsä¸­çæä¸ªåç´ åsä¸­çä»»ä½ä¸ä¸ªåç´ ä¸æ ·å°ãå¦æsæ¯åé{x}ï¼é£ä¹æä»¬è¦å¯»æ¾çåç´ åªè½æ¯xãç°å¨ï¼å¦æyæ¯sä¸­çåç´ ï¼æä»¬éè¦è¯ær(x, y)å ä¸ºsæ¯ä¸ä¸ªåä¾ï¼æä»¥æä»¬æy == xï¼ç¶år(x, y)ç´§è·çè¿éæ§ãéªè¯èä¸¢å¤±äºè¿ä¸¤ä¸ªäºå®ä¸­çä¸ä¸ªãè®©æä»¬å¯¹ç¬¬ä¸ä¸ªäºå®æ·»å ä¸ä¸ªæ­è¨:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nåï¼æ¯çï¼éªè¯èå¯ä»¥è¯æè¿ä¸ªæ­è¨ï¼ç¶åå¯ä»¥è¿è¡å©ä¸çè¯æã\n\nåæ¥ççéåä¾æåµãæä»¬å°åä¸é¢çæ´æ°éè¯æä¸æ ·å¼å§:\n\n  } else {\n    var s` := s - {x};\n    assert s == s` + {x};\n    thereisaminimum(s`, r);\n\n\n1\n2\n3\n4\n\n\néªè¯èæ±æ¨å¼ççåç½®æ¡ä»¶å¯è½ä¸æç«ï¼æä»¥æä»¬å°ç»éªè¯èæ´å¤çå¸®å©ã\n\nå¯¹å¼ççéå½è°ç¨(é¡ºä¾¿è¯´ä¸ä¸ï¼è¿ä¸ªå¼çè¢«ç§°ä¸ºâå½çº³åè¯´â)è¡¨æï¼å¨sä¸­å­å¨ä¸ä¸ªæå°å¼ãè®©æä»¬ç»å®ä¸ä¸ªåå­ï¼æä»¬éè¿å¼å¥ä¸ä¸ªå±é¨åéæ¥çº¦æå®çå¼ï¼ä»¥æ»¡è¶³å¼ççåç½®æ¡ä»¶å­å¨éè¯ä¸­çæ¡ä»¶:\n\n    var z :| z in s` && forall y :: y in s` ==> r(z, y);\n\n\n1\n\n\nå ä¸ºsæ¯s + {x} ï¼æä»¥æä»¬è¦å¯»æ¾çæå°å¼è¦ä¹æ¯ z ï¼è¦ä¹æ¯ x `ãè®©æä»¬åå«å¯¹å¾è¿äºæåµãæä»¬ç¨âifâè¯­å¥æ¥å®ç°è¿ä¸ç¹ãç±äºè¿ä¸¤ç§æåµæ¯å¦æ­¤å¯¹ç§°ï¼æè®¤ä¸ºä½¿ç¨dafnyçif-caseè¯­å¥çèµ·æ¥å¾å¥½:\n\n    // by connexity, one of the two cases below applies\n    if\n    case r(z, x) =>\n      // prove z is the minimum not just of s`, but of s\n      // ...\n    case r(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\næä»¬åæ¥çr(z, x)çæåµãæé¾çé¨åå¯è½æ¯åç½®æ¡ä»¶ä¸­çéè¯ï¼æä»¥è®©æä»¬ä»å®å¼å§ãè¦è¯æä¸ä¸ªå¨ç§°éè¯ï¼å¯ä»¥ä½¿ç¨âforallâè¯­å¥ã\n\n      forall y | y in s\n        ensures r(z, y)\n      {\n\n\n1\n2\n3\n\n\nä»y in sï¼æä»¬ç¥éè¦ä¹yæ¯xè¦ä¹yæ¯sãå¯¹äºåèï¼è¯ææ¯åºäºå®å«çr(z, x)ãå¯¹äºåèï¼è¯ææ¥èªäºæä»¬ç¨æ¥å¼å¥âzâçè¿ç§æ¡ä»¶ä¸çéåãä¸ç¥ä½æï¼éªè¯èæ²¡ææ³¨æå°è¿ä¸ç¹ï¼æä»¥è®©æä»¬å¸®å©å®ãæä»¬ä»è¿éå¼å§:\n\n        assert x == y || y in s`;\n      }\n\n\n1\n2\n\n\nä½ ç§!è¿å°±æ¯éªè¯èæéè¦çã\n\nå¨r(x, z)çæåµä¸ï¼æä»¬å°ç»åºç±»ä¼¼çforallå½é¢æ¥è¯æå¼ççåç½®æ¡ä»¶ä¸­çéè¯:\n\n      forall y | y in s\n        ensures r(x, y)\n      {\n\n\n1\n2\n3\n\n\nå¦æyæ¯xï¼år(x, y)ç´§è·å¨è¿éæ§åé¢ãå¦ä¸æ¹é¢ï¼å¦æyå¨sä¸­ï¼é£ä¹å¼å¥zçé£ä¸ªæ¡ä»¶åè¯æä»¬r(z, y)æä»¥æä»¬éè¿ä¼ éæ§å¾å°r(x, y)ä½ å¯ä»¥ç¨ä¸åçæ¹å¼æ·»å è¿äºæç¤ºï¼ä½¿è¯ææ´å ææãè¿éæä¸ç§æ¹æ³:\n\n        assert y in s` ==> r(z, y);\n      }\n\n\n1\n2\n\n\næåä¸ä¸ªè¯è®ºãå½æä»¬è¯ææ´æ°éçæå°å¼æ¶ï¼æè®¤ä¸ºåå«è¿æ ·çæ­è¨éå¸¸æ¯æç¨ç:\n\n    assert s == s` + {x};\n\n\n1\n\n\næä¹æå®åå«å¨éç¨çâthereisminimumâä¸­ãä½äºå®è¯æï¼å®å®éä¸å¹¶ä¸éè¦(å ä¸ºæä»¬å¨ä¸¤ç§æåµä¸æä¾çé¢å¤æç¤ºä¸­å¼¥è¡¥äºå®)ï¼æä»¥å¦æä½ æ¿æï¼ä½ å¯ä»¥å é¤å®ã\n\n\n# 8.âè¿åæ å°å°åºå\n\næä»¬åå°äº!\n\nå¨æä»¬å®£å¸æåä¹åï¼è®©æä»¬ç¡®ä¿æä»¬è½ä½¿ç¨æä»¬çå½æ°åå¼çæ¥åmaptosequenceå½æ°ï¼æä»¬è¦åçå½æ°ãä¸é¢æ¯éç¨çæ¬ï¼å®éè¦ä¸ä¸ªç»å®çæ»é¡ºåº:\n\nfunction method maptosequence<a(!new),b>(m: map<a,b>, r: (a, a) -> bool): seq<(a,b)>\n  requires istotalorder(r)\n{\n  var keys := settosequence(m.keys, (a,a`) => r(a, a`));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næä»¬ä¹å¯ä»¥å°å®ä¸é¨åä¸ºæ´æ°é:\n\nfunction method intmaptosequence<b>(m: map<int,b>): seq<(int,b)> {\n  maptosequence(m, (a, a`) => a <= a`)\n}\n\n\n1\n2\n3\n\n\næä»¬åå°äº\n\n\n# 9.âç»è®º\n\næå¸æè¿æ®µæ¼«é¿çæç¨åæ¨å±ç¤ºäºå¨dafnyå¤çèåçä¸ä¸¤ä»¶äºã\n\n\n# åèæç®\n\n[0]k. rustan m. leino. compiling hilbert`s epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning â short presentations, volume 35 of epic series in computing, pages 106â118. easychair, 2015. ð",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Dafny type system",frontmatter:{title:"Dafny type system",date:"2022-03-26T16:59:26.000Z",permalink:"/pages/8065fd/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/00.Dafny%20type%20system.html",relativePath:"40.èµæº/10.å¸¸ç¨å·¥å·/00.Dafny type system.md",key:"v-3c7b36da",path:"/pages/8065fd/",headers:[{level:2,title:"0.âåºæ¬ç±»å",slug:"_0-åºæ¬ç±»å",normalizedTitle:"0.âåºæ¬ç±»å",charIndex:100},{level:3,title:"0.0.âBooleans",slug:"_0-0-booleans",normalizedTitle:"0.0.âbooleans",charIndex:472},{level:3,title:"0.1.âæ°å­ç±»å",slug:"_0-1-æ°å­ç±»å",normalizedTitle:"0.1.âæ°å­ç±»å",charIndex:117},{level:3,title:"0.2.âå­ç¬¦",slug:"_0-2-å­ç¬¦",normalizedTitle:"0.2.âå­ç¬¦",charIndex:127},{level:2,title:"1.âç±»ååæ°",slug:"_1-ç±»ååæ°",normalizedTitle:"1.âç±»ååæ°",charIndex:135},{level:2,title:"2.âéåç±»å",slug:"_2-éåç±»å",normalizedTitle:"2.âéåç±»å",charIndex:143},{level:3,title:"2.0.âéå",slug:"_2-0-éå",normalizedTitle:"2.0.âéå",charIndex:151},{level:3,title:"2.1.âMultisets",slug:"_2-1-multisets",normalizedTitle:"2.1.âmultisets",charIndex:6073},{level:3,title:"2.2.âåºå",slug:"_2-2-åºå",normalizedTitle:"2.2.âåºå",charIndex:167},{level:4,title:"2.2.0.âå­ç¬¦ä¸²",slug:"_2-2-0-å­ç¬¦ä¸²",normalizedTitle:"2.2.0.âå­ç¬¦ä¸²",charIndex:175},{level:3,title:"2.3.âæéä¸æ éå¾",slug:"_2-3-æéä¸æ éå¾",normalizedTitle:"2.3.âæéä¸æ éå¾",charIndex:186},{level:2,title:"3.âè±¡å¾ç±»å",slug:"_3-è±¡å¾ç±»å",normalizedTitle:"3.âè±¡å¾ç±»å",charIndex:198},{level:3,title:"3.0.âåä¹è¯ç±»å",slug:"_3-0-åä¹è¯ç±»å",normalizedTitle:"3.0.âåä¹è¯ç±»å",charIndex:206},{level:3,title:"3.1.âä¸éæç±»å",slug:"_3-1-ä¸éæç±»å",normalizedTitle:"3.1.âä¸éæç±»å",charIndex:217},{level:2,title:"4.âæ°æ®ç±»å",slug:"_4-æ°æ®ç±»å",normalizedTitle:"4.âæ°æ®ç±»å",charIndex:228},{level:3,title:"4.0.âå½çº³ç±»å",slug:"_4-0-å½çº³ç±»å",normalizedTitle:"4.0.âå½çº³ç±»å",charIndex:12033},{level:3,title:"4.1.âåç»ç±»å",slug:"_4-1-åç»ç±»å",normalizedTitle:"4.1.âåç»ç±»å",charIndex:248},{level:3,title:"4.2.âå±åå½çº³ç±»å",slug:"_4-2-å±åå½çº³ç±»å",normalizedTitle:"4.2.âå±åå½çº³ç±»å",charIndex:258},{level:2,title:"5.âåç§ç±»å",slug:"_5-åç§ç±»å",normalizedTitle:"5.âåç§ç±»å",charIndex:270},{level:3,title:"5.0.âç±»",slug:"_5-0-ç±»",normalizedTitle:"5.0.âç±»",charIndex:278},{level:3,title:"5.1.âæ°ç»",slug:"_5-1-æ°ç»",normalizedTitle:"5.1.âæ°ç»",charIndex:285},{level:4,title:"5.1.0.âä¸ç»´æ°ç»",slug:"_5-1-0-ä¸ç»´æ°ç»",normalizedTitle:"5.1.0.âä¸ç»´æ°ç»",charIndex:293},{level:4,title:"5.1.1.âå¤ç»´æ°ç»",slug:"_5-1-1-å¤ç»´æ°ç»",normalizedTitle:"5.1.1.âå¤ç»´æ°ç»",charIndex:305},{level:3,title:"5.2.âç¹å¾",slug:"_5-2-ç¹å¾",normalizedTitle:"5.2.âç¹å¾",charIndex:317},{level:3,title:"5.3.âç±»å object",slug:"_5-3-ç±»å-object",normalizedTitle:"5.3.âç±»å object",charIndex:325},{level:3,title:"5.4.âè¿­ä»£å¨ç±»å",slug:"_5-4-è¿­ä»£å¨ç±»å",normalizedTitle:"5.4.âè¿­ä»£å¨ç±»å",charIndex:340},{level:3,title:"5.5.âå¼æ­¥ä»»å¡ç±»å",slug:"_5-5-å¼æ­¥ä»»å¡ç±»å",normalizedTitle:"5.5.âå¼æ­¥ä»»å¡ç±»å",charIndex:351},{level:2,title:"6.âå½æ°ç±»å",slug:"_6-å½æ°ç±»å",normalizedTitle:"6.âå½æ°ç±»å",charIndex:363},{level:3,title:"6.0.âLambdaè¡¨è¾¾å¼",slug:"_6-0-lambdaè¡¨è¾¾å¼",normalizedTitle:"6.0.âlambdaè¡¨è¾¾å¼",charIndex:371},{level:2,title:"7.âæ°ç±»å",slug:"_7-æ°ç±»å",normalizedTitle:"7.âæ°ç±»å",charIndex:386},{level:3,title:"7.0.âæ°å­è½¬æ¢æä½",slug:"_7-0-æ°å­è½¬æ¢æä½",normalizedTitle:"7.0.âæ°å­è½¬æ¢æä½",charIndex:26230},{level:2,title:"8.âå­éç±»å",slug:"_8-å­éç±»å",normalizedTitle:"8.âå­éç±»å",charIndex:405},{level:4,title:"åèèµæ",slug:"åèèµæ",normalizedTitle:"åèèµæ",charIndex:27631}],headersStr:"0.âåºæ¬ç±»å 0.0.âBooleans 0.1.âæ°å­ç±»å 0.2.âå­ç¬¦ 1.âç±»ååæ° 2.âéåç±»å 2.0.âéå 2.1.âMultisets 2.2.âåºå 2.2.0.âå­ç¬¦ä¸² 2.3.âæéä¸æ éå¾ 3.âè±¡å¾ç±»å 3.0.âåä¹è¯ç±»å 3.1.âä¸éæç±»å 4.âæ°æ®ç±»å 4.0.âå½çº³ç±»å 4.1.âåç»ç±»å 4.2.âå±åå½çº³ç±»å 5.âåç§ç±»å 5.0.âç±» 5.1.âæ°ç» 5.1.0.âä¸ç»´æ°ç» 5.1.1.âå¤ç»´æ°ç» 5.2.âç¹å¾ 5.3.âç±»å object 5.4.âè¿­ä»£å¨ç±»å 5.5.âå¼æ­¥ä»»å¡ç±»å 6.âå½æ°ç±»å 6.0.âLambdaè¡¨è¾¾å¼ 7.âæ°ç±»å 7.0.âæ°å­è½¬æ¢æä½ 8.âå­éç±»å åèèµæ",content:"# Dafny Type System\n\nDafnyè¯­è¨åèçè¿ä¸é¨åæè¿°äºDafnyç¼ç¨è¯­è¨ä¸­çç±»åãææè¿°çæ¯Dafnyçæ¬1.9.3.20107ä¸­å®ç°çåå®¹ï¼å¼æ­¥ä»»å¡ç±»åå°æªè¿å¥ä¸»åæ¯ã\n\n> 0.âåºæ¬ç±»å 0.0.âå¸å°å¼ 0.1.âæ°å­ç±»å 0.2.âå­ç¬¦ 1.âç±»ååæ° 2.âéåç±»å 2.0.âéå 2.1.âå¤é 2.2.âåºå 2.2.0.âå­ç¬¦ä¸² 2.3.âæéä¸æ éå¾ 3.âè±¡å¾ç±»å 3.0.âåä¹è¯ç±»å 3.1.âä¸éæç±»å 4.âæ°æ®ç±»å 4.0.âå½çº³æ°æ®ç±»å 4.1.âåç»ç±»å 4.2.âå±åå½çº³ç±»å 5.âåç§ç±»å 5.0.âç±» 5.1.âæ°ç» 5.1.0.âä¸ç»´æ°ç» 5.1.1.âå¤ç»´æ°ç» 5.2.âç¹å¾ 5.3.âç±»å object 5.4.âè¿­ä»£å¨ç±»å 5.5.âå¼æ­¥ä»»å¡ç±»å 6.âå½æ°ç±»å 6.0.âLambdaè¡¨è¾¾å¼ 7.âæ°ç±»å 7.0.âæ°å­è½¬åæä½ 8.âå­éç±»å\n\n\n# 0.âåºæ¬ç±»å\n\nDafnyæä¾äºä¸ç§åºæ¬ç±»åï¼boolè¡¨ç¤ºå¸å°ï¼intè¡¨ç¤ºæ´æ°ï¼realè¡¨ç¤ºå®æ°ã\n\n\n# 0.0.âBooleans\n\næä¸¤ä¸ªå¸å°å¼ï¼æ¯ä¸ªå¼å¨è¯­è¨ä¸­é½æä¸ä¸ªå¯¹åºçææ¬ï¼falseåtrueã\n\né¤äºå¨ææç±»åä¸å®ä¹çç¸ç­ï¼=ï¼ådisequalityï¼ï¼=ï¼ï¼ç±»åboolè¿æ¯æä»¥ä¸æä½ï¼\n\n       \næä½ç¬¦    æè¿°\n       \n<==>   å½ä¸ä»å½\n       \n==>    è´å«\n<==    ååè´å«\n       \n&&     è¿æ¥(ä¸)\n||     æå(æ)\n       \n!      å¦å®(é)\n       \n\nå¦å®æ¯ä¸åçï¼å¶ä»çæ¯äºè¿å¶çãè¯¥è¡¨æ¾ç¤ºäºä¸ç»ç»ååä¸æ­å¢å¼ºçè¿ç®ç¬¦ï¼ç­å¼ç»åæ¯åååæåå¼ºï¼æ¯å¦å®å¼±ãå¨æ¯ä¸ªç»ä¸­ï¼ä¸åçè¿ç®ç¬¦ä¸å³èï¼å æ­¤éè¦ä½¿ç¨æ¬å·ãä¾å¦,\n\nA && B || C    // error\n\n\n1\n\n\nå°æ¯ä¸æç¡®çï¼èå¿é¡»åä¸º\n\n(A && B) || C\n\n\n1\n\n\næ\n\nA && (B || C)\n\n\n1\n\n\nåå³äºé¢æçææã\n\nè¡¨è¾¾å¼A<=>BåA==Bç»åºäºç¸åçå¼ï¼ä½è¯·æ³¨æï¼<=>æ¯å³èçï¼=æ¯é¾æ¥çãæä»¥\n\nA <==> B <==> C\n\n\n1\n\n\nä¸ä¸å¼ç¸å\n\nA <==> (B <==> C)\n\n\n1\n\n\nå\n\n(A <==> B) <==> C\n\n\n1\n\n\né´äº\n\nA == B == C\n\n\n1\n\n\nåªæ¯ä¸å¼çéè®°\n\nA == B && B == C\n\n\n1\n\n\nååæ¯å³èçï¼æåä¹æ¯ãè¿äºè¿ç®ç¬¦æ¯ç­è·¯ï¼ä»å·¦å°å³ï¼ï¼è¿æå³çåªæå¨ç¬¬ä¸ä¸ªæä½æ°çè®¡ç®ä¸ç¡®å®è¡¨è¾¾å¼çå¼æ¶ï¼æä¼è®¡ç®å®ä»¬çç¬¬äºä¸ªåæ°ãä»é»è¾ä¸è®²ï¼è¡¨è¾¾å¼A&&Bæ¯å¨å®ä¹äºAå¹¶ä¸Açè®¡ç®ç»æä¸ºfalseæBæ¶å®ä¹çãå®ä¹A&&Bæ¶ï¼å¶å«ä¹ä¸æ®éçå¯¹ç§°æ°å­¦è¿è¯ç¸åâ§. | | |åâ¨.\n\nå«ä¹æ¯âå³å³èâï¼ä»å·¦å°å³ç­è·¯ãååè´æ¶µB<==Aä¸A==>Bå®å¨ç¸åï¼ä½å¯ä»¥æç¸åçé¡ºåºåå¥æä½æ°ãå æ­¤ï¼ååå«ä¹æ¯âå·¦å³èâï¼æ¯ä»âå³âå°âå·¦âçç­è·¯ãä¸ºäºè¯´æå³èæ§è§åï¼ä»¥ä¸åè¡ä¸­çæ¯ä¸è¡é½è¡¨ç¤ºäºç¸åçå±æ§ï¼å³boolç±»åçä»»ä½AãBåCï¼\n\nA ==> B ==> C\nA ==> (B ==> C)  // parentheses redundant, since ==> is right associative\nC <== B <== A\n(C <== B) <== A  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nä¸ºäºè¯´æç­è·¯è§åï¼è¯·æ³¨æï¼è¡¨è¾¾å¼a.Lengthä»å¨aä¸ä¸ºnullæ¶æä¸ºæ°ç»aå®ä¹ (è§ å°è 5), è¿æå³çä»¥ä¸ä¸¤ä¸ªè¡¨è¾¾å¼æ ¼å¼æ­£ç¡®ï¼\n\na != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n\n\n1\n2\n\n\nè¿ä¸¤ç§è¡¨è¾¾çåä½ç¨æ¯ï¼\n\na.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n\n\n1\n2\n\n\nä½è¿äºè¡¨è¾¾å¼çæ ¼å¼ä¸å¥½ï¼å ä¸ºæ ¼å¼å¥½è¦æ±å·¦ï¼åå³ï¼æä½æ°a.Length<0æ¬èº«æ ¼å¼è¯å¥½ã\n\nè´æ¶µA==>Bç¸å½äºæåï¼A | | Bï¼ä½ææ¶ï¼å°¤å¶æ¯å¨è§èä¸­ï¼æ´æ¸æ°æè¯»ãç±äº||æ¯ä»å·¦åå³ç­è·¯ï¼è¯·æ³¨æ\n\na == null || 0 <= a.Length\n\n\n1\n\n\nç»æè¯å¥½ï¼è\n\n0 <= a.Length || a == null  // not well-formed\n\n\n1\n\n\nç»æè¾å·®ã\n\næ­¤å¤ï¼å¸å°è¯­æ¯æé»è¾éè¯ï¼forallåexistsï¼ï¼å¨Dafnyè¯­è¨åèçå¦ä¸é¨åä¸­ææè¿°ã\n\n\n# 0.1.âæ°å­ç±»å\n\nDafny æ¯æä¸¤ç§ numeric ç±»åï¼integer-basedï¼åæ¬æææ´æ°çåºæ¬ç±»å intï¼å real-basedï¼åæ¬ææå®æ°çåºæ¬ç±»å realã ç¨æ·å®ä¹çåºäº int å real çæ°å­ç±»åï¼ç§°ä¸º newtypesï¼å¨ç¬¬ [7] è(http://leino.science/papers/krml243.html#sec-newtypes) ä¸­ææè¿°ã æ­¤å¤ï¼ä»£è¡¨ int çéè´å­èå´ç subset type nat å¨ç¬¬ [8] èï¼http://leino.science/papers/krml243.html#sec-subset-typesï¼ä¸­è¿è¡äºæè¿° . è¯¥è¯­è¨åå«æ¯ä¸ªéè´æ´æ°çæå­ï¼ä¾å¦â0âãâ13âåâ1985âã æ´æ°ä¹å¯ä»¥ä½¿ç¨åç¼â0xâä»¥åå­è¿å¶ä¹¦åï¼å¦â0x0âãâ0xDâåâ0x7c1âï¼å§ç»ä½¿ç¨å°åâxâï¼ä½åå­è¿å¶æ°å­æ¬èº«ä¸åºåå¤§å°åï¼ã åè®¸ä½¿ç¨åå¯¼é¶ã è¦å½¢æè´æ´æ°ï¼è¯·ä½¿ç¨ä¸ååå·è¿ç®ç¬¦ã ä¸äºéè´å®æ°ä¹ææå­ã è¿äºè¢«åæä¸ä¸ªå°æ°ç¹ï¼ä¸¤è¾¹é½æä¸ä¸ªéç©ºçåè¿å¶æ°å­åºåã ä¾å¦ï¼â1.0âãâ1609.344âåâ0.5772156649âã å¯¹äºæ´æ°ï¼åè¿å¶ååå­è¿å¶å½¢å¼ï¼åå®æ°ï¼æå­ä¸­çä»»ä½ä¸¤ä½æ°å­é½å¯ä»¥ç¨ä¸åçº¿åéï¼ä»¥æé«æå­çå¯è¯»æ§ã ä¾å¦ï¼\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 ÃngstrÃ¶m\n\n\n1\n2\n3\n4\n\n\né¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼æ°å¼ç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nå°±åç¸ç­åä¸ç¸ç­ä¸æ ·ï¼è¿äºè¿ç®ç¬¦æ¯é¾æ¥çï¼åªè¦å®ä»¬é¾æ¥å¨âç¸åçæ¹åâã é£å°±æ¯è¯´ï¼\n\nA <= B < C == D <= E\n\n\n1\n\n\nis simply a shorthand for\n\nA <= B && B < C && C == D && D <= E\n\n\n1\n\n\nè\n\nA < B > C\n\n\n1\n\n\nä¸è¢«åè®¸ã æ¯ç§æ°å­ç±»åä¹æè¿ç®ç¬¦ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n+     å \n-     å\n      \n*     ä¹\n/     é¤\n%     åæ¨¡\n      \n-     å¦å® (ä¸åå)\n      \n\näºåè¿ç®ç¬¦æ¯å·¦ç»åçï¼å®ä»¬å¨ä¸¤ç»ä¸­ç¸äºå³èã è¿äºç»æç»å®è½åå¢å çé¡ºåºååºï¼ç­å¼ç»å®æ¯ä¹æ³è¿ç®ç¬¦æ´å¼ºï¼æ¯ä¸åè¿ç®ç¬¦å¼±ã ä»åºäºæ´æ°çæ°å¼ç±»åæ¯ææ¨¡æ°ã æ´æ°é¤æ³åæ¨¡æ°æ¯æ¬§å éå¾é¤æ³åæ¨¡æ°ã è¿æå³çæ è®ºä¸¤ä¸ªæä½æ°çç¬¦å·å¦ä½ï¼æ¨¡æ°å§ç»è¿åéè´æ°ã æ´åç¡®å°è¯´ï¼å¯¹äºä»»ä½æ´æ°aåéé¶æ´æ°bï¼\n\na == a / b * b + a % b\n0 <= a % b < B\n\n\n1\n2\n\n\nå¶ä¸­âBâè¡¨ç¤ºâbâçç»å¯¹å¼ã åºäºå®æ°çæ°å¼ç±»åæä¸ä¸ªæå Truncï¼å®è¿åå®æ°å¼ç floorï¼å³ä¸è¶è¿å®æ°å¼çæå¤§æ´æ°ã ä¾å¦ï¼å¯¹äºä»»ä½ç±»åä¸ºârealâçârâåârâï¼ä»¥ä¸å±æ§æç«ï¼\n\n3.14.Trunc == 3\n(-2.5).Trunc == -3\n-2.5.Trunc == -2\nreal(r.Trunc) <= r\nr <= r' ==> r.Trunc <= r'.Trunc\n\n\n1\n2\n3\n4\n5\n\n\nè¯·æ³¨æï¼å¨ç¬¬ä¸è¡ä¸­ï¼æåè®¿é®ï¼å¦ .Truncï¼çç»å®æ¯ä¸ååå·æ´å¼ºã ç¬¬åè¡ä½¿ç¨ä» int å° real çè½¬æ¢å½æ° realï¼å¦ç¬¬ [7.0] è (http://leino.science/papers/krml243.html#sec-numeric-conversions) ä¸­æè¿°\n\n\n# 0.2.âå­ç¬¦\n\nDafny æ¯æ characters ç char ç±»åã å­ç¬¦æå­ç¨åå¼å·æ¬èµ·æ¥ï¼å¦ 'D'ã è¦å°åå¼å·åæå­ç¬¦æå­ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåã è½¬ä¹åºåä¹å¯ç¨äºåå¥å¶ä»å­ç¬¦ã æ¯æçè½¬ä¹åºåå¦ä¸ï¼\n\n           \nè½¬ä¹å­ç¬¦       å«ä¹\n           \n\\'         å­ç¬¦ '\n\\\"         å­ç¬¦ \"\n\\\\         å­ç¬¦ \\\n\\0         ç©ºå­ç¬¦ï¼å \\u0000\n\\n         æ¢è¡\n\\r         åè½¦\n\\t         æ°´å¹³å¶è¡¨\n\\u*xxxx*   åå­è¿å¶ç¼ç éç¨å­ç¬¦ *xxxx*\n           \n\nåå¼å·çè½¬ä¹åºåæ¯å¤ä½çï¼å ä¸º '\"' å '\"' è¡¨ç¤ºç¸åçå­ç¬¦ââæä¾è¿ä¸¤ç§å½¢å¼æ¯ä¸ºäºæ¯æä¸å­ç¬¦ä¸²æå­ç¸åçè½¬ä¹åºåï¼ç¬¬ [2.2.0] èï¼http: //leino.science/papers/krml243.html#sec-string))ã å¨ \\u*xxxx* å½¢å¼ä¸­ï¼u æ»æ¯å°åï¼ä½åä¸ªåå­è¿å¶æ°å­ä¸åºåå¤§å°åã å­ç¬¦å¼æ¯æåºçï¼å¯ä»¥ä½¿ç¨æ åå³ç³»è¿ç®ç¬¦è¿è¡æ¯è¾ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     å°äº\n<=    è³å¤\n>=    è³å°\n>     å¤§äº\n      \n\nå­ç¬¦åºåè¡¨ç¤ºå­ç¬¦ä¸²ï¼å¦ç¬¬ 2.2.0 èæè¿°ã(http://leino.science/papers/krml243.html#sec-string).\n\n\n# 1.âç±»ååæ°\n\nDafny ä¸­çè®¸å¤ç±»åï¼ä»¥åå½æ°åæ¹æ³ï¼é½å¯ä»¥éè¿ç±»åè¿è¡åæ°åã è¿äºç±»ååæ°éå¸¸å¨å°æ¬å·åå£°æï¼å¯ä»¥ä»£è¡¨ä»»ä½ç±»åã ææ¶éè¦éå¶è¿äºç±»ååæ°ï¼ä»¥ä¾¿å®ä»¬åªè½ç±æäºç±»åçç³»åå®ä¾åã å æ­¤ï¼Dafny ä¸ä»å¨å¹½çµä¸ä¸æä¸­èä¸å¨ç¼è¯ä¸ä¸æä¸­åºåæ¯æç¸ç­æä½çç±»åã ä¸ºäºè¡¨æä¸ä¸ªç±»ååæ°è¢«éå¶ä¸ºè¿ç§æ¯æå¹³ç­çç±»åï¼ç±»ååæ°çåç§°éç¨åç¼â(==)âã[0](http://leino.science/papers/krml243. html#fn-fn-type-mode) ä¾å¦ï¼\n\nmethod Compareâ©T(==)âª(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\næ¯ä¸ç§æ¹æ³ï¼å¶ç±»ååæ°ä»éäºæ¯æç¸ç­çç±»åã åæ ·ï¼è¯·æ³¨æ all ç±»åå¨ ghost ä¸ä¸æä¸­æ¯æç¸ç­ï¼ åºå«ä»éç¨äºéå¹½çµï¼å³ç¼è¯ï¼ä»£ç ã å±å½çº³æ°æ®ç±»åãå½æ°ç±»åä»¥åå¸¦æå¹»ååæ°çå½çº³æ°æ®ç±»åæ¯ä¸æ¯æç­å¼çç±»åçç¤ºä¾ã Dafny æä¸äºæ¨çæ¯æï¼å¯ä»¥ä½¿æäºç­¾åä¸é£ä¹æ··ä¹±ï¼å¨ Dafny è¯­è¨åèçä¸åé¨åä¸­è¿è¡äºæè¿°ï¼ã å¨æäºæåµä¸ï¼è¿ç§æ¯æä¼æ¨æ­åºå¿é¡»å°ç±»ååæ°éå¶ä¸ºæ¯æç¸ç­çç±»åï¼å¨è¿ç§æåµä¸ï¼Dafny ä¼èªå¨æ·»å â(==)âã\n\n\n# 2.âéåç±»å\n\nDafny æä¾äºå ç§åç½®çéåç±»åã\n\n\n# 2.0.âéå\n\nå¯¹äºä»»ä½ç±»å Tï¼setãTã ç±»åçæ¯ä¸ªå¼é½æ¯ T å¼çæééåã éåæåèµæ ¼ç±ç±»å T ä¸­çç¸ç­æ§ç¡®å®ï¼å æ­¤åªæå½T æ¯æç¸ç­æ§æ¶ï¼setãTã æè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã å¯ä»¥ä½¿ç¨ set display è¡¨è¾¾å¼å½¢æä¸ä¸ªéåï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæ åºçãä¸åºåéå¤çè¡¨è¾¾å¼åè¡¨ï¼ç¨è±æ¬å·æ¬èµ·æ¥ã ä¸ºäºæ¾ç¤ºï¼\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\næ¯è®¾ç½®æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã è¿æä¸ä¸ª set comprehension è¡¨è¾¾å¼ï¼å¸¦ææ´»é¡µå¤¹ï¼å°±åå¨é»è¾éåä¸­ä¸æ ·ï¼ï¼å¨ Dafny è¯­è¨åèçä¸åé¨åè¿è¡äºæè¿°ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼éåç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çå­é\n<=    å­é\n>=    è¶é\n>     çè¶é\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã éåæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼æç»å®è½åéå¢çé¡ºåºååºï¼\n\n      \næä½ç¬¦   æè¿°\n      \n!!    ä¸ç¸äº¤\n      \n+     è®¾ç½®èå\n-     è®¾ç½®å·®å¼\n      \n*     è®¾ç½®äº¤ç¹\n      \n\n+ã- å * çç»åæ§è§åç±»ä¼¼äºååç®æ¯è¿ç®ç¬¦çç»åæ§è§åã è¡¨è¾¾å¼A !! Bï¼å®ççº¦æåä¸ç¸ç­æ§ç¸åï¼ä½å®æ¢ä¸ä¸ç¸ç­æ§èç³»ä¹ä¸è¿éï¼ï¼è¯´éåAåBæ²¡æå±åçåç´ ï¼ä¹å°±æ¯è¯´ï¼å®ç­ä»·äº\n\nA * B == {}\n\n\n1\n\n\nä½æ¯ï¼ä¸ç¸äº¤è¿ç®ç¬¦æ¯é¾å¼çï¼æä»¥ A !! B !! C !! Dè¡¨ç¤ºï¼\n\nA * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n\n\n1\n\n\næ­¤å¤ï¼å¯¹äºä»»ä½setãTãç±»åçéåsåä»»ä½Tç±»åçè¡¨è¾¾å¼eï¼éåæ¯æä»¥ä¸æä½ï¼\n\n          \nè¡¨è¾¾å¼       æè¿°\n          \n|s|       éååºæ°\ne in s    éåæå\ne !in s   éåéæå\n          \n\nè¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã\n\n\n# 2.1.âMultisets\n\nmultiset ç±»ä¼¼äºéåï¼ä½è·è¸ªæ¯ä¸ªåç´ çå¤éæ§ï¼èä¸ä»ä»æ¯å®çå­å¨æä¸å­å¨ã å¯¹äºä»»ä½ç±»å Tï¼multisetãTã ç±»åçæ¯ä¸ªå¼é½æ¯ä» T å¼å°è¡¨ç¤ºæ¯ä¸ªåç´ çå¤éæ§çèªç¶æ°çæ å°ã Dafny ä¸­çå¤ééæ¯æéçï¼ä¹å°±æ¯è¯´ï¼å®ä»¬åå«æéæ°éçæ¯ä¸ªæéåç´ ã æ¢å¥è¯è¯´ï¼å¤ééä»å°æéæ°éçåç´ æ å°å°éé¶ï¼æéï¼å¤éæ§ã ä¸éåä¸æ ·ï¼å¤éæåèµæ ¼ç±ç±»åâTâä¸­çç¸ç­æ§ç¡®å®ï¼å æ­¤åªæå½âTâæ¯æç¸ç­æ¶ï¼âå¤éãTãâæè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã å¯ä»¥ä½¿ç¨ multiset display è¡¨è¾¾å¼æ¥å½¢æå¤ééï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæ åºåçè¡¨è¾¾å¼åè¡¨ï¼åå«å¨å³é®å­ multiset åé¢çè±æ¬å·ä¸­ã ä¸ºäºæ¾ç¤ºï¼\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\næ¯å¤ç»æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã æ²¡æå¤éçè§£è¡¨è¾¾å¼ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼å¤ééç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çå¤éå­é\n<=    å¤éå­é\n>=    å¤éè¶é\n>     çå¤éè¶é\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã å¤ééæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼æç»å®è½åéå¢çé¡ºåºååºï¼\n\n      \næä½ç¬¦   æè¿°\n      \n!!    å¤éä¸ç¸äº¤\n      \n+     å¤éèå\n-     å¤éå·®å¼\n      \n*     å¤éäº¤é\n      \n\n+ã- å * çç»åæ§è§åç±»ä¼¼äºååç®æ¯è¿ç®ç¬¦çç»åæ§è§åã è¡¨è¾¾å¼'A !! Bè¡¨ç¤ºå¤ééAåB` æ²¡æå±åçåç´ ï¼ä¹å°±æ¯è¯´ï¼å®ç­ä»·äº\n\nA * B == multiset{}\n\n\n1\n\n\nä¸ç±»ä¼¼çéåè¿ç®ç¬¦ä¸æ ·ï¼!! æ¯é¾å¼çã æ­¤å¤ï¼å¯¹äºä»»ä½ç±»åä¸ºmultisetãTãçå¤éésãç±»åä¸ºTçè¡¨è¾¾å¼eååºäºéè´æ´æ°çæ°å­nï¼å¤ééæ¯æä»¥ä¸æä½ï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \n|s|         å¤éåºæ°\ne in s      å¤éæå\ne !in s     å¤ééæå\ns[e]        e å¨ s ä¸­çå¤æ ·æ§\ns[e := n]   å¤éæ´æ° (å¤æ ·æ§åå)\n            \n\nå½ä¸ä»å½ s[e] != 0 æ¶ï¼è¡¨è¾¾å¼ e in s æä¼è¿å trueã è¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã è¡¨è¾¾å¼ s[e := n] è¡¨ç¤ºç±»ä¼¼äº s çå¤ééï¼ä½åç´  e çå¤éæ§æ¯ nã è¯·æ³¨æï¼å¤ééæ´æ° s[e := 0] ä¼äº§çç±»ä¼¼ s çå¤ééï¼ä½ä¸ä¼åºç°ä»»ä½ eï¼æ è®º s é¦åæ¯å¦åºç°è¿eï¼ã ä½ä¸ºå¦ä¸ä¸ªç¤ºä¾ï¼è¯·æ³¨æ s - multiset{e} ç­ä»·äºï¼\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2.âåºå\n\nå¯¹äºä»»ä½ç±»åâTâï¼âseqãTãâç±»åçå¼è¡¨ç¤ºâTâåç´ çåºåï¼å³ä»è¿ç»­èªç¶æ°çæééåï¼ç§°ä¸ºindiciesï¼å°âTâçæ å° `ä»·å¼è§ã ï¼å°å¶è§ä¸ºä¸ä¸ªæ å°ï¼å æ­¤åºåæ¯å¤ééçå¯¹å¶ãï¼å¯ä»¥ä½¿ç¨ sequence display è¡¨è¾¾å¼å½¢æåºåï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªåå«å¨æ¹æ¬å·ä¸­çç©ºçãæåºçè¡¨è¾¾å¼åè¡¨ã ä¸ºäºééï¼\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\næ¯é¡ºåºæ¾ç¤ºçä¸ä¸ªç¤ºä¾ã æ²¡æåºåçè§£è¡¨è¾¾å¼ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼åºåç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çåç¼\n<=    åç¼\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã æ³¨ææ²¡æ>å>=ã åºåæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n+     è¿æ¥\n      \n\nè¿ç®ç¬¦ + æ¯å³èçï¼å°±åååçç®æ¯è¿ç®ç¬¦ä¸æ ·ã æ­¤å¤ï¼å¯¹äºä»»ä½ç±»åä¸ºâseqãTãâçåºåâsâï¼ç±»åä¸ºâTâçè¡¨è¾¾å¼âeâï¼åºäºæ´æ°çæ°å­âiâæ»¡è¶³â0 <= i < |s|âï¼ä»¥åæ´æ°- åºäºæ°å­ lo å hi æ»¡è¶³ 0 <= lo <= hi <= |s|ï¼åºåæ¯æä»¥ä¸æä½ï¼\n\n              \nè¡¨è¾¾å¼           æè¿°\n              \n|s|           åºåé¿åº¦\ns[i]          åºåéæ©\ns[i := e]     åºåæ´æ°\ne in s        åºåæå\ne !in s       åºåéæå\ns[lo..hi]     å­åºå\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   åç\nmultiset(s)   åºåè½¬æ¢ä¸º multisetâ©Tâª\n              \n\nè¡¨è¾¾å¼ s[i := e] è¿åä¸ä¸ªç±»ä¼¼ s çåºåï¼é¤äºç´¢å¼ i å¤çåç´ æ¯ eã è¡¨è¾¾å¼ e in s è¡¨ç¤ºå­å¨ä¸ä¸ªç´¢å¼ i ä½¿å¾ s[i] == eã ä»å½åç´ ç±»åâTâæ¯æç¸ç­æ¶ï¼æåè®¸å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã è¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã\n\nè¡¨è¾¾å¼ s[lo..hi] äº§çä¸ä¸ªåºåï¼è¯¥åºåéè¿è·åç¬¬ä¸ä¸ª hi åç´ ç¶åå é¤ç¬¬ä¸ä¸ª lo åç´ èå½¢æã å æ­¤ï¼ç»æåºåçé¿åº¦ä¸ºâhi - loâã è¯·æ³¨æï¼s[0..|s|] ç­äº sã å¦æçç¥ä¸éï¼åé»è®¤ä¸º |s|ï¼å æ­¤ s[lo..] ä¼çæéè¿å é¤ s çç¬¬ä¸ä¸ª lo åç´ å½¢æçåºåã å¦æçç¥ä¸éï¼åé»è®¤ä¸º 0ï¼å æ­¤ s[..hi] äº§çç± s çç¬¬ä¸ä¸ª hi åç´ å½¢æçåºåã\n\nå¨åºååçæä½ä¸­ï¼slices æ¯ä¸ä¸ªé¿åº¦æç¤ºç¬¦çéç©ºåè¡¨ï¼ç±åå·åéå¹¶å¯éå°ç»æ­¢ï¼å¹¶ä¸è³å°æä¸ä¸ªåå·ã æ¯ä¸ªé¿åº¦æç¤ºç¬¦é½æ¯ä¸ä¸ªåºäºéè´æ´æ°çæ°å­ï¼å¶æ»åä¸å¤§äº|s|ã å¦ææ k ä¸ªåå·ï¼åè¯¥æä½ä¼ä» s çæ k ä¸ªè¿ç»­å­åºåï¼æ¯ä¸ªé¿åº¦ç±ç¸åºçé¿åº¦æç¤ºç¬¦æç¤ºï¼å¹¶å°è¿äºä½ä¸ºåºååºåè¿åã1 å¦æ slices ä»¥åå·ç»å°¾ï¼é£ä¹æåä¸ä¸ªåççé¿åº¦ä¼ä¸ç´å»¶ä¼¸å° s çæ«å°¾ï¼å³ å®çé¿åº¦æ¯|s|åå»ç»å®é¿åº¦æç¤ºç¬¦çæ»åã ä¾å¦ï¼å¯¹äºä»»ä½é¿åº¦è³å°ä¸º 10 çåºå s ï¼ä»¥ä¸ç­å¼æç«ï¼\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næä½multiset(s)äº§çåºåsçåç´ çå¤ééã ä»å½åç´ ç±»åâTâæ¯æç¸ç­æ¶ï¼æåè®¸å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã\n\n# 2.2.0.âå­ç¬¦ä¸²\n\nåºåç±»åçä¸ä¸ªç¹ä¾æ¯seqãcharãï¼Dafny æä¾äºä¸ä¸ªåä¹è¯ï¼stringã å­ç¬¦ä¸²ä¸å¶ä»åºåç±»ä¼¼ï¼ä½ä¸ºåºåæ¾ç¤ºè¡¨è¾¾å¼æä¾äºé¢å¤çè¯­æ³ï¼å³å­ç¬¦ä¸²æå­ã å­ç¬¦ä¸²æå­æä¸¤ç§è¯­æ³å½¢å¼ï¼æ åå½¢å¼åéå­å½¢å¼ã\n\næ åå½¢å¼çå­ç¬¦ä¸²æå­ç¨åå¼å·æ¬èµ·æ¥ï¼å¦ \"Dafny\"ã è¦å¨è¿æ ·çå­ç¬¦ä¸²æå­ä¸­åå«åå¼å·ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåã è½¬ä¹åºåä¹å¯ç¨äºåå«å¶ä»å­ç¬¦ã æ¯æçè½¬ä¹åºåä¸å­ç¬¦æå­ç¸åï¼è¯·åéç¬¬ [0.2] è(http://leino.science/papers/krml243.html#sec-char)ã ä¾å¦ï¼Dafny è¡¨è¾¾å¼ \"say \\\"yes\\\"\" è¡¨ç¤ºå­ç¬¦ä¸² say \"yes\"ã åå¼å·çè½¬ä¹åºåæ¯å¤ä½çï¼å ä¸º \"'\" å \"'\" è¡¨ç¤ºç¸åçå­ç¬¦ä¸²ââæä¾è¿ä¸¤ç§å½¢å¼æ¯ä¸ºäºæ¯æä¸å­ç¬¦æå­ç¸åçè½¬ä¹åºåã\n\néå­å½¢å¼çå­ç¬¦ä¸²æå­ç¨ @\" å \" æ¬èµ·æ¥ï¼å¦ @\"Dafny\"ã è¦å¨è¿æ ·çå­ç¬¦ä¸²æå­ä¸­åå«åå¼å·ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåââï¼å³ä¸¤æ¬¡åå¥å­ç¬¦ã å¨éå­å½¢å¼ä¸­ï¼æ²¡æå¶ä»è½¬ä¹åºåã çè³åæ¢è¡ç¬¦è¿æ ·çå­ç¬¦ä¹å¯ä»¥åå¨å­ç¬¦ä¸²æå­ä¸­ï¼å æ­¤å¨ç¨åºææ¬ä¸­è·¨è¶å¤è¡ï¼ã ä¾å¦ï¼ä»¥ä¸ä¸ä¸ªè¡¨è¾¾å¼è¡¨ç¤ºç¸åçå­ç¬¦ä¸²ï¼\n\n\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nç±äºå­ç¬¦ä¸²æ¯åºåï¼å æ­¤å¨å®ä»¬ä¸å®ä¹äºå³ç³»è¿ç®ç¬¦ < å <=ã ä½æ¯è¯·æ³¨æï¼è¿äºè¿ç®ç¬¦ä»ç¶åå«è¡¨ç¤ºæ­£ç¡®çåç¼ååç¼ï¼èä¸æ¯å¯è½éè¦çæç§å­æ¯æ¯è¾ï¼ä¾å¦ï¼å¨å¯¹å­ç¬¦ä¸²è¿è¡æåºæ¶ã\n\n\n# 2.3.âæéä¸æ éå¾\n\nå¯¹äºä»»ä½ç±»åTåUï¼mapãTï¼Uãç±»åçå¼è¡¨ç¤ºä»Tå°Uç*ï¼æéï¼æ å°*ã æ¢å¥è¯è¯´ï¼å®æ¯ä¸ä¸ªç±Tç´¢å¼çæ¥æ¾è¡¨ã å°å¾ç domain æ¯ä¸ç»æéç T å¼ï¼å®ä»¬å·æå³èç U å¼ã ç±äºåä¸­çé®æ¯ä½¿ç¨ T ç±»åä¸­çç¸ç­æ§è¿è¡æ¯è¾çï¼å æ­¤åªæå½T æ¯æç¸ç­æ§æ¶ï¼ç±»åmapãT,Uã æè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã\n\nç±»ä¼¼å°ï¼å¯¹äºä»»ä½ç±»å T å Uï¼imapâ¨T,Uâ© ç±»åçå¼è¡¨ç¤º*ï¼å¯è½ï¼æ éæ å°*ã å¨å¤§å¤æ°æåµä¸ï¼imap<T,U> ç±»ä¼¼äº map<T,U>ï¼ä½æ¯ imap<T,U> ç±»åçæ å°åè®¸æä¸ä¸ªæ éåã\n\nå¯ä»¥ä½¿ç¨ map display è¡¨è¾¾å¼å½¢æå°å¾ï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæåºç maplets åè¡¨ï¼æ¯ä¸ª maplet å·æ t := u çå½¢å¼ï¼å¶ä¸­ t æ¯ T ç±»åçè¡¨è¾¾å¼ï¼å¹¶ä¸ u æ¯U ç±»åçè¡¨è¾¾å¼ï¼æ¾å¨å³é®å­map åé¢çæ¹æ¬å·ä¸­ã ä¸ºäºæ¾ç¤ºï¼\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\næ¯å°å¾æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã éè¿ä½¿ç¨å³é®å­ imap èä¸æ¯ mapï¼çæçå°å¾å°æ¯ imap<T,U> ç±»åèä¸æ¯ map<T,U>ã è¯·æ³¨æï¼åè®¸æ éæ å° (imap) å·ææéåï¼èä¸åè®¸æéæ å° (map) å·ææ éåã å¦æåä¸ä¸ªé®åºç°å¤æ¬¡ï¼åç»ææ å°ä¸­åªåºç°æåä¸æ¬¡åºç°ã2 è¿æä¸ä¸ª * å°å¾çè§£è¡¨è¾¾å¼*ï¼å¨ Dafny è¯­è¨åèçä¸åé¨åè¿è¡äºè§£éã\n\nå¯¹äºmap<T,U>ç±»åçä»»ä½æ å°fmï¼map<T,U>æimap<T,U>ç±»åçä»»ä½æ å°mï¼ç±»åçä»»ä½è¡¨è¾¾å¼t Tï¼Uç±»åçä»»ä½è¡¨è¾¾å¼uï¼ä»¥åmåä¸­çä»»ä½dï¼å³æ»¡è¶³d in m`ï¼ï¼æ å°æ¯æä»¥ä¸æä½ï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \n|fm|        å°å¾åºæ°\nm[d]        å°å¾éæ©\nm[t := u]   å°å¾æ´æ°\nt in m      æ å°åæå\nt !in m     æ å°åéæå\n            \n\n|fm| è¡¨ç¤ºfm ä¸­çæ å°ä¸ªæ°ï¼å³fm çåçåºæ°ã è¯·æ³¨æï¼æ éæ å°ä¸æ¯æåºæ°è¿ç®ç¬¦ã è¡¨è¾¾å¼ m[d] è¿å m ä¸ d å³èç U å¼ã è¡¨è¾¾å¼ m[t := u] æ¯ä¸ä¸ªç±»ä¼¼äº m çæ å°ï¼é¤äºé® t å¤çåç´ æ¯ uã\n\nè¡¨è¾¾å¼ t in m è¡¨ç¤º t å¨ m çåä¸­ï¼è t !in m æ¯ !(t in m) çè¯­æ³ç®åã 3 è¿æ¯ä¸ä¸ªå°ä¾å­ï¼å¶ä¸­ç±»åä¸º map<int,real> çå°å¾ cache ç¨äºç¼å­ Joule-Thomson ç³»æ°çè®¡ç®å¼ ç»å®æ¸©åº¦ä¸çä¸äºåºå®æ°ä½ï¼\n\nif K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJouleThomsonCoefficient(K);  // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.âè±¡å¾ç±»å\n\nææ¶éè¿å¤ä¸ªåç§°äºè§£ä¸ä¸ªç±»åææ½è±¡å°å¤çä¸ä¸ªç±»åå¾æç¨ã\n\n\n# 3.0.âåä¹è¯ç±»å\n\nç±»ååä¹è¯å£°æï¼\n\ntype Yâ©Tâª = G\n\n\n1\n\n\nå£°æ YãTã æ¯ç±»å G çåä¹è¯ã è¿éï¼T æ¯ä¸ä¸ªç±»ååæ°çéç©ºåè¡¨ï¼æ¯ä¸ªåæ°é½å¯éå°ç¨åç¼â(==)âæå®ï¼ï¼å®å¯ä»¥ç¨ä½G ä¸­çèªç±ç±»ååéã å¦æåä¹è¯æ²¡æç±»ååæ°ï¼åå é¤âãTãâã å¨æææåµä¸ï¼ç±»ååä¹è¯åªæ¯åä¹è¯ã ä¹å°±æ¯è¯´ï¼é¤äºå¯è½äº§ççéè¯¯æ¶æ¯ä¹å¤ï¼YãTã å G ä¹é´ä»æ¥æ²¡æåºå«ã\n\nä¾å¦ï¼ä»¥ä¸ç±»ååä¹è¯çåç§°å¯è½ä¼æé«ç¨åºçå¯è¯»æ§ï¼\n\ntype Replacementsâ©Tâª = mapâ©T,Tâª\ntype Vertex = int\n\n\n1\n2\n\n\nå¦ç¬¬ 2.2.0 ä¸­æè¿°ï¼string æ¯seqãcharã çåç½®ç±»ååä¹è¯ï¼å¥½å å®å°è¢«å®£å¸å¦ä¸ï¼\n\ntype string = seqâ©charâª\n\n\n1\n\n\n\n# 3.1.âä¸éæç±»å\n\nç±»ååä¹è¯çä¸ä¸ªç¹ä¾æ¯æªæå®çã è¿æ ·çç±»åç®åå°éè¿ä»¥ä¸æ¹å¼å£°æï¼\n\ntype Yâ©Tâª\n\n\n1\n\n\nå®è¢«ç§°ä¸ºä¸éæç±»åã å®çå®ä¹å¯ä»¥å¨ç²¾ç¼æ¨¡åä¸­æ¾ç¤ºã ä¸ºäºè¡¨æ Y è¡¨ç¤ºæ¯æç¸ç­çç±»åï¼å¯ä»¥å¨åç§°âYâä¹åç´§è·â(==)âã\n\nä¾å¦ï¼å£°æ\n\ntype T\nfunction F(t: T): T\n\n\n1\n2\n\n\nå¯ç¨äºå¨æä¸ªä»»æç±»åâTâä¸å»ºæ¨¡æªè§£éçå½æ°âFâã ä½ä¸ºå¦ä¸ä¸ªä¾å­ï¼\n\ntype Monadâ©Tâª\n\n\n1\n\n\nå¯ä»¥æ½è±¡å°ç¨äºè¡¨ç¤ºä»»æåæ°åç monadã\n\n\n# 4.âæ°æ®ç±»å\n\nDafny æä¾äºä¸¤ç§ä»£æ°æ°æ®ç±»åï¼ä¸ç§æ¯å½çº³å®ä¹çï¼å¦ä¸ç§æ¯åå½çº³å®ä¹çã æ¯ä¸ªæ°æ®ç±»åçæ¾çå±æ§æ¯è¯¥ç±»åçæ¯ä¸ªå¼å¯ä¸æ è¯æ°æ®ç±»åçæé å½æ°ä¹ä¸ï¼å¹¶ä¸æ¯ä¸ªæé å½æ°çåæ°é½æ¯åå°çã\n\n\n# 4.0.âå½çº³ç±»å\n\nå½çº³æ°æ®ç±»åçå¼å¯ä»¥çä½æ¯æéæ ï¼å¶ä¸­å¶å­æ¯åºæ¬ç±»åãæ°å¼ç±»åãå¼ç¨ç±»åãå±å½çº³æ°æ®ç±»åæå½æ°ç±»åçå¼ã å®éä¸ï¼å¯ä»¥ä½¿ç¨ Dafny ææ ¹æ®ç < æåºæ¥æ¯è¾å½çº³æ°æ®ç±»åçå¼ã\n\nå½çº³æ°æ®ç±»åå£°æå¦ä¸ï¼\n\ndatatype Dâ©Tâª = Ctors\n\n\n1\n\n\nå¶ä¸­ *Ctors* æ¯ä¸ä¸ªéç©ºç | åéç (datatype) æé å½æ° çæ°æ®ç±»ååè¡¨ã æ¯ä¸ªæé å½æ°é½æä»¥ä¸å½¢å¼ï¼\n\nC(params)\n\n\n1\n\n\nå¶ä¸­ *params* æ¯ä¸ä¸ªéå·åéçç±»ååè¡¨ï¼åé¢å¯éåæ°åç§°ååå·ï¼åé¢å¯éå³é®å­ ghostã å¦ææé å½æ°æ²¡æåæ°ï¼åå¯ä»¥çç¥æé å½æ°åç§°åé¢çæ¬å·ã å¦ææ²¡ææé å½æ°æ¥ååæ°ï¼åè¯¥ç±»åéå¸¸ç§°ä¸ºæä¸¾ï¼ ä¾å¦ï¼\n\ndatatype Friends = Agnes | Agatha | Jermaine | Jack\n\n\n1\n\n\nå¯¹äºæ¯ä¸ªæé å½æ° Cï¼Dafny å®ä¹äºä¸ä¸ª discriminator C?ï¼å®æ¯ä¸ä¸ªè¿å true çæåï¼å½ä¸ä»å½æ°æ®ç±»åå¼æ¯ä½¿ç¨ C æé çã å¯¹äºæé å½æ° C çæ¯ä¸ªå½ååæ° pï¼Dafny å®ä¹äºä¸ä¸ª destructor pï¼å®æ¯ä»ç¨äºæé æ°æ®ç±»åå¼ç C è°ç¨è¿å p åæ°çæåï¼ å®çä½¿ç¨è¦æ± C? æç«ã ä¾å¦ï¼å¯¹äºæ åç List ç±»å\n\ndatatype Listâ©Tâª = Nil | Cons(head: T, tail: Listâ©Tâª)\n\n\n1\n\n\nä»¥ä¸æç«ï¼\n\nCons(5, Nil).Cons? && Cons(5, Nil).head == 5\n\n\n1\n\n\næ³¨æè¡¨è¾¾å¼\n\nCons(5, Nil).tail.head\n\n\n1\n\n\næ ¼å¼ä¸æ­£ç¡®ï¼å ä¸º Cons(5, Nil).tail ä¸æ»¡è¶³ Cons?ã\n\nææå½æ°çåç§°å¨æ°æ®ç±»åçæææé å½æ°ä¸­å¿é¡»æ¯å¯ä¸çã æé å½æ°å¯ä»¥ä¸å°é­æ°æ®ç±»åååï¼ è¿å¯¹äºéå¸¸ç§°ä¸ºè®°å½ç±»åçåæé å½æ°æ°æ®ç±»åç¹å«æç¨ã ä¾å¦ï¼é»ç½åç´ çè®°å½ç±»åå¯è½è¡¨ç¤ºå¦ä¸ï¼\n\ndatatype Pixel = Pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nè¦è°ç¨æé å½æ°ï¼éå¸¸åªéè¦æåæé å½æ°çåç§°ï¼ä½å¦æè¿ä¸æç¡®ï¼åå§ç»å¯ä»¥éè¿æ°æ®ç±»åçåç§°æ¥éå®æé å½æ°çåç§°ã æ¯å¦ä¸é¢çCons(5, Nil)å¯ä»¥åæ\n\nList.Cons(5, List.Nil)\n\n\n1\n\n\nä½ä¸ºæ¾å¼è°ç¨æ°æ®ç±»åæé å½æ°çæ¿ä»£æ¹æ³ï¼å¯ä»¥ä½¿ç¨ datatype update è¡¨è¾¾å¼å°æ°æ®ç±»åå¼æé ä¸ºä¸ä¸ªåæ°ä»ç»å®æ°æ®ç±»åå¼çååã å¯¹äºä»»ä½ç±»åä¸ºæ°æ®ç±»åçâdâï¼è¯¥æ°æ®ç±»ååæ¬æé å½æ°âCâï¼è¯¥æé å½æ°å·æåä¸ºâfâçç±»åä¸ºâTâçåæ°ï¼ææå½æ°ï¼ï¼ä»¥åä»»ä½ç±»åä¸ºâTâçè¡¨è¾¾å¼âtâï¼\n\nd[f := t]\n\n\n1\n\n\næé ä¸ä¸ªç±»ä¼¼äº d ä½å¶ f åæ°æ¯ t çå¼ã è¯¥æä½è¦æ± d æ»¡è¶³ C?ã ä¾å¦ï¼ä»¥ä¸ç­å¼æç«ï¼\n\nCons(4, Nil)[tail := Cons(3, Nil)] == Cons(4, Cons(3, Nil))\n\n\n1\n\n\n\n# 4.1.âåç»ç±»å\n\nDafny æå»ºäºå¯¹åºäºåç»çè®°å½ç±»åï¼å¹¶ä¸ºå®ä»¬æä¾äºä¸ç§æ¹ä¾¿çç¹æ®è¯­æ³ï¼å³æ¬å·ã ä¾å¦ï¼å¯è½å·²å£°æä¸ºï¼\n\ndatatype Pairâ©T,Uâª = Pair(0: T, 1: U)\n\n\n1\n\n\nDafny æä¾äºç±»å (T, U) åæé å½æ° (t, u)ï¼å¥½åæ°æ®ç±»åçåç§°æ¯ââï¼å¹¶ä¸å®çç±»ååæ°å¨åæ¬å·ä¸­ç»åºï¼å¹¶ä¸å¥½åæé å½æ°åç§°æ¯ââ . è¯·æ³¨æï¼ææå½æ°åç§°æ¯â0âåâ1âï¼å®ä»¬æ¯æåçåæ³æ è¯ç¬¦åç§°ã ä¾å¦ï¼æ¾ç¤ºåç»ææå½æ°çä½¿ç¨ï¼è¿éæä¸ä¸ªåå« 2 åç»çå±æ§ï¼å³ pairsï¼ï¼\n\n(5, true).1 == true\n\n\n1\n\n\nDafny å£°æ n åç»ï¼å¶ä¸­ n ä¸º 0 æ 2 ææ´é«ã æ²¡æ 1 åç»ï¼å ä¸ºå´ç»åä¸ªç±»åæåä¸ªå¼çæ¬å·æ²¡æè¯­ä¹æä¹ã 0 åç»ç±»å () éå¸¸è¢«ç§°ä¸º unit ç±»åï¼å®çåä¸ªå¼ï¼ä¹åä½ ()ï¼è¢«ç§°ä¸º unitã\n\n\n# 4.2.âå±åå½çº³ç±»å\n\nå°½ç®¡ Dafny åæè®¤ä¸ºæä¸ç§æ¹æ³å¯ä»¥ä»å¤´å¼å§æé æ¯ä¸ªå½çº³æ°æ®ç±»åå¼ï¼ä½ Dafny è¿æ¯æ co-inductive datatypesï¼å¶æé å½æ°è¢«å»¶è¿è¯ä¼°ï¼å æ­¤åè®¸æ éç»æã ä½¿ç¨å³é®å­âcodatatypeâå£°æå±å½çº³æ°æ®ç±»åï¼ é¤æ­¤ä¹å¤ï¼å®åå½çº³æ°æ®ç±»åä¸æ ·è¢«å£°æåä½¿ç¨ã\n\nä¾å¦,\n\ncodatatype IListâ©Tâª = Nil | Cons(head: T, tail: IListâ©Tâª)\ncodatatype Streamâ©Tâª = More(head: T, tail: Streamâ©Tâª)\ncodatatype Treeâ©Tâª = Node(left: Treeâ©Tâª, value: T, right: Treeâ©Tâª)\n\n\n1\n2\n3\n\n\nåå«å£°æå¯è½æ éçåè¡¨ï¼å³å¯ä»¥æ¯æéææ éçåè¡¨ï¼ãæ éæµï¼å³å§ç»æ éçåè¡¨ï¼åæ éäºåæ ï¼å³æ¯ä¸ªåæ¯æ°¸è¿å­å¨çæ ï¼ã\n\n\n# 5.âåç§ç±»å\n\nDafny æä¾äºè®¸å¤åèç±»åã è¿äºä»£è¡¨å¯¹ç¨åºå ä¸­å¨æåéçå¯¹è±¡çå¼ç¨ã è¦è®¿é®å¯¹è±¡çæåï¼å¯¹å¯¹è±¡çå¼ç¨ï¼å³æé æå¯¹è±¡æ è¯ï¼è¢«åæ¶å¼ç¨ã\n\nç¹æ®å¼ null æ¯æ¯ä¸ªå¼ç¨ç±»åçä¸é¨åã4\n\n\n# 5.0.âç±»\n\nclass C æ¯ä¸ä¸ªå¼ç¨ç±»åï¼å£°æå¦ä¸ï¼\n\nclass Câ©Tâª extends J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­ç±»ååæ°åè¡¨Tæ¯å¯éçï¼âextends Jâä¹æ¯å¦æ­¤ï¼å®è¡¨ç¤ºè¯¥ç±»æ©å±äºä¸ä¸ªç¹å¾âJâã ç±»çæåæ¯ fieldsãfunctions å methodsã è¿äºæ¯éè¿åæ¶å¼ç¨å¯¹âCâå®ä¾çå¼ç¨æ¥è®¿é®æè°ç¨çã é¤éå½æ°ææ¹æ³å£°æä¸º staticï¼å¦åå½æ°ææ¹æ³ä¼å¨ C ç instance ä¸è°ç¨ã æºæ¢°å°ï¼è¿åªæ¯æå³çè¯¥æ¹æ³éç¨éå¼ receiver åæ°ï¼å³ç¨äºè®¿é®æåçå®ä¾ã å¨å®ä¾å½æ°ææ¹æ³çè§èåä¸»ä½ä¸­ï¼æ¥æ¶å¨åæ°å¯ä»¥éè¿å³é®å­ this æ¾å¼å¼ç¨ã ä½æ¯ï¼å¨è¿æ ·çå°æ¹ï¼thisçæåä¹å¯ä»¥æ æ¡ä»¶å°è¢«æåã ä¸ºäºè¯´æï¼åæ ¼ç this.f åä¸åæ ¼ç f å¨ä»¥ä¸ç¤ºä¾ä¸­æçæ¯åä¸å¯¹è±¡çåä¸å­æ®µï¼\n\nclass C {\n  var f: int;\n  method Example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næä»¥æ¹æ³ä½æ»æ¯å° true åéç»è¾åºåæ° bã å¯¹åä¸æ¥æ¶èåæåçåæ ¼åä¸åæ ¼è®¿é®ä¹é´æ²¡æè¯­ä¹å·®å¼ã\n\nä¸ä¸ª C å®ä¾æ¯ä½¿ç¨ new åå»ºçï¼ä¾å¦ï¼\n\nc := new C;\n\n\n1\n\n\nè¯·æ³¨æï¼new åªæ¯åéä¸ä¸ª C å¯¹è±¡å¹¶è¿åå¯¹å®çå¼ç¨ï¼ å¶å­æ®µçåå§å¼æ¯å®ä»¬åèªç±»åçä»»æå¼ã å æ­¤ï¼éå¸¸å¨åå»ºåç«å³è°ç¨ç§°ä¸º initialization method çæ¹æ³ï¼ä¾å¦ï¼\n\nc := new C;\nc.InitFromList(xs, 3);\n\n\n1\n2\n\n\nå½åå§åæ¹æ³æ²¡æout-parameterå¹¶ä¸ä¿®æ¹ä¸è¶è¿thisæ¶ï¼é£ä¹ä¸é¢çä¸¤ä¸ªè¯­å¥å¯ä»¥åå¹¶ä¸ºä¸ä¸ªï¼\n\nc := new C.InitFromList(xs, 3);\n\n\n1\n\n\nè¯·æ³¨æï¼ä¸ä¸ªç±»å¯ä»¥åå«å¤ä¸ªåå§åæ¹æ³ï¼è¿äºæ¹æ³å¯ä»¥éæ¶è°ç¨ï¼èä¸ä»ä»æ¯ä½ä¸ºnewçä¸é¨åï¼å¹¶ä¸newä¸éè¦å¨åå»ºæ¶è°ç¨åå§åæ¹æ³ã\n\nè¦ç¼åç»æåçé¢åå¯¹è±¡ç¨åºï¼éå¸¸ä¾èµäºä»ä»¥ç¹å®æ¹å¼æé å¯¹è±¡ã ä¸ºæ­¤ï¼Dafny æä¾äº constructor (method)sï¼è¿æ¯ä¸ç§åéå½¢å¼çåå§åæ¹æ³ã æé å½æ°æ¯ç¨å³é®å­constructorèä¸æ¯methodå£°æçã å½ä¸ä¸ªç±»åå«æé å½æ°æ¶ï¼å¯¹è¯¥ç±»çæ¯æ¬¡è°ç¨ new é½å¿é¡»ä¼´éå¯¹æé å½æ°ä¹ä¸çè°ç¨ã æ­¤å¤ï¼ä¸è½å¨å¶ä»æ¶é´è°ç¨æé å½æ°ï¼åªè½å¨å¯¹è±¡åå»ºæé´è°ç¨ã é¤äºè¿äºéå¶ä¹å¤ï¼ä½¿ç¨æ®éåå§åæ¹æ³åä½¿ç¨æé å½æ°ä¹é´æ²¡æè¯­ä¹ä¸çåºå«ã\n\nDafny è®¾è®¡åè®¸å½åæé å½æ°ï¼è¿ä¿è¿äºä½¿ç¨ä¸é¢çâInitFromListâä¹ç±»çåç§°ã å°½ç®¡å¦æ­¤ï¼è®¸å¤ç±»åªæä¸ä¸ªæé å½æ°ææä¸ä¸ªå¸åçæé å½æ°ã å æ­¤ï¼Dafny åè®¸ä¸ä¸ªå¿åæé å½æ°ï¼å³åç§°æ¬è´¨ä¸æ¯ââçæé å½æ°ã ä¾å¦ï¼\n\nclass Item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nè°ç¨æ­¤æé å½æ°æ¶ï¼ä¼å é¤â.âï¼å¦ä¸æç¤ºï¼\n\nm := new Item(45, 29);\n\n\n1\n\n\nè¯·æ³¨æï¼å¿åæé å½æ°åªæ¯å½åæé å½æ°çä¸ç§æ¹å¼ï¼ ä¹å¯ä»¥æå¶ä»æé å½æ°ã\n\n\n# 5.1.âæ°ç»\n\nDafny æ¯æä»»ä½æ­£ç»´åº¦çå¯ååºå®é¿åº¦æ°ç»ç±»åã æ°ç»ç±»åæ¯å¼ç¨ç±»åã\n\n# 5.1.0.âä¸ç»´æ°ç»\n\nn T åç´ çä¸ç»´æ°ç»åå»ºå¦ä¸ï¼\n\na := new T[n];\n\n\n1\n\n\næ°ç»åç´ çåå§å¼æ¯âTâç±»åçä»»æå¼ã ä½¿ç¨ä¸å¯åç Length æåæ£ç´¢æ°ç»çé¿åº¦ã ä¾å¦ä¸é¢åéçæ°ç»æ»¡è¶³ï¼\n\na.Length == n\n\n\n1\n\n\nå¯¹äº 0 <= i < a.Length èå´åçä»»ä½åºäºæ´æ°çæ°å­ iï¼array selection è¡¨è¾¾å¼ a[i] æ£ç´¢åç´  iï¼å³ï¼åé¢æ i æ°ç»ä¸­çåç´ ï¼ã å¯ä»¥ä½¿ç¨æ°ç»æ´æ°è¯­å¥å°å­å¨å¨ i çåç´ æ´æ¹ä¸ºå¼ tï¼\n\na[i] := t;\n\n\n1\n\n\nè­¦åï¼ç±new T[n]åå»ºçæ°ç»ç±»åæ¯arrayãTãã ä¸ä¸ªå®¹æç¯çéè¯¯æ¯å¨ new åé¢å array<T> èä¸æ¯ Tã ä¾å¦ï¼èèä»¥ä¸æåµï¼\n\nvar a := new arrayâ©Tâª;\nvar b := new arrayâ©Tâª[n];\nvar c := new arrayâ©Tâª(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nç¬¬ä¸æ¡è¯­å¥åéäºä¸ä¸ªç±»åä¸º arrayãTã çæ°ç»ï¼ä½é¿åº¦æªç¥ã ç¬¬äºä¸ªåéä¸ä¸ªé¿åº¦ä¸ºânâçâarrayãarrayãTããâç±»åçæ°ç»ï¼å³ä¸ä¸ªåå«ânâç±»åçâarrayãTãâå¼çæ°ç»ã ç¬¬ä¸æ¡è¯­å¥åéä¸ä¸ªç±»åä¸ºarrayãTãçæ°ç»ï¼ç¶åå°è¯è°ç¨è¿ä¸ªæ°ç»çå¿åæé å½æ°ï¼ä¼ éåæ°nã ç±äºarrayæ²¡ææé å½æ°ï¼æ´ä¸ç¨è¯´å¿åæé å½æ°äºï¼è¿ä¸ªè¯­å¥ä¼äº§çéè¯¯ã å¦æå¯¹äºéè¦ç±»ååæ°çç±»åçç¥äºç±»ååæ°åè¡¨ï¼Dafny å°å°è¯å¡«åè¿äºï¼å æ­¤åªè¦å¯ä»¥æ¨æ­åºarrayç±»ååæ°ï¼å°±å¯ä»¥çç¥âãTã â å¨ä¸é¢çç¬¬åä¸ªè¯­å¥ä¸­ã ä½æ¯ï¼ä¸ç¬¬ä¸æ¡è¯­å¥ä¸æ ·ï¼array` æ²¡æå¿åæé å½æ°ï¼å æ­¤ä¼çæéè¯¯æ¶æ¯ã\n\nä¸ç»´æ°ç»æ¯æå°ä¸ç³»åè¿ç»­åç´ è½¬æ¢ä¸ºåºåçæä½ã å¯¹äºä»»ä½ç±»åä¸ºarrayãTãçæ°ç»aï¼åºäºæ´æ°çæ°å­loåhiæ»¡è¶³0 <= lo <= hi <= a.Lengthï¼ä»¥ä¸æä½åèªäº§çä¸ä¸ªseq ãTãï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \na[lo..hi]   å­æ°ç»è½¬ä¸ºåºå\na[lo..]     drop\na[..hi]     take\na[..]       æ°ç»è½¬æ¢ä¸ºåºå\n            \n\nè¡¨è¾¾å¼ a[lo..hi] è·åæ°ç»çç¬¬ä¸ä¸ª hi åç´ ï¼ç¶åå é¤å¶ä¸­çç¬¬ä¸ä¸ª lo åç´ å¹¶è¿åå©ä½çåºåã å æ­¤ï¼ç»æåºåçé¿åº¦ä¸ºâhi - loâã å¶ä»æä½æ¯ç¬¬ä¸ä¸ªæä½çç¹æ®å®ä¾ã å¦æçç¥ loï¼åé»è®¤ä¸º 0ï¼å¦æçç¥ hiï¼åé»è®¤ä¸º a.Lengthã å¨æåä¸ä¸ªæä½ä¸­ï¼lo å hi é½è¢«çç¥äºï¼å æ­¤ a[..] è¿åç± a çæææ°ç»åç´ ç»æçåºåã\n\nå­æ°ç»æä½å¨è§èä¸­ç¹å«æç¨ã ä¾å¦ï¼ä½¿ç¨åéâloâåâhiâæ¥ååä»ç¶å¯ä»¥æ¾å°æç´¢âkeyâçå­æ°ç»çäºåæç´¢ç®æ³çå¾ªç¯ä¸åéå¯ä»¥è¡¨ç¤ºå¦ä¸ï¼\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nå¦ä¸ä¸ªç¨éæ¯è¯´æä¸ªèå´çæ°ç»åç´ èªæ¹æ³å¼å§ä»¥æ¥æ²¡ææ¹åï¼\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\næä»å¾ªç¯å¼å§ï¼\n\nghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næ³¨æè¿ä¸ªä¾å­ä¸­çprevElementsçç±»åæ¯seq<T>ï¼å¦æaçç±»åæ¯array<T>ã\n\nå­æ°ç»æä½çæåä¸ä¸ªç¤ºä¾å¨äºè¡¨ç¤ºæ°ç»çåç´ æ¯æ¹æ³å¼å¤´çæ°ç»åç´ çæåï¼å°±åå¨å¤§å¤æ°æåºç®æ³ä¸­æåçé£æ ·ã å¨è¿éï¼å­æ°ç»æä½ä¸åºåå°å¤éçè½¬æ¢ç¸ç»åï¼\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1.âå¤ç»´æ°ç»\n\n2 ç»´ææ´å¤ç»´çæ°ç»å¤§å¤ç±»ä¼¼äºä¸ç»´æ°ç»ï¼ä¸åä¹å¤å¨äº new éè¦æ´å¤é¿åº¦åæ°ï¼æ¯ä¸ªç»´åº¦ä¸ä¸ªï¼ï¼å¹¶ä¸æ°ç»éæ©è¡¨è¾¾å¼åæ°ç»æ´æ°è¯­å¥éè¦æ´å¤ç´¢å¼ã ä¾å¦ï¼\n\nmatrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\nåå»ºä¸ä¸ªäºç»´æ°ç»ï¼å¶ç»´åº¦çé¿åº¦åå«ä¸ºâmâåânâï¼ç¶åäº¤æ¢âi,jâåâx,yâå¤çåç´ ã matrix çç±»åæ¯ array2<T>ï¼å¯¹äºé«ç»´æ°ç»ï¼array3<T>ãarray4<T> ç­ï¼ä¹æ¯å¦æ­¤ã ä½æ¯è¯·æ³¨æï¼æ²¡æç±»å array0<T>ï¼æ¬æ¥å¯ä»¥æ¯ array1<T> çä¸è¥¿å®éä¸åªæ¯å½åä¸º array<T>ã\n\nä¸é¢ç new æä½è¦æ± m å n æ¯åºäºéè´æ´æ°çæ°å­ã å¯ä»¥ä½¿ç¨ä¸å¯åå­æ®µ Length0 å Length1 æ£ç´¢è¿äºé¿åº¦ã ä¾å¦ï¼ä»¥ä¸ä¿å­äºä¸é¢åå»ºçæ°ç»ï¼\n\nmatrix.Length0 == m && matrix.Length1 == n\n\n\n1\n\n\né«ç»´æ°ç»ç±»ä¼¼ï¼Length0ãLength1ãLength2ã...ï¼ã æ°ç»éæ©è¡¨è¾¾å¼åæ°ç»æ´æ°è¯­å¥è¦æ±ç´¢å¼å¨èå´åã ä¾å¦ï¼ä¸é¢çäº¤æ¢è¯­å¥åªæå¨ä»¥ä¸æåµä¸ææ¯æ ¼å¼æ­£ç¡®çï¼\n\n0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n\n\n1\n2\n\n\nä¸ä¸ç»´æ°ç»ç¸æ¯ï¼æ²¡æå°åç´ çå»¶ä¼¸ä»å¤ç»´æ°ç»è½¬æ¢ä¸ºåºåçæä½ã\n\n\n# 5.2.âç¹å¾\n\ntrait æ¯ä¸ä¸ªâæ½è±¡è¶ç±»âï¼æèç§°å®ä¸ºâæ¥å£âæâmixinâã ç¹å¾å¯¹ Dafny æ¥è¯´æ¯æ°çï¼å¹¶ä¸å¯è½ä¼åå±ä¸æ®µæ¶é´ã ä¸ä¸ª trait çå£°æå¾åä¸ä¸ªç±»çå£°æï¼\n\ntrait J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­ *members* å¯ä»¥åå«å­æ®µãå½æ°åæ¹æ³ï¼ä½ä¸è½åå«æé å½æ°æ¹æ³ã åè®¸å°å½æ°åæ¹æ³å£°æä¸ºâéæâã\n\næ©å±ç¹å¾âJâçå¼ç¨ç±»åâCâå¯ä»¥åéç»âJâï¼ä½ä¸è½åè¿æ¥ã J çæåå¯ä»¥ä½ä¸ºC çæåä½¿ç¨ã J ä¸­çæåä¸åè®¸å¨C ä¸­éæ°å£°æï¼é¤éè¯¥æåæ¯å¨J ä¸­æ²¡æä¸»ä½çéstatic å½æ°ææ¹æ³ã éè¿è¿æ ·åï¼ç±»åâCâå¯ä»¥ä¸ºæåæä¾æ´å¼ºå¤§çè§èåä¸»ä½ã\n\nnew ä¸åè®¸ä¸ç¹å¾ä¸èµ·ä½¿ç¨ã å æ­¤ï¼æ²¡æåéç±»åæ¯ç¹å¾çå¯¹è±¡ã ä½æ¯å½ç¶å¯ä»¥æä¸ä¸ªç±» C çå¯¹è±¡å®ç°äºä¸ä¸ªç¹å¾ J ï¼å¹¶ä¸å¯¹è¿æ ·ä¸ä¸ª C å¯¹è±¡çå¼ç¨å¯ä»¥ç¨ä½ç±»å J çå¼ã\n\nä¾å¦ï¼ä»¥ä¸ç¹å¾è¡¨ç¤ºå¯ç§»å¨çå ä½å½¢ç¶ï¼\n\ntrait Shape\n{\n  function method Width(): real\n    reads this\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næå Width å Move æ¯ abstract ï¼å³æ ä¸»ä½ï¼ï¼å¹¶ä¸å¯ä»¥ç±æ©å± trait çä¸åç±»ä»¥ä¸åæ¹å¼å®ç°ã æ¹æ³ MoveH çå®ç°å¨ trait ä¸­ç»åºï¼å æ­¤è¢«æææ©å± Shape çç±»ä½¿ç¨ã è¿éæä¸¤ä¸ªç±»ï¼æ¯ä¸ªç±»é½æ©å±äºâShapeâï¼\n\nclass UnitSquare extends Shape\n{\n  var x: real, y: real;\n  function method Width(): real {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real;\n  function method Width(): real\n    reads this\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nè¯·æ³¨æï¼ç±»å¯ä»¥å£°æå¶ä»æåï¼å®ä»¬ä¸ºç¹å¾çæ½è±¡æåæä¾å®ç°ï¼å®ä»¬éå¤æåç­¾åï¼å¹¶ä¸å®ä»¬è´è´£æä¾èªå·±çæåè§èï¼è¿äºè§èæ¢å å¼ºäºç¹å¾ä¸­çç¸åºè§èï¼åæ¯ å¯¹æä¾çæºææå°æ»¡æã æåï¼è¿æ¯ä¸äºåå»ºä¸¤ä¸ªç±»å®ä¾å¹¶å°å®ä»¬ä¸èµ·ç¨ä½å½¢ç¶çä»£ç :\n\nvar myShapes: seqâ©Shapeâª;\nvar A := new UnitSquare;\nmyShapes := [A];\nvar tri := new LowerRightTriangle;\nmyShapes := myShapes + [tri];  // myShapes contains two Shape values, of different classes\nmyShapes[1].MoveH(myShapes[0].Width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.âç±»å object\n\næä¸ä¸ªåç½®çå¼ç¨ç±»åobjectï¼å®å°±åææå¼ç¨ç±»åçè¶ç±»åã5 type object æ¯ä¸ºäºå¯ç¨å¯¹å¨æå¸§çç»ä¸å¤çã ç¹å«æ¯ï¼ä¿çç±»åä¸º setãobjectã çå¹½çµå­æ®µï¼éå¸¸å½åä¸ºRepr` è¡¨ç¤ºâè¡¨ç¤ºâï¼å¾æç¨ã\n\n\n# 5.4.âè¿­ä»£å¨ç±»å\n\niterator ä¸ºç¼åè¿­ä»£è¿ååç´ çä»£ç æä¾äºç¼ç¨æ½è±¡ã è¿äº CLU é£æ ¼çè¿­ä»£å¨æ¯ååä¾ç¨ï¼å ä¸ºå®ä»¬è·è¸ªèªå·±çç¨åºè®¡æ°å¨ï¼å¹¶ä¸æ§å¶å¯ä»¥ä¼ å¥åä¼ åºè¿­ä»£å¨ä¸»ä½ã\n\nè¿­ä»£å¨å£°æå¦ä¸ï¼\n\niterator Iterâ©Tâª(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nå¶ä¸­ T æ¯ç±»ååæ°çåè¡¨ï¼éå¸¸ï¼å¦ææ²¡æç±»ååæ°ï¼åçç¥âãTãâï¼ã è¿ä¸ªå£°æäº§çäºä¸ä¸ªååçå¼ç¨ç±»åï¼IterãTãã å¨ç­¾åä¸­ï¼in-parameters å yield-parameters æ¯è¿­ä»£å¨å¯¹æ¹æ³ç in-parameters å out-parameters çæ¨¡æã ä¸åä¹å¤å¨äºï¼æ¹æ³çè¾åºåæ°åªè¿åç»è°ç¨èä¸æ¬¡ï¼èè¿­ä»£å¨ç yield åæ°å¨è¿­ä»£å¨ä¸»ä½æ§è¡ yield æ¶è¿åã è§èçè¯¦ç»ä¿¡æ¯å¨ Dafny è¯­è¨åèçä¸åé¨åä¸­è¿è¡äºæè¿°ã ä¸»ä½ç±è¯­å¥ç»æï¼å°±åå¨æ¹æ³ä¸»ä½ä¸­ä¸æ ·ï¼ä½ä¹å¯ä»¥ä½¿ç¨ yield è¯­å¥ã\n\nä»è¿­ä»£å¨å®¢æ·ç«¯çè§åº¦æ¥çï¼iterator å£°æå¯ä»¥çè§£ä¸ºçæå·æåç§æåçç±»IterãTãï¼ä¸é¢å°æè¿°å¶ç®åçæ¬ã\n\n`IterãTã ç±»åå«ä¸ä¸ªå¿åæé å½æ°ï¼å¶åæ°æ¯è¿­ä»£å¨çååæ°ï¼\n\npredicate Valid()\nconstructor (in-params)\n  modifies this\n  ensures Valid()\n\n\n1\n2\n3\n4\n\n\nä½¿ç¨ new åè¿ä¸ªå¿åæé å½æ°åå»ºäºä¸ä¸ªè¿­ä»£å¨ã ä¾å¦ï¼ä¸ä¸ªæ¿æä» start è¿ååä¸ªè¿ç»­æ´æ°çè¿­ä»£å¨å¯ä»¥å£°æå¦ä¸ï¼\n\niterator Gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿ä¸ªè¿­ä»£å¨çä¸ä¸ªå®ä¾æ¯ä½¿ç¨ä»¥ä¸æ¹æ³åå»ºçï¼\n\niter := new Gen(30);\n\n\n1\n\n\nè°è¯âValid()âè¡¨ç¤ºè¿­ä»£å¨ä½æ¶å¤äºå¯ä»¥å°è¯è®¡ç®æ´å¤åç´ çç¶æã å®æ¯æé å½æ°çåç½®æ¡ä»¶ï¼åºç°å¨âMoveNextâæåçè§èä¸­ï¼\n\nmethod MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n\n\n1\n2\n3\n4\n\n\nè¯·æ³¨æï¼åªè¦ MoveNext è¿å trueï¼è¿­ä»£å¨ä»ç¶ææã ä¸æ¦ MoveNext è¿å falseï¼å°±ä¸è½åè°ç¨ MoveNext æ¹æ³ã è¯·æ³¨æï¼å®¢æ·ç«¯æ²¡æä¹å¡ç»§ç»­è°ç¨ MoveNext ç´å°å®è¿å falseï¼å¹¶ä¸åè®¸è¿­ä»£å¨çä¸»ä½æ°¸è¿ä¿æè¿ååç´ ã\n\nè¿­ä»£å¨çè¾å¥åæ°å­å¨å¨è¿­ä»£å¨ç±»çä¸å¯åå­æ®µä¸­ã ä¸ºäºæ ¹æ®ä¸é¢çç¤ºä¾è¿è¡è¯´æï¼è¿­ä»£å¨ç±»âGenâåå«ä»¥ä¸å­æ®µï¼\n\nvar start: int;\n\n\n1\n\n\näº§éåæ°ä¹å¯¼è´è¿­ä»£å¨çæå class:\n\nvar x: int;\n\n\n1\n\n\nè¿äºå­æ®µç±âMoveNextâæ¹æ³è®¾ç½®ã å¦æ MoveNext è¿å trueï¼åè¿äºå­æ®µä¸­æä¾äºææ°çæ¶ççå¼ï¼å®¢æ·ç«¯å¯ä»¥ä»é£éè¯»åå®ä»¬ã\n\nä¸ºäºå¸®å©ç¼åè§èï¼è¿­ä»£å¨ç±»è¿åå«ä¿çâMoveNextâè¿åå¼çåå²è®°å½çå¹½çµæåã è¿äºå¹½çµå­æ®µçåç§°è·å¨ yield åæ°çåç§°ä¹åï¼å¹¶å¨åç§°åé¢éå äºä¸ä¸ªâsâï¼è¡¨ç¤ºå¤æ°ï¼ã åç§°æ£æ¥è§åç¡®ä¿è¿äºåç§°ä¸ä¼å¼èµ·æ­§ä¹ã å æ­¤ï¼ä¸è¿°âGenâçè¿­ä»£å¨ç±»åå«ï¼\n\nghost var xs: seqâ©intâª;\n\n\n1\n\n\nè¿äºåå²å­æ®µç±âMoveNextâèªå¨æ´æ¹ï¼ä½ä¸è½ç±ç¨æ·ä»£ç åéã\n\næåï¼è¿­ä»£å¨ç±»åå«ä¸äºç¨äºè§èçç¹æ®å­æ®µã ç¹å«æ¯ï¼è¿­ä»£å¨è§èè®°å½å¨ä»¥ä¸ä¸å¯åå­æ®µä¸­ï¼\n\nghost var _reads: setâ©objectâª;\nghost var _modifies: setâ©objectâª;\nghost var _decreases0: T0;\nghost var _decreases1: T1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nå¶ä¸­ï¼è¿­ä»£å¨ç decreases å­å¥çæ¯ä¸ªç»ä»¶é½æä¸ä¸ª _decreases*i*: T*i* å­æ®µã [6](http://leino.science/papers/krml243.html#fn-fn-iterator -field-names) å¦å¤è¿æä¸ä¸ªå­æ®µï¼\n\nghost var _new: setâ©objectâª;\n\n\n1\n\n\nä»£è¡¨è¿­ä»£å¨ä¸»ä½åéçä»»ä½å¯¹è±¡é½å°æ·»å å°å¶ä¸­ã è¿­ä»£å¨ä¸»ä½å¯ä»¥ä» _new éä¸­å é¤åç´ ï¼ä½ä¸è½éè¿èµå¼ç» _new æ·»å ä»»ä½åç´ ã\n\nè¯·æ³¨æï¼å¨è¿­ä»£å¨çåææ¡ä»¶ä¸­ï¼å³åææé è¿­ä»£å¨ï¼ååæ°ç¡®å®æ¯ååæ°ï¼èä¸æ¯ this çå­æ®µã\n\n\n# 5.5.âå¼æ­¥ä»»å¡ç±»å\n\nDafny ä¸­å¦ä¸ä¸ªå¯è½ä¼ç»åä¸äºæ¼åçå®éªæ§åè½æ¯å¼æ­¥æ¹æ³ã è°ç¨å¼æ­¥æ¹æ³æ¶ï¼å®ä¸ä¼è¿å out-parameters çå¼ï¼èæ¯è¿å *async-task ç±»å * çå®ä¾ã å¨Cç±»ä¸­å£°æçå¼æ­¥æ¹æ³ï¼å·æä»¥ä¸ç­¾åï¼\n\nasync method AMâ©Tâª(in-params) returns (out-params)\n\n\n1\n\n\nä¹äº§çäºä¸ä¸ªå¼æ­¥ä»»å¡ç±»åAMãTãï¼å¨å°é­ç±»ä¹å¤ï¼ç±»åçåç§°éè¦éå®C.AMãTãï¼ã async-task ç±»åæ¯ä¸ä¸ªå¼ç¨ç±»åï¼å¯ä»¥çè§£ä¸ºä¸ä¸ªæåç§æåçç±»ï¼ä¸é¢ä»ç»å®çç®åçæ¬ã å¼æ­¥æ¹æ³çæ¯ä¸ªç±»åä¸ºXçåæ°xé½ä¼äº§çä¸ä¸ªå¼æ­¥ä»»å¡ç±»åçä¸å¯åå¹½çµå­æ®µï¼\n\nghost var x: X;\n\n\n1\n\n\næ¯ä¸ªYç±»åçè¾åºåæ°yé½ä¼äº§çä¸ä¸ªå­æ®µ\n\nvar y: Y;\n\n\n1\n\n\nè¿äºå­æ®µä¼å¨å¼æ­¥æ¹æ³æåç­å¾æ¶èªå¨æ´æ¹ï¼ä½ä¸è½ç±ç¨æ·ä»£ç åéã\n\nasync-task ç±»åè¿æä¸äºç¹æ®å­æ®µï¼ç¨äºè·è¸ªä¾èµå³ç³»ãæªå®æçä»»å¡ãæ°åéçå¯¹è±¡ç­ãéçå¼æ­¥æ¹æ³è®¾è®¡çåå±ï¼è¿äºå­æ®µå°è¢«æ´è¯¦ç»å°æè¿°ã\n\n\n# 6.âå½æ°ç±»å\n\nå½æ°æ¯ Dafny ä¸­çä¸ç­å¼ã å½æ°ç±»åå·æ (T) -> U çå½¢å¼ï¼å¶ä¸­ T æ¯ä¸ä¸ªä»¥éå·åéçç±»ååè¡¨ï¼è U æ¯ä¸ä¸ªç±»åã T è¢«ç§°ä¸ºå½æ°ç domain type(s) å¹¶ä¸ U æ¯å®ç range typeã ä¾å¦ï¼å½æ°çç±»å\n\nfunction F(x: int, b: bool): real\n\n\n1\n\n\næ¯(int, bool) -> realã åæ°ä¸åè®¸ä¸ºghostã\n\nä¸ºäºç®åå½æ°åç±ä¸ä¸ªç±»ååè¡¨ç»æçåºæ¬æåµçå¤è§ï¼å¨è¿ç§æåµä¸å¯ä»¥å é¤åç±»åå¨å´çæ¬å·ï¼å¦ T -> Uã å¨ä¸ç§ç±»åæ¯åç»ç±»åçæåµä¸ï¼è¿ç§æ å®³çç®åéè¦é¢å¤çè§£éï¼å ä¸ºåç»ç±»åä¹æ¯ç¨æ¬å·æ¬èµ·æ¥çã å¦æå½æ°æ¥åä¸ä¸ªåç»åæ°ï¼åéè¦é¢å¤çä¸ç»æ¬å·ã ä¾å¦ï¼å½æ°\n\nfunction G(pair: (int, bool)): real\n\n\n1\n\n\nç±»åä¸º ((int, bool)) -> realã æ³¨æå¿è¦çåæ¬å·ã ç±»ä¼¼å°ï¼ä¸å¸¦åæ°çå½æ°ä¸å¸¦ 0 åç»ä½ä¸ºåæ°çå½æ°ä¸åã ä¾å¦ï¼å½æ°\n\nfunction NoArgs(): real\nfunction Z(unit: ()): real\n\n\n1\n2\n\n\nåå«æ () -> real å (()) -> real ç±»åã\n\nå½æ°ç®­å¤´ -> æ¯å³ç»åçï¼æä»¥ A -> B -> C è¡¨ç¤º A -> (B -> C)ã å¦ä¸ä¸ªå³èéè¦æ¾å¼æ¬å·ï¼(A -> B) -> Cã\n\nè¯·æ³¨æï¼å½åå½æ°çæ¥æ¶å¨åæ°ä¸æ¯ç±»åçä¸é¨åã ç¸åï¼å®å¨æ¥æ¾å½æ°æ¶ä½¿ç¨ï¼ç¶åå¯ä»¥è¢«è®¤ä¸ºæ¯è¢«æè·å°å½æ°å®ä¹ä¸­ã ä¾å¦ï¼åè®¾ä¸é¢çå½æ°âFâå¨ç±»âCâä¸­å£°æï¼èâcâå¼ç¨äºä¸ä¸ªâCâç±»åçå¯¹è±¡ï¼ é£ä¹ï¼ä»¥ä¸æ¯æ­£ç¡®çç±»åï¼\n\nvar f: (int, bool) -> real := c.F;\n\n\n1\n\n\nèåå¦ä¸åå®¹æ¯ä¸æ­£ç¡®çï¼\n\nvar f': (C, int, bool) -> real := F;  // not correct\n\n\n1\n\n\nå¨å¶ç±»åç­¾åä¹å¤ï¼æ¯ä¸ªå½æ°å¼é½å·æä¸ä¸ªå±æ§ï¼å¦ä¸æè¿°ã\n\næ¯ä¸ªå½æ°é½éå«å°å°å ä½ä¸ºåæ°ã ç¶èï¼æ²¡æä»»ä½å½æ°ä¾èµäºæ´ä¸ªå ã å½æ°çä¸ä¸ªå±æ§æ¯å®å¨ç»å®è¾å¥æä¾èµçå ä½ç½®éä¸å£°æçä¸éã è¿è®©éªè¯èå¯ä»¥ç¡®å®æäºå ä¿®æ¹å¯¹æä¸ªå½æ°è¿åçå¼æ²¡æå½±åã å¯¹äºå½æ°f: T -> UåTç±»åçå¼tï¼ä¾èµéè¡¨ç¤ºä¸ºf.reads(t)å¹¶ä¸å·æsetãobjectãç±»åã\n\nå½æ°çç¬¬äºä¸ªå±æ§æºäºæ¯ä¸ªå½æ°é½å¯è½æ¯é¨åçã æ¢å¥è¯è¯´ï¼å½æ°çå±æ§æ¯å®çåææ¡ä»¶ã å¯¹äºå½æ°f: T -> Uï¼Tç±»åçåæ°å¼tçfçåææ¡ä»¶è¡¨ç¤ºä¸ºf.requires(t)å¹¶ä¸å·æboolç±»åã\n\nå½æ°çç¬¬ä¸ä¸ªå±æ§æ´ä¸ºææ¾ââå½æ°ä½ã å¯¹äºå½æ°âf: T -> Uâï¼è¯¥å½æ°å¯¹âTâç±»åçè¾å¥âtâäº§ççå¼è¡¨ç¤ºä¸ºâf(t)âï¼å¹¶ä¸å·æâUâç±»åã\n\nè¯·æ³¨æï¼f.reads å f.requires æ¬èº«å°±æ¯å½æ°ã åè®¾ f çç±»åä¸º T -> Uï¼è t çç±»åä¸º Tã é£ä¹ï¼f.reads æ¯ T -> setãobjectã ç±»åçå½æ°ï¼å¶ reads å requires å±æ§æ¯ï¼\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires æ¯ T -> bool ç±»åçå½æ°ï¼å¶ reads å requires å±æ§ä¸ºï¼\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0.âLambdaè¡¨è¾¾å¼\n\né¤äºå½åå½æ°ä¹å¤ï¼Dafny è¿æ¯æå®ä¹å½æ°çè¡¨è¾¾å¼ã è¿äºè¢«ç§°ä¸º lambda (expression)sï¼ä¸äºè¯­è¨å°å®ä»¬ç§°ä¸º å¿åå½æ°ï¼ã lambda è¡¨è¾¾å¼å·æä»¥ä¸å½¢å¼ï¼\n\n(params) specification => body\n\n\n1\n\n\nå¶ä¸­ *params* æ¯ä»¥éå·åéçåæ°å£°æåè¡¨ï¼æ¯ä¸ªåæ°å£°æçå½¢å¼ä¸º x æ x: Tã åæ°çç±»åâTâå¨å¯ä»¥æ¨æ­æ¶å¯ä»¥çç¥ã å¦æä¸éè¦æ è¯ç¬¦xï¼å¯ä»¥ç¨â_âä»£æ¿ã å¦æ *params* åå«ä¸ä¸ªæ²¡ææç¡®ç±»åçåæ° xï¼æ _ï¼ï¼åå¯ä»¥å é¤æ¬å·ï¼ ä¾å¦ï¼è¿åç»å®æ´æ°çåç»§çå½æ°å¯ä»¥åæä»¥ä¸ lambda è¡¨è¾¾å¼ï¼\n\nx => x + 1\n\n\n1\n\n\n*specification* æ¯ requires E æ reads W çå­å¥åè¡¨ï¼å¶ä¸­ E æ¯å¸å°è¡¨è¾¾å¼ï¼ W æ¯æ¡æ¶è¡¨è¾¾å¼ã\n\n*body* æ¯å®ä¹å½æ°è¿åå¼çè¡¨è¾¾å¼ã å¯¹äºæ»¡è¶³åææ¡ä»¶çåæ°çææå¯è½å¼ï¼ä¸»ä½å¿é¡»æ ¼å¼æ­£ç¡®ï¼å°±åå½åå½æ°åæ¹æ³çä¸»ä½ä¸æ ·ï¼ã å¨æäºæåµä¸ï¼è¿æå³çæå¿è¦ç¼åæç¡®ç requires å reads å­å¥ã ä¾å¦ï¼lambda è¡¨è¾¾å¼\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nå¦æçç¥ requires å­å¥ï¼åæ ¼å¼ä¸æ­£ç¡®ï¼å ä¸ºå¯è½ä¼è¢«é¶é¤ã\n\nå¨å½æ°ä¸è½æ¯é¨åçå¹¶ä¸å¯¹è¯»åå æ²¡æéå¶çè®¾ç½®ä¸­ï¼å½æ° F: T -> U ç eta æ©å±ï¼å³ï¼å° F åè£å¨è¿æ ·ç lambda è¡¨è¾¾å¼ä¸­ï¼ lambda è¡¨è¾¾å¼ç­ä»·äº F) çæ¹å¼å°åä½ x => F(x)ã å¨ Dafny ä¸­ï¼eta æ©å±è¿å¿é¡»èèå½æ°çåææ¡ä»¶åè¯»åéï¼å æ­¤ F ç eta æ©å±å¦ä¸æç¤ºï¼\n\nx requires F.requires(x) reads F.reads(x) => F(x)\n\n\n1\n\n\n\n# 7.âæ°ç±»å\n\nå¯ä»¥ä½¿ç¨ newtype å£°æ7 å£°ææ°çæ°å­ç±»å\n\nnewtype N = x: M | Q\n\n\n1\n\n\nå¶ä¸­âMâæ¯æ°å­ç±»åï¼âQâæ¯å¸å°è¡¨è¾¾å¼ï¼å¯ä»¥å°âxâç¨ä½èªç±åéã å¦æMæ¯ä¸ä¸ªåºäºæ´æ°çæ°å¼ç±»åï¼é£ä¹Nä¹æ¯ï¼ å¦æâMâæ¯å®æ°ï¼é£ä¹âNâä¹æ¯å¦æ­¤ã å¦æå¯ä»¥ä» Q æ¨æ­åºç±»å Mï¼åå¯ä»¥çç¥â:Mâã å¦æ Q åªæ¯ trueï¼é£ä¹å£°æå¯ä»¥ç®åå°ç»åºï¼\n\nnewtype N = M\n\n\n1\n\n\nç±»åâMâè¢«ç§°ä¸ºâNâçåºæ¬ç±»åã\n\nnewtype æ¯ä¸ç§æ°å­ç±»åï¼å®æ¯æä¸å¶åºæ¬ç±»åç¸åçæä½ã newtype ä¸å¶ä»æ°å­ç±»åä¸åä¸ä¸å¼å®¹ï¼ ç¹å«æ¯ï¼å¦ææ²¡ææ¾å¼è½¬æ¢ï¼å®å°±ä¸è½åéç»å®çåºæ¬ç±»åã å¯¹ newtype çæä½ä¸å¶åºç±»åçæä½ä¹é´çä¸ä¸ªéè¦åºå«æ¯ newtype æä½ä»å¨ç»ææ»¡è¶³è°è¯ Q æ¶æè¢«å®ä¹ï¼å¯¹äº newtype çå­é¢éä¹æ¯å¦æ­¤ã [8](http:// /leino.science/papers/krml243.html#fn-fn-newtype-design-questionï¼\n\nä¾å¦ï¼åè®¾ lo å hi æ¯åºäºæ´æ°çæ°å­ï¼å®ä»¬æ»¡è¶³ 0 <= lo <= hi å¹¶èèä»¥ä¸ä»£ç çæ®µï¼\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nå¦æ lo å hi çç±»åä¸º intï¼é£ä¹ä»£ç çæ®µæ¯åæ³çï¼ ç¹å«æ¯ï¼å®æ°¸è¿ä¸ä¼æº¢åºï¼å ä¸º int æ²¡æä¸éã ç¸åï¼å¦æ lo å hi æ¯æ°ç±»å int32 çåéï¼å£°æå¦ä¸ï¼\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\né£ä¹ä»£ç çæ®µæ¯éè¯¯çï¼å ä¸ºå æ³çç»æå¯è½æ æ³æ»¡è¶³int32å®ä¹ä¸­çè°è¯ã ä»£ç çæ®µå¯ä»¥éåä¸º\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nå¨è¿ç§æåµä¸ï¼int å int32 é½æ¯åæ³çã\n\nç±äº newtype ä¸å¶åºç±»åä¸å¼å®¹ï¼å¹¶ä¸ç±äº newtype æä½çææç»æé½æ¯ newtype çæåï¼å æ­¤ Dafny çç¼è¯å¨å¯ä»¥èªç±å°ä¸é¨å newtype çè¿è¡æ¶è¡¨ç¤ºã ä¾å¦ï¼éè¿ä»ç»æ£æ¥ä¸é¢ int32 çå®ä¹ï¼ç¼è¯å¨å¯è½ä¼å³å®å¨ç®æ ç¡¬ä»¶ä¸­ä½¿ç¨å¸¦ç¬¦å·ç 32 ä½æ´æ°æ¥å­å¨ int32 å¼ã\n\nè¯·æ³¨æï¼Q ä¸­çç»å®åéx çç±»åä¸ºMï¼èä¸æ¯Nã nå æ­¤ï¼å¯è½æ æ³å°±âNâå¼è¯´æâQâã ä¾å¦ï¼èèä»¥ä¸ç±»åç 8 ä½ 2 çè¡¥ç æ´æ°ï¼\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nå¹¶èèä¸ä¸ªç±»åä¸ºint8çåécã è¡¨è¾¾å¼\n\n-128 <= c < 128\n\n\n1\n\n\nå®ä¹ä¸æç¡®ï¼å ä¸ºæ¯è¾è¦æ±æ¯ä¸ªæä½æ°çç±»åä¸ºâint8âï¼è¿æå³çæå­â128âè¢«æ£æ¥ä¸ºâint8âç±»åï¼ä½äºå®å¹¶éå¦æ­¤ã ç¼åæ­¤è¡¨è¾¾å¼çæ­£ç¡®æ¹æ³æ¯å¨ c ä¸ä½¿ç¨è½¬æ¢æä½ï¼å¦ä¸æè¿°ï¼å°å¶è½¬æ¢ä¸ºåºæ¬ç±»åï¼\n\n-128 <= int(c) < 128\n\n\n1\n\n\næä¸ä¸ªéå¶ï¼å³å¼0å¿é¡»æ¯æ¯ä¸ªæ°ç±»åçä¸é¨åã9\n\n\n# 7.0.âæ°å­è½¬æ¢æä½\n\nå¯¹äºæ¯ä¸ªæ°å­ç±»åNï¼é½æä¸ä¸ªååçè½¬æ¢å½æ°ã å®æ¯ä¸ä¸ªé¨åæç­å½æ°ã å®æ¯å¨ç»å®å¼ï¼å¯ä»¥æ¯ä»»ä½æ°å­ç±»åï¼æ¯è½¬æ¢ä¸ºçç±»åçæåæ¶å®ä¹çã å½ä»åºäºå®æ°çæ°å¼ç±»åè½¬æ¢ä¸ºåºäºæ´æ°çæ°å¼ç±»åæ¶ï¼è¯¥æä½è¦æ±åºäºå®æ°çåæ°æ²¡æå°æ°é¨åã ï¼è¦å°åºäºå®æ°çæ°å¼åä¸èå¥å°ææ¥è¿çæ´æ°ï¼è¯·ä½¿ç¨ .Trunc æåï¼è¯·åéç¬¬ [0.1] èï¼http://leino.science/papers/krml243.html#sec-numeric-typesï¼ã )\n\nä½¿ç¨ä¸é¢çä¾å­æ¥è¯´æï¼å¦æ lo å hi çç±»åæ¯ int32ï¼é£ä¹ä»£ç çæ®µå¯ä»¥åæ³å°åæå¦ä¸\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nå¶ä¸­midçç±»åè¢«æ¨æ­ä¸ºintã ç±äºé¤æ³çç»æå¼æ¯ int32 ç±»åçæåï¼å æ­¤å¯ä»¥å¼å¥å¦ä¸ç§è½¬æ¢æä½ï¼ä½¿ mid çç±»åä¸º int32ï¼\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nå¦æç¼è¯å¨ç¡®å®ä¸é¨éå¯¹int32çè¿è¡æ¶è¡¨ç¤ºï¼é£ä¹è¿äºè¯­å¥çä»£ä»·æ¯ä¸¤ä¸ªæä¸ä¸ªè¿è¡æ¶è½¬æ¢ã\n\n\n# 8.âå­éç±»å\n\nå­éç±»åæ¯å¯¹ç°æç±»åçéå¶ä½¿ç¨ï¼ç§°ä¸ºå­éç±»åçåºæ¬ç±»åã å­éç±»åå°±ååºç±»åååºç±»åä¸çè°è¯çç»åä½¿ç¨ã\n\nå§ç»åè®¸ä»å­éç±»åå°å¶åºæ¬ç±»åçèµå¼ã å¦æåéçå¼ç¡®å®æ»¡è¶³å­éç±»åçè°è¯ï¼ååè®¸ä»åºæ¬ç±»åå°å­éç±»åçå¦ä¸ä¸ªæ¹åçåéã ï¼æ³¨æï¼ç¸æ¯ä¹ä¸ï¼newtype åå®çåºç±»åä¹é´çèµå¼æ¯ä¸åè®¸çï¼å³ä½¿èµå¼æ¯ç®æ ç±»åçå¼ãå¯¹äºè¿æ ·çèµå¼ï¼å¿é¡»ä½¿ç¨æ¾å¼è½¬æ¢ï¼åè§ç¬¬ [7.0]ï¼http: //leino.science/papers/krml243.html#sec-numeric-conversions)ã) Dafny æ¯æä¸ç§å­éç±»åï¼å³åç½®ç±»å natï¼å¶åºæ¬ç±»åä¸º intã[10](http: //leino.science/papers/krml243.html#fn-fn-more-subset-typesï¼\n\nç±»ånatæå®intçéè´å­èå´ã ä¸ä¸ªå¾å¥½å°ä½¿ç¨å­éç±»åânatâçç®åç¤ºä¾æ¯æ åææ³¢é£å¥å½æ°ï¼\n\nfunction Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\næ­¤å½æ°çç­æä½ç¬¨æçå¬å¼ï¼ä»¥è°ç¨ç«ç¹äº§ççä»»ä½éè¯¯æ¶æ¯çæªè¾ä¸ºæ¨¡ï¼å°ä½¿ç¨ç±»åintå¹¶å¨åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸­ç¼åéå¶è°è¯ï¼\n\nfunction Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nç±»åæ¨æ­æ°¸è¿ä¸ä¼å°åéçç±»åæ¨æ­ä¸ºå­éç±»åã ç¸åï¼å®ä¼å°ç±»åæ¨æ­ä¸ºå­éç±»åçåºæ¬ç±»åã ä¾å¦ï¼x çç±»å\n\nforall x :: P(x)\n\n\n1\n\n\nå°æ¯ intï¼å³ä½¿è°è¯ P å£°æå¶åæ°çç±»åä¸º natã\n\n# åèèµæ\n\nç±äº Nadia Polikarpova å Paqui Lucio çè¯è®ºï¼æ¬ææ¡£å¾å°äºæ¹è¿ã\n\n----------------------------------------\n\n 0.  æ¯æå¹³ç­åªæ¯äººä»¬å¯ä»¥æ³è±¡çä¸°å¯ç±»åç³»ç»ä¸­çç±»åæ¥æçä¼å¤æ¨¡å¼ä¹ä¸ã ä¾å¦ï¼å¶ä»æ¨¡å¼å¯è½åæ¬å·ææ»è®¢åãå¯é¶åå§åä»¥åå¯è½æ äººå±ä½ã å¦æ Dafny å°æ¥æ¯ææ´å¤æ¨¡å¼ï¼â( )âåç¼è¯­æ³å¯è½ä¼è¢«æ©å±ã ç®åï¼åç¼åªè½è¡¨ç¤ºæ¯æå¹³ç­çæ¨¡å¼ã â©\n 1.  ç°å¨Dafnyæ¯æåç½®åç»ï¼æç®æåºååçæä½æ¹æè¿å ä¸æ¯å­åºåçåºåï¼èæ¯å­åºåçåç»ã â©\n 2.  è¿å¯è½ä¼å¨æªæ¥åçååï¼ä¸åè®¸å¤æ¬¡åºç°ç¸åçé®ã â©\n 3.  è¿å¨æªæ¥å¯è½ä¼æ¹åå¦ä¸ï¼inå!in å°å¾å°ä¸åæ¯ææä½ã ç¸åï¼å¯¹äºä»»ä½å°å¾ mï¼m.Domain å°è¿åå¶åä½ä¸ºä¸ä¸ªéåï¼è m.Range å°è¿åï¼ä¹ä½ä¸ºä¸ä¸ªéåï¼å¨å¶åä¸ç m çå¾åã â©\n 4.  è¿å°å¨ Dafny çæªæ¥çæ¬ä¸­åçååï¼å®å°åæ¶æ¯æå¯ç©ºåï¼é»è®¤æåµä¸ï¼é -null å¼ç¨ç±»åã â©\n 5.  å¾å¿«ï¼object å°æä¸ºä¸ä¸ªåç½®ç trait èä¸æ¯åç½®çç¹æ® ç­çº§ã åçè¿ç§æåµæ¶ï¼å°ä¸åå¯è½æ§è¡âæ°å¯¹è±¡âã object ä¸è½ç¨ä½ç±»ååæ°çå½åç¼è¯å¨éå¶ä¹å°æ¶å¤±ã â©\n 6.  å°ç¹æ®å­æ®µ_readså_modifieséå½åä¸ºç¸åæ¯ææä¹ç åç§°ä½ä¸ºç¸åºçå³é®å­ï¼âè¯»åâåâä¿®æ¹âï¼å°±åå¯¹å½æ°å¼æåçé£æ ·ã æ­¤å¤ï¼åç§ _decreases*i* å­æ®µå¯ä»¥ç»åæä¸ä¸ªåä¸º decreases çå­æ®µï¼å¶ç±»åæ¯ n åç»ã â©\n 7.  æ¯å¦åºè¯¥å°newtypeéå½åä¸ºnumtypeï¼ â©\n 8.  èªå¨å®ä¹âè°è¯Nâæç¨åï¼(m:M){Q} `? â©\n 9.  éå¶æ¯ç±äºå½åç¼è¯å¨çéå¶ã è¿å°å¨æªæ¥åçååï¼ä¹å°ä¸ºå­éç±»ååéç©ºå¼ç¨ç±»åå¼è¾å¯è½æ§ã â©\n 10. Dafny çæªæ¥çæ¬å°æ¯æç¨æ·å®ä¹çå­éç±»åã â©",normalizedContent:"# dafny type system\n\ndafnyè¯­è¨åèçè¿ä¸é¨åæè¿°äºdafnyç¼ç¨è¯­è¨ä¸­çç±»åãææè¿°çæ¯dafnyçæ¬1.9.3.20107ä¸­å®ç°çåå®¹ï¼å¼æ­¥ä»»å¡ç±»åå°æªè¿å¥ä¸»åæ¯ã\n\n> 0.âåºæ¬ç±»å 0.0.âå¸å°å¼ 0.1.âæ°å­ç±»å 0.2.âå­ç¬¦ 1.âç±»ååæ° 2.âéåç±»å 2.0.âéå 2.1.âå¤é 2.2.âåºå 2.2.0.âå­ç¬¦ä¸² 2.3.âæéä¸æ éå¾ 3.âè±¡å¾ç±»å 3.0.âåä¹è¯ç±»å 3.1.âä¸éæç±»å 4.âæ°æ®ç±»å 4.0.âå½çº³æ°æ®ç±»å 4.1.âåç»ç±»å 4.2.âå±åå½çº³ç±»å 5.âåç§ç±»å 5.0.âç±» 5.1.âæ°ç» 5.1.0.âä¸ç»´æ°ç» 5.1.1.âå¤ç»´æ°ç» 5.2.âç¹å¾ 5.3.âç±»å object 5.4.âè¿­ä»£å¨ç±»å 5.5.âå¼æ­¥ä»»å¡ç±»å 6.âå½æ°ç±»å 6.0.âlambdaè¡¨è¾¾å¼ 7.âæ°ç±»å 7.0.âæ°å­è½¬åæä½ 8.âå­éç±»å\n\n\n# 0.âåºæ¬ç±»å\n\ndafnyæä¾äºä¸ç§åºæ¬ç±»åï¼boolè¡¨ç¤ºå¸å°ï¼intè¡¨ç¤ºæ´æ°ï¼realè¡¨ç¤ºå®æ°ã\n\n\n# 0.0.âbooleans\n\næä¸¤ä¸ªå¸å°å¼ï¼æ¯ä¸ªå¼å¨è¯­è¨ä¸­é½æä¸ä¸ªå¯¹åºçææ¬ï¼falseåtrueã\n\né¤äºå¨ææç±»åä¸å®ä¹çç¸ç­ï¼=ï¼ådisequalityï¼ï¼=ï¼ï¼ç±»åboolè¿æ¯æä»¥ä¸æä½ï¼\n\n       \næä½ç¬¦    æè¿°\n       \n<==>   å½ä¸ä»å½\n       \n==>    è´å«\n<==    ååè´å«\n       \n&&     è¿æ¥(ä¸)\n||     æå(æ)\n       \n!      å¦å®(é)\n       \n\nå¦å®æ¯ä¸åçï¼å¶ä»çæ¯äºè¿å¶çãè¯¥è¡¨æ¾ç¤ºäºä¸ç»ç»ååä¸æ­å¢å¼ºçè¿ç®ç¬¦ï¼ç­å¼ç»åæ¯åååæåå¼ºï¼æ¯å¦å®å¼±ãå¨æ¯ä¸ªç»ä¸­ï¼ä¸åçè¿ç®ç¬¦ä¸å³èï¼å æ­¤éè¦ä½¿ç¨æ¬å·ãä¾å¦,\n\na && b || c    // error\n\n\n1\n\n\nå°æ¯ä¸æç¡®çï¼èå¿é¡»åä¸º\n\n(a && b) || c\n\n\n1\n\n\næ\n\na && (b || c)\n\n\n1\n\n\nåå³äºé¢æçææã\n\nè¡¨è¾¾å¼a<=>båa==bç»åºäºç¸åçå¼ï¼ä½è¯·æ³¨æï¼<=>æ¯å³èçï¼=æ¯é¾æ¥çãæä»¥\n\na <==> b <==> c\n\n\n1\n\n\nä¸ä¸å¼ç¸å\n\na <==> (b <==> c)\n\n\n1\n\n\nå\n\n(a <==> b) <==> c\n\n\n1\n\n\né´äº\n\na == b == c\n\n\n1\n\n\nåªæ¯ä¸å¼çéè®°\n\na == b && b == c\n\n\n1\n\n\nååæ¯å³èçï¼æåä¹æ¯ãè¿äºè¿ç®ç¬¦æ¯ç­è·¯ï¼ä»å·¦å°å³ï¼ï¼è¿æå³çåªæå¨ç¬¬ä¸ä¸ªæä½æ°çè®¡ç®ä¸ç¡®å®è¡¨è¾¾å¼çå¼æ¶ï¼æä¼è®¡ç®å®ä»¬çç¬¬äºä¸ªåæ°ãä»é»è¾ä¸è®²ï¼è¡¨è¾¾å¼a&&bæ¯å¨å®ä¹äºaå¹¶ä¸açè®¡ç®ç»æä¸ºfalseæbæ¶å®ä¹çãå®ä¹a&&bæ¶ï¼å¶å«ä¹ä¸æ®éçå¯¹ç§°æ°å­¦è¿è¯ç¸åâ§. | | |åâ¨.\n\nå«ä¹æ¯âå³å³èâï¼ä»å·¦å°å³ç­è·¯ãååè´æ¶µb<==aä¸a==>bå®å¨ç¸åï¼ä½å¯ä»¥æç¸åçé¡ºåºåå¥æä½æ°ãå æ­¤ï¼ååå«ä¹æ¯âå·¦å³èâï¼æ¯ä»âå³âå°âå·¦âçç­è·¯ãä¸ºäºè¯´æå³èæ§è§åï¼ä»¥ä¸åè¡ä¸­çæ¯ä¸è¡é½è¡¨ç¤ºäºç¸åçå±æ§ï¼å³boolç±»åçä»»ä½aãbåcï¼\n\na ==> b ==> c\na ==> (b ==> c)  // parentheses redundant, since ==> is right associative\nc <== b <== a\n(c <== b) <== a  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nä¸ºäºè¯´æç­è·¯è§åï¼è¯·æ³¨æï¼è¡¨è¾¾å¼a.lengthä»å¨aä¸ä¸ºnullæ¶æä¸ºæ°ç»aå®ä¹ (è§ å°è 5), è¿æå³çä»¥ä¸ä¸¤ä¸ªè¡¨è¾¾å¼æ ¼å¼æ­£ç¡®ï¼\n\na != null ==> 0 <= a.length\n0 <= a.length <== a != null\n\n\n1\n2\n\n\nè¿ä¸¤ç§è¡¨è¾¾çåä½ç¨æ¯ï¼\n\na.length < 0 ==> a == null  // not well-formed\na == null <== a.length < 0  // not well-formed\n\n\n1\n2\n\n\nä½è¿äºè¡¨è¾¾å¼çæ ¼å¼ä¸å¥½ï¼å ä¸ºæ ¼å¼å¥½è¦æ±å·¦ï¼åå³ï¼æä½æ°a.length<0æ¬èº«æ ¼å¼è¯å¥½ã\n\nè´æ¶µa==>bç¸å½äºæåï¼a | | bï¼ä½ææ¶ï¼å°¤å¶æ¯å¨è§èä¸­ï¼æ´æ¸æ°æè¯»ãç±äº||æ¯ä»å·¦åå³ç­è·¯ï¼è¯·æ³¨æ\n\na == null || 0 <= a.length\n\n\n1\n\n\nç»æè¯å¥½ï¼è\n\n0 <= a.length || a == null  // not well-formed\n\n\n1\n\n\nç»æè¾å·®ã\n\næ­¤å¤ï¼å¸å°è¯­æ¯æé»è¾éè¯ï¼forallåexistsï¼ï¼å¨dafnyè¯­è¨åèçå¦ä¸é¨åä¸­ææè¿°ã\n\n\n# 0.1.âæ°å­ç±»å\n\ndafny æ¯æä¸¤ç§ numeric ç±»åï¼integer-basedï¼åæ¬æææ´æ°çåºæ¬ç±»å intï¼å real-basedï¼åæ¬ææå®æ°çåºæ¬ç±»å realã ç¨æ·å®ä¹çåºäº int å real çæ°å­ç±»åï¼ç§°ä¸º newtypesï¼å¨ç¬¬ [7] è(http://leino.science/papers/krml243.html#sec-newtypes) ä¸­ææè¿°ã æ­¤å¤ï¼ä»£è¡¨ int çéè´å­èå´ç subset type nat å¨ç¬¬ [8] èï¼http://leino.science/papers/krml243.html#sec-subset-typesï¼ä¸­è¿è¡äºæè¿° . è¯¥è¯­è¨åå«æ¯ä¸ªéè´æ´æ°çæå­ï¼ä¾å¦â0âãâ13âåâ1985âã æ´æ°ä¹å¯ä»¥ä½¿ç¨åç¼â0xâä»¥åå­è¿å¶ä¹¦åï¼å¦â0x0âãâ0xdâåâ0x7c1âï¼å§ç»ä½¿ç¨å°åâxâï¼ä½åå­è¿å¶æ°å­æ¬èº«ä¸åºåå¤§å°åï¼ã åè®¸ä½¿ç¨åå¯¼é¶ã è¦å½¢æè´æ´æ°ï¼è¯·ä½¿ç¨ä¸ååå·è¿ç®ç¬¦ã ä¸äºéè´å®æ°ä¹ææå­ã è¿äºè¢«åæä¸ä¸ªå°æ°ç¹ï¼ä¸¤è¾¹é½æä¸ä¸ªéç©ºçåè¿å¶æ°å­åºåã ä¾å¦ï¼â1.0âãâ1609.344âåâ0.5772156649âã å¯¹äºæ´æ°ï¼åè¿å¶ååå­è¿å¶å½¢å¼ï¼åå®æ°ï¼æå­ä¸­çä»»ä½ä¸¤ä½æ°å­é½å¯ä»¥ç¨ä¸åçº¿åéï¼ä»¥æé«æå­çå¯è¯»æ§ã ä¾å¦ï¼\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 angstrom\n\n\n1\n2\n3\n4\n\n\né¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼æ°å¼ç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nå°±åç¸ç­åä¸ç¸ç­ä¸æ ·ï¼è¿äºè¿ç®ç¬¦æ¯é¾æ¥çï¼åªè¦å®ä»¬é¾æ¥å¨âç¸åçæ¹åâã é£å°±æ¯è¯´ï¼\n\na <= b < c == d <= e\n\n\n1\n\n\nis simply a shorthand for\n\na <= b && b < c && c == d && d <= e\n\n\n1\n\n\nè\n\na < b > c\n\n\n1\n\n\nä¸è¢«åè®¸ã æ¯ç§æ°å­ç±»åä¹æè¿ç®ç¬¦ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n+     å \n-     å\n      \n*     ä¹\n/     é¤\n%     åæ¨¡\n      \n-     å¦å® (ä¸åå)\n      \n\näºåè¿ç®ç¬¦æ¯å·¦ç»åçï¼å®ä»¬å¨ä¸¤ç»ä¸­ç¸äºå³èã è¿äºç»æç»å®è½åå¢å çé¡ºåºååºï¼ç­å¼ç»å®æ¯ä¹æ³è¿ç®ç¬¦æ´å¼ºï¼æ¯ä¸åè¿ç®ç¬¦å¼±ã ä»åºäºæ´æ°çæ°å¼ç±»åæ¯ææ¨¡æ°ã æ´æ°é¤æ³åæ¨¡æ°æ¯æ¬§å éå¾é¤æ³åæ¨¡æ°ã è¿æå³çæ è®ºä¸¤ä¸ªæä½æ°çç¬¦å·å¦ä½ï¼æ¨¡æ°å§ç»è¿åéè´æ°ã æ´åç¡®å°è¯´ï¼å¯¹äºä»»ä½æ´æ°aåéé¶æ´æ°bï¼\n\na == a / b * b + a % b\n0 <= a % b < b\n\n\n1\n2\n\n\nå¶ä¸­âbâè¡¨ç¤ºâbâçç»å¯¹å¼ã åºäºå®æ°çæ°å¼ç±»åæä¸ä¸ªæå truncï¼å®è¿åå®æ°å¼ç floorï¼å³ä¸è¶è¿å®æ°å¼çæå¤§æ´æ°ã ä¾å¦ï¼å¯¹äºä»»ä½ç±»åä¸ºârealâçârâåârâï¼ä»¥ä¸å±æ§æç«ï¼\n\n3.14.trunc == 3\n(-2.5).trunc == -3\n-2.5.trunc == -2\nreal(r.trunc) <= r\nr <= r' ==> r.trunc <= r'.trunc\n\n\n1\n2\n3\n4\n5\n\n\nè¯·æ³¨æï¼å¨ç¬¬ä¸è¡ä¸­ï¼æåè®¿é®ï¼å¦ .truncï¼çç»å®æ¯ä¸ååå·æ´å¼ºã ç¬¬åè¡ä½¿ç¨ä» int å° real çè½¬æ¢å½æ° realï¼å¦ç¬¬ [7.0] è (http://leino.science/papers/krml243.html#sec-numeric-conversions) ä¸­æè¿°\n\n\n# 0.2.âå­ç¬¦\n\ndafny æ¯æ characters ç char ç±»åã å­ç¬¦æå­ç¨åå¼å·æ¬èµ·æ¥ï¼å¦ 'd'ã è¦å°åå¼å·åæå­ç¬¦æå­ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåã è½¬ä¹åºåä¹å¯ç¨äºåå¥å¶ä»å­ç¬¦ã æ¯æçè½¬ä¹åºåå¦ä¸ï¼\n\n           \nè½¬ä¹å­ç¬¦       å«ä¹\n           \n\\'         å­ç¬¦ '\n\\\"         å­ç¬¦ \"\n\\\\         å­ç¬¦ \\\n\\0         ç©ºå­ç¬¦ï¼å \\u0000\n\\n         æ¢è¡\n\\r         åè½¦\n\\t         æ°´å¹³å¶è¡¨\n\\u*xxxx*   åå­è¿å¶ç¼ç éç¨å­ç¬¦ *xxxx*\n           \n\nåå¼å·çè½¬ä¹åºåæ¯å¤ä½çï¼å ä¸º '\"' å '\"' è¡¨ç¤ºç¸åçå­ç¬¦ââæä¾è¿ä¸¤ç§å½¢å¼æ¯ä¸ºäºæ¯æä¸å­ç¬¦ä¸²æå­ç¸åçè½¬ä¹åºåï¼ç¬¬ [2.2.0] èï¼http: //leino.science/papers/krml243.html#sec-string))ã å¨ \\u*xxxx* å½¢å¼ä¸­ï¼u æ»æ¯å°åï¼ä½åä¸ªåå­è¿å¶æ°å­ä¸åºåå¤§å°åã å­ç¬¦å¼æ¯æåºçï¼å¯ä»¥ä½¿ç¨æ åå³ç³»è¿ç®ç¬¦è¿è¡æ¯è¾ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     å°äº\n<=    è³å¤\n>=    è³å°\n>     å¤§äº\n      \n\nå­ç¬¦åºåè¡¨ç¤ºå­ç¬¦ä¸²ï¼å¦ç¬¬ 2.2.0 èæè¿°ã(http://leino.science/papers/krml243.html#sec-string).\n\n\n# 1.âç±»ååæ°\n\ndafny ä¸­çè®¸å¤ç±»åï¼ä»¥åå½æ°åæ¹æ³ï¼é½å¯ä»¥éè¿ç±»åè¿è¡åæ°åã è¿äºç±»ååæ°éå¸¸å¨å°æ¬å·åå£°æï¼å¯ä»¥ä»£è¡¨ä»»ä½ç±»åã ææ¶éè¦éå¶è¿äºç±»ååæ°ï¼ä»¥ä¾¿å®ä»¬åªè½ç±æäºç±»åçç³»åå®ä¾åã å æ­¤ï¼dafny ä¸ä»å¨å¹½çµä¸ä¸æä¸­èä¸å¨ç¼è¯ä¸ä¸æä¸­åºåæ¯æç¸ç­æä½çç±»åã ä¸ºäºè¡¨æä¸ä¸ªç±»ååæ°è¢«éå¶ä¸ºè¿ç§æ¯æå¹³ç­çç±»åï¼ç±»ååæ°çåç§°éç¨åç¼â(==)âã[0](http://leino.science/papers/krml243. html#fn-fn-type-mode) ä¾å¦ï¼\n\nmethod compareãt(==)ã(a: t, b: t) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\næ¯ä¸ç§æ¹æ³ï¼å¶ç±»ååæ°ä»éäºæ¯æç¸ç­çç±»åã åæ ·ï¼è¯·æ³¨æ all ç±»åå¨ ghost ä¸ä¸æä¸­æ¯æç¸ç­ï¼ åºå«ä»éç¨äºéå¹½çµï¼å³ç¼è¯ï¼ä»£ç ã å±å½çº³æ°æ®ç±»åãå½æ°ç±»åä»¥åå¸¦æå¹»ååæ°çå½çº³æ°æ®ç±»åæ¯ä¸æ¯æç­å¼çç±»åçç¤ºä¾ã dafny æä¸äºæ¨çæ¯æï¼å¯ä»¥ä½¿æäºç­¾åä¸é£ä¹æ··ä¹±ï¼å¨ dafny è¯­è¨åèçä¸åé¨åä¸­è¿è¡äºæè¿°ï¼ã å¨æäºæåµä¸ï¼è¿ç§æ¯æä¼æ¨æ­åºå¿é¡»å°ç±»ååæ°éå¶ä¸ºæ¯æç¸ç­çç±»åï¼å¨è¿ç§æåµä¸ï¼dafny ä¼èªå¨æ·»å â(==)âã\n\n\n# 2.âéåç±»å\n\ndafny æä¾äºå ç§åç½®çéåç±»åã\n\n\n# 2.0.âéå\n\nå¯¹äºä»»ä½ç±»å tï¼setãtã ç±»åçæ¯ä¸ªå¼é½æ¯ t å¼çæééåã éåæåèµæ ¼ç±ç±»å t ä¸­çç¸ç­æ§ç¡®å®ï¼å æ­¤åªæå½t æ¯æç¸ç­æ§æ¶ï¼setãtã æè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã å¯ä»¥ä½¿ç¨ set display è¡¨è¾¾å¼å½¢æä¸ä¸ªéåï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæ åºçãä¸åºåéå¤çè¡¨è¾¾å¼åè¡¨ï¼ç¨è±æ¬å·æ¬èµ·æ¥ã ä¸ºäºæ¾ç¤ºï¼\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\næ¯è®¾ç½®æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã è¿æä¸ä¸ª set comprehension è¡¨è¾¾å¼ï¼å¸¦ææ´»é¡µå¤¹ï¼å°±åå¨é»è¾éåä¸­ä¸æ ·ï¼ï¼å¨ dafny è¯­è¨åèçä¸åé¨åè¿è¡äºæè¿°ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼éåç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çå­é\n<=    å­é\n>=    è¶é\n>     çè¶é\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã éåæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼æç»å®è½åéå¢çé¡ºåºååºï¼\n\n      \næä½ç¬¦   æè¿°\n      \n!!    ä¸ç¸äº¤\n      \n+     è®¾ç½®èå\n-     è®¾ç½®å·®å¼\n      \n*     è®¾ç½®äº¤ç¹\n      \n\n+ã- å * çç»åæ§è§åç±»ä¼¼äºååç®æ¯è¿ç®ç¬¦çç»åæ§è§åã è¡¨è¾¾å¼a !! bï¼å®ççº¦æåä¸ç¸ç­æ§ç¸åï¼ä½å®æ¢ä¸ä¸ç¸ç­æ§èç³»ä¹ä¸è¿éï¼ï¼è¯´éåaåbæ²¡æå±åçåç´ ï¼ä¹å°±æ¯è¯´ï¼å®ç­ä»·äº\n\na * b == {}\n\n\n1\n\n\nä½æ¯ï¼ä¸ç¸äº¤è¿ç®ç¬¦æ¯é¾å¼çï¼æä»¥ a !! b !! c !! dè¡¨ç¤ºï¼\n\na * b == {} && (a + b) * c == {} && (a + b + c) * d == {}\n\n\n1\n\n\næ­¤å¤ï¼å¯¹äºä»»ä½setãtãç±»åçéåsåä»»ä½tç±»åçè¡¨è¾¾å¼eï¼éåæ¯æä»¥ä¸æä½ï¼\n\n          \nè¡¨è¾¾å¼       æè¿°\n          \n|s|       éååºæ°\ne in s    éåæå\ne !in s   éåéæå\n          \n\nè¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã\n\n\n# 2.1.âmultisets\n\nmultiset ç±»ä¼¼äºéåï¼ä½è·è¸ªæ¯ä¸ªåç´ çå¤éæ§ï¼èä¸ä»ä»æ¯å®çå­å¨æä¸å­å¨ã å¯¹äºä»»ä½ç±»å tï¼multisetãtã ç±»åçæ¯ä¸ªå¼é½æ¯ä» t å¼å°è¡¨ç¤ºæ¯ä¸ªåç´ çå¤éæ§çèªç¶æ°çæ å°ã dafny ä¸­çå¤ééæ¯æéçï¼ä¹å°±æ¯è¯´ï¼å®ä»¬åå«æéæ°éçæ¯ä¸ªæéåç´ ã æ¢å¥è¯è¯´ï¼å¤ééä»å°æéæ°éçåç´ æ å°å°éé¶ï¼æéï¼å¤éæ§ã ä¸éåä¸æ ·ï¼å¤éæåèµæ ¼ç±ç±»åâtâä¸­çç¸ç­æ§ç¡®å®ï¼å æ­¤åªæå½âtâæ¯æç¸ç­æ¶ï¼âå¤éãtãâæè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã å¯ä»¥ä½¿ç¨ multiset display è¡¨è¾¾å¼æ¥å½¢æå¤ééï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæ åºåçè¡¨è¾¾å¼åè¡¨ï¼åå«å¨å³é®å­ multiset åé¢çè±æ¬å·ä¸­ã ä¸ºäºæ¾ç¤ºï¼\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\næ¯å¤ç»æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã æ²¡æå¤éçè§£è¡¨è¾¾å¼ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼å¤ééç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çå¤éå­é\n<=    å¤éå­é\n>=    å¤éè¶é\n>     çå¤éè¶é\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã å¤ééæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼æç»å®è½åéå¢çé¡ºåºååºï¼\n\n      \næä½ç¬¦   æè¿°\n      \n!!    å¤éä¸ç¸äº¤\n      \n+     å¤éèå\n-     å¤éå·®å¼\n      \n*     å¤éäº¤é\n      \n\n+ã- å * çç»åæ§è§åç±»ä¼¼äºååç®æ¯è¿ç®ç¬¦çç»åæ§è§åã è¡¨è¾¾å¼'a !! bè¡¨ç¤ºå¤ééaåb` æ²¡æå±åçåç´ ï¼ä¹å°±æ¯è¯´ï¼å®ç­ä»·äº\n\na * b == multiset{}\n\n\n1\n\n\nä¸ç±»ä¼¼çéåè¿ç®ç¬¦ä¸æ ·ï¼!! æ¯é¾å¼çã æ­¤å¤ï¼å¯¹äºä»»ä½ç±»åä¸ºmultisetãtãçå¤éésãç±»åä¸ºtçè¡¨è¾¾å¼eååºäºéè´æ´æ°çæ°å­nï¼å¤ééæ¯æä»¥ä¸æä½ï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \n|s|         å¤éåºæ°\ne in s      å¤éæå\ne !in s     å¤ééæå\ns[e]        e å¨ s ä¸­çå¤æ ·æ§\ns[e := n]   å¤éæ´æ° (å¤æ ·æ§åå)\n            \n\nå½ä¸ä»å½ s[e] != 0 æ¶ï¼è¡¨è¾¾å¼ e in s æä¼è¿å trueã è¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã è¡¨è¾¾å¼ s[e := n] è¡¨ç¤ºç±»ä¼¼äº s çå¤ééï¼ä½åç´  e çå¤éæ§æ¯ nã è¯·æ³¨æï¼å¤ééæ´æ° s[e := 0] ä¼äº§çç±»ä¼¼ s çå¤ééï¼ä½ä¸ä¼åºç°ä»»ä½ eï¼æ è®º s é¦åæ¯å¦åºç°è¿eï¼ã ä½ä¸ºå¦ä¸ä¸ªç¤ºä¾ï¼è¯·æ³¨æ s - multiset{e} ç­ä»·äºï¼\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2.âåºå\n\nå¯¹äºä»»ä½ç±»åâtâï¼âseqãtãâç±»åçå¼è¡¨ç¤ºâtâåç´ çåºåï¼å³ä»è¿ç»­èªç¶æ°çæééåï¼ç§°ä¸ºindiciesï¼å°âtâçæ å° `ä»·å¼è§ã ï¼å°å¶è§ä¸ºä¸ä¸ªæ å°ï¼å æ­¤åºåæ¯å¤ééçå¯¹å¶ãï¼å¯ä»¥ä½¿ç¨ sequence display è¡¨è¾¾å¼å½¢æåºåï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªåå«å¨æ¹æ¬å·ä¸­çç©ºçãæåºçè¡¨è¾¾å¼åè¡¨ã ä¸ºäºééï¼\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\næ¯é¡ºåºæ¾ç¤ºçä¸ä¸ªç¤ºä¾ã æ²¡æåºåçè§£è¡¨è¾¾å¼ã é¤äºç¸ç­åä¸ç¸ç­ä¹å¤ï¼åºåç±»åè¿æ¯æä»¥ä¸å³ç³»è¿ç®ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n<     çåç¼\n<=    åç¼\n      \n\nä¸ç®æ¯å³ç³»è¿ç®ç¬¦ä¸æ ·ï¼è¿ äºè¿ç®ç¬¦æ¯é¾æ¥çã æ³¨ææ²¡æ>å>=ã åºåæ¯æä»¥ä¸äºåè¿ç®ç¬¦ï¼\n\n      \næä½ç¬¦   æè¿°\n      \n+     è¿æ¥\n      \n\nè¿ç®ç¬¦ + æ¯å³èçï¼å°±åååçç®æ¯è¿ç®ç¬¦ä¸æ ·ã æ­¤å¤ï¼å¯¹äºä»»ä½ç±»åä¸ºâseqãtãâçåºåâsâï¼ç±»åä¸ºâtâçè¡¨è¾¾å¼âeâï¼åºäºæ´æ°çæ°å­âiâæ»¡è¶³â0 <= i < |s|âï¼ä»¥åæ´æ°- åºäºæ°å­ lo å hi æ»¡è¶³ 0 <= lo <= hi <= |s|ï¼åºåæ¯æä»¥ä¸æä½ï¼\n\n              \nè¡¨è¾¾å¼           æè¿°\n              \n|s|           åºåé¿åº¦\ns[i]          åºåéæ©\ns[i := e]     åºåæ´æ°\ne in s        åºåæå\ne !in s       åºåéæå\ns[lo..hi]     å­åºå\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   åç\nmultiset(s)   åºåè½¬æ¢ä¸º multisetãtã\n              \n\nè¡¨è¾¾å¼ s[i := e] è¿åä¸ä¸ªç±»ä¼¼ s çåºåï¼é¤äºç´¢å¼ i å¤çåç´ æ¯ eã è¡¨è¾¾å¼ e in s è¡¨ç¤ºå­å¨ä¸ä¸ªç´¢å¼ i ä½¿å¾ s[i] == eã ä»å½åç´ ç±»åâtâæ¯æç¸ç­æ¶ï¼æåè®¸å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã è¡¨è¾¾å¼ e !in s æ¯ !(e in s) çè¯­æ³ç®åã\n\nè¡¨è¾¾å¼ s[lo..hi] äº§çä¸ä¸ªåºåï¼è¯¥åºåéè¿è·åç¬¬ä¸ä¸ª hi åç´ ç¶åå é¤ç¬¬ä¸ä¸ª lo åç´ èå½¢æã å æ­¤ï¼ç»æåºåçé¿åº¦ä¸ºâhi - loâã è¯·æ³¨æï¼s[0..|s|] ç­äº sã å¦æçç¥ä¸éï¼åé»è®¤ä¸º |s|ï¼å æ­¤ s[lo..] ä¼çæéè¿å é¤ s çç¬¬ä¸ä¸ª lo åç´ å½¢æçåºåã å¦æçç¥ä¸éï¼åé»è®¤ä¸º 0ï¼å æ­¤ s[..hi] äº§çç± s çç¬¬ä¸ä¸ª hi åç´ å½¢æçåºåã\n\nå¨åºååçæä½ä¸­ï¼slices æ¯ä¸ä¸ªé¿åº¦æç¤ºç¬¦çéç©ºåè¡¨ï¼ç±åå·åéå¹¶å¯éå°ç»æ­¢ï¼å¹¶ä¸è³å°æä¸ä¸ªåå·ã æ¯ä¸ªé¿åº¦æç¤ºç¬¦é½æ¯ä¸ä¸ªåºäºéè´æ´æ°çæ°å­ï¼å¶æ»åä¸å¤§äº|s|ã å¦ææ k ä¸ªåå·ï¼åè¯¥æä½ä¼ä» s çæ k ä¸ªè¿ç»­å­åºåï¼æ¯ä¸ªé¿åº¦ç±ç¸åºçé¿åº¦æç¤ºç¬¦æç¤ºï¼å¹¶å°è¿äºä½ä¸ºåºååºåè¿åã1 å¦æ slices ä»¥åå·ç»å°¾ï¼é£ä¹æåä¸ä¸ªåççé¿åº¦ä¼ä¸ç´å»¶ä¼¸å° s çæ«å°¾ï¼å³ å®çé¿åº¦æ¯|s|åå»ç»å®é¿åº¦æç¤ºç¬¦çæ»åã ä¾å¦ï¼å¯¹äºä»»ä½é¿åº¦è³å°ä¸º 10 çåºå s ï¼ä»¥ä¸ç­å¼æç«ï¼\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næä½multiset(s)äº§çåºåsçåç´ çå¤ééã ä»å½åç´ ç±»åâtâæ¯æç¸ç­æ¶ï¼æåè®¸å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã\n\n# 2.2.0.âå­ç¬¦ä¸²\n\nåºåç±»åçä¸ä¸ªç¹ä¾æ¯seqãcharãï¼dafny æä¾äºä¸ä¸ªåä¹è¯ï¼stringã å­ç¬¦ä¸²ä¸å¶ä»åºåç±»ä¼¼ï¼ä½ä¸ºåºåæ¾ç¤ºè¡¨è¾¾å¼æä¾äºé¢å¤çè¯­æ³ï¼å³å­ç¬¦ä¸²æå­ã å­ç¬¦ä¸²æå­æä¸¤ç§è¯­æ³å½¢å¼ï¼æ åå½¢å¼åéå­å½¢å¼ã\n\næ åå½¢å¼çå­ç¬¦ä¸²æå­ç¨åå¼å·æ¬èµ·æ¥ï¼å¦ \"dafny\"ã è¦å¨è¿æ ·çå­ç¬¦ä¸²æå­ä¸­åå«åå¼å·ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåã è½¬ä¹åºåä¹å¯ç¨äºåå«å¶ä»å­ç¬¦ã æ¯æçè½¬ä¹åºåä¸å­ç¬¦æå­ç¸åï¼è¯·åéç¬¬ [0.2] è(http://leino.science/papers/krml243.html#sec-char)ã ä¾å¦ï¼dafny è¡¨è¾¾å¼ \"say \\\"yes\\\"\" è¡¨ç¤ºå­ç¬¦ä¸² say \"yes\"ã åå¼å·çè½¬ä¹åºåæ¯å¤ä½çï¼å ä¸º \"'\" å \"'\" è¡¨ç¤ºç¸åçå­ç¬¦ä¸²ââæä¾è¿ä¸¤ç§å½¢å¼æ¯ä¸ºäºæ¯æä¸å­ç¬¦æå­ç¸åçè½¬ä¹åºåã\n\néå­å½¢å¼çå­ç¬¦ä¸²æå­ç¨ @\" å \" æ¬èµ·æ¥ï¼å¦ @\"dafny\"ã è¦å¨è¿æ ·çå­ç¬¦ä¸²æå­ä¸­åå«åå¼å·ï¼å¿é¡»ä½¿ç¨è½¬ä¹åºåââï¼å³ä¸¤æ¬¡åå¥å­ç¬¦ã å¨éå­å½¢å¼ä¸­ï¼æ²¡æå¶ä»è½¬ä¹åºåã çè³åæ¢è¡ç¬¦è¿æ ·çå­ç¬¦ä¹å¯ä»¥åå¨å­ç¬¦ä¸²æå­ä¸­ï¼å æ­¤å¨ç¨åºææ¬ä¸­è·¨è¶å¤è¡ï¼ã ä¾å¦ï¼ä»¥ä¸ä¸ä¸ªè¡¨è¾¾å¼è¡¨ç¤ºç¸åçå­ç¬¦ä¸²ï¼\n\n\"c:\\\\tmp.txt\"\n@\"c:\\tmp.txt\"\n['c', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nç±äºå­ç¬¦ä¸²æ¯åºåï¼å æ­¤å¨å®ä»¬ä¸å®ä¹äºå³ç³»è¿ç®ç¬¦ < å <=ã ä½æ¯è¯·æ³¨æï¼è¿äºè¿ç®ç¬¦ä»ç¶åå«è¡¨ç¤ºæ­£ç¡®çåç¼ååç¼ï¼èä¸æ¯å¯è½éè¦çæç§å­æ¯æ¯è¾ï¼ä¾å¦ï¼å¨å¯¹å­ç¬¦ä¸²è¿è¡æåºæ¶ã\n\n\n# 2.3.âæéä¸æ éå¾\n\nå¯¹äºä»»ä½ç±»åtåuï¼mapãtï¼uãç±»åçå¼è¡¨ç¤ºä»tå°uç*ï¼æéï¼æ å°*ã æ¢å¥è¯è¯´ï¼å®æ¯ä¸ä¸ªç±tç´¢å¼çæ¥æ¾è¡¨ã å°å¾ç domain æ¯ä¸ç»æéç t å¼ï¼å®ä»¬å·æå³èç u å¼ã ç±äºåä¸­çé®æ¯ä½¿ç¨ t ç±»åä¸­çç¸ç­æ§è¿è¡æ¯è¾çï¼å æ­¤åªæå½t æ¯æç¸ç­æ§æ¶ï¼ç±»åmapãt,uã æè½å¨éå¹½çµä¸ä¸æä¸­ä½¿ç¨ã\n\nç±»ä¼¼å°ï¼å¯¹äºä»»ä½ç±»å t å uï¼imapâ¨t,uâ© ç±»åçå¼è¡¨ç¤º*ï¼å¯è½ï¼æ éæ å°*ã å¨å¤§å¤æ°æåµä¸ï¼imap<t,u> ç±»ä¼¼äº map<t,u>ï¼ä½æ¯ imap<t,u> ç±»åçæ å°åè®¸æä¸ä¸ªæ éåã\n\nå¯ä»¥ä½¿ç¨ map display è¡¨è¾¾å¼å½¢æå°å¾ï¼è¯¥è¡¨è¾¾å¼å¯è½æ¯ä¸ä¸ªç©ºçãæåºç maplets åè¡¨ï¼æ¯ä¸ª maplet å·æ t := u çå½¢å¼ï¼å¶ä¸­ t æ¯ t ç±»åçè¡¨è¾¾å¼ï¼å¹¶ä¸ u æ¯u ç±»åçè¡¨è¾¾å¼ï¼æ¾å¨å³é®å­map åé¢çæ¹æ¬å·ä¸­ã ä¸ºäºæ¾ç¤ºï¼\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\næ¯å°å¾æ¾ç¤ºçä¸ä¸ªç¤ºä¾ã éè¿ä½¿ç¨å³é®å­ imap èä¸æ¯ mapï¼çæçå°å¾å°æ¯ imap<t,u> ç±»åèä¸æ¯ map<t,u>ã è¯·æ³¨æï¼åè®¸æ éæ å° (imap) å·ææéåï¼èä¸åè®¸æéæ å° (map) å·ææ éåã å¦æåä¸ä¸ªé®åºç°å¤æ¬¡ï¼åç»ææ å°ä¸­åªåºç°æåä¸æ¬¡åºç°ã2 è¿æä¸ä¸ª * å°å¾çè§£è¡¨è¾¾å¼*ï¼å¨ dafny è¯­è¨åèçä¸åé¨åè¿è¡äºè§£éã\n\nå¯¹äºmap<t,u>ç±»åçä»»ä½æ å°fmï¼map<t,u>æimap<t,u>ç±»åçä»»ä½æ å°mï¼ç±»åçä»»ä½è¡¨è¾¾å¼t tï¼uç±»åçä»»ä½è¡¨è¾¾å¼uï¼ä»¥åmåä¸­çä»»ä½dï¼å³æ»¡è¶³d in m`ï¼ï¼æ å°æ¯æä»¥ä¸æä½ï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \n|fm|        å°å¾åºæ°\nm[d]        å°å¾éæ©\nm[t := u]   å°å¾æ´æ°\nt in m      æ å°åæå\nt !in m     æ å°åéæå\n            \n\n|fm| è¡¨ç¤ºfm ä¸­çæ å°ä¸ªæ°ï¼å³fm çåçåºæ°ã è¯·æ³¨æï¼æ éæ å°ä¸æ¯æåºæ°è¿ç®ç¬¦ã è¡¨è¾¾å¼ m[d] è¿å m ä¸ d å³èç u å¼ã è¡¨è¾¾å¼ m[t := u] æ¯ä¸ä¸ªç±»ä¼¼äº m çæ å°ï¼é¤äºé® t å¤çåç´ æ¯ uã\n\nè¡¨è¾¾å¼ t in m è¡¨ç¤º t å¨ m çåä¸­ï¼è t !in m æ¯ !(t in m) çè¯­æ³ç®åã 3 è¿æ¯ä¸ä¸ªå°ä¾å­ï¼å¶ä¸­ç±»åä¸º map<int,real> çå°å¾ cache ç¨äºç¼å­ joule-thomson ç³»æ°çè®¡ç®å¼ ç»å®æ¸©åº¦ä¸çä¸äºåºå®æ°ä½ï¼\n\nif k in cache {  // check if temperature is in domain of cache\n  coeff := cache[k];  // read result in cache\n} else {\n  coeff := computejoulethomsoncoefficient(k);  // do expensive computation\n  cache := cache[k := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.âè±¡å¾ç±»å\n\nææ¶éè¿å¤ä¸ªåç§°äºè§£ä¸ä¸ªç±»åææ½è±¡å°å¤çä¸ä¸ªç±»åå¾æç¨ã\n\n\n# 3.0.âåä¹è¯ç±»å\n\nç±»ååä¹è¯å£°æï¼\n\ntype yãtã = g\n\n\n1\n\n\nå£°æ yãtã æ¯ç±»å g çåä¹è¯ã è¿éï¼t æ¯ä¸ä¸ªç±»ååæ°çéç©ºåè¡¨ï¼æ¯ä¸ªåæ°é½å¯éå°ç¨åç¼â(==)âæå®ï¼ï¼å®å¯ä»¥ç¨ä½g ä¸­çèªç±ç±»ååéã å¦æåä¹è¯æ²¡æç±»ååæ°ï¼åå é¤âãtãâã å¨æææåµä¸ï¼ç±»ååä¹è¯åªæ¯åä¹è¯ã ä¹å°±æ¯è¯´ï¼é¤äºå¯è½äº§ççéè¯¯æ¶æ¯ä¹å¤ï¼yãtã å g ä¹é´ä»æ¥æ²¡æåºå«ã\n\nä¾å¦ï¼ä»¥ä¸ç±»ååä¹è¯çåç§°å¯è½ä¼æé«ç¨åºçå¯è¯»æ§ï¼\n\ntype replacementsãtã = mapãt,tã\ntype vertex = int\n\n\n1\n2\n\n\nå¦ç¬¬ 2.2.0 ä¸­æè¿°ï¼string æ¯seqãcharã çåç½®ç±»ååä¹è¯ï¼å¥½å å®å°è¢«å®£å¸å¦ä¸ï¼\n\ntype string = seqãcharã\n\n\n1\n\n\n\n# 3.1.âä¸éæç±»å\n\nç±»ååä¹è¯çä¸ä¸ªç¹ä¾æ¯æªæå®çã è¿æ ·çç±»åç®åå°éè¿ä»¥ä¸æ¹å¼å£°æï¼\n\ntype yãtã\n\n\n1\n\n\nå®è¢«ç§°ä¸ºä¸éæç±»åã å®çå®ä¹å¯ä»¥å¨ç²¾ç¼æ¨¡åä¸­æ¾ç¤ºã ä¸ºäºè¡¨æ y è¡¨ç¤ºæ¯æç¸ç­çç±»åï¼å¯ä»¥å¨åç§°âyâä¹åç´§è·â(==)âã\n\nä¾å¦ï¼å£°æ\n\ntype t\nfunction f(t: t): t\n\n\n1\n2\n\n\nå¯ç¨äºå¨æä¸ªä»»æç±»åâtâä¸å»ºæ¨¡æªè§£éçå½æ°âfâã ä½ä¸ºå¦ä¸ä¸ªä¾å­ï¼\n\ntype monadãtã\n\n\n1\n\n\nå¯ä»¥æ½è±¡å°ç¨äºè¡¨ç¤ºä»»æåæ°åç monadã\n\n\n# 4.âæ°æ®ç±»å\n\ndafny æä¾äºä¸¤ç§ä»£æ°æ°æ®ç±»åï¼ä¸ç§æ¯å½çº³å®ä¹çï¼å¦ä¸ç§æ¯åå½çº³å®ä¹çã æ¯ä¸ªæ°æ®ç±»åçæ¾çå±æ§æ¯è¯¥ç±»åçæ¯ä¸ªå¼å¯ä¸æ è¯æ°æ®ç±»åçæé å½æ°ä¹ä¸ï¼å¹¶ä¸æ¯ä¸ªæé å½æ°çåæ°é½æ¯åå°çã\n\n\n# 4.0.âå½çº³ç±»å\n\nå½çº³æ°æ®ç±»åçå¼å¯ä»¥çä½æ¯æéæ ï¼å¶ä¸­å¶å­æ¯åºæ¬ç±»åãæ°å¼ç±»åãå¼ç¨ç±»åãå±å½çº³æ°æ®ç±»åæå½æ°ç±»åçå¼ã å®éä¸ï¼å¯ä»¥ä½¿ç¨ dafny ææ ¹æ®ç < æåºæ¥æ¯è¾å½çº³æ°æ®ç±»åçå¼ã\n\nå½çº³æ°æ®ç±»åå£°æå¦ä¸ï¼\n\ndatatype dãtã = ctors\n\n\n1\n\n\nå¶ä¸­ *ctors* æ¯ä¸ä¸ªéç©ºç | åéç (datatype) æé å½æ° çæ°æ®ç±»ååè¡¨ã æ¯ä¸ªæé å½æ°é½æä»¥ä¸å½¢å¼ï¼\n\nc(params)\n\n\n1\n\n\nå¶ä¸­ *params* æ¯ä¸ä¸ªéå·åéçç±»ååè¡¨ï¼åé¢å¯éåæ°åç§°ååå·ï¼åé¢å¯éå³é®å­ ghostã å¦ææé å½æ°æ²¡æåæ°ï¼åå¯ä»¥çç¥æé å½æ°åç§°åé¢çæ¬å·ã å¦ææ²¡ææé å½æ°æ¥ååæ°ï¼åè¯¥ç±»åéå¸¸ç§°ä¸ºæä¸¾ï¼ ä¾å¦ï¼\n\ndatatype friends = agnes | agatha | jermaine | jack\n\n\n1\n\n\nå¯¹äºæ¯ä¸ªæé å½æ° cï¼dafny å®ä¹äºä¸ä¸ª discriminator c?ï¼å®æ¯ä¸ä¸ªè¿å true çæåï¼å½ä¸ä»å½æ°æ®ç±»åå¼æ¯ä½¿ç¨ c æé çã å¯¹äºæé å½æ° c çæ¯ä¸ªå½ååæ° pï¼dafny å®ä¹äºä¸ä¸ª destructor pï¼å®æ¯ä»ç¨äºæé æ°æ®ç±»åå¼ç c è°ç¨è¿å p åæ°çæåï¼ å®çä½¿ç¨è¦æ± c? æç«ã ä¾å¦ï¼å¯¹äºæ åç list ç±»å\n\ndatatype listãtã = nil | cons(head: t, tail: listãtã)\n\n\n1\n\n\nä»¥ä¸æç«ï¼\n\ncons(5, nil).cons? && cons(5, nil).head == 5\n\n\n1\n\n\næ³¨æè¡¨è¾¾å¼\n\ncons(5, nil).tail.head\n\n\n1\n\n\næ ¼å¼ä¸æ­£ç¡®ï¼å ä¸º cons(5, nil).tail ä¸æ»¡è¶³ cons?ã\n\nææå½æ°çåç§°å¨æ°æ®ç±»åçæææé å½æ°ä¸­å¿é¡»æ¯å¯ä¸çã æé å½æ°å¯ä»¥ä¸å°é­æ°æ®ç±»åååï¼ è¿å¯¹äºéå¸¸ç§°ä¸ºè®°å½ç±»åçåæé å½æ°æ°æ®ç±»åç¹å«æç¨ã ä¾å¦ï¼é»ç½åç´ çè®°å½ç±»åå¯è½è¡¨ç¤ºå¦ä¸ï¼\n\ndatatype pixel = pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nè¦è°ç¨æé å½æ°ï¼éå¸¸åªéè¦æåæé å½æ°çåç§°ï¼ä½å¦æè¿ä¸æç¡®ï¼åå§ç»å¯ä»¥éè¿æ°æ®ç±»åçåç§°æ¥éå®æé å½æ°çåç§°ã æ¯å¦ä¸é¢çcons(5, nil)å¯ä»¥åæ\n\nlist.cons(5, list.nil)\n\n\n1\n\n\nä½ä¸ºæ¾å¼è°ç¨æ°æ®ç±»åæé å½æ°çæ¿ä»£æ¹æ³ï¼å¯ä»¥ä½¿ç¨ datatype update è¡¨è¾¾å¼å°æ°æ®ç±»åå¼æé ä¸ºä¸ä¸ªåæ°ä»ç»å®æ°æ®ç±»åå¼çååã å¯¹äºä»»ä½ç±»åä¸ºæ°æ®ç±»åçâdâï¼è¯¥æ°æ®ç±»ååæ¬æé å½æ°âcâï¼è¯¥æé å½æ°å·æåä¸ºâfâçç±»åä¸ºâtâçåæ°ï¼ææå½æ°ï¼ï¼ä»¥åä»»ä½ç±»åä¸ºâtâçè¡¨è¾¾å¼âtâï¼\n\nd[f := t]\n\n\n1\n\n\næé ä¸ä¸ªç±»ä¼¼äº d ä½å¶ f åæ°æ¯ t çå¼ã è¯¥æä½è¦æ± d æ»¡è¶³ c?ã ä¾å¦ï¼ä»¥ä¸ç­å¼æç«ï¼\n\ncons(4, nil)[tail := cons(3, nil)] == cons(4, cons(3, nil))\n\n\n1\n\n\n\n# 4.1.âåç»ç±»å\n\ndafny æå»ºäºå¯¹åºäºåç»çè®°å½ç±»åï¼å¹¶ä¸ºå®ä»¬æä¾äºä¸ç§æ¹ä¾¿çç¹æ®è¯­æ³ï¼å³æ¬å·ã ä¾å¦ï¼å¯è½å·²å£°æä¸ºï¼\n\ndatatype pairãt,uã = pair(0: t, 1: u)\n\n\n1\n\n\ndafny æä¾äºç±»å (t, u) åæé å½æ° (t, u)ï¼å¥½åæ°æ®ç±»åçåç§°æ¯ââï¼å¹¶ä¸å®çç±»ååæ°å¨åæ¬å·ä¸­ç»åºï¼å¹¶ä¸å¥½åæé å½æ°åç§°æ¯ââ . è¯·æ³¨æï¼ææå½æ°åç§°æ¯â0âåâ1âï¼å®ä»¬æ¯æåçåæ³æ è¯ç¬¦åç§°ã ä¾å¦ï¼æ¾ç¤ºåç»ææå½æ°çä½¿ç¨ï¼è¿éæä¸ä¸ªåå« 2 åç»çå±æ§ï¼å³ pairsï¼ï¼\n\n(5, true).1 == true\n\n\n1\n\n\ndafny å£°æ n åç»ï¼å¶ä¸­ n ä¸º 0 æ 2 ææ´é«ã æ²¡æ 1 åç»ï¼å ä¸ºå´ç»åä¸ªç±»åæåä¸ªå¼çæ¬å·æ²¡æè¯­ä¹æä¹ã 0 åç»ç±»å () éå¸¸è¢«ç§°ä¸º unit ç±»åï¼å®çåä¸ªå¼ï¼ä¹åä½ ()ï¼è¢«ç§°ä¸º unitã\n\n\n# 4.2.âå±åå½çº³ç±»å\n\nå°½ç®¡ dafny åæè®¤ä¸ºæä¸ç§æ¹æ³å¯ä»¥ä»å¤´å¼å§æé æ¯ä¸ªå½çº³æ°æ®ç±»åå¼ï¼ä½ dafny è¿æ¯æ co-inductive datatypesï¼å¶æé å½æ°è¢«å»¶è¿è¯ä¼°ï¼å æ­¤åè®¸æ éç»æã ä½¿ç¨å³é®å­âcodatatypeâå£°æå±å½çº³æ°æ®ç±»åï¼ é¤æ­¤ä¹å¤ï¼å®åå½çº³æ°æ®ç±»åä¸æ ·è¢«å£°æåä½¿ç¨ã\n\nä¾å¦,\n\ncodatatype ilistãtã = nil | cons(head: t, tail: ilistãtã)\ncodatatype streamãtã = more(head: t, tail: streamãtã)\ncodatatype treeãtã = node(left: treeãtã, value: t, right: treeãtã)\n\n\n1\n2\n3\n\n\nåå«å£°æå¯è½æ éçåè¡¨ï¼å³å¯ä»¥æ¯æéææ éçåè¡¨ï¼ãæ éæµï¼å³å§ç»æ éçåè¡¨ï¼åæ éäºåæ ï¼å³æ¯ä¸ªåæ¯æ°¸è¿å­å¨çæ ï¼ã\n\n\n# 5.âåç§ç±»å\n\ndafny æä¾äºè®¸å¤åèç±»åã è¿äºä»£è¡¨å¯¹ç¨åºå ä¸­å¨æåéçå¯¹è±¡çå¼ç¨ã è¦è®¿é®å¯¹è±¡çæåï¼å¯¹å¯¹è±¡çå¼ç¨ï¼å³æé æå¯¹è±¡æ è¯ï¼è¢«åæ¶å¼ç¨ã\n\nç¹æ®å¼ null æ¯æ¯ä¸ªå¼ç¨ç±»åçä¸é¨åã4\n\n\n# 5.0.âç±»\n\nclass c æ¯ä¸ä¸ªå¼ç¨ç±»åï¼å£°æå¦ä¸ï¼\n\nclass cãtã extends j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­ç±»ååæ°åè¡¨tæ¯å¯éçï¼âextends jâä¹æ¯å¦æ­¤ï¼å®è¡¨ç¤ºè¯¥ç±»æ©å±äºä¸ä¸ªç¹å¾âjâã ç±»çæåæ¯ fieldsãfunctions å methodsã è¿äºæ¯éè¿åæ¶å¼ç¨å¯¹âcâå®ä¾çå¼ç¨æ¥è®¿é®æè°ç¨çã é¤éå½æ°ææ¹æ³å£°æä¸º staticï¼å¦åå½æ°ææ¹æ³ä¼å¨ c ç instance ä¸è°ç¨ã æºæ¢°å°ï¼è¿åªæ¯æå³çè¯¥æ¹æ³éç¨éå¼ receiver åæ°ï¼å³ç¨äºè®¿é®æåçå®ä¾ã å¨å®ä¾å½æ°ææ¹æ³çè§èåä¸»ä½ä¸­ï¼æ¥æ¶å¨åæ°å¯ä»¥éè¿å³é®å­ this æ¾å¼å¼ç¨ã ä½æ¯ï¼å¨è¿æ ·çå°æ¹ï¼thisçæåä¹å¯ä»¥æ æ¡ä»¶å°è¢«æåã ä¸ºäºè¯´æï¼åæ ¼ç this.f åä¸åæ ¼ç f å¨ä»¥ä¸ç¤ºä¾ä¸­æçæ¯åä¸å¯¹è±¡çåä¸å­æ®µï¼\n\nclass c {\n  var f: int;\n  method example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\næä»¥æ¹æ³ä½æ»æ¯å° true åéç»è¾åºåæ° bã å¯¹åä¸æ¥æ¶èåæåçåæ ¼åä¸åæ ¼è®¿é®ä¹é´æ²¡æè¯­ä¹å·®å¼ã\n\nä¸ä¸ª c å®ä¾æ¯ä½¿ç¨ new åå»ºçï¼ä¾å¦ï¼\n\nc := new c;\n\n\n1\n\n\nè¯·æ³¨æï¼new åªæ¯åéä¸ä¸ª c å¯¹è±¡å¹¶è¿åå¯¹å®çå¼ç¨ï¼ å¶å­æ®µçåå§å¼æ¯å®ä»¬åèªç±»åçä»»æå¼ã å æ­¤ï¼éå¸¸å¨åå»ºåç«å³è°ç¨ç§°ä¸º initialization method çæ¹æ³ï¼ä¾å¦ï¼\n\nc := new c;\nc.initfromlist(xs, 3);\n\n\n1\n2\n\n\nå½åå§åæ¹æ³æ²¡æout-parameterå¹¶ä¸ä¿®æ¹ä¸è¶è¿thisæ¶ï¼é£ä¹ä¸é¢çä¸¤ä¸ªè¯­å¥å¯ä»¥åå¹¶ä¸ºä¸ä¸ªï¼\n\nc := new c.initfromlist(xs, 3);\n\n\n1\n\n\nè¯·æ³¨æï¼ä¸ä¸ªç±»å¯ä»¥åå«å¤ä¸ªåå§åæ¹æ³ï¼è¿äºæ¹æ³å¯ä»¥éæ¶è°ç¨ï¼èä¸ä»ä»æ¯ä½ä¸ºnewçä¸é¨åï¼å¹¶ä¸newä¸éè¦å¨åå»ºæ¶è°ç¨åå§åæ¹æ³ã\n\nè¦ç¼åç»æåçé¢åå¯¹è±¡ç¨åºï¼éå¸¸ä¾èµäºä»ä»¥ç¹å®æ¹å¼æé å¯¹è±¡ã ä¸ºæ­¤ï¼dafny æä¾äº constructor (method)sï¼è¿æ¯ä¸ç§åéå½¢å¼çåå§åæ¹æ³ã æé å½æ°æ¯ç¨å³é®å­constructorèä¸æ¯methodå£°æçã å½ä¸ä¸ªç±»åå«æé å½æ°æ¶ï¼å¯¹è¯¥ç±»çæ¯æ¬¡è°ç¨ new é½å¿é¡»ä¼´éå¯¹æé å½æ°ä¹ä¸çè°ç¨ã æ­¤å¤ï¼ä¸è½å¨å¶ä»æ¶é´è°ç¨æé å½æ°ï¼åªè½å¨å¯¹è±¡åå»ºæé´è°ç¨ã é¤äºè¿äºéå¶ä¹å¤ï¼ä½¿ç¨æ®éåå§åæ¹æ³åä½¿ç¨æé å½æ°ä¹é´æ²¡æè¯­ä¹ä¸çåºå«ã\n\ndafny è®¾è®¡åè®¸å½åæé å½æ°ï¼è¿ä¿è¿äºä½¿ç¨ä¸é¢çâinitfromlistâä¹ç±»çåç§°ã å°½ç®¡å¦æ­¤ï¼è®¸å¤ç±»åªæä¸ä¸ªæé å½æ°ææä¸ä¸ªå¸åçæé å½æ°ã å æ­¤ï¼dafny åè®¸ä¸ä¸ªå¿åæé å½æ°ï¼å³åç§°æ¬è´¨ä¸æ¯ââçæé å½æ°ã ä¾å¦ï¼\n\nclass item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nè°ç¨æ­¤æé å½æ°æ¶ï¼ä¼å é¤â.âï¼å¦ä¸æç¤ºï¼\n\nm := new item(45, 29);\n\n\n1\n\n\nè¯·æ³¨æï¼å¿åæé å½æ°åªæ¯å½åæé å½æ°çä¸ç§æ¹å¼ï¼ ä¹å¯ä»¥æå¶ä»æé å½æ°ã\n\n\n# 5.1.âæ°ç»\n\ndafny æ¯æä»»ä½æ­£ç»´åº¦çå¯ååºå®é¿åº¦æ°ç»ç±»åã æ°ç»ç±»åæ¯å¼ç¨ç±»åã\n\n# 5.1.0.âä¸ç»´æ°ç»\n\nn t åç´ çä¸ç»´æ°ç»åå»ºå¦ä¸ï¼\n\na := new t[n];\n\n\n1\n\n\næ°ç»åç´ çåå§å¼æ¯âtâç±»åçä»»æå¼ã ä½¿ç¨ä¸å¯åç length æåæ£ç´¢æ°ç»çé¿åº¦ã ä¾å¦ä¸é¢åéçæ°ç»æ»¡è¶³ï¼\n\na.length == n\n\n\n1\n\n\nå¯¹äº 0 <= i < a.length èå´åçä»»ä½åºäºæ´æ°çæ°å­ iï¼array selection è¡¨è¾¾å¼ a[i] æ£ç´¢åç´  iï¼å³ï¼åé¢æ i æ°ç»ä¸­çåç´ ï¼ã å¯ä»¥ä½¿ç¨æ°ç»æ´æ°è¯­å¥å°å­å¨å¨ i çåç´ æ´æ¹ä¸ºå¼ tï¼\n\na[i] := t;\n\n\n1\n\n\nè­¦åï¼ç±new t[n]åå»ºçæ°ç»ç±»åæ¯arrayãtãã ä¸ä¸ªå®¹æç¯çéè¯¯æ¯å¨ new åé¢å array<t> èä¸æ¯ tã ä¾å¦ï¼èèä»¥ä¸æåµï¼\n\nvar a := new arrayãtã;\nvar b := new arrayãtã[n];\nvar c := new arrayãtã(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nç¬¬ä¸æ¡è¯­å¥åéäºä¸ä¸ªç±»åä¸º arrayãtã çæ°ç»ï¼ä½é¿åº¦æªç¥ã ç¬¬äºä¸ªåéä¸ä¸ªé¿åº¦ä¸ºânâçâarrayãarrayãtããâç±»åçæ°ç»ï¼å³ä¸ä¸ªåå«ânâç±»åçâarrayãtãâå¼çæ°ç»ã ç¬¬ä¸æ¡è¯­å¥åéä¸ä¸ªç±»åä¸ºarrayãtãçæ°ç»ï¼ç¶åå°è¯è°ç¨è¿ä¸ªæ°ç»çå¿åæé å½æ°ï¼ä¼ éåæ°nã ç±äºarrayæ²¡ææé å½æ°ï¼æ´ä¸ç¨è¯´å¿åæé å½æ°äºï¼è¿ä¸ªè¯­å¥ä¼äº§çéè¯¯ã å¦æå¯¹äºéè¦ç±»ååæ°çç±»åçç¥äºç±»ååæ°åè¡¨ï¼dafny å°å°è¯å¡«åè¿äºï¼å æ­¤åªè¦å¯ä»¥æ¨æ­åºarrayç±»ååæ°ï¼å°±å¯ä»¥çç¥âãtã â å¨ä¸é¢çç¬¬åä¸ªè¯­å¥ä¸­ã ä½æ¯ï¼ä¸ç¬¬ä¸æ¡è¯­å¥ä¸æ ·ï¼array` æ²¡æå¿åæé å½æ°ï¼å æ­¤ä¼çæéè¯¯æ¶æ¯ã\n\nä¸ç»´æ°ç»æ¯æå°ä¸ç³»åè¿ç»­åç´ è½¬æ¢ä¸ºåºåçæä½ã å¯¹äºä»»ä½ç±»åä¸ºarrayãtãçæ°ç»aï¼åºäºæ´æ°çæ°å­loåhiæ»¡è¶³0 <= lo <= hi <= a.lengthï¼ä»¥ä¸æä½åèªäº§çä¸ä¸ªseq ãtãï¼\n\n            \nè¡¨è¾¾å¼         æè¿°\n            \na[lo..hi]   å­æ°ç»è½¬ä¸ºåºå\na[lo..]     drop\na[..hi]     take\na[..]       æ°ç»è½¬æ¢ä¸ºåºå\n            \n\nè¡¨è¾¾å¼ a[lo..hi] è·åæ°ç»çç¬¬ä¸ä¸ª hi åç´ ï¼ç¶åå é¤å¶ä¸­çç¬¬ä¸ä¸ª lo åç´ å¹¶è¿åå©ä½çåºåã å æ­¤ï¼ç»æåºåçé¿åº¦ä¸ºâhi - loâã å¶ä»æä½æ¯ç¬¬ä¸ä¸ªæä½çç¹æ®å®ä¾ã å¦æçç¥ loï¼åé»è®¤ä¸º 0ï¼å¦æçç¥ hiï¼åé»è®¤ä¸º a.lengthã å¨æåä¸ä¸ªæä½ä¸­ï¼lo å hi é½è¢«çç¥äºï¼å æ­¤ a[..] è¿åç± a çæææ°ç»åç´ ç»æçåºåã\n\nå­æ°ç»æä½å¨è§èä¸­ç¹å«æç¨ã ä¾å¦ï¼ä½¿ç¨åéâloâåâhiâæ¥ååä»ç¶å¯ä»¥æ¾å°æç´¢âkeyâçå­æ°ç»çäºåæç´¢ç®æ³çå¾ªç¯ä¸åéå¯ä»¥è¡¨ç¤ºå¦ä¸ï¼\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nå¦ä¸ä¸ªç¨éæ¯è¯´æä¸ªèå´çæ°ç»åç´ èªæ¹æ³å¼å§ä»¥æ¥æ²¡ææ¹åï¼\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\næä»å¾ªç¯å¼å§ï¼\n\nghost var prevelements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevelements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\næ³¨æè¿ä¸ªä¾å­ä¸­çprevelementsçç±»åæ¯seq<t>ï¼å¦æaçç±»åæ¯array<t>ã\n\nå­æ°ç»æä½çæåä¸ä¸ªç¤ºä¾å¨äºè¡¨ç¤ºæ°ç»çåç´ æ¯æ¹æ³å¼å¤´çæ°ç»åç´ çæåï¼å°±åå¨å¤§å¤æ°æåºç®æ³ä¸­æåçé£æ ·ã å¨è¿éï¼å­æ°ç»æä½ä¸åºåå°å¤éçè½¬æ¢ç¸ç»åï¼\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1.âå¤ç»´æ°ç»\n\n2 ç»´ææ´å¤ç»´çæ°ç»å¤§å¤ç±»ä¼¼äºä¸ç»´æ°ç»ï¼ä¸åä¹å¤å¨äº new éè¦æ´å¤é¿åº¦åæ°ï¼æ¯ä¸ªç»´åº¦ä¸ä¸ªï¼ï¼å¹¶ä¸æ°ç»éæ©è¡¨è¾¾å¼åæ°ç»æ´æ°è¯­å¥éè¦æ´å¤ç´¢å¼ã ä¾å¦ï¼\n\nmatrix := new t[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\nåå»ºä¸ä¸ªäºç»´æ°ç»ï¼å¶ç»´åº¦çé¿åº¦åå«ä¸ºâmâåânâï¼ç¶åäº¤æ¢âi,jâåâx,yâå¤çåç´ ã matrix çç±»åæ¯ array2<t>ï¼å¯¹äºé«ç»´æ°ç»ï¼array3<t>ãarray4<t> ç­ï¼ä¹æ¯å¦æ­¤ã ä½æ¯è¯·æ³¨æï¼æ²¡æç±»å array0<t>ï¼æ¬æ¥å¯ä»¥æ¯ array1<t> çä¸è¥¿å®éä¸åªæ¯å½åä¸º array<t>ã\n\nä¸é¢ç new æä½è¦æ± m å n æ¯åºäºéè´æ´æ°çæ°å­ã å¯ä»¥ä½¿ç¨ä¸å¯åå­æ®µ length0 å length1 æ£ç´¢è¿äºé¿åº¦ã ä¾å¦ï¼ä»¥ä¸ä¿å­äºä¸é¢åå»ºçæ°ç»ï¼\n\nmatrix.length0 == m && matrix.length1 == n\n\n\n1\n\n\né«ç»´æ°ç»ç±»ä¼¼ï¼length0ãlength1ãlength2ã...ï¼ã æ°ç»éæ©è¡¨è¾¾å¼åæ°ç»æ´æ°è¯­å¥è¦æ±ç´¢å¼å¨èå´åã ä¾å¦ï¼ä¸é¢çäº¤æ¢è¯­å¥åªæå¨ä»¥ä¸æåµä¸ææ¯æ ¼å¼æ­£ç¡®çï¼\n\n0 <= i < matrix.length0 && 0 <= j < matrix.length1 &&\n0 <= x < matrix.length0 && 0 <= y < matrix.length1\n\n\n1\n2\n\n\nä¸ä¸ç»´æ°ç»ç¸æ¯ï¼æ²¡æå°åç´ çå»¶ä¼¸ä»å¤ç»´æ°ç»è½¬æ¢ä¸ºåºåçæä½ã\n\n\n# 5.2.âç¹å¾\n\ntrait æ¯ä¸ä¸ªâæ½è±¡è¶ç±»âï¼æèç§°å®ä¸ºâæ¥å£âæâmixinâã ç¹å¾å¯¹ dafny æ¥è¯´æ¯æ°çï¼å¹¶ä¸å¯è½ä¼åå±ä¸æ®µæ¶é´ã ä¸ä¸ª trait çå£°æå¾åä¸ä¸ªç±»çå£°æï¼\n\ntrait j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nå¶ä¸­ *members* å¯ä»¥åå«å­æ®µãå½æ°åæ¹æ³ï¼ä½ä¸è½åå«æé å½æ°æ¹æ³ã åè®¸å°å½æ°åæ¹æ³å£°æä¸ºâéæâã\n\næ©å±ç¹å¾âjâçå¼ç¨ç±»åâcâå¯ä»¥åéç»âjâï¼ä½ä¸è½åè¿æ¥ã j çæåå¯ä»¥ä½ä¸ºc çæåä½¿ç¨ã j ä¸­çæåä¸åè®¸å¨c ä¸­éæ°å£°æï¼é¤éè¯¥æåæ¯å¨j ä¸­æ²¡æä¸»ä½çéstatic å½æ°ææ¹æ³ã éè¿è¿æ ·åï¼ç±»åâcâå¯ä»¥ä¸ºæåæä¾æ´å¼ºå¤§çè§èåä¸»ä½ã\n\nnew ä¸åè®¸ä¸ç¹å¾ä¸èµ·ä½¿ç¨ã å æ­¤ï¼æ²¡æåéç±»åæ¯ç¹å¾çå¯¹è±¡ã ä½æ¯å½ç¶å¯ä»¥æä¸ä¸ªç±» c çå¯¹è±¡å®ç°äºä¸ä¸ªç¹å¾ j ï¼å¹¶ä¸å¯¹è¿æ ·ä¸ä¸ª c å¯¹è±¡çå¼ç¨å¯ä»¥ç¨ä½ç±»å j çå¼ã\n\nä¾å¦ï¼ä»¥ä¸ç¹å¾è¡¨ç¤ºå¯ç§»å¨çå ä½å½¢ç¶ï¼\n\ntrait shape\n{\n  function method width(): real\n    reads this\n  method move(dx: real, dy: real)\n    modifies this\n  method moveh(dx: real)\n    modifies this\n  {\n    move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\næå width å move æ¯ abstract ï¼å³æ ä¸»ä½ï¼ï¼å¹¶ä¸å¯ä»¥ç±æ©å± trait çä¸åç±»ä»¥ä¸åæ¹å¼å®ç°ã æ¹æ³ moveh çå®ç°å¨ trait ä¸­ç»åºï¼å æ­¤è¢«æææ©å± shape çç±»ä½¿ç¨ã è¿éæä¸¤ä¸ªç±»ï¼æ¯ä¸ªç±»é½æ©å±äºâshapeâï¼\n\nclass unitsquare extends shape\n{\n  var x: real, y: real;\n  function method width(): real {  // note the empty reads clause\n    1.0\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass lowerrighttriangle extends shape\n{\n  var xnw: real, ynw: real, xse: real, yse: real;\n  function method width(): real\n    reads this\n  {\n    xse - xnw\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    xnw, ynw, xse, yse := xnw + dx, ynw + dy, xse + dx, yse + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nè¯·æ³¨æï¼ç±»å¯ä»¥å£°æå¶ä»æåï¼å®ä»¬ä¸ºç¹å¾çæ½è±¡æåæä¾å®ç°ï¼å®ä»¬éå¤æåç­¾åï¼å¹¶ä¸å®ä»¬è´è´£æä¾èªå·±çæåè§èï¼è¿äºè§èæ¢å å¼ºäºç¹å¾ä¸­çç¸åºè§èï¼åæ¯ å¯¹æä¾çæºææå°æ»¡æã æåï¼è¿æ¯ä¸äºåå»ºä¸¤ä¸ªç±»å®ä¾å¹¶å°å®ä»¬ä¸èµ·ç¨ä½å½¢ç¶çä»£ç :\n\nvar myshapes: seqãshapeã;\nvar a := new unitsquare;\nmyshapes := [a];\nvar tri := new lowerrighttriangle;\nmyshapes := myshapes + [tri];  // myshapes contains two shape values, of different classes\nmyshapes[1].moveh(myshapes[0].width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.âç±»å object\n\næä¸ä¸ªåç½®çå¼ç¨ç±»åobjectï¼å®å°±åææå¼ç¨ç±»åçè¶ç±»åã5 type object æ¯ä¸ºäºå¯ç¨å¯¹å¨æå¸§çç»ä¸å¤çã ç¹å«æ¯ï¼ä¿çç±»åä¸º setãobjectã çå¹½çµå­æ®µï¼éå¸¸å½åä¸ºrepr` è¡¨ç¤ºâè¡¨ç¤ºâï¼å¾æç¨ã\n\n\n# 5.4.âè¿­ä»£å¨ç±»å\n\niterator ä¸ºç¼åè¿­ä»£è¿ååç´ çä»£ç æä¾äºç¼ç¨æ½è±¡ã è¿äº clu é£æ ¼çè¿­ä»£å¨æ¯ååä¾ç¨ï¼å ä¸ºå®ä»¬è·è¸ªèªå·±çç¨åºè®¡æ°å¨ï¼å¹¶ä¸æ§å¶å¯ä»¥ä¼ å¥åä¼ åºè¿­ä»£å¨ä¸»ä½ã\n\nè¿­ä»£å¨å£°æå¦ä¸ï¼\n\niterator iterãtã(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nå¶ä¸­ t æ¯ç±»ååæ°çåè¡¨ï¼éå¸¸ï¼å¦ææ²¡æç±»ååæ°ï¼åçç¥âãtãâï¼ã è¿ä¸ªå£°æäº§çäºä¸ä¸ªååçå¼ç¨ç±»åï¼iterãtãã å¨ç­¾åä¸­ï¼in-parameters å yield-parameters æ¯è¿­ä»£å¨å¯¹æ¹æ³ç in-parameters å out-parameters çæ¨¡æã ä¸åä¹å¤å¨äºï¼æ¹æ³çè¾åºåæ°åªè¿åç»è°ç¨èä¸æ¬¡ï¼èè¿­ä»£å¨ç yield åæ°å¨è¿­ä»£å¨ä¸»ä½æ§è¡ yield æ¶è¿åã è§èçè¯¦ç»ä¿¡æ¯å¨ dafny è¯­è¨åèçä¸åé¨åä¸­è¿è¡äºæè¿°ã ä¸»ä½ç±è¯­å¥ç»æï¼å°±åå¨æ¹æ³ä¸»ä½ä¸­ä¸æ ·ï¼ä½ä¹å¯ä»¥ä½¿ç¨ yield è¯­å¥ã\n\nä»è¿­ä»£å¨å®¢æ·ç«¯çè§åº¦æ¥çï¼iterator å£°æå¯ä»¥çè§£ä¸ºçæå·æåç§æåçç±»iterãtãï¼ä¸é¢å°æè¿°å¶ç®åçæ¬ã\n\n`iterãtã ç±»åå«ä¸ä¸ªå¿åæé å½æ°ï¼å¶åæ°æ¯è¿­ä»£å¨çååæ°ï¼\n\npredicate valid()\nconstructor (in-params)\n  modifies this\n  ensures valid()\n\n\n1\n2\n3\n4\n\n\nä½¿ç¨ new åè¿ä¸ªå¿åæé å½æ°åå»ºäºä¸ä¸ªè¿­ä»£å¨ã ä¾å¦ï¼ä¸ä¸ªæ¿æä» start è¿ååä¸ªè¿ç»­æ´æ°çè¿­ä»£å¨å¯ä»¥å£°æå¦ä¸ï¼\n\niterator gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿ä¸ªè¿­ä»£å¨çä¸ä¸ªå®ä¾æ¯ä½¿ç¨ä»¥ä¸æ¹æ³åå»ºçï¼\n\niter := new gen(30);\n\n\n1\n\n\nè°è¯âvalid()âè¡¨ç¤ºè¿­ä»£å¨ä½æ¶å¤äºå¯ä»¥å°è¯è®¡ç®æ´å¤åç´ çç¶æã å®æ¯æé å½æ°çåç½®æ¡ä»¶ï¼åºç°å¨âmovenextâæåçè§èä¸­ï¼\n\nmethod movenext() returns (more: bool)\n  requires valid()\n  modifies this\n  ensures more ==> valid()\n\n\n1\n2\n3\n4\n\n\nè¯·æ³¨æï¼åªè¦ movenext è¿å trueï¼è¿­ä»£å¨ä»ç¶ææã ä¸æ¦ movenext è¿å falseï¼å°±ä¸è½åè°ç¨ movenext æ¹æ³ã è¯·æ³¨æï¼å®¢æ·ç«¯æ²¡æä¹å¡ç»§ç»­è°ç¨ movenext ç´å°å®è¿å falseï¼å¹¶ä¸åè®¸è¿­ä»£å¨çä¸»ä½æ°¸è¿ä¿æè¿ååç´ ã\n\nè¿­ä»£å¨çè¾å¥åæ°å­å¨å¨è¿­ä»£å¨ç±»çä¸å¯åå­æ®µä¸­ã ä¸ºäºæ ¹æ®ä¸é¢çç¤ºä¾è¿è¡è¯´æï¼è¿­ä»£å¨ç±»âgenâåå«ä»¥ä¸å­æ®µï¼\n\nvar start: int;\n\n\n1\n\n\näº§éåæ°ä¹å¯¼è´è¿­ä»£å¨çæå class:\n\nvar x: int;\n\n\n1\n\n\nè¿äºå­æ®µç±âmovenextâæ¹æ³è®¾ç½®ã å¦æ movenext è¿å trueï¼åè¿äºå­æ®µä¸­æä¾äºææ°çæ¶ççå¼ï¼å®¢æ·ç«¯å¯ä»¥ä»é£éè¯»åå®ä»¬ã\n\nä¸ºäºå¸®å©ç¼åè§èï¼è¿­ä»£å¨ç±»è¿åå«ä¿çâmovenextâè¿åå¼çåå²è®°å½çå¹½çµæåã è¿äºå¹½çµå­æ®µçåç§°è·å¨ yield åæ°çåç§°ä¹åï¼å¹¶å¨åç§°åé¢éå äºä¸ä¸ªâsâï¼è¡¨ç¤ºå¤æ°ï¼ã åç§°æ£æ¥è§åç¡®ä¿è¿äºåç§°ä¸ä¼å¼èµ·æ­§ä¹ã å æ­¤ï¼ä¸è¿°âgenâçè¿­ä»£å¨ç±»åå«ï¼\n\nghost var xs: seqãintã;\n\n\n1\n\n\nè¿äºåå²å­æ®µç±âmovenextâèªå¨æ´æ¹ï¼ä½ä¸è½ç±ç¨æ·ä»£ç åéã\n\næåï¼è¿­ä»£å¨ç±»åå«ä¸äºç¨äºè§èçç¹æ®å­æ®µã ç¹å«æ¯ï¼è¿­ä»£å¨è§èè®°å½å¨ä»¥ä¸ä¸å¯åå­æ®µä¸­ï¼\n\nghost var _reads: setãobjectã;\nghost var _modifies: setãobjectã;\nghost var _decreases0: t0;\nghost var _decreases1: t1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nå¶ä¸­ï¼è¿­ä»£å¨ç decreases å­å¥çæ¯ä¸ªç»ä»¶é½æä¸ä¸ª _decreases*i*: t*i* å­æ®µã [6](http://leino.science/papers/krml243.html#fn-fn-iterator -field-names) å¦å¤è¿æä¸ä¸ªå­æ®µï¼\n\nghost var _new: setãobjectã;\n\n\n1\n\n\nä»£è¡¨è¿­ä»£å¨ä¸»ä½åéçä»»ä½å¯¹è±¡é½å°æ·»å å°å¶ä¸­ã è¿­ä»£å¨ä¸»ä½å¯ä»¥ä» _new éä¸­å é¤åç´ ï¼ä½ä¸è½éè¿èµå¼ç» _new æ·»å ä»»ä½åç´ ã\n\nè¯·æ³¨æï¼å¨è¿­ä»£å¨çåææ¡ä»¶ä¸­ï¼å³åææé è¿­ä»£å¨ï¼ååæ°ç¡®å®æ¯ååæ°ï¼èä¸æ¯ this çå­æ®µã\n\n\n# 5.5.âå¼æ­¥ä»»å¡ç±»å\n\ndafny ä¸­å¦ä¸ä¸ªå¯è½ä¼ç»åä¸äºæ¼åçå®éªæ§åè½æ¯å¼æ­¥æ¹æ³ã è°ç¨å¼æ­¥æ¹æ³æ¶ï¼å®ä¸ä¼è¿å out-parameters çå¼ï¼èæ¯è¿å *async-task ç±»å * çå®ä¾ã å¨cç±»ä¸­å£°æçå¼æ­¥æ¹æ³ï¼å·æä»¥ä¸ç­¾åï¼\n\nasync method amãtã(in-params) returns (out-params)\n\n\n1\n\n\nä¹äº§çäºä¸ä¸ªå¼æ­¥ä»»å¡ç±»åamãtãï¼å¨å°é­ç±»ä¹å¤ï¼ç±»åçåç§°éè¦éå®c.amãtãï¼ã async-task ç±»åæ¯ä¸ä¸ªå¼ç¨ç±»åï¼å¯ä»¥çè§£ä¸ºä¸ä¸ªæåç§æåçç±»ï¼ä¸é¢ä»ç»å®çç®åçæ¬ã å¼æ­¥æ¹æ³çæ¯ä¸ªç±»åä¸ºxçåæ°xé½ä¼äº§çä¸ä¸ªå¼æ­¥ä»»å¡ç±»åçä¸å¯åå¹½çµå­æ®µï¼\n\nghost var x: x;\n\n\n1\n\n\næ¯ä¸ªyç±»åçè¾åºåæ°yé½ä¼äº§çä¸ä¸ªå­æ®µ\n\nvar y: y;\n\n\n1\n\n\nè¿äºå­æ®µä¼å¨å¼æ­¥æ¹æ³æåç­å¾æ¶èªå¨æ´æ¹ï¼ä½ä¸è½ç±ç¨æ·ä»£ç åéã\n\nasync-task ç±»åè¿æä¸äºç¹æ®å­æ®µï¼ç¨äºè·è¸ªä¾èµå³ç³»ãæªå®æçä»»å¡ãæ°åéçå¯¹è±¡ç­ãéçå¼æ­¥æ¹æ³è®¾è®¡çåå±ï¼è¿äºå­æ®µå°è¢«æ´è¯¦ç»å°æè¿°ã\n\n\n# 6.âå½æ°ç±»å\n\nå½æ°æ¯ dafny ä¸­çä¸ç­å¼ã å½æ°ç±»åå·æ (t) -> u çå½¢å¼ï¼å¶ä¸­ t æ¯ä¸ä¸ªä»¥éå·åéçç±»ååè¡¨ï¼è u æ¯ä¸ä¸ªç±»åã t è¢«ç§°ä¸ºå½æ°ç domain type(s) å¹¶ä¸ u æ¯å®ç range typeã ä¾å¦ï¼å½æ°çç±»å\n\nfunction f(x: int, b: bool): real\n\n\n1\n\n\næ¯(int, bool) -> realã åæ°ä¸åè®¸ä¸ºghostã\n\nä¸ºäºç®åå½æ°åç±ä¸ä¸ªç±»ååè¡¨ç»æçåºæ¬æåµçå¤è§ï¼å¨è¿ç§æåµä¸å¯ä»¥å é¤åç±»åå¨å´çæ¬å·ï¼å¦ t -> uã å¨ä¸ç§ç±»åæ¯åç»ç±»åçæåµä¸ï¼è¿ç§æ å®³çç®åéè¦é¢å¤çè§£éï¼å ä¸ºåç»ç±»åä¹æ¯ç¨æ¬å·æ¬èµ·æ¥çã å¦æå½æ°æ¥åä¸ä¸ªåç»åæ°ï¼åéè¦é¢å¤çä¸ç»æ¬å·ã ä¾å¦ï¼å½æ°\n\nfunction g(pair: (int, bool)): real\n\n\n1\n\n\nç±»åä¸º ((int, bool)) -> realã æ³¨æå¿è¦çåæ¬å·ã ç±»ä¼¼å°ï¼ä¸å¸¦åæ°çå½æ°ä¸å¸¦ 0 åç»ä½ä¸ºåæ°çå½æ°ä¸åã ä¾å¦ï¼å½æ°\n\nfunction noargs(): real\nfunction z(unit: ()): real\n\n\n1\n2\n\n\nåå«æ () -> real å (()) -> real ç±»åã\n\nå½æ°ç®­å¤´ -> æ¯å³ç»åçï¼æä»¥ a -> b -> c è¡¨ç¤º a -> (b -> c)ã å¦ä¸ä¸ªå³èéè¦æ¾å¼æ¬å·ï¼(a -> b) -> cã\n\nè¯·æ³¨æï¼å½åå½æ°çæ¥æ¶å¨åæ°ä¸æ¯ç±»åçä¸é¨åã ç¸åï¼å®å¨æ¥æ¾å½æ°æ¶ä½¿ç¨ï¼ç¶åå¯ä»¥è¢«è®¤ä¸ºæ¯è¢«æè·å°å½æ°å®ä¹ä¸­ã ä¾å¦ï¼åè®¾ä¸é¢çå½æ°âfâå¨ç±»âcâä¸­å£°æï¼èâcâå¼ç¨äºä¸ä¸ªâcâç±»åçå¯¹è±¡ï¼ é£ä¹ï¼ä»¥ä¸æ¯æ­£ç¡®çç±»åï¼\n\nvar f: (int, bool) -> real := c.f;\n\n\n1\n\n\nèåå¦ä¸åå®¹æ¯ä¸æ­£ç¡®çï¼\n\nvar f': (c, int, bool) -> real := f;  // not correct\n\n\n1\n\n\nå¨å¶ç±»åç­¾åä¹å¤ï¼æ¯ä¸ªå½æ°å¼é½å·æä¸ä¸ªå±æ§ï¼å¦ä¸æè¿°ã\n\næ¯ä¸ªå½æ°é½éå«å°å°å ä½ä¸ºåæ°ã ç¶èï¼æ²¡æä»»ä½å½æ°ä¾èµäºæ´ä¸ªå ã å½æ°çä¸ä¸ªå±æ§æ¯å®å¨ç»å®è¾å¥æä¾èµçå ä½ç½®éä¸å£°æçä¸éã è¿è®©éªè¯èå¯ä»¥ç¡®å®æäºå ä¿®æ¹å¯¹æä¸ªå½æ°è¿åçå¼æ²¡æå½±åã å¯¹äºå½æ°f: t -> uåtç±»åçå¼tï¼ä¾èµéè¡¨ç¤ºä¸ºf.reads(t)å¹¶ä¸å·æsetãobjectãç±»åã\n\nå½æ°çç¬¬äºä¸ªå±æ§æºäºæ¯ä¸ªå½æ°é½å¯è½æ¯é¨åçã æ¢å¥è¯è¯´ï¼å½æ°çå±æ§æ¯å®çåææ¡ä»¶ã å¯¹äºå½æ°f: t -> uï¼tç±»åçåæ°å¼tçfçåææ¡ä»¶è¡¨ç¤ºä¸ºf.requires(t)å¹¶ä¸å·æboolç±»åã\n\nå½æ°çç¬¬ä¸ä¸ªå±æ§æ´ä¸ºææ¾ââå½æ°ä½ã å¯¹äºå½æ°âf: t -> uâï¼è¯¥å½æ°å¯¹âtâç±»åçè¾å¥âtâäº§ççå¼è¡¨ç¤ºä¸ºâf(t)âï¼å¹¶ä¸å·æâuâç±»åã\n\nè¯·æ³¨æï¼f.reads å f.requires æ¬èº«å°±æ¯å½æ°ã åè®¾ f çç±»åä¸º t -> uï¼è t çç±»åä¸º tã é£ä¹ï¼f.reads æ¯ t -> setãobjectã ç±»åçå½æ°ï¼å¶ reads å requires å±æ§æ¯ï¼\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires æ¯ t -> bool ç±»åçå½æ°ï¼å¶ reads å requires å±æ§ä¸ºï¼\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0.âlambdaè¡¨è¾¾å¼\n\né¤äºå½åå½æ°ä¹å¤ï¼dafny è¿æ¯æå®ä¹å½æ°çè¡¨è¾¾å¼ã è¿äºè¢«ç§°ä¸º lambda (expression)sï¼ä¸äºè¯­è¨å°å®ä»¬ç§°ä¸º å¿åå½æ°ï¼ã lambda è¡¨è¾¾å¼å·æä»¥ä¸å½¢å¼ï¼\n\n(params) specification => body\n\n\n1\n\n\nå¶ä¸­ *params* æ¯ä»¥éå·åéçåæ°å£°æåè¡¨ï¼æ¯ä¸ªåæ°å£°æçå½¢å¼ä¸º x æ x: tã åæ°çç±»åâtâå¨å¯ä»¥æ¨æ­æ¶å¯ä»¥çç¥ã å¦æä¸éè¦æ è¯ç¬¦xï¼å¯ä»¥ç¨â_âä»£æ¿ã å¦æ *params* åå«ä¸ä¸ªæ²¡ææç¡®ç±»åçåæ° xï¼æ _ï¼ï¼åå¯ä»¥å é¤æ¬å·ï¼ ä¾å¦ï¼è¿åç»å®æ´æ°çåç»§çå½æ°å¯ä»¥åæä»¥ä¸ lambda è¡¨è¾¾å¼ï¼\n\nx => x + 1\n\n\n1\n\n\n*specification* æ¯ requires e æ reads w çå­å¥åè¡¨ï¼å¶ä¸­ e æ¯å¸å°è¡¨è¾¾å¼ï¼ w æ¯æ¡æ¶è¡¨è¾¾å¼ã\n\n*body* æ¯å®ä¹å½æ°è¿åå¼çè¡¨è¾¾å¼ã å¯¹äºæ»¡è¶³åææ¡ä»¶çåæ°çææå¯è½å¼ï¼ä¸»ä½å¿é¡»æ ¼å¼æ­£ç¡®ï¼å°±åå½åå½æ°åæ¹æ³çä¸»ä½ä¸æ ·ï¼ã å¨æäºæåµä¸ï¼è¿æå³çæå¿è¦ç¼åæç¡®ç requires å reads å­å¥ã ä¾å¦ï¼lambda è¡¨è¾¾å¼\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nå¦æçç¥ requires å­å¥ï¼åæ ¼å¼ä¸æ­£ç¡®ï¼å ä¸ºå¯è½ä¼è¢«é¶é¤ã\n\nå¨å½æ°ä¸è½æ¯é¨åçå¹¶ä¸å¯¹è¯»åå æ²¡æéå¶çè®¾ç½®ä¸­ï¼å½æ° f: t -> u ç eta æ©å±ï¼å³ï¼å° f åè£å¨è¿æ ·ç lambda è¡¨è¾¾å¼ä¸­ï¼ lambda è¡¨è¾¾å¼ç­ä»·äº f) çæ¹å¼å°åä½ x => f(x)ã å¨ dafny ä¸­ï¼eta æ©å±è¿å¿é¡»èèå½æ°çåææ¡ä»¶åè¯»åéï¼å æ­¤ f ç eta æ©å±å¦ä¸æç¤ºï¼\n\nx requires f.requires(x) reads f.reads(x) => f(x)\n\n\n1\n\n\n\n# 7.âæ°ç±»å\n\nå¯ä»¥ä½¿ç¨ newtype å£°æ7 å£°ææ°çæ°å­ç±»å\n\nnewtype n = x: m | q\n\n\n1\n\n\nå¶ä¸­âmâæ¯æ°å­ç±»åï¼âqâæ¯å¸å°è¡¨è¾¾å¼ï¼å¯ä»¥å°âxâç¨ä½èªç±åéã å¦æmæ¯ä¸ä¸ªåºäºæ´æ°çæ°å¼ç±»åï¼é£ä¹nä¹æ¯ï¼ å¦æâmâæ¯å®æ°ï¼é£ä¹ânâä¹æ¯å¦æ­¤ã å¦æå¯ä»¥ä» q æ¨æ­åºç±»å mï¼åå¯ä»¥çç¥â:mâã å¦æ q åªæ¯ trueï¼é£ä¹å£°æå¯ä»¥ç®åå°ç»åºï¼\n\nnewtype n = m\n\n\n1\n\n\nç±»åâmâè¢«ç§°ä¸ºânâçåºæ¬ç±»åã\n\nnewtype æ¯ä¸ç§æ°å­ç±»åï¼å®æ¯æä¸å¶åºæ¬ç±»åç¸åçæä½ã newtype ä¸å¶ä»æ°å­ç±»åä¸åä¸ä¸å¼å®¹ï¼ ç¹å«æ¯ï¼å¦ææ²¡ææ¾å¼è½¬æ¢ï¼å®å°±ä¸è½åéç»å®çåºæ¬ç±»åã å¯¹ newtype çæä½ä¸å¶åºç±»åçæä½ä¹é´çä¸ä¸ªéè¦åºå«æ¯ newtype æä½ä»å¨ç»ææ»¡è¶³è°è¯ q æ¶æè¢«å®ä¹ï¼å¯¹äº newtype çå­é¢éä¹æ¯å¦æ­¤ã [8](http:// /leino.science/papers/krml243.html#fn-fn-newtype-design-questionï¼\n\nä¾å¦ï¼åè®¾ lo å hi æ¯åºäºæ´æ°çæ°å­ï¼å®ä»¬æ»¡è¶³ 0 <= lo <= hi å¹¶èèä»¥ä¸ä»£ç çæ®µï¼\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nå¦æ lo å hi çç±»åä¸º intï¼é£ä¹ä»£ç çæ®µæ¯åæ³çï¼ ç¹å«æ¯ï¼å®æ°¸è¿ä¸ä¼æº¢åºï¼å ä¸º int æ²¡æä¸éã ç¸åï¼å¦æ lo å hi æ¯æ°ç±»å int32 çåéï¼å£°æå¦ä¸ï¼\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\né£ä¹ä»£ç çæ®µæ¯éè¯¯çï¼å ä¸ºå æ³çç»æå¯è½æ æ³æ»¡è¶³int32å®ä¹ä¸­çè°è¯ã ä»£ç çæ®µå¯ä»¥éåä¸º\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nå¨è¿ç§æåµä¸ï¼int å int32 é½æ¯åæ³çã\n\nç±äº newtype ä¸å¶åºç±»åä¸å¼å®¹ï¼å¹¶ä¸ç±äº newtype æä½çææç»æé½æ¯ newtype çæåï¼å æ­¤ dafny çç¼è¯å¨å¯ä»¥èªç±å°ä¸é¨å newtype çè¿è¡æ¶è¡¨ç¤ºã ä¾å¦ï¼éè¿ä»ç»æ£æ¥ä¸é¢ int32 çå®ä¹ï¼ç¼è¯å¨å¯è½ä¼å³å®å¨ç®æ ç¡¬ä»¶ä¸­ä½¿ç¨å¸¦ç¬¦å·ç 32 ä½æ´æ°æ¥å­å¨ int32 å¼ã\n\nè¯·æ³¨æï¼q ä¸­çç»å®åéx çç±»åä¸ºmï¼èä¸æ¯nã nå æ­¤ï¼å¯è½æ æ³å°±ânâå¼è¯´æâqâã ä¾å¦ï¼èèä»¥ä¸ç±»åç 8 ä½ 2 çè¡¥ç æ´æ°ï¼\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nå¹¶èèä¸ä¸ªç±»åä¸ºint8çåécã è¡¨è¾¾å¼\n\n-128 <= c < 128\n\n\n1\n\n\nå®ä¹ä¸æç¡®ï¼å ä¸ºæ¯è¾è¦æ±æ¯ä¸ªæä½æ°çç±»åä¸ºâint8âï¼è¿æå³çæå­â128âè¢«æ£æ¥ä¸ºâint8âç±»åï¼ä½äºå®å¹¶éå¦æ­¤ã ç¼åæ­¤è¡¨è¾¾å¼çæ­£ç¡®æ¹æ³æ¯å¨ c ä¸ä½¿ç¨è½¬æ¢æä½ï¼å¦ä¸æè¿°ï¼å°å¶è½¬æ¢ä¸ºåºæ¬ç±»åï¼\n\n-128 <= int(c) < 128\n\n\n1\n\n\næä¸ä¸ªéå¶ï¼å³å¼0å¿é¡»æ¯æ¯ä¸ªæ°ç±»åçä¸é¨åã9\n\n\n# 7.0.âæ°å­è½¬æ¢æä½\n\nå¯¹äºæ¯ä¸ªæ°å­ç±»ånï¼é½æä¸ä¸ªååçè½¬æ¢å½æ°ã å®æ¯ä¸ä¸ªé¨åæç­å½æ°ã å®æ¯å¨ç»å®å¼ï¼å¯ä»¥æ¯ä»»ä½æ°å­ç±»åï¼æ¯è½¬æ¢ä¸ºçç±»åçæåæ¶å®ä¹çã å½ä»åºäºå®æ°çæ°å¼ç±»åè½¬æ¢ä¸ºåºäºæ´æ°çæ°å¼ç±»åæ¶ï¼è¯¥æä½è¦æ±åºäºå®æ°çåæ°æ²¡æå°æ°é¨åã ï¼è¦å°åºäºå®æ°çæ°å¼åä¸èå¥å°ææ¥è¿çæ´æ°ï¼è¯·ä½¿ç¨ .trunc æåï¼è¯·åéç¬¬ [0.1] èï¼http://leino.science/papers/krml243.html#sec-numeric-typesï¼ã )\n\nä½¿ç¨ä¸é¢çä¾å­æ¥è¯´æï¼å¦æ lo å hi çç±»åæ¯ int32ï¼é£ä¹ä»£ç çæ®µå¯ä»¥åæ³å°åæå¦ä¸\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nå¶ä¸­midçç±»åè¢«æ¨æ­ä¸ºintã ç±äºé¤æ³çç»æå¼æ¯ int32 ç±»åçæåï¼å æ­¤å¯ä»¥å¼å¥å¦ä¸ç§è½¬æ¢æä½ï¼ä½¿ mid çç±»åä¸º int32ï¼\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nå¦æç¼è¯å¨ç¡®å®ä¸é¨éå¯¹int32çè¿è¡æ¶è¡¨ç¤ºï¼é£ä¹è¿äºè¯­å¥çä»£ä»·æ¯ä¸¤ä¸ªæä¸ä¸ªè¿è¡æ¶è½¬æ¢ã\n\n\n# 8.âå­éç±»å\n\nå­éç±»åæ¯å¯¹ç°æç±»åçéå¶ä½¿ç¨ï¼ç§°ä¸ºå­éç±»åçåºæ¬ç±»åã å­éç±»åå°±ååºç±»åååºç±»åä¸çè°è¯çç»åä½¿ç¨ã\n\nå§ç»åè®¸ä»å­éç±»åå°å¶åºæ¬ç±»åçèµå¼ã å¦æåéçå¼ç¡®å®æ»¡è¶³å­éç±»åçè°è¯ï¼ååè®¸ä»åºæ¬ç±»åå°å­éç±»åçå¦ä¸ä¸ªæ¹åçåéã ï¼æ³¨æï¼ç¸æ¯ä¹ä¸ï¼newtype åå®çåºç±»åä¹é´çèµå¼æ¯ä¸åè®¸çï¼å³ä½¿èµå¼æ¯ç®æ ç±»åçå¼ãå¯¹äºè¿æ ·çèµå¼ï¼å¿é¡»ä½¿ç¨æ¾å¼è½¬æ¢ï¼åè§ç¬¬ [7.0]ï¼http: //leino.science/papers/krml243.html#sec-numeric-conversions)ã) dafny æ¯æä¸ç§å­éç±»åï¼å³åç½®ç±»å natï¼å¶åºæ¬ç±»åä¸º intã[10](http: //leino.science/papers/krml243.html#fn-fn-more-subset-typesï¼\n\nç±»ånatæå®intçéè´å­èå´ã ä¸ä¸ªå¾å¥½å°ä½¿ç¨å­éç±»åânatâçç®åç¤ºä¾æ¯æ åææ³¢é£å¥å½æ°ï¼\n\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\næ­¤å½æ°çç­æä½ç¬¨æçå¬å¼ï¼ä»¥è°ç¨ç«ç¹äº§ççä»»ä½éè¯¯æ¶æ¯çæªè¾ä¸ºæ¨¡ï¼å°ä½¿ç¨ç±»åintå¹¶å¨åç½®æ¡ä»¶ååç½®æ¡ä»¶ä¸­ç¼åéå¶è°è¯ï¼\n\nfunction fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nç±»åæ¨æ­æ°¸è¿ä¸ä¼å°åéçç±»åæ¨æ­ä¸ºå­éç±»åã ç¸åï¼å®ä¼å°ç±»åæ¨æ­ä¸ºå­éç±»åçåºæ¬ç±»åã ä¾å¦ï¼x çç±»å\n\nforall x :: p(x)\n\n\n1\n\n\nå°æ¯ intï¼å³ä½¿è°è¯ p å£°æå¶åæ°çç±»åä¸º natã\n\n# åèèµæ\n\nç±äº nadia polikarpova å paqui lucio çè¯è®ºï¼æ¬ææ¡£å¾å°äºæ¹è¿ã\n\n----------------------------------------\n\n 0.  æ¯æå¹³ç­åªæ¯äººä»¬å¯ä»¥æ³è±¡çä¸°å¯ç±»åç³»ç»ä¸­çç±»åæ¥æçä¼å¤æ¨¡å¼ä¹ä¸ã ä¾å¦ï¼å¶ä»æ¨¡å¼å¯è½åæ¬å·ææ»è®¢åãå¯é¶åå§åä»¥åå¯è½æ äººå±ä½ã å¦æ dafny å°æ¥æ¯ææ´å¤æ¨¡å¼ï¼â( )âåç¼è¯­æ³å¯è½ä¼è¢«æ©å±ã ç®åï¼åç¼åªè½è¡¨ç¤ºæ¯æå¹³ç­çæ¨¡å¼ã â©\n 1.  ç°å¨dafnyæ¯æåç½®åç»ï¼æç®æåºååçæä½æ¹æè¿å ä¸æ¯å­åºåçåºåï¼èæ¯å­åºåçåç»ã â©\n 2.  è¿å¯è½ä¼å¨æªæ¥åçååï¼ä¸åè®¸å¤æ¬¡åºç°ç¸åçé®ã â©\n 3.  è¿å¨æªæ¥å¯è½ä¼æ¹åå¦ä¸ï¼inå!in å°å¾å°ä¸åæ¯ææä½ã ç¸åï¼å¯¹äºä»»ä½å°å¾ mï¼m.domain å°è¿åå¶åä½ä¸ºä¸ä¸ªéåï¼è m.range å°è¿åï¼ä¹ä½ä¸ºä¸ä¸ªéåï¼å¨å¶åä¸ç m çå¾åã â©\n 4.  è¿å°å¨ dafny çæªæ¥çæ¬ä¸­åçååï¼å®å°åæ¶æ¯æå¯ç©ºåï¼é»è®¤æåµä¸ï¼é -null å¼ç¨ç±»åã â©\n 5.  å¾å¿«ï¼object å°æä¸ºä¸ä¸ªåç½®ç trait èä¸æ¯åç½®çç¹æ® ç­çº§ã åçè¿ç§æåµæ¶ï¼å°ä¸åå¯è½æ§è¡âæ°å¯¹è±¡âã object ä¸è½ç¨ä½ç±»ååæ°çå½åç¼è¯å¨éå¶ä¹å°æ¶å¤±ã â©\n 6.  å°ç¹æ®å­æ®µ_readså_modifieséå½åä¸ºç¸åæ¯ææä¹ç åç§°ä½ä¸ºç¸åºçå³é®å­ï¼âè¯»åâåâä¿®æ¹âï¼å°±åå¯¹å½æ°å¼æåçé£æ ·ã æ­¤å¤ï¼åç§ _decreases*i* å­æ®µå¯ä»¥ç»åæä¸ä¸ªåä¸º decreases çå­æ®µï¼å¶ç±»åæ¯ n åç»ã â©\n 7.  æ¯å¦åºè¯¥å°newtypeéå½åä¸ºnumtypeï¼ â©\n 8.  èªå¨å®ä¹âè°è¯nâæç¨åï¼(m:m){q} `? â©\n 9.  éå¶æ¯ç±äºå½åç¼è¯å¨çéå¶ã è¿å°å¨æªæ¥åçååï¼ä¹å°ä¸ºå­éç±»ååéç©ºå¼ç¨ç±»åå¼è¾å¯è½æ§ã â©\n 10. dafny çæªæ¥çæ¬å°æ¯æç¨æ·å®ä¹çå­éç±»åã â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"Style Guide for Dafny programs",frontmatter:{title:"Style Guide for Dafny programs",date:"2022-03-26T17:01:15.000Z",permalink:"/pages/0f17ab/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:"111 -",readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/05.Style%20Guide%20for%20Dafny%20programs.html",relativePath:"40.èµæº/10.å¸¸ç¨å·¥å·/05.Style Guide for Dafny programs.md",key:"v-03378743",path:"/pages/0f17ab/",headers:[{level:2,title:"å½åçº¦å®",slug:"å½åçº¦å®",normalizedTitle:"å½åçº¦å®",charIndex:50},{level:2,title:"åç¼æ¹æ³",slug:"åç¼æ¹æ³",normalizedTitle:"åç¼æ¹æ³",charIndex:582},{level:3,title:"ä»£ç å¸å±",slug:"ä»£ç å¸å±",normalizedTitle:"ä»£ç å¸å±",charIndex:68},{level:3,title:"Braces",slug:"braces",normalizedTitle:"braces",charIndex:78},{level:3,title:"Imports",slug:"imports",normalizedTitle:"imports",charIndex:90},{level:2,title:"ç¼©è¿åæ¢è¡",slug:"ç¼©è¿åæ¢è¡",normalizedTitle:"ç¼©è¿åæ¢è¡",charIndex:101},{level:3,title:"å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼?",slug:"å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼",normalizedTitle:"å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼?",charIndex:2136},{level:3,title:"æå¤§å­ç¬¦éå¶",slug:"æå¤§å­ç¬¦éå¶",normalizedTitle:"æå¤§å­ç¬¦éå¶",charIndex:126},{level:3,title:"æ¢è¡ç¬¦",slug:"æ¢è¡ç¬¦",normalizedTitle:"æ¢è¡ç¬¦",charIndex:138},{level:3,title:"å½æ°ãæ¹æ³ãè°è¯åå¼ç",slug:"å½æ°ãæ¹æ³ãè°è¯åå¼ç",normalizedTitle:"å½æ°ãæ¹æ³ãè°è¯åå¼ç",charIndex:147},{level:2,title:"éè¦é¿åçäºæ",slug:"éè¦é¿åçäºæ",normalizedTitle:"éè¦é¿åçäºæ",charIndex:162},{level:3,title:"æ¬å·",slug:"æ¬å·",normalizedTitle:"æ¬å·",charIndex:175},{level:3,title:"ç©ºæ ¼",slug:"ç©ºæ ¼",normalizedTitle:"ç©ºæ ¼",charIndex:117},{level:4,title:"ç±»åå£°æ",slug:"ç±»åå£°æ",normalizedTitle:"ç±»åå£°æ",charIndex:193},{level:4,title:"å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ",slug:"å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ",normalizedTitle:"å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ",charIndex:205},{level:2,title:"å»ºè®®",slug:"å»ºè®®",normalizedTitle:"å»ºè®®",charIndex:222},{level:3,title:"Externs",slug:"externs",normalizedTitle:"externs",charIndex:230},{level:3,title:"éè¦èèçäºé¡¹",slug:"éè¦èèçäºé¡¹",normalizedTitle:"éè¦èèçäºé¡¹",charIndex:243}],headersStr:"å½åçº¦å® åç¼æ¹æ³ ä»£ç å¸å± Braces Imports ç¼©è¿åæ¢è¡ å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼? æå¤§å­ç¬¦éå¶ æ¢è¡ç¬¦ å½æ°ãæ¹æ³ãè°è¯åå¼ç éè¦é¿åçäºæ æ¬å· ç©ºæ ¼ ç±»åå£°æ å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ å»ºè®® Externs éè¦èèçäºé¡¹",content:'# Style Guide for Dafny Programmers\n\nDafny ææ¡£\n\n * å½åçº¦å®\n   * æ¹æ³åç¼\n * ä»£ç å¸å±\n   * Braces\n   * Imports\n * ç¼©è¿åæ¢è¡\n   * å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼ï¼\n   * æå¤§å­ç¬¦éå¶\n   * æ¢è¡ç¬¦\n   * å½æ°ãæ¹æ³ãè°è¯åå¼ç\n * éè¦é¿åçäºæ\n   * æ¬å·\n   * ç©ºæ ¼\n     * ç±»åå£°æ\n     * å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ\n * å»ºè®®\n   * Externs\n   * éè¦èèçäºé¡¹\n\næ¬æ ·å¼æåæä¾äº Dafny ä»£ç çç¼ç çº¦å®ã\n\næ­¤ææ¡£ä»å¨è¿è¡ä¸­ã è¯·éæ¶æ·»å æ´å¤å»ºè®®ã\n\n\n# å½åçº¦å®\n\nä»»ä½åéé½ä»¥camelCaseå½åã\n\nvar minValue := 1;\nvar cipherMessage := "Hello World";\n\n\n1\n2\n\n\nä»»ä½å¼çãè°è¯ãå½æ°ãæ¹æ³ãç±»ãæ¨¡åãæ°æ®ç±»ååæ°ç±»åé½ä»¥PascalCaseå½åã\n\nmethod FindIndex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nä»»ä½éææå¨å± å¸¸é é½ä»¥ UPPERCASE_WITH_UNDERSCORES å½åã\n\nstatic const MONTHS_IN_A_YEAR := 12\n\n\n1\n\n\n\n# åç¼æ¹æ³\n\nå½åéææ¹æ³ä½äºç±»/æ¨¡åä¸­æ¶ï¼é¿åä½¿ç¨åä½åç§°ã\n\nclass Integer {\n\n    // The following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to ToString()\n    // so that the method call is Integer.ToString(i)\n    // instead of Integer.IntegerToString(i).\n\n    // YES\n    method ToString(i: int) returns (s: string)\n        ...\n\n    // NO\n    method IntegerToString(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ä»£ç å¸å±\n\n\n# Braces\n\né»è®¤æåµä¸ï¼å·¦å¤§æ¬å·å¨åä¸è¡ã\n\nmodule M {\n    ...\n    method Met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nå¦ææ¹æ³ï¼æå½æ°ãå¼çç­ï¼ç­¾åå¤ªé¿èä¸è½æ¾å¨ä¸è¡ä¸­ï¼æèå¦æç­¾åè³å°æä¸ä¸ªè§èå­å¥ï¼åå·¦å¤§æ¬å·å°æ¢è¡ã\n\nmodule M {\n    ...\n    method Met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿éç¨äºæ¯ä¸ªèå´ï¼moduleãclassãpredicateãifãwhile ç­ç­ã\n\n\n# Imports\n\né»è®¤æåµä¸ï¼å¯¼å¥æ¨¡åèä¸æå¼å®ä»¬ã\n\nimport Coffee\n...\n\n\n1\n2\n\n\nä½æ¯ï¼å¦ææä¸ªæ¨¡åçæäºæåéå¸¸é¢ç¹å°ä½¿ç¨ï¼è¯·ä½¿ç¨ opened å¯¼å¥å®ï¼\n\nimport opened Donut\n...\n\n\n1\n2\n\n\nå½ä¸ä¸ªæä»¶ä½¿ç¨ä¸¤ä¸ªæ¨¡åå¹¶ä¸å®ä»¬é½å®ä¹ååçæ¹æ³æ¶ï¼ä¸è¦å°å®ä»¬å¯¼å¥ openedã\n\nimport MyModule\nimport YourModule\n...\nmethod MyMethod() {\n    MyModule.foo();\n    YourModule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è¿ç§æåµä¸ï¼å¦æè¦ç¼©ç­æ¨¡ååç§°ï¼è¯·ä½¿ç¨ç®ååç§°å¯¼å¥ã\n\nimport M = MyModuleWithACumbersomeName\nimport Y = YourModuleWithACumbersomeName\n...\nmethod MyMethod() {\n    M.foo();\n    Y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¸¸è§çå¯¼å¥ï¼ä¾å¦ StandardLibrary å Nativeï¼åºè¯¥ç»åå¨ä¸èµ·ï¼ç¶åæ¯èªå®ä¹æ¨¡åå¯¼å¥ï¼ä¸­é´æä¸ä¸ªç©ºè¡ã\n\nimport opened StandardLibrary\nimport opened Native\n\nimport opened Donut\nimport Coffee\n\n\n1\n2\n3\n4\n5\n\n\nè½ç¶ä¸æ¯å¿éçï¼ä½å»ºè®®ä¿æ imports å includes çå­æ¯é¡ºåºï¼é¤éå°å®ä»¬æé»è¾åç»æ´ææä¹ã\n\n\n# ç¼©è¿åæ¢è¡\n\n\n# å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼?\n\nç©ºæ ¼ä¼äºå¶è¡¨ç¬¦ã éé¡¹å¡åªè½ç¨äºä¸åå«éé¡¹å¡çç°æä»£ç ä¿æä¸è´ã\n\næ¯ä¸ªç¼©è¿ä½¿ç¨ 2 ä¸ªç©ºæ ¼ã\n\n\n# æå¤§å­ç¬¦éå¶\n\nè½ç¶æ²¡æç¹å«çä¸¥æ ¼è¦æ±ï¼ä½ä¸è¬å»ºè®®æ¯è¡æå¤ 120 ä¸ªå­ç¬¦ã\n\n\n# æ¢è¡ç¬¦\n\nå¨è¿ç»­çå½æ°ãæ¹æ³ãè°è¯åå¼çä¹é´ä½¿ç¨æ¢è¡ç¬¦ï¼æé«ä»£ç å¯è¯»æ§ã\n\nä»¥æ¢è¡ç¬¦ç»ææ¯ä¸ªæä»¶ã\n\n\n# å½æ°ãæ¹æ³ãè°è¯åå¼ç\n\næ¯ä¸ª Dafny æ¹æ³é½æä»¥ä¸ç­¾åã\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type) returns (ret: Type)\n    requires P()\n    modifies param2\n    ensures Q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nå¦æå¯è½ï¼å° MethodName å returns è¯­å¥æ¾å¨åä¸è¡ï¼å ä¸ºå³é®å­ returns ä¸å¶ä»æ¹æ³è§èå­å¥ä¸åï¼ä¾å¦ requiresãmodifiesãensures å decreases ï¼åºè¯¥æè¿ä¸ªé¡ºåºåºç°ã æ¯ä¸ªæ¹æ³è§èå­å¥åºè¯¥å¨åç¬çè¡ä¸ï¼ç¼©è¿ã\n\nå¦æ Method ç­¾åå¤ªé¿ï¼æä»¬å¯ä»¥å°å¶åè§£ã\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type,\n        param3: Type, param4: Type, param5: Type)\n    returns (ret1: Type, ret2: Type, ret3: Type, ret4: Type,\n        ret5: Type)\n    requires P1()\n    requires P2()\n    requires P3()\n    modifies param2\n    modifies param3\n    ensures Q1()\n    ensures Q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå¤ä¸ª requires æ ensures å¯ä»¥åå¹¶ä¸ºä¸ä¸ªï¼\n\nrequires\n    && P1()\n    && P2()\n    && P3()\n\n\n1\n2\n3\n4\n\n\nç¸åçè§åéç¨äº functionãpredicate å lemma å®ä¹ã\n\n\n# éè¦é¿åçäºæ\n\n\n# æ¬å·\n\nå¨è®¸å¤æåµä¸ï¼Dafny ä¸éè¦å¨è¡¨è¾¾å¼å¨å´å ä¸æ¬å·ã è¿éæäºä¾å­ã\n\n * If-Else-While è¯­å¥\n\n// YES\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// NO\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * å¸¦æè¡¨è¾¾å¼åæ°çè¯­å¥\n\n// YES\nassert x < 100;\nprint x;\n\n// NO\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * ç®åçå¸å°/ç®æ¯è¡¨è¾¾å¼\n\n// YES\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// NO\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ç©ºæ ¼\n\né¿åè¡¨è¾¾å¼ä¸­ä¸å¿è¦çç©ºæ ¼ã\n\n# ç±»åå£°æ\n\nç±»åå£°æåºè¯¥å·ævariableName: variableTypeçå½¢å¼ã\n\n// YES\nconst one: int := 1\nclass {:extern} Util {\n    var {:extern} Exception: System.String\n}\n\n// NO\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} Util {\n    var {:extern} Exception : System.String // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¦æ Dafny å¯ä»¥æ¨æ­åºè¯¥ç±»åï¼è¯·å°å¶çç¥ï¼é¤éæ¨è®¤ä¸ºå®å¨ç¨åºä¸­æä¾äºæç¨çææ¡£ã æä»¥ï¼ä¸é¢çå¸¸é one æå¥½å£°æä¸º\n\nconst one := 1\n\n\n1\n\n\n# å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ\n\nfunctionãmethodãpredicate å lemma å®ä¹åºè¯¥å·æ FunctionName(parameterName: parameterType, ...) çå½¢å¼ã\n\n// YES\nfunction method Foo<int>(i: int): int\n\n// NO\nfunction method Foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\nAvoid too little or too much whitespace that reduces the overall readability.\n\n// YES\nlemma MyLemma<A, B>(x: seq<seq<A>>, y: B) {\n    ...\n}\n\n// NO\nlemma MyLemma <A,B> ( x : seq<seq<A>> , y :B){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# å»ºè®®\n\næ¬èæè¿°äºä¸äºå»ºè®®ï¼è¿äºå»ºè®®å¯ä»¥å¸®å©ä½¿ä»£ç æ´å·å¯è¯»æ§åæäºéµå¾ªï¼å°½ç®¡æ²¡æä¸¥æ ¼æ§è¡ã\n\n\n# Externs\n\nå°½å¯è½å¨ Dafny åç®æ è¯­è¨ï¼ä¾å¦ C#ãJava ç­ï¼ä¸­å°å®ä»¬å½åä¸ºç¸åçåç§°ï¼è¿æ ·å¨ Dafny ä¸­æä»¬åªéç¼å {:extern}ï¼èä¸æ¯ {:extern "<name>"}ã\n\n\n# éè¦èèçäºé¡¹\n\nå¨ Dafny ä¸­è®¾è®¡/å®æ½ç¨åºä¹åæèè¿äºé®é¢ã\n\n * è¿ä¸ªåéå/å½æ°åXæ¯ä¸ªå¥½åå­åï¼\n * è¿ä¸ªæ¹æ³Må¨æ¨¡åXä¸­ææä¹åï¼ å®ä¸åºè¯¥å¨æ¨¡å Y ä¸­åï¼\n * å®ä¹Xæ¯å¦å±äºæä»¶Y.dfyï¼\n * X.dfy æ¯ä¸ä¸ªå¥½çæä»¶ååï¼',normalizedContent:'# style guide for dafny programmers\n\ndafny ææ¡£\n\n * å½åçº¦å®\n   * æ¹æ³åç¼\n * ä»£ç å¸å±\n   * braces\n   * imports\n * ç¼©è¿åæ¢è¡\n   * å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼ï¼\n   * æå¤§å­ç¬¦éå¶\n   * æ¢è¡ç¬¦\n   * å½æ°ãæ¹æ³ãè°è¯åå¼ç\n * éè¦é¿åçäºæ\n   * æ¬å·\n   * ç©ºæ ¼\n     * ç±»åå£°æ\n     * å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ\n * å»ºè®®\n   * externs\n   * éè¦èèçäºé¡¹\n\næ¬æ ·å¼æåæä¾äº dafny ä»£ç çç¼ç çº¦å®ã\n\næ­¤ææ¡£ä»å¨è¿è¡ä¸­ã è¯·éæ¶æ·»å æ´å¤å»ºè®®ã\n\n\n# å½åçº¦å®\n\nä»»ä½åéé½ä»¥camelcaseå½åã\n\nvar minvalue := 1;\nvar ciphermessage := "hello world";\n\n\n1\n2\n\n\nä»»ä½å¼çãè°è¯ãå½æ°ãæ¹æ³ãç±»ãæ¨¡åãæ°æ®ç±»ååæ°ç±»åé½ä»¥pascalcaseå½åã\n\nmethod findindex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nä»»ä½éææå¨å± å¸¸é é½ä»¥ uppercase_with_underscores å½åã\n\nstatic const months_in_a_year := 12\n\n\n1\n\n\n\n# åç¼æ¹æ³\n\nå½åéææ¹æ³ä½äºç±»/æ¨¡åä¸­æ¶ï¼é¿åä½¿ç¨åä½åç§°ã\n\nclass integer {\n\n    // the following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to tostring()\n    // so that the method call is integer.tostring(i)\n    // instead of integer.integertostring(i).\n\n    // yes\n    method tostring(i: int) returns (s: string)\n        ...\n\n    // no\n    method integertostring(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# ä»£ç å¸å±\n\n\n# braces\n\né»è®¤æåµä¸ï¼å·¦å¤§æ¬å·å¨åä¸è¡ã\n\nmodule m {\n    ...\n    method met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nå¦ææ¹æ³ï¼æå½æ°ãå¼çç­ï¼ç­¾åå¤ªé¿èä¸è½æ¾å¨ä¸è¡ä¸­ï¼æèå¦æç­¾åè³å°æä¸ä¸ªè§èå­å¥ï¼åå·¦å¤§æ¬å·å°æ¢è¡ã\n\nmodule m {\n    ...\n    method met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nè¿éç¨äºæ¯ä¸ªèå´ï¼moduleãclassãpredicateãifãwhile ç­ç­ã\n\n\n# imports\n\né»è®¤æåµä¸ï¼å¯¼å¥æ¨¡åèä¸æå¼å®ä»¬ã\n\nimport coffee\n...\n\n\n1\n2\n\n\nä½æ¯ï¼å¦ææä¸ªæ¨¡åçæäºæåéå¸¸é¢ç¹å°ä½¿ç¨ï¼è¯·ä½¿ç¨ opened å¯¼å¥å®ï¼\n\nimport opened donut\n...\n\n\n1\n2\n\n\nå½ä¸ä¸ªæä»¶ä½¿ç¨ä¸¤ä¸ªæ¨¡åå¹¶ä¸å®ä»¬é½å®ä¹ååçæ¹æ³æ¶ï¼ä¸è¦å°å®ä»¬å¯¼å¥ openedã\n\nimport mymodule\nimport yourmodule\n...\nmethod mymethod() {\n    mymodule.foo();\n    yourmodule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¨è¿ç§æåµä¸ï¼å¦æè¦ç¼©ç­æ¨¡ååç§°ï¼è¯·ä½¿ç¨ç®ååç§°å¯¼å¥ã\n\nimport m = mymodulewithacumbersomename\nimport y = yourmodulewithacumbersomename\n...\nmethod mymethod() {\n    m.foo();\n    y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nå¸¸è§çå¯¼å¥ï¼ä¾å¦ standardlibrary å nativeï¼åºè¯¥ç»åå¨ä¸èµ·ï¼ç¶åæ¯èªå®ä¹æ¨¡åå¯¼å¥ï¼ä¸­é´æä¸ä¸ªç©ºè¡ã\n\nimport opened standardlibrary\nimport opened native\n\nimport opened donut\nimport coffee\n\n\n1\n2\n3\n4\n5\n\n\nè½ç¶ä¸æ¯å¿éçï¼ä½å»ºè®®ä¿æ imports å includes çå­æ¯é¡ºåºï¼é¤éå°å®ä»¬æé»è¾åç»æ´ææä¹ã\n\n\n# ç¼©è¿åæ¢è¡\n\n\n# å¶è¡¨ç¬¦è¿æ¯ç©ºæ ¼?\n\nç©ºæ ¼ä¼äºå¶è¡¨ç¬¦ã éé¡¹å¡åªè½ç¨äºä¸åå«éé¡¹å¡çç°æä»£ç ä¿æä¸è´ã\n\næ¯ä¸ªç¼©è¿ä½¿ç¨ 2 ä¸ªç©ºæ ¼ã\n\n\n# æå¤§å­ç¬¦éå¶\n\nè½ç¶æ²¡æç¹å«çä¸¥æ ¼è¦æ±ï¼ä½ä¸è¬å»ºè®®æ¯è¡æå¤ 120 ä¸ªå­ç¬¦ã\n\n\n# æ¢è¡ç¬¦\n\nå¨è¿ç»­çå½æ°ãæ¹æ³ãè°è¯åå¼çä¹é´ä½¿ç¨æ¢è¡ç¬¦ï¼æé«ä»£ç å¯è¯»æ§ã\n\nä»¥æ¢è¡ç¬¦ç»ææ¯ä¸ªæä»¶ã\n\n\n# å½æ°ãæ¹æ³ãè°è¯åå¼ç\n\næ¯ä¸ª dafny æ¹æ³é½æä»¥ä¸ç­¾åã\n\nmethod {:<attributes>} methodname(param1: type, param2: type) returns (ret: type)\n    requires p()\n    modifies param2\n    ensures q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nå¦æå¯è½ï¼å° methodname å returns è¯­å¥æ¾å¨åä¸è¡ï¼å ä¸ºå³é®å­ returns ä¸å¶ä»æ¹æ³è§èå­å¥ä¸åï¼ä¾å¦ requiresãmodifiesãensures å decreases ï¼åºè¯¥æè¿ä¸ªé¡ºåºåºç°ã æ¯ä¸ªæ¹æ³è§èå­å¥åºè¯¥å¨åç¬çè¡ä¸ï¼ç¼©è¿ã\n\nå¦æ method ç­¾åå¤ªé¿ï¼æä»¬å¯ä»¥å°å¶åè§£ã\n\nmethod {:<attributes>} methodname(param1: type, param2: type,\n        param3: type, param4: type, param5: type)\n    returns (ret1: type, ret2: type, ret3: type, ret4: type,\n        ret5: type)\n    requires p1()\n    requires p2()\n    requires p3()\n    modifies param2\n    modifies param3\n    ensures q1()\n    ensures q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nå¤ä¸ª requires æ ensures å¯ä»¥åå¹¶ä¸ºä¸ä¸ªï¼\n\nrequires\n    && p1()\n    && p2()\n    && p3()\n\n\n1\n2\n3\n4\n\n\nç¸åçè§åéç¨äº functionãpredicate å lemma å®ä¹ã\n\n\n# éè¦é¿åçäºæ\n\n\n# æ¬å·\n\nå¨è®¸å¤æåµä¸ï¼dafny ä¸éè¦å¨è¡¨è¾¾å¼å¨å´å ä¸æ¬å·ã è¿éæäºä¾å­ã\n\n * if-else-while è¯­å¥\n\n// yes\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// no\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * å¸¦æè¡¨è¾¾å¼åæ°çè¯­å¥\n\n// yes\nassert x < 100;\nprint x;\n\n// no\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * ç®åçå¸å°/ç®æ¯è¡¨è¾¾å¼\n\n// yes\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// no\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# ç©ºæ ¼\n\né¿åè¡¨è¾¾å¼ä¸­ä¸å¿è¦çç©ºæ ¼ã\n\n# ç±»åå£°æ\n\nç±»åå£°æåºè¯¥å·ævariablename: variabletypeçå½¢å¼ã\n\n// yes\nconst one: int := 1\nclass {:extern} util {\n    var {:extern} exception: system.string\n}\n\n// no\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} util {\n    var {:extern} exception : system.string // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nå¦æ dafny å¯ä»¥æ¨æ­åºè¯¥ç±»åï¼è¯·å°å¶çç¥ï¼é¤éæ¨è®¤ä¸ºå®å¨ç¨åºä¸­æä¾äºæç¨çææ¡£ã æä»¥ï¼ä¸é¢çå¸¸é one æå¥½å£°æä¸º\n\nconst one := 1\n\n\n1\n\n\n# å½æ°ãæ¹æ³ãè°è¯åå¼çå£°æ\n\nfunctionãmethodãpredicate å lemma å®ä¹åºè¯¥å·æ functionname(parametername: parametertype, ...) çå½¢å¼ã\n\n// yes\nfunction method foo<int>(i: int): int\n\n// no\nfunction method foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\navoid too little or too much whitespace that reduces the overall readability.\n\n// yes\nlemma mylemma<a, b>(x: seq<seq<a>>, y: b) {\n    ...\n}\n\n// no\nlemma mylemma <a,b> ( x : seq<seq<a>> , y :b){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# å»ºè®®\n\næ¬èæè¿°äºä¸äºå»ºè®®ï¼è¿äºå»ºè®®å¯ä»¥å¸®å©ä½¿ä»£ç æ´å·å¯è¯»æ§åæäºéµå¾ªï¼å°½ç®¡æ²¡æä¸¥æ ¼æ§è¡ã\n\n\n# externs\n\nå°½å¯è½å¨ dafny åç®æ è¯­è¨ï¼ä¾å¦ c#ãjava ç­ï¼ä¸­å°å®ä»¬å½åä¸ºç¸åçåç§°ï¼è¿æ ·å¨ dafny ä¸­æä»¬åªéç¼å {:extern}ï¼èä¸æ¯ {:extern "<name>"}ã\n\n\n# éè¦èèçäºé¡¹\n\nå¨ dafny ä¸­è®¾è®¡/å®æ½ç¨åºä¹åæèè¿äºé®é¢ã\n\n * è¿ä¸ªåéå/å½æ°åxæ¯ä¸ªå¥½åå­åï¼\n * è¿ä¸ªæ¹æ³må¨æ¨¡åxä¸­ææä¹åï¼ å®ä¸åºè¯¥å¨æ¨¡å y ä¸­åï¼\n * å®ä¹xæ¯å¦å±äºæä»¶y.dfyï¼\n * x.dfy æ¯ä¸ä¸ªå¥½çæä»¶ååï¼',charsets:{cjk:!0},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3},{title:"Cheet Sheet",frontmatter:{title:"Cheet Sheet",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/a65c3f/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:[null],readingShow:"top"},regularPath:"/40.%E8%B5%84%E6%BA%90/10.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Cheet%20Sheet.html",relativePath:"40.èµæº/10.å¸¸ç¨å·¥å·/10.Cheet Sheet.md",key:"v-7bba5a2e",path:"/pages/a65c3f/",headers:[{level:2,title:"Specification",slug:"specification",normalizedTitle:"specification",charIndex:1855}],headersStr:"Specification",content:"KEYWORD(S)       WHAT IT DOES             SNIPPET\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { Foo(i);\n                                          }\nmethod returns   subroutines              /* Without a return value*/ method Hello() { print âHello\n                                          Dafnyâ; } /*With a return value */ method Norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* Multiple return values */\n                                          method Prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class Point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method Dist2(that: Point) returns\n                                          (z: real) requires that != null { z := Norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          Find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# Specification\n\nKEYWORD(S)             WHAT IT DOES              SNIPPET\nrequires               precondition              method Rot90(p: Point) returns (q: Point) requires p !=\n                                                 null{ q := new Point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.Length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.Length }\nmodifies               framing (for methods)     method Reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to âaâ otherwise */\nreads                  framing (for functions)   predicate Sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to âa[_]â otherwise */\ninvariant              loop invariants           i := 0;while i < a.Length invariant 0 <= i <= a.Length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.Length ==> a[k] ==\n                                                 0;",normalizedContent:"keyword(s)       what it does             snippet\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { foo(i);\n                                          }\nmethod returns   subroutines              /* without a return value*/ method hello() { print âhello\n                                          dafnyâ; } /*with a return value */ method norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* multiple return values */\n                                          method prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method dist2(that: point) returns\n                                          (z: real) requires that != null { z := norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# specification\n\nkeyword(s)             what it does              snippet\nrequires               precondition              method rot90(p: point) returns (q: point) requires p !=\n                                                 null{ q := new point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.length }\nmodifies               framing (for methods)     method reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to âaâ otherwise */\nreads                  framing (for functions)   predicate sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to âa[_]â otherwise */\ninvariant              loop invariants           i := 0;while i < a.length invariant 0 <= i <= a.length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.length ==> a[k] ==\n                                                 0;",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"æ¶èç«",frontmatter:{title:"æ¶èç«",date:"2022-03-25T11:48:45.000Z",permalink:"/pages/1b94a4/",categories:["æ¶è"],tags:[null],readingShow:"top"},regularPath:"/50.%E6%94%B6%E8%97%8F/01.%E6%94%B6%E8%97%8F%E7%AB%99.html",relativePath:"50.æ¶è/01.æ¶èç«.md",key:"v-99fc7970",path:"/pages/1b94a4/",headers:[{level:2,title:"å®æ¹ç½ç«",slug:"å®æ¹ç½ç«",normalizedTitle:"å®æ¹ç½ç«",charIndex:99},{level:2,title:"æç« æ¶è",slug:"æç« æ¶è",normalizedTitle:"æç« æ¶è",charIndex:111},{level:2,title:"ç¸å³ç¤¾ç¾¤",slug:"ç¸å³ç¤¾ç¾¤",normalizedTitle:"ç¸å³ç¤¾ç¾¤",charIndex:120}],headersStr:"å®æ¹ç½ç« æç« æ¶è ç¸å³ç¤¾ç¾¤",content:"# Dafnyå®èå¤§å¨\n\n> æ¬ç«ç¹æ¶èå¹¶ç»è®¡æ´çäºç»å¤§é¨åDafnyå­¦ä¹ èµæºï¼åä½çå®å¯æ ¹æ®éè¦èªè¡è®¿é®å­¦ä¹ ã\n\næç¤º\n\nè¥ææ¨èç½ç«æèé¾æ¥å¤±æçå¡çï¼å¯ä»¥èç³»ç«é¿æå¨é¡µåºè¯è®ºåºçè¨ã\n\n\n# å®æ¹ç½ç«\n\nÂ·\n\n\n# æç« æ¶è\n\n\n# ç¸å³ç¤¾ç¾¤",normalizedContent:"# dafnyå®èå¤§å¨\n\n> æ¬ç«ç¹æ¶èå¹¶ç»è®¡æ´çäºç»å¤§é¨ådafnyå­¦ä¹ èµæºï¼åä½çå®å¯æ ¹æ®éè¦èªè¡è®¿é®å­¦ä¹ ã\n\næç¤º\n\nè¥ææ¨èç½ç«æèé¾æ¥å¤±æçå¡çï¼å¯ä»¥èç³»ç«é¿æå¨é¡µåºè¯è®ºåºçè¨ã\n\n\n# å®æ¹ç½ç«\n\nÂ·\n\n\n# æç« æ¶è\n\n\n# ç¸å³ç¤¾ç¾¤",charsets:{cjk:!0},lastUpdated:"2022/03/25, 15:04:11",lastUpdatedTimestamp:1648191851e3},{title:"æ¬ç« - å¯¼èªç«æ¨¡å",frontmatter:{title:"æ¬ç« - å¯¼èªç«æ¨¡å",date:"2022-01-11T14:03:46.000Z",categories:[null],tags:[null],permalink:"/pages/30bf81/",readingShow:"top"},regularPath:"/60.%E6%94%AF%E6%8C%81/01.%E5%AF%BC%E8%88%AA%E7%AB%99.html",relativePath:"60.æ¯æ/01.å¯¼èªç«.md",key:"v-18848ef1",path:"/pages/30bf81/",headers:[{level:2,title:"æç´¢å¼æ",slug:"æç´¢å¼æ",normalizedTitle:"æç´¢å¼æ",charIndex:2},{level:2,title:"åç«¯å¼å",slug:"åç«¯å¼å",normalizedTitle:"åç«¯å¼å",charIndex:11}],headersStr:"æç´¢å¼æ åç«¯å¼å",content:"# æç´¢å¼æ\n\n\n# åç«¯å¼å",normalizedContent:"# æç´¢å¼æ\n\n\n# åç«¯å¼å",charsets:{cjk:!0},lastUpdated:"2022/03/25, 01:03:52",lastUpdatedTimestamp:1648141432e3},{title:"Dafny Quick Reference",frontmatter:{title:"Dafny Quick Reference",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8fb957/",categories:["è¯­è¨","dafny-quick-start"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/00.Dafny%20Quick%20Reference.html",relativePath:"80.è¯­è¨/00.dafny-quick-start/00.Dafny Quick Reference.md",key:"v-77d4d05b",path:"/pages/8fb957/",headers:[{level:2,title:"åºæ¬å®ä¹",slug:"åºæ¬å®ä¹",normalizedTitle:"åºæ¬å®ä¹",charIndex:439},{level:2,title:"æ¹æ³ methods",slug:"æ¹æ³-methods",normalizedTitle:"æ¹æ³ methods",charIndex:797},{level:3,title:"æ¡æ¶Frame",slug:"æ¡æ¶frame",normalizedTitle:"æ¡æ¶frame",charIndex:1498},{level:3,title:"åä½å½æ° variant function",slug:"åä½å½æ°-variant-function",normalizedTitle:"åä½å½æ° variant function",charIndex:1737},{level:3,title:"ghost å³é®å­",slug:"ghost-å³é®å­",normalizedTitle:"ghost å³é®å­",charIndex:1883},{level:3,title:"this å³é®å­",slug:"this-å³é®å­",normalizedTitle:"this å³é®å­",charIndex:1946},{level:3,title:"æé å½æ°/æé ä½ constructor",slug:"æé å½æ°-æé ä½-constructor",normalizedTitle:"æé å½æ°/æé ä½ constructor",charIndex:2050},{level:3,title:"lemma å³é®å­",slug:"lemma-å³é®å­",normalizedTitle:"lemma å³é®å­",charIndex:2356},{level:2,title:"å½æ° function",slug:"å½æ°-function",normalizedTitle:"å½æ° function",charIndex:2720},{level:3,title:"ç±» class",slug:"ç±»-class",normalizedTitle:"ç±» class",charIndex:3632},{level:3,title:"æ°æ®ç±»å datatypes",slug:"æ°æ®ç±»å-datatypes",normalizedTitle:"æ°æ®ç±»å datatypes",charIndex:3732},{level:3,title:"æ³å Generics",slug:"æ³å-generics",normalizedTitle:"æ³å generics",charIndex:4387},{level:3,title:"å£°æ Statement",slug:"å£°æ-statement",normalizedTitle:"å£°æ statement",charIndex:4691},{level:4,title:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",slug:"å½æ°-æ¹æ³çè¿åå¼èµå¼ç»åé",normalizedTitle:"å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé",charIndex:5054},{level:4,title:"assert å£°æ",slug:"assert-å£°æ",normalizedTitle:"assert å£°æ",charIndex:5492},{level:4,title:"print æå°è¯­å¥",slug:"print-æå°è¯­å¥",normalizedTitle:"print æå°è¯­å¥",charIndex:5539},{level:4,title:"if éæ©è¯­å¥",slug:"if-éæ©è¯­å¥",normalizedTitle:"if éæ©è¯­å¥",charIndex:5622},{level:4,title:"while å¾ªç¯è¯­å¥",slug:"while-å¾ªç¯è¯­å¥",normalizedTitle:"while å¾ªç¯è¯­å¥",charIndex:5692},{level:4,title:"matchè¯­å¥(é¿å·´é¿å·´)",slug:"matchè¯­å¥-é¿å·´é¿å·´",normalizedTitle:"matchè¯­å¥(é¿å·´é¿å·´)",charIndex:5962},{level:4,title:"breakè¯­å¥",slug:"breakè¯­å¥",normalizedTitle:"breakè¯­å¥",charIndex:6102},{level:2,title:"è¡¨è¾¾å¼ Expressions",slug:"è¡¨è¾¾å¼-expressions",normalizedTitle:"è¡¨è¾¾å¼ expressions",charIndex:6151},{level:3,title:"åºæ¬è¿ç®ç¬¦",slug:"åºæ¬è¿ç®ç¬¦",normalizedTitle:"åºæ¬è¿ç®ç¬¦",charIndex:6217},{level:4,title:"æ´æ°è¿ç®",slug:"æ´æ°è¿ç®",normalizedTitle:"æ´æ°è¿ç®",charIndex:6676},{level:4,title:"ç¦» æ£ æ° å­¦",slug:"ç¦»-æ£-æ°-å­¦",normalizedTitle:"ç¦» æ£ æ° å­¦",charIndex:6843},{level:4,title:"éåè¿ç®",slug:"éåè¿ç®",normalizedTitle:"éåè¿ç®",charIndex:6964},{level:4,title:"åºåè¿ç®",slug:"åºåè¿ç®",normalizedTitle:"åºåè¿ç®",charIndex:7185},{level:4,title:"if-then-elseå¤æ­è¯­å¥",slug:"if-then-elseå¤æ­è¯­å¥",normalizedTitle:"if-then-elseå¤æ­è¯­å¥",charIndex:7731},{level:4,title:"matchå¹éè¡¨è¾¾å¼",slug:"matchå¹éè¡¨è¾¾å¼",normalizedTitle:"matchå¹éè¡¨è¾¾å¼",charIndex:7894}],headersStr:"åºæ¬å®ä¹ æ¹æ³ methods æ¡æ¶Frame åä½å½æ° variant function ghost å³é®å­ this å³é®å­ æé å½æ°/æé ä½ constructor lemma å³é®å­ å½æ° function ç±» class æ°æ®ç±»å datatypes æ³å Generics å£°æ Statement å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé assert å£°æ print æå°è¯­å¥ if éæ©è¯­å¥ while å¾ªç¯è¯­å¥ matchè¯­å¥(é¿å·´é¿å·´) breakè¯­å¥ è¡¨è¾¾å¼ Expressions åºæ¬è¿ç®ç¬¦ æ´æ°è¿ç® ç¦» æ£ æ° å­¦ éåè¿ç® åºåè¿ç® if-then-elseå¤æ­è¯­å¥ matchå¹éè¡¨è¾¾å¼",content:"# åºç¡å­¦ä¹ \n\næ­¤é¡µé¢è¯´æäº Dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ Dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\nDafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼Dafnyæä»¶æ¯ä»¥dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼mainä¸æ¯å¿é¡»çã\n\næ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)Tï¼\n\nvar x: T\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\nDafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<'T>ï¼ä¸å¯åçæ åºéå\n * seq<'T>ï¼ä¸å¯åçæåºéå\n * array<'T>ãarray2<'T>ãarray3<'T>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã\n\naaaaaaaaaaaa\n\n\n# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nsssssss\n\nmethod M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y) //è¾å¥è¾åºåæ°\n\nrequires Pre //åç½®æ¡ä»¶\n\nmodifies Frame //æ¡æ¶\n\nensures Post //åç½®æ¡ä»¶\n\ndecreases TerminationMetric //åä½å½æ°\n\n{\n\n`sssssss`\n\n`method M(a: A, b: B, c: C) r eturns (x: X, y: Y, z: Y)  //è¾å¥è¾åºåæ°`\n\n `requires Pre\t//åç½®æ¡ä»¶`   \n\n `modifies Frame  //æ¡æ¶`\n\n `ensures Post\t//åç½®æ¡ä»¶`\n\n `decreases TerminationMetric //åä½å½æ°`\n\n`{`\n\n\n}\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * Pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * Frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°(Frame denotes a set of objects whose fields may be updated by the method)\n * Post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * TerminationMetric: æ¯æ¹æ³çåä½å½æ°(TerminationMetric is the methodâs variant function)\n * Body: æ¯å®ç°æ¹æ³çè¯­å¥ã\n\n\n# æ¡æ¶Frame\n\næ¡æ¶Frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶Frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»Cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çâtopâåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼Dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\nDafny IDE å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéææ¹æ³ M å¯ä»¥ç± C.M(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨\n\nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼\n\n{\n\nBody\n\n}\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³(method)å³é®å­ä¼è¢«å¼ç(lemmas)åä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod Sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\n\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶\n\n{\n\nx, y, z := a, b, c;\n\nif z < y {\n\ny, z := z, y;\n\n}\n\nif y < x {\n\nx, y := y, x;\n\n}\n\nif z < y {\n\ny, z := z, y;\n\n}\n\n}\n\n\n# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction F(a: A, b: B, c: C): T\n\nrequires Pre //åç½®æ¡ä»¶pre\n\nreads Frame //æ¡æ¶frame\n\nensures Post //åç½®æ¡ä»¶post\n\ndecreases TerminationMetric //åä½å½æ°\n\n{\n\nBody //å½æ°ä½\n\n}\n\n * a, b, c : è¾å¥çå½¢åï¼\n * T : è¿åç»æçç±»åï¼\n * Pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * Frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * Post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * TerminationMetric: åä½å½æ°\n * Body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ Dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦Factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction Factorial(n: int): int\n\nrequires 0 <= n //åç½®æ¡ä»¶pre\n\nensures 1 <= Factorial(n) //åç½®æ¡ä»¶post\n\n{\n\nif n == 0 then 1 else Factorial(n-1) * n //å½æ°ä½body\n\n}\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» C ä¸­çéæå½æ° F å¯ä»¥è¢« C.F(...) è°ç¨ã\n\n\n# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass C {\n\n// member declarations go here\n\n}\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã\n\n\n# æ°æ®ç±»å datatypes\n\nå½çº³æ°æ®ç±»åï¼inductive datatypeï¼æ¯ä¸ç§ç±»åï¼å¶å¼æ¯ç¨ä¸ç»åºå®çæé å½æ°åå»ºçã\n\næ°æ®ç±»å ä¸ºTreeå¸¦ææé å½æ° Leaf å Node çå½æ°å£°æå¦ä¸ï¼\n\ndatatype Tree = Leaf | Node(Tree, int, Tree)//Leafä¸ºæ åæé å½æ° Nodeä¸ºæå\n\næé å½æ°ç±ç«çº¿åéã æ åæ°æé å½æ°ä¸éè¦ä½¿ç¨æ¬å·ï¼å¦ Leaf æç¤ºã\n\nå¯¹äºæ¯ä¸ªæé å½æ° Ctï¼æ°æ®ç±»åéå¼å£°æäºä¸ä¸ªå¸å°æå Ct?ï¼å¯¹äºå·²ç»ä½¿ç¨ Ct æé å½æ°èµçå¼çæåï¼å®è¿å trueã ä¾å¦ï¼å¨ä»£ç çæ®µä¹åï¼\n\nvar t0 := Leaf;\n\nvar t1 := Node(t0, 5, t0);\n\nè¡¨è¾¾å¼ t1.Nodeç»æä¸º true, t0.Nodeç»æä¸ºfalseã\n\nå¦æä¸¤ä¸ªæ°æ®ç±»åå¼æ¯ä½¿ç¨ç¸åçæé å½æ°åè¯¥æé å½æ°çç¸ååæ°åå»ºçï¼åå®ä»¬æ¯ç¸ç­çãå æ­¤ï¼å¯¹äºå Leafãt.Leaf è¿æ ·çæ åæ°æé å½æ°ï¼Dafnyä¼ç»åºä¸ t == Leaf ç¸åçç»æã(æ²¡çæï¼ä¸ç®¡äº)\n\næé å½æ°å¯ä»¥éæ©ä¸ºå¶ä»»ä½åæ°å£°æææå½æ°ï¼è¿æ¯éè¿ä¸ºåæ°å¼å¥åç§°æ¥å®æçã ä¾å¦ï¼å¦æ Tree è¢«å£°æä¸ºï¼\n\ndatatype Tree = Leaf | Node(left: Tree, data: int, right: Tree)\n\né£ä¹t1.data == 5åt1.left == t0å¨ä¸é¢çä»£ç çæ®µä¹åä¿æä¸åã(è¿æ¯æ²¡æ)\n\n\n# æ³å Generics\n\nDafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åT\n\nclass MyMultiset<T> {\n\n/*...*/\n\n} //ç±»æ³å\n\ndatatype Tree<T> = Leaf | Node(Tree<T>, T, Tree<T>) //èªå®ä¹æ°æ®æ³å\n\nmethod Find<T>(key: T, collection: Tree<T>) { //æ¹æ³æ³å\n\n/*...*/\n\n}\n\nfunction IfThenElse<T>(b: bool, x: T, y: T): T { //å½æ°æ³å\n\n/*...*/\n\n}\n\n\n# å£°æ Statement\n\nä»¥ä¸æ¯ Dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar LocalVariables := ExprList;\n\nLvalues := ExprList;\n\nassert BoolExpr;\n\nprint ExprList;\n\nif BoolExpr0 {\n\nStmts0\n\n} else if BoolExpr1 {\n\nStmts1\n\n} else {\n\nStmts2\n\n}\n\nwhile BoolExpr\n\ninvariant Inv\n\nmodifies Frame\n\ndecreases Rank\n\n{\n\nStmts\n\n}\n\nmatch Expr {\n\ncase Empty => Stmts0\n\ncase Node(l, d, r) => Stmts1\n\n}\n\nbreak;\n\nreturn;\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ª å±é¨åé èå·²ï¼\n\nvar LocalVariables := ExprList;\n\nvar è¯­å¥å¼å¥äºå±é¨åéã\n\nLvalues := ExprList;\n\nèµå¼è¯­å¥å° ExprListåéèµç»Lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç L å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new T\n\n 2. new T.Init(ExprList)\n\n 3. new T(ExprList)\n\n 4. new T[SizeExpr]\n\n 5. new T[SizeExpr0, SizeExpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º T çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºTæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifiesè¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reductionè¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã(çæ²¡çæï¼\n\nwhile BoolExpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶\n\ninvariant Inv\n\nmodifies Frame\n\ndecreases Rank\n\n{\n\nStatements\n\n}\n\n# matchè¯­å¥(é¿å·´é¿å·´)\n\nmatch è¯­å¥è®¡ç®æº Exprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã\n\n\n# è¡¨è¾¾å¼ Expressions\n\nDafny ä¸­çè¡¨è¾¾å¼ä¸ç±» Java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼Dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==> ä½çç»å®åï¼èåèåæ¯ && å || å·ææ´ä½çç»å®åã\n\nDafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çâç¸åæ¹åâçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.Length == N\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.Length && a.Length == N\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ == å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å %ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç % æ»æ¯å¯¼è´éè´æ°ã ï¼å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ CãJava æ C# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/Modulo_operationãï¼\n\n# ç¦» æ£ æ° å­¦\n\nDafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: Expr åexists x :: Exprï¼å¶ä¸­x æ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: T ä¸­æç¤ºï¼ï¼èExpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã S ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå S çæåï¼è x !in S æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in S)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in S å x !in Sãåºå S çé¿åº¦è¡¨ç¤ºä¸º |S|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |S| çç´¢å¼ãè¡¨è¾¾å¼ S[j] è¡¨ç¤ºåºå S çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ S[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |S|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯S ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» S[m]ãS[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ S[n]ï¼ãè¡¨è¾¾å¼ S[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâï¼ä¸ S[m..|S|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ S çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ S[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ S[0..n] ç¸åï¼å³å®è¿åç± S çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå S çææç´¢å¼ï¼åè¡¨è¾¾å¼ S[j := x];æ¯ç±»ä¼¼äº S çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾ [x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if BoolExpr then Expr0 else Expr1\n\nå¶ä¸­ Expr0 å Expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch Expr { case Empty => Expr0 case Node(l, d, r) => Expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",normalizedContent:"# åºç¡å­¦ä¹ \n\næ­¤é¡µé¢è¯´æäº dafny ä¸­è®¸å¤æå¸¸è§çè¯­è¨åè½ã ä¸ºäºè®©æ¨æ´å¿«ä¸æï¼è¿éçæè¿°è¢«ç®åäºââè¿ä¸ªé¡µé¢ä¸æ¯è¯­è¨åèãä¾å¦ï¼æ­¤é¡µé¢ä¸ä¼æ¶åæ¨¡åãè¿­ä»£å¨æç»åï¼é¤éæ¨å¨ dafny ä¸­ç¼åæ´å¤§ææ´é«çº§çç¨åºï¼å¦åæ¨å°ä¸éè¦è¿äºã\n\ndafnyç¨åºé¿è¿æ ·ï¼xxxxx.dfyï¼dafnyæä»¶æ¯ä»¥dfyç»å°¾çã\n\nç¨åºä¸»è¦åå«ä»¥ä¸å é¨åï¼\n\n 1. ç±»å(types)\n\n 2. æ¹æ³(methods)\n\n 3. å½æ°(functions)\n\n 4. ç¨æ·èªå®ä¹çç±»ååæ¬ç±»ï¼classï¼åå½çº³æ°æ®ç±»å(inductive class)\n\n 5. ç±»classæ¬èº«ä¹åå«ä¸ç»å£°æ(declarations)ãä»ç»å­æ®µï¼introducing fieldsï¼ãæ¹æ³(methods)åå½æ°(functions)ã\n    \n    å¦ææmainæ¹æ³é£å°±ä»mainå¼å§éªè¯ç¨åºï¼æ²¡æä¹æ²¡å³ç³»ï¼mainä¸æ¯å¿é¡»çã\n\næ³¨éï¼// åææ  æè /* xxxxx */\n\n\n# åºæ¬å®ä¹\n\nå¨ç±»ä¸­ï¼å®ä¹å­æ®µxä¸ºæ°æ®ç±»å(types)tï¼\n\nvar x: t\n\næ³¨æäºé¡¹ï¼\n\n * æ°æ®ç±»åå¿éæå¨ç³æçï¼ä¸ä¼è¢«èªå¨æ¨æ­ã\n\n * éè¿å¨å£°æåå ä¸å³é® ghost å¯ä»¥å°è¯¥å­æ®µå£°æä¸ºå¹½çµï¼å³ç¨äºè§èèä¸æ¯æ§è¡ï¼å­æ®µã\n\ndafny ç9ç§æ°æ®ç±»ååæ¬ï¼\n\n * boolï¼å¸å°å¼\n * intï¼æ çæ´æ°\n * string: å­ç¬¦ä¸²\n * class/inductive class: ç¨æ·èªå®ä¹çç±»åå½çº³ç±»ã\n * set<'t>ï¼ä¸å¯åçæ åºéå\n * seq<'t>ï¼ä¸å¯åçæåºéå\n * array<'t>ãarray2<'t>ãarray3<'t>: å¤ç»´æ°ç»ç±»å\n * objectï¼ææç±»åçè¶ç±»\n * natï¼èå´æ¯intä¸åï¼éè´æ´æ°ã\n\naaaaaaaaaaaa\n\n\n# æ¹æ³ methods\n\næ¹æ³çå£°æå¦ä¸ï¼\n\nsssssss\n\nmethod m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y) //è¾å¥è¾åºåæ°\n\nrequires pre //åç½®æ¡ä»¶\n\nmodifies frame //æ¡æ¶\n\nensures post //åç½®æ¡ä»¶\n\ndecreases terminationmetric //åä½å½æ°\n\n{\n\n`sssssss`\n\n`method m(a: a, b: b, c: c) r eturns (x: x, y: y, z: y)  //è¾å¥è¾åºåæ°`\n\n `requires pre\t//åç½®æ¡ä»¶`   \n\n `modifies frame  //æ¡æ¶`\n\n `ensures post\t//åç½®æ¡ä»¶`\n\n `decreases terminationmetric //åä½å½æ°`\n\n`{`\n\n\n}\n\nå¶ä¸­ï¼\n\n * a, b, c : è¾å¥åæ°\n * x, y, z : è¾åºåæ°\n * pre: è¡¨ç¤ºæ¹æ³ åææ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * frame: è¡¨ç¤ºç±»å¯¹è±¡çéåï¼å¯ä»¥è¢«æ¹æ³æ´æ°(frame denotes a set of objects whose fields may be updated by the method)\n * post: æ¯æ¹æ³ åç½®æ¡ä»¶ ç å¸å°è¡¨è¾¾å¼\n * terminationmetric: æ¯æ¹æ³çåä½å½æ°(terminationmetric is the methodâs variant function)\n * body: æ¯å®ç°æ¹æ³çè¯­å¥ã\n\n\n# æ¡æ¶frame\n\næ¡æ¶frame æ¯åä¸ªæå¤ä¸ªå¯¹è±¡ç»æçè¡¨è¾¾å¼çéåã(è§ä¸é¢ä¾å­)\n\næ¡æ¶frameæ¯ç±ç±»åå¯¹è±¡åç±»å¤æ¹æ³åå¯¹è±¡ä¸¤é¨åç»æã(åæ­£å°±æ¯ä¸å ç±»å¯¹è±¡çéåï¼\n\nä¾å¦ï¼å¦æ c å d æ¯ç±»cçå¯¹è±¡ï¼é£ä¹ä»¥ä¸æ¯è¡æææ¯ä¸æ ·çã\n\n * modifies {c, d}\n\n * modifies {c} + {d}\n\n * modifies c, {d}\n\n * modifies c, d\n\nå¦ææ¹æ³åå¥é½æ²¡åï¼é£ä¹åç½®ååç½®æ¡ä»¶é»è®¤ä¸ºçï¼æ¡æ¶é»è®¤ä¸ºç©ºéã\n\n\n# åä½å½æ° variant function\n\nåä½å½æ°æ¯ä¸ä¸ªè¡¨è¾¾å¼ç»æçåè¡¨ï¼è¡¨ç¤ºç±ç»å®è¡¨è¾¾å¼ç»æçå­å¸åç»ï¼åè·éå«çâtopâåç´ ã\n\nå¦æçç¥æ²¡åçè¯ï¼dafny å°çæµè¯¥æ¹æ³çåä½å½æ°ï¼éå¸¸æ¯ä»¥è¯¥æ¹æ³çåæ°åè¡¨å¼å¤´çå­å¸åç»ã\n\ndafny ide å°å¨å·¥å·æç¤ºä¸­æ¾ç¤ºçæµã\n\n\n# ghost å³é®å­\n\néè¿å¨å£°æä¹åå ä¸å³é®å­ ghost å¯ä»¥å°æ¹æ³å£°æä¸º ghostæ¹æ³ï¼ä»è§èèä¸ç¨äºæ§è¡ï¼ã\n\n\n# this å³é®å­\n\né»è®¤æåµä¸ï¼ç±»ä¸­çæ¹æ³é½å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨æ¹æ³å£°æä¹åä½¿ç¨å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéææ¹æ³ m å¯ä»¥ç± c.m(...) è°ç¨ã\n\n\n# æé å½æ°/æé ä½ constructor\n\nå¨ç±»ä¸­ï¼ä¸ä¸ªæ¹æ³å¯ä»¥éè¿å°methodå³é®å­æ¿æ¢ä¸ºconstructorï¼ç³æä¸ä¸ªæé æ¹æ³ã\n\næé å½æ°(æé æ¹æ³)åªè½å¨åéå¯¹è±¡æ¶è°ç¨ï¼åè§ç¤ºä¾ï¼\n\nå¯¹äºåå«ä¸ä¸ªæå¤ä¸ªæé å½æ°çç±»ï¼å¯¹è±¡åå»ºå¿é¡»ä¸å¯¹æé å½æ°çè°ç¨ä¸èµ·å®æã\n\néå¸¸ï¼ä¸ä¸ªæ¹æ³å½ç¶å¾æä¸ä¸ªåå­ï¼ä½æ¯ä¸ä¸ªç±»å¯ä»¥æä¸ä¸ªæ²¡æåå­çæé å½æ°ï¼ä¹å°±æ¯å¿åæé å½æ° constructor (n:int )\n\nconstructor (n: int) //constructor å¿åæé å¨\n\nmodifies this //æ¡æ¶åå¯¹è±¡çæé ä½ thiså°±æ¯this.frameï¼\n\n{\n\nbody\n\n}\n\n\n# lemma å³é®å­\n\nææ¶ï¼æ¹æ³(method)å³é®å­ä¼è¢«å¼ç(lemmas)åä»£ã\n\néè¿ä½¿ç¨lemmaå³é®å­èä¸æ¯methodæ¥å£°ææ¹æ³ï¼ä¼è®©ç¨åºæ´æ¸æ¥æç½\n\nç¤ºä¾ï¼è¾å¥ä¸ä¸ªæ´æ°ï¼è¿åæåºåçä¸ä¸ªæ´æ°\n\nmethod sort(a: int, b: int, c: int) returns (x: int, y: int, z: int)\n\nensures x <= y <= z && multiset{a, b, c} == multiset{x, y, z} //åç½®æ¡ä»¶\n\n{\n\nx, y, z := a, b, c;\n\nif z < y {\n\ny, z := z, y;\n\n}\n\nif y < x {\n\nx, y := y, x;\n\n}\n\nif z < y {\n\ny, z := z, y;\n\n}\n\n}\n\n\n# å½æ° function\n\nå½æ°å·æä»¥ä¸å½¢å¼ï¼\n\nfunction f(a: a, b: b, c: c): t\n\nrequires pre //åç½®æ¡ä»¶pre\n\nreads frame //æ¡æ¶frame\n\nensures post //åç½®æ¡ä»¶post\n\ndecreases terminationmetric //åä½å½æ°\n\n{\n\nbody //å½æ°ä½\n\n}\n\n * a, b, c : è¾å¥çå½¢åï¼\n * t : è¿åç»æçç±»åï¼\n * pre: è¡¨ç¤ºå½æ°åææ¡ä»¶çå¸å°è¡¨è¾¾å¼ï¼\n * frame: å½æ°ä½bodyéè¦çå¯¹è±¡åè¡¨\n * post: å½æ°çåç½®æ¡ä»¶å¸å°è¡¨è¾¾å¼\n * terminationmetric: åä½å½æ°\n * body: å®ä¹å½æ°çè¡¨è¾¾å¼ã\n\nåç½®æ¡ä»¶åè®¸å½æ°æ¯é¨åç(åªç¨åç½®å°±è¡ä¸ç¨ååç½®ï¼ï¼å³åç½®æ¡ä»¶è¡¨ç¤ºå½æ°ä½æ¶å®ä¹ï¼å¹¶ä¸ dafny ä¼éªè¯å½æ°çæ¯æ¬¡ä½¿ç¨é½æ»¡è¶³åç½®æ¡ä»¶ã\n\néå¸¸ä¸éè¦åç½®æ¡ä»¶ï¼å ä¸ºå½æ°å¨å½æ°ä½åå·²ç»ç»åºäºå®æ´çå®ä¹ã\n\nä¾å¦ï¼\n\nï¼åä¸ªåç½®å ä¸ªä¿é©ä¹è¡ï¼ä¸è¬åç½®å°±æ¯å£°æè¯¥å½æ°çåºæ¬å±æ§ï¼æ¯å¦factorialè¿ä¸ªå½æ°æææ°å­é½â¥1ï¼\n\nfunction factorial(n: int): int\n\nrequires 0 <= n //åç½®æ¡ä»¶pre\n\nensures 1 <= factorial(n) //åç½®æ¡ä»¶post\n\n{\n\nif n == 0 then 1 else factorial(n-1) * n //å½æ°ä½body\n\n}\n\nè¦å¨åç½®æ¡ä»¶ä¸­å¼ç¨å½æ°çç»æï¼è¯·ä½¿ç¨å½æ°æ¬èº«çåç§°ï¼å¦ç¤ºä¾ä¸­æç¤ºã\n\né»è®¤æåµä¸ï¼å½æ°æ¯ghostï¼ä¸è½ä»å¯æ§è¡ï¼éghostï¼ä»£ç ä¸­è°ç¨ã\n\nä¸ºäºä½¿å®ä»ghoståæéghostï¼ç¨å³é®å­function methodæ¿æ¢ function.\n\nä¸ä¸ªè¿åå¸å°å¼çå½æ°å¯ä»¥ç¨å³é®å­å£°æï¼ç¶åçç¥åå·åè¿åç±»åã\n\nå¦æå½æ°ææ¹æ³è¢«å£°æä¸ºç±»classæåï¼åå®å·æéå¼æ¥æ¶å¨åæ° thisãå¯ä»¥éè¿å¨å£°æä¹åå ä¸å³é®å­ static æ¥å é¤æ­¤åæ°ã\n\nç±» c ä¸­çéæå½æ° f å¯ä»¥è¢« c.f(...) è°ç¨ã\n\n\n# ç±» class\n\nä¸ä¸ªç±»å®ä¹å¦ä¸ï¼\n\nclass c {\n\n// member declarations go here\n\n}\n\nå¶ä¸­ç±»çæåï¼å­æ®µãæ¹æ³åå½æ°ï¼å¨è±æ¬å·åå®ä¹ï¼å¦ä¸æè¿°ï¼ã\n\n\n# æ°æ®ç±»å datatypes\n\nå½çº³æ°æ®ç±»åï¼inductive datatypeï¼æ¯ä¸ç§ç±»åï¼å¶å¼æ¯ç¨ä¸ç»åºå®çæé å½æ°åå»ºçã\n\næ°æ®ç±»å ä¸ºtreeå¸¦ææé å½æ° leaf å node çå½æ°å£°æå¦ä¸ï¼\n\ndatatype tree = leaf | node(tree, int, tree)//leafä¸ºæ åæé å½æ° nodeä¸ºæå\n\næé å½æ°ç±ç«çº¿åéã æ åæ°æé å½æ°ä¸éè¦ä½¿ç¨æ¬å·ï¼å¦ leaf æç¤ºã\n\nå¯¹äºæ¯ä¸ªæé å½æ° ctï¼æ°æ®ç±»åéå¼å£°æäºä¸ä¸ªå¸å°æå ct?ï¼å¯¹äºå·²ç»ä½¿ç¨ ct æé å½æ°èµçå¼çæåï¼å®è¿å trueã ä¾å¦ï¼å¨ä»£ç çæ®µä¹åï¼\n\nvar t0 := leaf;\n\nvar t1 := node(t0, 5, t0);\n\nè¡¨è¾¾å¼ t1.nodeç»æä¸º true, t0.nodeç»æä¸ºfalseã\n\nå¦æä¸¤ä¸ªæ°æ®ç±»åå¼æ¯ä½¿ç¨ç¸åçæé å½æ°åè¯¥æé å½æ°çç¸ååæ°åå»ºçï¼åå®ä»¬æ¯ç¸ç­çãå æ­¤ï¼å¯¹äºå leafãt.leaf è¿æ ·çæ åæ°æé å½æ°ï¼dafnyä¼ç»åºä¸ t == leaf ç¸åçç»æã(æ²¡çæï¼ä¸ç®¡äº)\n\næé å½æ°å¯ä»¥éæ©ä¸ºå¶ä»»ä½åæ°å£°æææå½æ°ï¼è¿æ¯éè¿ä¸ºåæ°å¼å¥åç§°æ¥å®æçã ä¾å¦ï¼å¦æ tree è¢«å£°æä¸ºï¼\n\ndatatype tree = leaf | node(left: tree, data: int, right: tree)\n\né£ä¹t1.data == 5åt1.left == t0å¨ä¸é¢çä»£ç çæ®µä¹åä¿æä¸åã(è¿æ¯æ²¡æ)\n\n\n# æ³å generics\n\ndafnyåå¶ä»è¯­è¨ä¸æ ·é½ææ³åï¼ä»»ä½ç±»ãæ¹æ³ãå½æ°é½å¯ä»¥æç±»ååæ°ï¼å¨<>ä¸­ç³æè¯¥æ°æ®ç±»åt\n\nclass mymultiset<t> {\n\n/*...*/\n\n} //ç±»æ³å\n\ndatatype tree<t> = leaf | node(tree<t>, t, tree<t>) //èªå®ä¹æ°æ®æ³å\n\nmethod find<t>(key: t, collection: tree<t>) { //æ¹æ³æ³å\n\n/*...*/\n\n}\n\nfunction ifthenelse<t>(b: bool, x: t, y: t): t { //å½æ°æ³å\n\n/*...*/\n\n}\n\n\n# å£°æ statement\n\nä»¥ä¸æ¯ dafny ä¸­æå¸¸è§è¯­å¥:\n\nvar localvariables := exprlist;\n\nlvalues := exprlist;\n\nassert boolexpr;\n\nprint exprlist;\n\nif boolexpr0 {\n\nstmts0\n\n} else if boolexpr1 {\n\nstmts1\n\n} else {\n\nstmts2\n\n}\n\nwhile boolexpr\n\ninvariant inv\n\nmodifies frame\n\ndecreases rank\n\n{\n\nstmts\n\n}\n\nmatch expr {\n\ncase empty => stmts0\n\ncase node(l, d, r) => stmts1\n\n}\n\nbreak;\n\nreturn;\n\n# å½æ°/æ¹æ³çè¿åå¼èµå¼ç»åé\n\n(å°±æ¯å°å½æ°/æ¹æ³è¿åçå¼æå¯¹è±¡ èµç» ä¸ä¸ª å±é¨åé èå·²ï¼\n\nvar localvariables := exprlist;\n\nvar è¯­å¥å¼å¥äºå±é¨åéã\n\nlvalues := exprlist;\n\nèµå¼è¯­å¥å° exprliståéèµç»lvaluesã è¿äºåéæ¯å¹¶è¡æ§è¡çï¼æ´éè¦çæ¯ï¼ææå¿è¦çè¯»åé½åçå¨åå¥ä¹åï¼ï¼å æ­¤å·¦ä¾§å¿é¡»è¡¨ç¤ºä¸åç l å¼ã æ¯ä¸ªå³ä¾§é½å¯ä»¥æ¯ä»¥ä¸å½¢å¼ä¹ä¸çè¡¨è¾¾å¼æå¯¹è±¡åå»ºï¼\n\n 1. new t\n\n 2. new t.init(exprlist)\n\n 3. new t(exprlist)\n\n 4. new t[sizeexpr]\n\n 5. new t[sizeexpr0, sizeexpr1]\n\nç¬¬ä¸ç§å½¢å¼åéä¸ä¸ªç±»åä¸º t çå¯¹è±¡ã\n\nç¬¬äºç§å½¢å¼å¦å¤å¨æ°åéçå¯¹è±¡ä¸è°ç¨åå§åæ¹æ³ææé å½æ°ã\n\nç¬¬ä¸ç§å½¢å¼æ¯å½è°ç¨å¿åæé å½æ°æ¶çè¯­æ³ã\n\nå¶ä»å½¢å¼åå«äºtæ¯ä¸ç»´åäºç»´æ°ç»å¯¹è±¡çå¿åæé æ¹æ³\n\n# assert å£°æ\n\nassert è¯­å¥å¤æ­åé¢çè¡¨è¾¾å¼ç»ææ¯å¦ä¸ºçï¼ç±éªè¯å¨éªè¯ï¼ã\n\n# print æå°è¯­å¥\n\næå°è¯­å¥å°ç»å®æå°è¡¨è¾¾å¼çå¼è¾åºå°æ åè¾åºãå­ç¬¦ä¸²ä¸­çå­ç¬¦å¯ä»¥è½¬ä¹ï¼ä¾å¦ï¼å¯¹ print è¯­å¥æå´è¶£çæ¯ \\n è¡¨ç¤ºå­ç¬¦ä¸²ä¸­çæ¢è¡ç¬¦ã\n\n# if éæ©è¯­å¥\n\nif è¯­å¥æ¯éå¸¸çè¯­å¥ãè¯¥ç¤ºä¾æ¾ç¤ºäºä½¿ç¨ else if å°å¤éæ¹æ¡ä¸²å¨ä¸èµ·ãåå¾å¸¸ä¸æ ·ï¼else åæ¯æ¯å¯éçã\n\n# while å¾ªç¯è¯­å¥\n\n * while è¯­å¥æ¯éå¸¸çå¾ªç¯ï¼å¶ä¸­\n * invariant å£°æç»åºäºä¸ä¸ªå¾ªç¯åé\n * modifiesè¯­å¥éå¶äºå¾ªç¯çæ¡æ¶\n * reductionè¯­å¥ä»å¾ªç¯ä¸­å¼å¥äºä¸ä¸ªåä½å½æ°ã\n\né»è®¤æåµä¸ï¼å¾ªç¯ä¸åå¼ä¸ºçï¼ä¿®æ¹æ¡ä¸å°é­ä¸ä¸æä¸­çç¸åï¼éå¸¸æ¯å°é­æ¹æ³çä¿®æ¹å­å¥ï¼ï¼å¹¶ä»å¾ªç¯ä¿æ¤ä¸­çæµåä½å½æ°ã(çæ²¡çæï¼\n\nwhile boolexpr //å¸å°è¡¨è¾¾å¼-å¾ªç¯æ¡ä»¶\n\ninvariant inv\n\nmodifies frame\n\ndecreases rank\n\n{\n\nstatements\n\n}\n\n# matchè¯­å¥(é¿å·´é¿å·´)\n\nmatch è¯­å¥è®¡ç®æº exprï¼ä¸ä¸ªç±»åä¸ºå½çº³æ°æ®ç±»åçè¡¨è¾¾å¼ï¼ï¼ç¶åæ§è¡ä¸ç¨äºåå»ºæºæ°æ®ç±»åå¼çæé å½æ°ç¸å¯¹åºç caseï¼å°æé å½æ°åæ°ç»å®å°ç»å®çåç§°ãå¦æä¸éè¦å®ä»¬æ¥æ è®° match è¯­å¥çç»å°¾ï¼åå¯ä»¥çç¥åå´ case çè±æ¬å·ã\n\n# breakè¯­å¥\n\nbreak è¯­å¥å¯ç¨äºéåºå¾ªç¯ï¼è return è¯­å¥å¯ç¨äºéåºæ¹æ³ã\n\n\n# è¡¨è¾¾å¼ expressions\n\ndafny ä¸­çè¡¨è¾¾å¼ä¸ç±» java è¯­è¨ä¸­çè¡¨è¾¾å¼éå¸¸ç¸ä¼¼ãä»¥ä¸æ¯ä¸äºå¼å¾æ³¨æçå·®å¼ã\n\n\n# åºæ¬è¿ç®ç¬¦\n\né¤äºç­è·¯å¸å°è¿ç®ç¬¦ && (and) å || ï¼æï¼ï¼dafny æä¸ä¸ªç­è·¯è´æ¶µè¿ç®ç¬¦ ==> åä¸ä¸ª if-and-only-if è¿ç®ç¬¦ <==>ã\n\næ­£å¦å®ä»¬çå®½åº¦ææç¤ºçé£æ ·ï¼<==> å·ææ¯ ==> ä½çç»å®åï¼èåèåæ¯ && å || å·ææ´ä½çç»å®åã\n\ndafny æ¯è¾è¡¨è¾¾å¼å¯ä»¥æ¯é¾å¼çï¼è¿æå³çâç¸åæ¹åâçæ¯è¾å¯ä»¥ä¸²å¨ä¸èµ·ãä¾å¦ï¼0 <= i < j <= a.length == n\n\nå«ä¹ç¸åï¼ 0 <= i && i < j && j <= a.length && a.length == n\n\nè¯·æ³¨æï¼å¸å°ç¸ç­å¯ä»¥ä½¿ç¨ == å <==> æ¥è¡¨ç¤ºãè¿äºä¹é´æä¸¤ä¸ªåºå«ãé¦åï¼== æ¯ <==> å·ææ´é«ççº¦æåãå¶æ¬¡ï¼== æ¯é¾æ¥ï¼è <==> æ¯å³èçãä¹å°±æ¯è¯´ï¼a == b == c ä¸ a == b && b == c ç¸åï¼è a <==> b <==> c ä¸ a <==> (b <== > c)ï¼è¿ä¹ä¸ (a <==> b) <==> c ç¸åã\n\n# æ´æ°è¿ç®\n\nå¯¹æ´æ°çè¿ç®æ¯å¸¸ç¨çè¿ç®ï¼é¤äº /ï¼æ´æ°é¤æ³ï¼å %ï¼æ´æ°æ¨¡ï¼éµå¾ªæ¬§å éå¾·å®ä¹ï¼è¿æå³ç % æ»æ¯å¯¼è´éè´æ°ã ï¼å æ­¤ï¼å½ / æ % çç¬¬ä¸ä¸ªåæ°ä¸ºè´æ°æ¶ï¼ç»æä¸æ¨å¨ cãjava æ c# ä¸­å¾å°çç»æä¸åï¼è¯·åé http://en.wikipedia.org/wiki/modulo_operationãï¼\n\n# ç¦» æ£ æ° å­¦\n\ndafny è¡¨è¾¾å¼åæ¬å¨ç§°éè¯åå­å¨éè¯ï¼å¶å½¢å¼ä¸ºï¼forall x :: expr åexists x :: exprï¼å¶ä¸­x æ¯ç»å®åéï¼å¯ä»¥ä½¿ç¨æ¾å¼ç±»åå£°æï¼å¦x: t ä¸­æç¤ºï¼ï¼èexpr æ¯ä¸ä¸ªå¸å°è¡¨è¾¾å¼ã\n\n# éåè¿ç®\n\néåä¸çæä½åæ¬+ï¼å¹¶ï¼ã*ï¼äº¤ï¼å-ï¼éåå·®ï¼ãéåæ¯è¾è¿ç®ç¬¦<ï¼çå­éï¼ã<=ï¼å­éï¼ãå®ä»¬çå¯¹å¶> å>=ï¼ä»¥å!! ï¼è±èï¼ã s ä¸­çè¡¨è¾¾å¼ x è¡¨ç¤º x æ¯éå s çæåï¼è x !in s æ¯ä¸ä¸ªæ¹ä¾¿çåæ³ !(x in s)ã\n\nè¦ä»æäºåç´ åå»ºä¸ä¸ªéåï¼è¯·å°å®ä»¬æ¬å¨è±æ¬å·ä¸­ãä¾å¦ï¼{x,y} æ¯ç± x å y ç»æçéåï¼å¦æ x == yï¼åä¸ºåä¾éï¼ï¼{x} æ¯åå« x çåä¾éï¼{} æ¯ç©ºéã\n\n# åºåè¿ç®\n\nå¯¹åºåçæä½åæ¬ +ï¼è¿æ¥ï¼åæ¯è¾è¿ç®ç¬¦ <ï¼éå½çåç¼ï¼å <=ï¼åç¼ï¼ãæåèµæ ¼å¯ä»¥åéåä¸æ ·æ£æ¥ï¼x in s å x !in sãåºå s çé¿åº¦è¡¨ç¤ºä¸º |s|ï¼å¹¶ä¸æ­¤ç±»åºåçåç´ å·æä» 0 å°å°äº |s| çç´¢å¼ãè¡¨è¾¾å¼ s[j] è¡¨ç¤ºåºå s çç´¢å¼ j å¤çåç´ ãè¡¨è¾¾å¼ s[m..n]ï¼å¶ä¸­ 0 <= m <= n <= |s|ï¼è¿åä¸ä¸ªåºåï¼å¶åç´ æ¯s ä»ç´¢å¼ m å¼å§ï¼å³ï¼ä» s[m]ãs[m+1]ãâ¦â¦ç´å°ä½ä¸åæ¬ s[n]ï¼ãè¡¨è¾¾å¼ s[m..]; ï¼éå¸¸ç§°ä¸ºâdrop mâï¼ä¸ s[m..|s|] ç¸åï¼ä¹å°±æ¯è¯´ï¼å®è¿åé¤ s çå m ä¸ªåç´ ä¹å¤çææåç´ çåºåãè¡¨è¾¾å¼ s[..n] ; ï¼éå¸¸ç§°ä¸ºâtake nâï¼ä¸ s[0..n] ç¸åï¼å³å®è¿åç± s çå n ä¸ªåç´ ç»æçåºåã\n\nå¦æ j æ¯åºå s çææç´¢å¼ï¼åè¡¨è¾¾å¼ s[j := x];æ¯ç±»ä¼¼äº s çåºåï¼åªæ¯å®å¨ç´¢å¼ j å¤æ xã\n\næåï¼è¦ä»ä¸äºåç´ ç»æä¸ä¸ªåºåï¼è¯·å°å®ä»¬æ¬å¨æ¹æ¬å·ä¸­ãä¾å¦ï¼[x,y] æ¯ç±ä¸¤ä¸ªåç´  x å y ç»æçåºåï¼ä½¿å¾ [x,y][0] == x å [x,y][1] == yï¼[x] æ¯å¯ä¸åç´ æ¯ x çåä¾åºåï¼[] æ¯ç©ºåºåã\n\n# if-then-elseå¤æ­è¯­å¥\n\nif-then-else è¡¨è¾¾å¼çå½¢å¼ä¸ºï¼if boolexpr then expr0 else expr1\n\nå¶ä¸­ expr0 å expr1 æ¯ç¸åç±»åçä»»ä½è¡¨è¾¾å¼ãä¸ if è¯­å¥ä¸åï¼if-then-else è¡¨è¾¾å¼ä½¿ç¨ then å³é®å­ï¼å¹¶ä¸å¿é¡»åå«æ¾å¼ç else åæ¯ã\n\n# matchå¹éè¡¨è¾¾å¼\n\nmatch è¡¨è¾¾å¼ç±»ä¼¼äº match è¯­å¥å¹¶å·æä»¥ä¸å½¢å¼ï¼\n\nmatch expr { case empty => expr0 case node(l, d, r) => expr1 }\n\nå¤§æ¬å·å¯ç¨äºæ è®°å¹éè¡¨è¾¾å¼çç»æï¼ä½æå¸¸è§çæ¯ä¸éè¦è¿æ ·åï¼ç¶åå¯ä»¥çç¥å¤§æ¬å·ã",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Getting Started with Dafny A Guide",frontmatter:{title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8766fd/",categories:["è¯­è¨","dafny-quick-start"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/10.Getting%20Started%20with%20Dafny%20A%20Guide.html",relativePath:"80.è¯­è¨/00.dafny-quick-start/10.Getting Started with Dafny A Guide.md",key:"v-618eaefe",path:"/pages/8766fd/",headers:[{level:2,title:"Getting Started with Dafny: A Guide",slug:"getting-started-with-dafny-a-guide",normalizedTitle:"getting started with dafny: a guide",charIndex:28},{level:3,title:"Introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:242},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:1945},{level:3,title:"Pre- and Postconditions",slug:"pre-and-postconditions",normalizedTitle:"pre- and postconditions",charIndex:5156},{level:3,title:"Assertions",slug:"assertions",normalizedTitle:"assertions",charIndex:12244},{level:3,title:"Functions",slug:"functions",normalizedTitle:"functions",charIndex:22875},{level:3,title:"Loop Invariants",slug:"loop-invariants",normalizedTitle:"loop invariants",charIndex:28455},{level:3,title:"Termination",slug:"termination",normalizedTitle:"termination",charIndex:39962},{level:3,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:43929},{level:3,title:"Quantifiers",slug:"quantifiers",normalizedTitle:"quantifiers",charIndex:46819},{level:3,title:"Predicates",slug:"predicates",normalizedTitle:"predicates",charIndex:53780},{level:3,title:"Framing",slug:"framing",normalizedTitle:"framing",charIndex:55371},{level:3,title:"Binary Search",slug:"binary-search",normalizedTitle:"binary search",charIndex:59349},{level:3,title:"Conclusion",slug:"conclusion",normalizedTitle:"conclusion",charIndex:64781}],headersStr:"Getting Started with Dafny: A Guide Introduction Methods Pre- and Postconditions Assertions Functions Loop Invariants Termination Arrays Quantifiers Predicates Framing Binary Search Conclusion",content:'Dafny Documentation\n\n\n#\n\n\n# Getting Started with Dafny: A Guide\n\nBe sure to follow along with the code examples by clicking the âload in editorâ link in the corner. See what the tool says, try to fix programs on your own, and experiment!\n\n\n# Introduction\n\nDafny is a language that is designed to make it easy to write correct code. This means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. To accomplish this, Dafny relies on high-level annotations to reason about and prove correctness of code. The effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. Dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). Dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. This is often easier than writing the code, because annotations are shorter and more direct. For example, the following fragment of annotation in Dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nThis says that for all integers k that are indices into the array, the value at that index is greater than zero. By writing these annotations, one is confident that the code is correct. Further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nIn addition to proving a correspondence to user supplied annotations, Dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. This guarantee is a powerful one, and is a strong case in and of itself for the use of Dafny and tools like it. Dafny also proves the termination of code, except in specially designated loops.\n\nLetâs get started writing some Dafny programs.\n\n\n# Methods\n\nDafny resembles a typical imperative programming language in many ways. There are methods, variables, types, loops, if statements, arrays, integers, and more. One of the basic units of any Dafny program is the method. A method is a piece of imperative, executable code. In other languages, they might be called procedures, or functions, but in Dafny the term âfunctionâ is reserved for a different concept that we will cover later. A method is declared in the following way:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a method called âAbsâ which takes a single integer parameter, called âxâ, and returns a single integer, called âyâ. Note that the types are required for each parameter and return value, and follow each name after a colon (:). Also, the return values are named, and there can be multiple return values, as in below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThe method body is the code contained within the braces, which until now has been cleverly represented as â...â (which is not Dafny syntax). The body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. For example, the MultipleReturns method may be implemented as:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nAssignments do not use â=â, but rather â:=â. (In fact, as Dafny uses â==â for equality, there is no use of a single equals sign in Dafny expressions.) Simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. To return a value from a method, the value is assigned to one of the named return values sometime before a return statement. In fact, the return values act very much like local variables, and can be assigned to more than once. The input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. Return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. There are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). Here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (Other comparison operators are <=, >, >=, != and ==, with the expected meaning. See the reference for more on operators.)\n\n\n# Pre- and Postconditions\n\nNone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). The real power of Dafny comes from the ability to annotate these methods to specify their behavior. For example, one property that we observe with the Abs method is that the result is always greater than or equal to zero, regardless of the input. We could put this observation in a comment, but then we would have no way to know whether the method actually had this property. Further, if someone came along and changed the method, we wouldnât be guaranteed that the comment was changed to match. With annotations, we can have Dafny prove that the property we claim of the method is true. There are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nThis property of the Abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. Postconditions, declared with the ensures keyword, are given as part of the methodâs declaration, after the return values (if present) and before the method body. The keyword is followed by the boolean expression. Like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. In the case of the Abs method, a reasonable postcondition is the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nYou can see here why return values are given names. This makes them easy to refer to in the postcondition of a method. When the expression is true, we say that the postcondition holds. The postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). In this case, the only property we are expressing is that the return value is always at least zero.\n\nSometimes there are multiple properties that we would like to establish about our code. In this case, we have two options. We can either join the two conditions together with the boolean âandâ operator (&&), or we can write multiple ensures specifications. The latter is basically the same as the former, but it seperates distinct properties. For example, the return value names from the MultipleReturns method might lead one to guess the following postconditions:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition can also be written:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in Dafny. (In general, most of the comparison operators can be chained, but only âin one directionâ, i.e. not mixing âgreater thanâ and âless thanâ. See the reference for details.)\n\nThe first way of expressing the postconditions separates the âlessâ part from the âmoreâ part, which may be desirable. Another thing to note is that we have included one of the input parameters in the postcondition. This is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\nDafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). This means that Dafny wasnât able to prove that this annotation holds every time the method returns. In general, there are two main causes for Dafny verification errors: specifications that are inconsistent with the code, and situations where it is not âcleverâ enough to prove the required properties. Differentiating between these two possibilities can be a difficult task, but fortunately, Dafny and the Boogie/Z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nIn this situation, Dafny is correct in saying there is an error with the code. The key to the problem is that y is an integer, so it can be negative. If y is negative (or zero), then more can actually be smaller than or equal to x. Our method will not work as intended unless y is strictly larger than zero. This is precisely the idea of a precondition. A precondition is similar to a postcondition, except that it is something that must be true before a method is called. When you call a method, it is your job to establish (make true) the preconditions, something Dafny will enforce using a proof. Likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. The caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. We can give the necessary precondition to MultipleReturns as below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nLike postconditions, multiple preconditions can be written either with the boolean âandâ operator (&&), or by multiple requires keywords. Traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). With the addition of this condition, Dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nExercise 0. Write a method Max that takes two integer parameters and returns their maximum. Add appropriate annotations and make sure your code verifies.\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNot all methods necessarily have preconditions. For example, the Abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). Even though it has no need of preconditions, the Abs function as it stands now is not very useful. To investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# Assertions\n\nUnlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. Like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. An assertion says that a particular expression always holds when control reaches that part of the code. For example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try "asserting" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny proves this method correct, as 2 is always less than 3. Asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. You can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. Assertions are a powerful tool for debugging annotations, by checking what Dafny is able to prove about your code. For example, we can use it to investigate what Dafny knows about the Abs function.\n\nTo do this, we need one more concept: local variables. Local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (See the reference for details.) Local variables are declared with the var keyword, and can optionally have type declarations. Unlike method parameters, where types are required, Dafny can infer the types of local variables in almost all situations. This is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nThe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nMultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nExplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. We needed variables because we want to talk about the return value of the Abs method. We cannot put Abs inside a specification directly, as the method could change memory state, among other problems. So we capture the return value of a call to Abs as follows:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is an example of a situation where we can ask Dafny what it knows about the values in the code, in this case v. We do this by adding assertions, like the one above. Every time Dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. In this example, there is only one control path through the method, and Dafny is able to prove the annotation easily because it is exactly the postcondition of the Abs method. Abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to Abs.\n\nExercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nBut we know something stronger about the Abs method. In particular, for non-negative x, Abs(x) == x. Specifically, in the above program, the value of v is 3. If we try adding an assertion (or changing the existing one) to say:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that Dafny cannot prove our assertion, and gives an error. The reason this happens is that Dafny âforgetsâ about the body of every method except the one it is currently working on. This simplifies Dafnyâs job tremendously, and is one of the reasons it is able to operate at reasonable speeds. It also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). We donât care at all what happens inside each method when we call it, as long as it satisfies its annotations. This works because Dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nFor the Abs method, this means that the only thing Dafny knows in the Testing method about the value returned from Abs is what the postconditions say about it, and nothing more. This means that Dafny wonât know the nice property about Abs and non-negative integers unless we tell it by putting this in the postcondition of the Abs method. Another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. Everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. In the Abs case, we might have written:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nThis method satisfies the postconditions, but clearly the program fragment:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. Dafny is considering, in an abstract way, all methods with those annotations. The mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. We need stronger postconditions to eliminate these other possibilities, and âfixâ the method down to exactly the one we want. We can partially do this with the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. The second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean âandâ and comparisons, so the above says 0 <= x implies y == x). The left and right sides must both be boolean expressions.\n\nThe postcondition says that after Abs is called, if the value of x was non-negative, then y is equal to x. One caveat of the implication is that it is still true if the left part (the antecedent) is false. So the second postcondition is trivially true when x is negative. In fact, the only thing that the annotations say when x is negative is that the result, y, is positive. But this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nThese annotations are enough to require that our method actually computes the absolute value of x. These postconditions are not the only way to express this property. For example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIn general, there can be many ways to write down a given property. Most of the time it doesnât matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nBut we still have an issue: there seems to be a lot of duplication. The body of the method is reflected very closely in the annotations. While this is correct code, we want to eliminate this redundancy. As you might guess, Dafny provides a means of doing this: functions.\n\nExercise 2. Using a precondition, change Abs to say it can only be called on negative values. Simplify the body of Abs into just one return statement and make sure the method still verifies.\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 3. Keeping the postconditions of Abs the same as above, change the body of Abs to just y := x + 2. What precondition do you need to annotate the method with in order for the verification to go through? What precondition do you need if the body is y := x + 1? What does that precondition say about when you can call the method?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a function called abs which takes a single integer, and returns an integer (the second int). Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. Here our body must be an integer expression. In order to implement the absolute value function, we need to use an if expression. An if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nObviously, the condition must be a boolean expression, and the two branches must have the same type. You might wonder why anyone would bother with functions, if they are so limited compared to methods. The power of functions comes from the fact that they can be used directly in specifications. So we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nIn fact, not only can we write this statement directly without capturing to a local variable, we didnât even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). The limitations of functions are precisely what let Dafny do this. Unlike methods, Dafny does not forget the body of a function when considering other functions. So it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nExercise 4. Write a function max that returns the larger of two given integer parameters. Write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat of functions is that not only can they appear in annotations, they can only appear in annotations. One cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. Functions are never part of the final compiled program, they are just tools to help us verify our code. Sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. Note that there are restrictions on what functions can be function methods (See the reference for details).\n\nExercise 5. Change your test method from Exercise 4 to capture the value of max to a variable, and then do the checks from Exercise 4 using the variable. Dafny will reject this program because you are calling max from real code. Fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nExercise 6. Now that we have an abs function, change the postcondition of method Abs to make use of abs. After confirming the method still verifies, change the body of Abs to also use abs. (After doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nUnlike methods, functions can appear in expressions. Thus we can do something like implement the mathematical Fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nHere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. It turns out that we could make this function a function method if we wanted to. But this would be extremely slow, as this version of calculating the Fibonacci numbers has exponential complexity. There are much better ways to calculate the Fibonacci function. But this function is still useful, as we can have Dafny prove that a fast version really matches the mathematical definition. We can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nWe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWe havenât written the body yet, so Dafny will complain that our postcondition doesnât hold. We need an algorithm to calculate the nth Fibonacci number. The basic idea is to keep a counter, and repeatedly calculate adjacent pairs of Fibonacci numbers until the desired number is reached. To do this, we need a loop. In Dafny, this is done via a while loop. A while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nThis is a trivial loop that just increments i until it reaches n. This will form the core of our loop to calculate Fibonacci numbers.\n\n\n# Loop Invariants\n\nwhile loops present a problem for Dafny. There is no way for Dafny to know in advance how many times the code will go around the loop. But Dafny needs to consider all paths through a program, which could include going around the loop any number of times. To make it possible for Dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\nA loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. It captures something that is invariant, i.e. does not change, about every step of the loop. Now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldnât need the loop. Like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. For example, we see in the above loop that if i starts off positive, then it stays positive. So we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWhen you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. By preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. Dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). Just as Dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nIn our example, the point of the loop is to build up the Fibonacci numbers one (well, two) at a time until we reach the desired number. After we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. We can use our assertion trick to check to see if Dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nWe find that this assertion fails. As far as Dafny knows, it is possible that i somehow became much larger than n at some point during the loop. All it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. In this case, this amounts to n <= i and 0 <= i. But this is not enough to guarantee that i == n, just that n <= i. Somehow we need to eliminate the possibility of i exceeding n. One first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThis does not verify, as Dafny complains that the invariant is not preserved (also known as not maintained) by the loop. We want to be able to say that after the loop exits, then all the invariants hold. Our invariant holds for every execution of the loop except for the very last one. Because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. Thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nNow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows Dafny to prove the assertion i == n. The challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nExercise 7. Change the loop invariant to 0 <= i <= n+2. Does the loop still verify? Does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExercise 8. With the original loop invariant, change the loop guard from i < n to i != n. Do the loop and the assertion after the loop still verify? Why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIn addition to the counter, our algorithm called for a pair of numbers which represent adjacent Fibonacci numbers in the sequence. Unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. To find these invariants, we employ a common Dafny trick: working backwards from the postconditions.\n\nOur postcondition for the Fibonacci method is that the return value b is equal to fib(n). But after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. This might make a good invariant, as it relates something to the loop counter. This observation is surprisingly common throughout Dafny programs. Often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. So we have that the variable b, which is conveniently our out parameter, will be the current Fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nWe also note that in our algorithm, we can compute any Fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. So we want a way of tracking the previous Fibonacci number, which we will call a. Another invariant will express that numberâs relation to the loop counter. The invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nAt each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. Using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nHere a is the trailing number, and b is the leading number. The parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. Thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nWe also have made a change to the loop counter i. Because we also want to track the trailing number, we canât start the counter at zero, as otherwise we would have to calculate a negative Fibonacci number. The problem with doing this is that the loop counter invariant may not hold when we enter the loop. The only problem is when n is zero. This can be eliminated as a special case, by testing for this condition at the beginning of the loop. The completed Fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. Dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nExercise 9. The ComputeFib method above is more complicated than necessary. Write a simpler program by not introducing a as the Fibonacci number that precedes b, but instead introducing a variable c that succeeds b. Verify your program is correct according to the mathematical definition of Fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nExercise 10. Starting with the completed ComputeFib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. Verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nOne of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. For example, we could have omitted the entire body of the loop in the previous program. The invariants would be correct, because they are still true upon entering the loop, and since the loop doesnât change anything, they would be preserved by the loop. We know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. Thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# Termination\n\nDafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. For many things, Dafny is able to guess the right annotations, but sometimes it needs to be made explicit. In fact, for all of the code we have seen so far, Dafny has been able to do this proof on its own, which is why we havenât seen the decreases annotation explicitly yet. There are two places Dafny proves termination: loops and recursion. Both of these situations require either an explicit annotation or a correct guess by Dafny.\n\nA decreases annotation, as its name suggests, gives Dafny an expression that decreases with every loop iteration or recursive call. There are two conditions that Dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. Many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (See the reference for details.) In the case of integers, the bound is assumed to be zero. For example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nHere Dafny has all the ingredients it needs to prove termination. The variable i gets smaller each loop iteration, and is bounded below by zero. This is fine, except the loop is backwards from most loops, which tend to count up instead of down. In this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. A simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis is actually Dafnyâs guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. The upper bound of the loop invariant implies that 0 <= n â i, and gives Dafny a lower bound on the quantity. This also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nExercise 11. In the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. Note that if the loop guard were instead written as i != n (as in Exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. Change the loop guard to i != n and delete the invariant annotation. Does the program verify? What happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe other situation that requires a termination proof is when methods or functions are recursive. Similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. When Dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nAs before, Dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where Dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# Arrays\n\nAll that we have considered is fine for toy functions and little mathematical exercises, but it really isnât helpful for real programs. So far we have only considered a handful of values at a time in local variables. Now we turn our attention to arrays of data. Arrays are a built-in part of the language, with their own type, array<T>, where T is another type. For now we only consider arrays of integers, array<int>. Arrays can be null, and have a built-in length field, a.Length. Element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. All array accesses must be proven to be within bounds, which is part of Dafnyâs no-runtime-errors safety guarantee. Because bounds checks are proven at verification time, no runtime checks need to be made. To create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (See the tutorial on memory for more on allocation.)\n\nOne of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. We have two outcomes for a search, with a different correctness condition for each. If the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. This might be expressed as follows:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe array index here is safe because the implication operator is short circuiting. Short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. Using the short circuiting property of the implication operator, along with the boolean âandâ (&&), which is also short circuiting, is a common Dafny practice. The condition index < a.Length is necessary because otherwise the method could return a large integer which is not an index into the array. Together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nIf the key is not in the array, then we would like the method to return a negative number. In this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. To express this property, we turn to another common Dafny tool: quantifiers.\n\n\n# Quantifiers\n\nA quantifier in Dafny most often takes the form of a forall expression, also called a universal quantifier. As its name suggests, this expression is true if some property holds for all elements of some set. For now, we will consider the set of integers. An example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\nA quantifier introduces a temporary name for each element of the set it is considering. This is called the bound variable, in this case k. The bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (In general, one can have any number of bound variables, a topic we will return to later.) A pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). In this case, the property is that adding one to any integer makes a strictly larger integer. Dafny is able to prove this simple property automatically. Generally it is not very useful to quantify over infinite sets, such as all the integers. Instead, quantifiers are typically used to quantify over all elements in an array or data structure. We do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\nThis says that some property holds for each element of the array. The implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. Dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nWith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\nThus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nAs you can see, we have omitted the loop invariants on the while loop, so Dafny gives us a verification error on one of the postconditions. The reason we get an error is that Dafny does not know that the loop actually covers all the elements. In order to convince Dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). Just like the postcondition, we can use a quantifier to express this property:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThis says that everything before, but excluding, the current index is not the key. Notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. This common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. This means that it is true when entering the loop. We test the value of the array before we extend the non-key part of the array, so Dafny can prove that this invariant is preserved. One problem arises when we try to add this invariant: Dafny complains about the index being out of range for the array access within the invariant.\n\nThis code does not verify because there is no invariant on index, so it could be greater than the length of the array. Then the bound variable, k, could exceed the length of the array. To fix this, we put the standard bounds on index, 0 <= index <= a.Length. Note that because we say k < index, the array access is still protected from error even when index == a.Length. The use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. The complete method is given below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 12. Write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the arrayâs elements. Annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nA linear search is not very efficient, especially when many queries are made of the same data. If the array is sorted, then we can use the very efficient binary search procedure to find the key. But in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. We could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# Predicates\n\nA predicate is a function which returns a boolean. It is a simple but powerful idea that occurs throughout Dafny programs. For example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. The use of predicates makes our code shorter, as we do not need to write out a long property over and over. It can also make our code easier to read by giving a common property a name.\n\nThere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. We can write a quantifier that expresses the property, âif x is before y in the array, then x <= y,â as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\nHere we have two bound variables, j and k, which are both integers. The comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. Then the second part says that they are ordered properly with respect to one another. Quantifiers are just a type of boolean valued expression in Dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nNote that there is no return type, because predicates always return a boolean.\n\nDafny rejects this code as given, claiming that the predicate cannot read a. Fixing this issue requires another annotation, the reads annotation.\n\n\n# Framing\n\nThe sorted predicate is not able to access the array because the array was not included in the functionâs reading frame. The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. The reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. For example, we might have two arrays, one of which we know is sorted. If we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. While we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. In this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nA reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. Instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. The name of an array, like a in the above example, stands for all the elements of that array. One can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. Dafny will check that you do not read any memory location that is not stated in the reading frame. This means that function calls within a function must have reading frames that are a subset of the calling functionâs reading frame. One thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nFrames also affect methods. As you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. Methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. They are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. In combination with reads, modification restrictions allow Dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow Dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that Dafny can reason about.\n\nNote that framing only applies to the heap, or memory accessed through references. Local variables are not stored on the heap, so they cannot be mentioned in reads annotations. Note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. Arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nExercise 13. Modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nExercise 14. What happens if you remove the precondition a != null? Change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Binary Search\n\nPredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nWe have the same postconditions that we did for the linear search, as the goal is the same. The difference is that now we know the array is sorted. Because Dafny can unwrap functions, inside the body of the method it knows this too. We can then use that property to prove the correctness of the search. The method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nThis is a fairly standard binary search implementation. First we declare our range to search over. This can be thought of as the remaining space where the key could possibly be. The range is inclusive-exclusive, meaning it encompasses indices [low, high). The first invariant expresses the fact that this range is within the array. The second says that the key is not anywhere outside of this range. In the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. We need the addition of one when moving the lower end of the range because it is inclusive on the low side. If we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. We could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. In the above formulation, this is unnecessary because when low == high, the loop exits. But this means that no elements are left in the search range, so the key was not found. This can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nWhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). Thus the invariant says that all elements in the array are not the key, and the second postcondition holds. As you can see, it is easy to introduce subtle off by one errors in this code. With the invariants, not only can Dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nExercise 15. Change the assignments in the body of BinarySearch to set low to mid or to set high to mid - 1. In each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Conclusion\n\nWeâve seen a whirlwind tour of the major features of Dafny, and used it for some interesting, if a little on the small side, examples of what Dafny can do. But to really take advantage of the power Dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. Now that you are familiar with the basics of Dafny, you can peruse the tutorials on each of these topics at your leisure. Each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. The examples are also a good place to look for model Dafny programs. Finally, the reference contains the gritty details of Dafny syntax and semantics, for when you just need to know what the disjoint set operator is (itâs !!, for those interested).\n\nEven if you do not use Dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. Invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. When modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. They also ensure that APIs are used correctly, by formalizing behavior and requirements and enforcing correct usage. Reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',normalizedContent:'dafny documentation\n\n\n#\n\n\n# getting started with dafny: a guide\n\nbe sure to follow along with the code examples by clicking the âload in editorâ link in the corner. see what the tool says, try to fix programs on your own, and experiment!\n\n\n# introduction\n\ndafny is a language that is designed to make it easy to write correct code. this means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. to accomplish this, dafny relies on high-level annotations to reason about and prove correctness of code. the effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. this is often easier than writing the code, because annotations are shorter and more direct. for example, the following fragment of annotation in dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nthis says that for all integers k that are indices into the array, the value at that index is greater than zero. by writing these annotations, one is confident that the code is correct. further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nin addition to proving a correspondence to user supplied annotations, dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. this guarantee is a powerful one, and is a strong case in and of itself for the use of dafny and tools like it. dafny also proves the termination of code, except in specially designated loops.\n\nletâs get started writing some dafny programs.\n\n\n# methods\n\ndafny resembles a typical imperative programming language in many ways. there are methods, variables, types, loops, if statements, arrays, integers, and more. one of the basic units of any dafny program is the method. a method is a piece of imperative, executable code. in other languages, they might be called procedures, or functions, but in dafny the term âfunctionâ is reserved for a different concept that we will cover later. a method is declared in the following way:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a method called âabsâ which takes a single integer parameter, called âxâ, and returns a single integer, called âyâ. note that the types are required for each parameter and return value, and follow each name after a colon (:). also, the return values are named, and there can be multiple return values, as in below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthe method body is the code contained within the braces, which until now has been cleverly represented as â...â (which is not dafny syntax). the body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. for example, the multiplereturns method may be implemented as:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nassignments do not use â=â, but rather â:=â. (in fact, as dafny uses â==â for equality, there is no use of a single equals sign in dafny expressions.) simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. to return a value from a method, the value is assigned to one of the named return values sometime before a return statement. in fact, the return values act very much like local variables, and can be assigned to more than once. the input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. there are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (other comparison operators are <=, >, >=, != and ==, with the expected meaning. see the reference for more on operators.)\n\n\n# pre- and postconditions\n\nnone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). the real power of dafny comes from the ability to annotate these methods to specify their behavior. for example, one property that we observe with the abs method is that the result is always greater than or equal to zero, regardless of the input. we could put this observation in a comment, but then we would have no way to know whether the method actually had this property. further, if someone came along and changed the method, we wouldnât be guaranteed that the comment was changed to match. with annotations, we can have dafny prove that the property we claim of the method is true. there are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nthis property of the abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. postconditions, declared with the ensures keyword, are given as part of the methodâs declaration, after the return values (if present) and before the method body. the keyword is followed by the boolean expression. like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. in the case of the abs method, a reasonable postcondition is the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nyou can see here why return values are given names. this makes them easy to refer to in the postcondition of a method. when the expression is true, we say that the postcondition holds. the postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). in this case, the only property we are expressing is that the return value is always at least zero.\n\nsometimes there are multiple properties that we would like to establish about our code. in this case, we have two options. we can either join the two conditions together with the boolean âandâ operator (&&), or we can write multiple ensures specifications. the latter is basically the same as the former, but it seperates distinct properties. for example, the return value names from the multiplereturns method might lead one to guess the following postconditions:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition can also be written:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in dafny. (in general, most of the comparison operators can be chained, but only âin one directionâ, i.e. not mixing âgreater thanâ and âless thanâ. see the reference for details.)\n\nthe first way of expressing the postconditions separates the âlessâ part from the âmoreâ part, which may be desirable. another thing to note is that we have included one of the input parameters in the postcondition. this is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\ndafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). this means that dafny wasnât able to prove that this annotation holds every time the method returns. in general, there are two main causes for dafny verification errors: specifications that are inconsistent with the code, and situations where it is not âcleverâ enough to prove the required properties. differentiating between these two possibilities can be a difficult task, but fortunately, dafny and the boogie/z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nin this situation, dafny is correct in saying there is an error with the code. the key to the problem is that y is an integer, so it can be negative. if y is negative (or zero), then more can actually be smaller than or equal to x. our method will not work as intended unless y is strictly larger than zero. this is precisely the idea of a precondition. a precondition is similar to a postcondition, except that it is something that must be true before a method is called. when you call a method, it is your job to establish (make true) the preconditions, something dafny will enforce using a proof. likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. the caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. we can give the necessary precondition to multiplereturns as below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlike postconditions, multiple preconditions can be written either with the boolean âandâ operator (&&), or by multiple requires keywords. traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). with the addition of this condition, dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nexercise 0. write a method max that takes two integer parameters and returns their maximum. add appropriate annotations and make sure your code verifies.\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnot all methods necessarily have preconditions. for example, the abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). even though it has no need of preconditions, the abs function as it stands now is not very useful. to investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# assertions\n\nunlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. an assertion says that a particular expression always holds when control reaches that part of the code. for example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try "asserting" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny proves this method correct, as 2 is always less than 3. asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. you can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. assertions are a powerful tool for debugging annotations, by checking what dafny is able to prove about your code. for example, we can use it to investigate what dafny knows about the abs function.\n\nto do this, we need one more concept: local variables. local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (see the reference for details.) local variables are declared with the var keyword, and can optionally have type declarations. unlike method parameters, where types are required, dafny can infer the types of local variables in almost all situations. this is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nthe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nmultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nexplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. we needed variables because we want to talk about the return value of the abs method. we cannot put abs inside a specification directly, as the method could change memory state, among other problems. so we capture the return value of a call to abs as follows:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is an example of a situation where we can ask dafny what it knows about the values in the code, in this case v. we do this by adding assertions, like the one above. every time dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. in this example, there is only one control path through the method, and dafny is able to prove the annotation easily because it is exactly the postcondition of the abs method. abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to abs.\n\nexercise 1. write a test method that calls your max method from exercise 0 and then asserts something about the result.\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbut we know something stronger about the abs method. in particular, for non-negative x, abs(x) == x. specifically, in the above program, the value of v is 3. if we try adding an assertion (or changing the existing one) to say:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that dafny cannot prove our assertion, and gives an error. the reason this happens is that dafny âforgetsâ about the body of every method except the one it is currently working on. this simplifies dafnyâs job tremendously, and is one of the reasons it is able to operate at reasonable speeds. it also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). we donât care at all what happens inside each method when we call it, as long as it satisfies its annotations. this works because dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nfor the abs method, this means that the only thing dafny knows in the testing method about the value returned from abs is what the postconditions say about it, and nothing more. this means that dafny wonât know the nice property about abs and non-negative integers unless we tell it by putting this in the postcondition of the abs method. another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. in the abs case, we might have written:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nthis method satisfies the postconditions, but clearly the program fragment:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. dafny is considering, in an abstract way, all methods with those annotations. the mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. we need stronger postconditions to eliminate these other possibilities, and âfixâ the method down to exactly the one we want. we can partially do this with the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. the second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean âandâ and comparisons, so the above says 0 <= x implies y == x). the left and right sides must both be boolean expressions.\n\nthe postcondition says that after abs is called, if the value of x was non-negative, then y is equal to x. one caveat of the implication is that it is still true if the left part (the antecedent) is false. so the second postcondition is trivially true when x is negative. in fact, the only thing that the annotations say when x is negative is that the result, y, is positive. but this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nthese annotations are enough to require that our method actually computes the absolute value of x. these postconditions are not the only way to express this property. for example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nin general, there can be many ways to write down a given property. most of the time it doesnât matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nbut we still have an issue: there seems to be a lot of duplication. the body of the method is reflected very closely in the annotations. while this is correct code, we want to eliminate this redundancy. as you might guess, dafny provides a means of doing this: functions.\n\nexercise 2. using a precondition, change abs to say it can only be called on negative values. simplify the body of abs into just one return statement and make sure the method still verifies.\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 3. keeping the postconditions of abs the same as above, change the body of abs to just y := x + 2. what precondition do you need to annotate the method with in order for the verification to go through? what precondition do you need if the body is y := x + 1? what does that precondition say about when you can call the method?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a function called abs which takes a single integer, and returns an integer (the second int). unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. here our body must be an integer expression. in order to implement the absolute value function, we need to use an if expression. an if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nobviously, the condition must be a boolean expression, and the two branches must have the same type. you might wonder why anyone would bother with functions, if they are so limited compared to methods. the power of functions comes from the fact that they can be used directly in specifications. so we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nin fact, not only can we write this statement directly without capturing to a local variable, we didnât even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). the limitations of functions are precisely what let dafny do this. unlike methods, dafny does not forget the body of a function when considering other functions. so it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nexercise 4. write a function max that returns the larger of two given integer parameters. write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat of functions is that not only can they appear in annotations, they can only appear in annotations. one cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. functions are never part of the final compiled program, they are just tools to help us verify our code. sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. note that there are restrictions on what functions can be function methods (see the reference for details).\n\nexercise 5. change your test method from exercise 4 to capture the value of max to a variable, and then do the checks from exercise 4 using the variable. dafny will reject this program because you are calling max from real code. fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexercise 6. now that we have an abs function, change the postcondition of method abs to make use of abs. after confirming the method still verifies, change the body of abs to also use abs. (after doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nunlike methods, functions can appear in expressions. thus we can do something like implement the mathematical fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nhere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. it turns out that we could make this function a function method if we wanted to. but this would be extremely slow, as this version of calculating the fibonacci numbers has exponential complexity. there are much better ways to calculate the fibonacci function. but this function is still useful, as we can have dafny prove that a fast version really matches the mathematical definition. we can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nwe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwe havenât written the body yet, so dafny will complain that our postcondition doesnât hold. we need an algorithm to calculate the nth fibonacci number. the basic idea is to keep a counter, and repeatedly calculate adjacent pairs of fibonacci numbers until the desired number is reached. to do this, we need a loop. in dafny, this is done via a while loop. a while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nthis is a trivial loop that just increments i until it reaches n. this will form the core of our loop to calculate fibonacci numbers.\n\n\n# loop invariants\n\nwhile loops present a problem for dafny. there is no way for dafny to know in advance how many times the code will go around the loop. but dafny needs to consider all paths through a program, which could include going around the loop any number of times. to make it possible for dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\na loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. it captures something that is invariant, i.e. does not change, about every step of the loop. now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldnât need the loop. like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. for example, we see in the above loop that if i starts off positive, then it stays positive. so we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwhen you specify an invariant, dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. by preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). just as dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nin our example, the point of the loop is to build up the fibonacci numbers one (well, two) at a time until we reach the desired number. after we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. we can use our assertion trick to check to see if dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nwe find that this assertion fails. as far as dafny knows, it is possible that i somehow became much larger than n at some point during the loop. all it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. in this case, this amounts to n <= i and 0 <= i. but this is not enough to guarantee that i == n, just that n <= i. somehow we need to eliminate the possibility of i exceeding n. one first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthis does not verify, as dafny complains that the invariant is not preserved (also known as not maintained) by the loop. we want to be able to say that after the loop exits, then all the invariants hold. our invariant holds for every execution of the loop except for the very last one. because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nnow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows dafny to prove the assertion i == n. the challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nexercise 7. change the loop invariant to 0 <= i <= n+2. does the loop still verify? does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexercise 8. with the original loop invariant, change the loop guard from i < n to i != n. do the loop and the assertion after the loop still verify? why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nin addition to the counter, our algorithm called for a pair of numbers which represent adjacent fibonacci numbers in the sequence. unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. to find these invariants, we employ a common dafny trick: working backwards from the postconditions.\n\nour postcondition for the fibonacci method is that the return value b is equal to fib(n). but after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. this might make a good invariant, as it relates something to the loop counter. this observation is surprisingly common throughout dafny programs. often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. so we have that the variable b, which is conveniently our out parameter, will be the current fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nwe also note that in our algorithm, we can compute any fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. so we want a way of tracking the previous fibonacci number, which we will call a. another invariant will express that numberâs relation to the loop counter. the invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nat each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nhere a is the trailing number, and b is the leading number. the parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nwe also have made a change to the loop counter i. because we also want to track the trailing number, we canât start the counter at zero, as otherwise we would have to calculate a negative fibonacci number. the problem with doing this is that the loop counter invariant may not hold when we enter the loop. the only problem is when n is zero. this can be eliminated as a special case, by testing for this condition at the beginning of the loop. the completed fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nexercise 9. the computefib method above is more complicated than necessary. write a simpler program by not introducing a as the fibonacci number that precedes b, but instead introducing a variable c that succeeds b. verify your program is correct according to the mathematical definition of fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nexercise 10. starting with the completed computefib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\none of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. for example, we could have omitted the entire body of the loop in the previous program. the invariants would be correct, because they are still true upon entering the loop, and since the loop doesnât change anything, they would be preserved by the loop. we know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# termination\n\ndafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. for many things, dafny is able to guess the right annotations, but sometimes it needs to be made explicit. in fact, for all of the code we have seen so far, dafny has been able to do this proof on its own, which is why we havenât seen the decreases annotation explicitly yet. there are two places dafny proves termination: loops and recursion. both of these situations require either an explicit annotation or a correct guess by dafny.\n\na decreases annotation, as its name suggests, gives dafny an expression that decreases with every loop iteration or recursive call. there are two conditions that dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (see the reference for details.) in the case of integers, the bound is assumed to be zero. for example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nhere dafny has all the ingredients it needs to prove termination. the variable i gets smaller each loop iteration, and is bounded below by zero. this is fine, except the loop is backwards from most loops, which tend to count up instead of down. in this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. a simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis is actually dafnyâs guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. the upper bound of the loop invariant implies that 0 <= n â i, and gives dafny a lower bound on the quantity. this also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nexercise 11. in the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. note that if the loop guard were instead written as i != n (as in exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. change the loop guard to i != n and delete the invariant annotation. does the program verify? what happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe other situation that requires a termination proof is when methods or functions are recursive. similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. when dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nas before, dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# arrays\n\nall that we have considered is fine for toy functions and little mathematical exercises, but it really isnât helpful for real programs. so far we have only considered a handful of values at a time in local variables. now we turn our attention to arrays of data. arrays are a built-in part of the language, with their own type, array<t>, where t is another type. for now we only consider arrays of integers, array<int>. arrays can be null, and have a built-in length field, a.length. element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. all array accesses must be proven to be within bounds, which is part of dafnyâs no-runtime-errors safety guarantee. because bounds checks are proven at verification time, no runtime checks need to be made. to create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (see the tutorial on memory for more on allocation.)\n\none of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. we have two outcomes for a search, with a different correctness condition for each. if the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. this might be expressed as follows:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe array index here is safe because the implication operator is short circuiting. short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. using the short circuiting property of the implication operator, along with the boolean âandâ (&&), which is also short circuiting, is a common dafny practice. the condition index < a.length is necessary because otherwise the method could return a large integer which is not an index into the array. together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nif the key is not in the array, then we would like the method to return a negative number. in this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. to express this property, we turn to another common dafny tool: quantifiers.\n\n\n# quantifiers\n\na quantifier in dafny most often takes the form of a forall expression, also called a universal quantifier. as its name suggests, this expression is true if some property holds for all elements of some set. for now, we will consider the set of integers. an example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\na quantifier introduces a temporary name for each element of the set it is considering. this is called the bound variable, in this case k. the bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (in general, one can have any number of bound variables, a topic we will return to later.) a pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). in this case, the property is that adding one to any integer makes a strictly larger integer. dafny is able to prove this simple property automatically. generally it is not very useful to quantify over infinite sets, such as all the integers. instead, quantifiers are typically used to quantify over all elements in an array or data structure. we do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\nthis says that some property holds for each element of the array. the implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nwith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\nthus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nas you can see, we have omitted the loop invariants on the while loop, so dafny gives us a verification error on one of the postconditions. the reason we get an error is that dafny does not know that the loop actually covers all the elements. in order to convince dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). just like the postcondition, we can use a quantifier to express this property:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthis says that everything before, but excluding, the current index is not the key. notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. this common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. this means that it is true when entering the loop. we test the value of the array before we extend the non-key part of the array, so dafny can prove that this invariant is preserved. one problem arises when we try to add this invariant: dafny complains about the index being out of range for the array access within the invariant.\n\nthis code does not verify because there is no invariant on index, so it could be greater than the length of the array. then the bound variable, k, could exceed the length of the array. to fix this, we put the standard bounds on index, 0 <= index <= a.length. note that because we say k < index, the array access is still protected from error even when index == a.length. the use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. the complete method is given below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 12. write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the arrayâs elements. annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\na linear search is not very efficient, especially when many queries are made of the same data. if the array is sorted, then we can use the very efficient binary search procedure to find the key. but in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. we could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# predicates\n\na predicate is a function which returns a boolean. it is a simple but powerful idea that occurs throughout dafny programs. for example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. the use of predicates makes our code shorter, as we do not need to write out a long property over and over. it can also make our code easier to read by giving a common property a name.\n\nthere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. we can write a quantifier that expresses the property, âif x is before y in the array, then x <= y,â as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\nhere we have two bound variables, j and k, which are both integers. the comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. then the second part says that they are ordered properly with respect to one another. quantifiers are just a type of boolean valued expression in dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nnote that there is no return type, because predicates always return a boolean.\n\ndafny rejects this code as given, claiming that the predicate cannot read a. fixing this issue requires another annotation, the reads annotation.\n\n\n# framing\n\nthe sorted predicate is not able to access the array because the array was not included in the functionâs reading frame. the reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. the reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. for example, we might have two arrays, one of which we know is sorted. if we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. while we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. in this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. the name of an array, like a in the above example, stands for all the elements of that array. one can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. dafny will check that you do not read any memory location that is not stated in the reading frame. this means that function calls within a function must have reading frames that are a subset of the calling functionâs reading frame. one thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nframes also affect methods. as you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. they are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. in combination with reads, modification restrictions allow dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that dafny can reason about.\n\nnote that framing only applies to the heap, or memory accessed through references. local variables are not stored on the heap, so they cannot be mentioned in reads annotations. note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nexercise 13. modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexercise 14. what happens if you remove the precondition a != null? change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# binary search\n\npredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nwe have the same postconditions that we did for the linear search, as the goal is the same. the difference is that now we know the array is sorted. because dafny can unwrap functions, inside the body of the method it knows this too. we can then use that property to prove the correctness of the search. the method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nthis is a fairly standard binary search implementation. first we declare our range to search over. this can be thought of as the remaining space where the key could possibly be. the range is inclusive-exclusive, meaning it encompasses indices [low, high). the first invariant expresses the fact that this range is within the array. the second says that the key is not anywhere outside of this range. in the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. we need the addition of one when moving the lower end of the range because it is inclusive on the low side. if we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. we could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. in the above formulation, this is unnecessary because when low == high, the loop exits. but this means that no elements are left in the search range, so the key was not found. this can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nwhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). thus the invariant says that all elements in the array are not the key, and the second postcondition holds. as you can see, it is easy to introduce subtle off by one errors in this code. with the invariants, not only can dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nexercise 15. change the assignments in the body of binarysearch to set low to mid or to set high to mid - 1. in each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# conclusion\n\nweâve seen a whirlwind tour of the major features of dafny, and used it for some interesting, if a little on the small side, examples of what dafny can do. but to really take advantage of the power dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. now that you are familiar with the basics of dafny, you can peruse the tutorials on each of these topics at your leisure. each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. the examples are also a good place to look for model dafny programs. finally, the reference contains the gritty details of dafny syntax and semantics, for when you just need to know what the disjoint set operator is (itâs !!, for those interested).\n\neven if you do not use dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. when modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. they also ensure that apis are used correctly, by formalizing behavior and requirements and enforcing correct usage. reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"cheet",frontmatter:{title:"cheet",date:"2022-03-26T11:02:27.000Z",categories:["è¯­è¨","dafny-quick-start"],tags:[null],permalink:"/pages/fe5721/",readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/00.dafny-quick-start/20.cheet.html",relativePath:"80.è¯­è¨/00.dafny-quick-start/20.cheet.md",key:"v-e10e4096",path:"/pages/fe5721/",headers:[{level:2,title:"Specification",slug:"specification",normalizedTitle:"specification",charIndex:1855}],headersStr:"Specification",content:"KEYWORD(S)       WHAT IT DOES             SNIPPET\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { Foo(i);\n                                          }\nmethod returns   subroutines              /* Without a return value*/ method Hello() { print âHello\n                                          Dafnyâ; } /*With a return value */ method Norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* Multiple return values */\n                                          method Prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class Point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method Dist2(that: Point) returns\n                                          (z: real) requires that != null { z := Norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          Find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# Specification\n\nKEYWORD(S)             WHAT IT DOES              SNIPPET\nrequires               precondition              method Rot90(p: Point) returns (q: Point) requires p !=\n                                                 null{ q := new Point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.Length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.Length }\nmodifies               framing (for methods)     method Reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to âaâ otherwise */\nreads                  framing (for functions)   predicate Sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to âa[_]â otherwise */\ninvariant              loop invariants           i := 0;while i < a.Length invariant 0 <= i <= a.Length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.Length ==> a[k] ==\n                                                 0;",normalizedContent:"keyword(s)       what it does             snippet\nvar              declares variables       var nish: int;var m := 5; inferred type var i: int, j:\n                                          nat;var x, y, z: bool := 1, 2, true;\n:=               assignment               z := false;x, y := x+y, x-y; /* parallel assignment */\nif..else         conditional statement    if z { x := x + 1; } /* braces are* / else{ y := y - 1; } /*\n                                          mandatory */\nif..then..else   conditional expression   m := if x < y then x else y;\nwhile forall     loops                    while x > y { x := x - y; } forall i | 0 <= i < m { foo(i);\n                                          }\nmethod returns   subroutines              /* without a return value*/ method hello() { print âhello\n                                          dafnyâ; } /*with a return value */ method norm2(x: real, y:\n                                          real) returns (z: real) /* return values */ { /* must be\n                                          named */ z := x * x + y * y;}/* multiple return values */\n                                          method prod(x: int) returns(dbl: int, trpl: int){ dbl, trpl\n                                          := x * 2, x * 3; }\nclass            object classes           class point /* classes contain */{ /* variables and methods\n                                          */ var x: real, y: real method dist2(that: point) returns\n                                          (z: real) requires that != null { z := norm2(x - that.x, y -\n                                          that.y); }}\narray            typed arrays             var a := new bool[2];a[0], a[1] := true, false;method\n                                          find(a: array<int>, v: int) returns (index: int)\n                                          \n\n\n# specification\n\nkeyword(s)             what it does              snippet\nrequires               precondition              method rot90(p: point) returns (q: point) requires p !=\n                                                 null{ q := new point; q.x, q.y := -p.y, p.x; }\nensures                postcondition             method max(a: nat, b: nat) returns (m: nat) ensures m >= a\n                                                 /* can have as many */ ensures m >= b /* as you like */{ if\n                                                 a > b { m := a; } else { m := b; } }\nassert assume          inline propositions       assume x > 1;assert 2 * x + x / x > 3;\n! && || ==> <== <==>   logical connectives       assume (z || !z) && x > y;assert j < a.length ==> a[j]*a[j]\n                                                 >= 0;assert !(a && b) <==> !a || !b;\nforall exists          logical quantifiers       assume forall n: nat :: n >= 0; assert forall k :: k + 1 >\n                                                 k; /* inferred k:int */\nfunction predicate     pure definitions          function min(a: nat, b: nat): nat{ /* body must be an\n                                                 expression */ if a < b then a else b }predicate win(a:\n                                                 array<int>, j: int) requires a != null{ /* just like\n                                                 function(...): bool */ 0 <= j < a.length }\nmodifies               framing (for methods)     method reverse(a: array<int>) /* not allowed to */ modifies\n                                                 a /* assign to âaâ otherwise */\nreads                  framing (for functions)   predicate sorted(a: array<int>) /* not allowed to */ reads a\n                                                 /* refer to âa[_]â otherwise */\ninvariant              loop invariants           i := 0;while i < a.length invariant 0 <= i <= a.length\n                                                 invariant forall k :: 0 <= k < i ==> a[k] == 0{ a[i], i :=\n                                                 0, i + 1; } assert forall k :: 0 <= k < a.length ==> a[k] ==\n                                                 0;",charsets:{cjk:!0},lastUpdated:"2022/03/26, 19:35:15",lastUpdatedTimestamp:1648294515e3},{title:"Getting Started with Dafny A Guide",frontmatter:{title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:03:41.000Z",permalink:"/pages/c80a4c/",categories:["è¯­è¨","dafny-tutorials"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/10.dafny-tutorials/00.Getting%20Started%20with%20Dafny%20A%20Guide.html",relativePath:"80.è¯­è¨/10.dafny-tutorials/00.Getting Started with Dafny A Guide.md",key:"v-6f2fc85c",path:"/pages/c80a4c/",headers:[{level:2,title:"Getting Started with Dafny: A Guide",slug:"getting-started-with-dafny-a-guide",normalizedTitle:"getting started with dafny: a guide",charIndex:28},{level:3,title:"Introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:242},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:1945},{level:3,title:"Pre- and Postconditions",slug:"pre-and-postconditions",normalizedTitle:"pre- and postconditions",charIndex:5156},{level:3,title:"Assertions",slug:"assertions",normalizedTitle:"assertions",charIndex:12244},{level:3,title:"Functions",slug:"functions",normalizedTitle:"functions",charIndex:22875},{level:3,title:"Loop Invariants",slug:"loop-invariants",normalizedTitle:"loop invariants",charIndex:28455},{level:3,title:"Termination",slug:"termination",normalizedTitle:"termination",charIndex:39962},{level:3,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:43929},{level:3,title:"Quantifiers",slug:"quantifiers",normalizedTitle:"quantifiers",charIndex:46819},{level:3,title:"Predicates",slug:"predicates",normalizedTitle:"predicates",charIndex:53780},{level:3,title:"Framing",slug:"framing",normalizedTitle:"framing",charIndex:55371},{level:3,title:"Binary Search",slug:"binary-search",normalizedTitle:"binary search",charIndex:59349},{level:3,title:"Conclusion",slug:"conclusion",normalizedTitle:"conclusion",charIndex:64781}],headersStr:"Getting Started with Dafny: A Guide Introduction Methods Pre- and Postconditions Assertions Functions Loop Invariants Termination Arrays Quantifiers Predicates Framing Binary Search Conclusion",content:'Dafny Documentation\n\n\n#\n\n\n# Getting Started with Dafny: A Guide\n\nBe sure to follow along with the code examples by clicking the âload in editorâ link in the corner. See what the tool says, try to fix programs on your own, and experiment!\n\n\n# Introduction\n\nDafny is a language that is designed to make it easy to write correct code. This means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. To accomplish this, Dafny relies on high-level annotations to reason about and prove correctness of code. The effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. Dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). Dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. This is often easier than writing the code, because annotations are shorter and more direct. For example, the following fragment of annotation in Dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n\n\n1\n\n\nThis says that for all integers k that are indices into the array, the value at that index is greater than zero. By writing these annotations, one is confident that the code is correct. Further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nIn addition to proving a correspondence to user supplied annotations, Dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. This guarantee is a powerful one, and is a strong case in and of itself for the use of Dafny and tools like it. Dafny also proves the termination of code, except in specially designated loops.\n\nLetâs get started writing some Dafny programs.\n\n\n# Methods\n\nDafny resembles a typical imperative programming language in many ways. There are methods, variables, types, loops, if statements, arrays, integers, and more. One of the basic units of any Dafny program is the method. A method is a piece of imperative, executable code. In other languages, they might be called procedures, or functions, but in Dafny the term âfunctionâ is reserved for a different concept that we will cover later. A method is declared in the following way:\n\nmethod Abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a method called âAbsâ which takes a single integer parameter, called âxâ, and returns a single integer, called âyâ. Note that the types are required for each parameter and return value, and follow each name after a colon (:). Also, the return values are named, and there can be multiple return values, as in below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThe method body is the code contained within the braces, which until now has been cleverly represented as â...â (which is not Dafny syntax). The body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. For example, the MultipleReturns method may be implemented as:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nAssignments do not use â=â, but rather â:=â. (In fact, as Dafny uses â==â for equality, there is no use of a single equals sign in Dafny expressions.) Simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. To return a value from a method, the value is assigned to one of the named return values sometime before a return statement. In fact, the return values act very much like local variables, and can be assigned to more than once. The input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. Return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. There are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). Here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (Other comparison operators are <=, >, >=, != and ==, with the expected meaning. See the reference for more on operators.)\n\n\n# Pre- and Postconditions\n\nNone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). The real power of Dafny comes from the ability to annotate these methods to specify their behavior. For example, one property that we observe with the Abs method is that the result is always greater than or equal to zero, regardless of the input. We could put this observation in a comment, but then we would have no way to know whether the method actually had this property. Further, if someone came along and changed the method, we wouldnât be guaranteed that the comment was changed to match. With annotations, we can have Dafny prove that the property we claim of the method is true. There are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nThis property of the Abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. Postconditions, declared with the ensures keyword, are given as part of the methodâs declaration, after the return values (if present) and before the method body. The keyword is followed by the boolean expression. Like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. In the case of the Abs method, a reasonable postcondition is the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nYou can see here why return values are given names. This makes them easy to refer to in the postcondition of a method. When the expression is true, we say that the postcondition holds. The postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). In this case, the only property we are expressing is that the return value is always at least zero.\n\nSometimes there are multiple properties that we would like to establish about our code. In this case, we have two options. We can either join the two conditions together with the boolean âandâ operator (&&), or we can write multiple ensures specifications. The latter is basically the same as the former, but it seperates distinct properties. For example, the return value names from the MultipleReturns method might lead one to guess the following postconditions:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition can also be written:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in Dafny. (In general, most of the comparison operators can be chained, but only âin one directionâ, i.e. not mixing âgreater thanâ and âless thanâ. See the reference for details.)\n\nThe first way of expressing the postconditions separates the âlessâ part from the âmoreâ part, which may be desirable. Another thing to note is that we have included one of the input parameters in the postcondition. This is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\nDafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). This means that Dafny wasnât able to prove that this annotation holds every time the method returns. In general, there are two main causes for Dafny verification errors: specifications that are inconsistent with the code, and situations where it is not âcleverâ enough to prove the required properties. Differentiating between these two possibilities can be a difficult task, but fortunately, Dafny and the Boogie/Z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nIn this situation, Dafny is correct in saying there is an error with the code. The key to the problem is that y is an integer, so it can be negative. If y is negative (or zero), then more can actually be smaller than or equal to x. Our method will not work as intended unless y is strictly larger than zero. This is precisely the idea of a precondition. A precondition is similar to a postcondition, except that it is something that must be true before a method is called. When you call a method, it is your job to establish (make true) the preconditions, something Dafny will enforce using a proof. Likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. The caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. We can give the necessary precondition to MultipleReturns as below:\n\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nLike postconditions, multiple preconditions can be written either with the boolean âandâ operator (&&), or by multiple requires keywords. Traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). With the addition of this condition, Dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nExercise 0. Write a method Max that takes two integer parameters and returns their maximum. Add appropriate annotations and make sure your code verifies.\n\nmethod Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNot all methods necessarily have preconditions. For example, the Abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). Even though it has no need of preconditions, the Abs function as it stands now is not very useful. To investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# Assertions\n\nUnlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. Like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. An assertion says that a particular expression always holds when control reaches that part of the code. For example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod Testing()\n{\n   assert 2 < 3;\n   // Try "asserting" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nDafny proves this method correct, as 2 is always less than 3. Asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. You can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. Assertions are a powerful tool for debugging annotations, by checking what Dafny is able to prove about your code. For example, we can use it to investigate what Dafny knows about the Abs function.\n\nTo do this, we need one more concept: local variables. Local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (See the reference for details.) Local variables are declared with the var keyword, and can optionally have type declarations. Unlike method parameters, where types are required, Dafny can infer the types of local variables in almost all situations. This is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nThe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nMultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nExplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. We needed variables because we want to talk about the return value of the Abs method. We cannot put Abs inside a specification directly, as the method could change memory state, among other problems. So we capture the return value of a call to Abs as follows:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is an example of a situation where we can ask Dafny what it knows about the values in the code, in this case v. We do this by adding assertions, like the one above. Every time Dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. In this example, there is only one control path through the method, and Dafny is able to prove the annotation easily because it is exactly the postcondition of the Abs method. Abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to Abs.\n\nExercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n\nmethod Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nBut we know something stronger about the Abs method. In particular, for non-negative x, Abs(x) == x. Specifically, in the above program, the value of v is 3. If we try adding an assertion (or changing the existing one) to say:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that Dafny cannot prove our assertion, and gives an error. The reason this happens is that Dafny âforgetsâ about the body of every method except the one it is currently working on. This simplifies Dafnyâs job tremendously, and is one of the reasons it is able to operate at reasonable speeds. It also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). We donât care at all what happens inside each method when we call it, as long as it satisfies its annotations. This works because Dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nFor the Abs method, this means that the only thing Dafny knows in the Testing method about the value returned from Abs is what the postconditions say about it, and nothing more. This means that Dafny wonât know the nice property about Abs and non-negative integers unless we tell it by putting this in the postcondition of the Abs method. Another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. Everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. In the Abs case, we might have written:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nThis method satisfies the postconditions, but clearly the program fragment:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. Dafny is considering, in an abstract way, all methods with those annotations. The mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. We need stronger postconditions to eliminate these other possibilities, and âfixâ the method down to exactly the one we want. We can partially do this with the following:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. The second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean âandâ and comparisons, so the above says 0 <= x implies y == x). The left and right sides must both be boolean expressions.\n\nThe postcondition says that after Abs is called, if the value of x was non-negative, then y is equal to x. One caveat of the implication is that it is still true if the left part (the antecedent) is false. So the second postcondition is trivially true when x is negative. In fact, the only thing that the annotations say when x is negative is that the result, y, is positive. But this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nThese annotations are enough to require that our method actually computes the absolute value of x. These postconditions are not the only way to express this property. For example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIn general, there can be many ways to write down a given property. Most of the time it doesnât matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nBut we still have an issue: there seems to be a lot of duplication. The body of the method is reflected very closely in the annotations. While this is correct code, we want to eliminate this redundancy. As you might guess, Dafny provides a means of doing this: functions.\n\nExercise 2. Using a precondition, change Abs to say it can only be called on negative values. Simplify the body of Abs into just one return statement and make sure the method still verifies.\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 3. Keeping the postconditions of Abs the same as above, change the body of Abs to just y := x + 2. What precondition do you need to annotate the method with in order for the verification to go through? What precondition do you need if the body is y := x + 1? What does that precondition say about when you can call the method?\n\nmethod Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nThis declares a function called abs which takes a single integer, and returns an integer (the second int). Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. Here our body must be an integer expression. In order to implement the absolute value function, we need to use an if expression. An if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nObviously, the condition must be a boolean expression, and the two branches must have the same type. You might wonder why anyone would bother with functions, if they are so limited compared to methods. The power of functions comes from the fact that they can be used directly in specifications. So we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nIn fact, not only can we write this statement directly without capturing to a local variable, we didnât even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). The limitations of functions are precisely what let Dafny do this. Unlike methods, Dafny does not forget the body of a function when considering other functions. So it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nExercise 4. Write a function max that returns the larger of two given integer parameters. Write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nOne caveat of functions is that not only can they appear in annotations, they can only appear in annotations. One cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. Functions are never part of the final compiled program, they are just tools to help us verify our code. Sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. Note that there are restrictions on what functions can be function methods (See the reference for details).\n\nExercise 5. Change your test method from Exercise 4 to capture the value of max to a variable, and then do the checks from Exercise 4 using the variable. Dafny will reject this program because you are calling max from real code. Fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nExercise 6. Now that we have an abs function, change the postcondition of method Abs to make use of abs. After confirming the method still verifies, change the body of Abs to also use abs. (After doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nUnlike methods, functions can appear in expressions. Thus we can do something like implement the mathematical Fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nHere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. It turns out that we could make this function a function method if we wanted to. But this would be extremely slow, as this version of calculating the Fibonacci numbers has exponential complexity. There are much better ways to calculate the Fibonacci function. But this function is still useful, as we can have Dafny prove that a fast version really matches the mathematical definition. We can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nWe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWe havenât written the body yet, so Dafny will complain that our postcondition doesnât hold. We need an algorithm to calculate the nth Fibonacci number. The basic idea is to keep a counter, and repeatedly calculate adjacent pairs of Fibonacci numbers until the desired number is reached. To do this, we need a loop. In Dafny, this is done via a while loop. A while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nThis is a trivial loop that just increments i until it reaches n. This will form the core of our loop to calculate Fibonacci numbers.\n\n\n# Loop Invariants\n\nwhile loops present a problem for Dafny. There is no way for Dafny to know in advance how many times the code will go around the loop. But Dafny needs to consider all paths through a program, which could include going around the loop any number of times. To make it possible for Dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\nA loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. It captures something that is invariant, i.e. does not change, about every step of the loop. Now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldnât need the loop. Like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. For example, we see in the above loop that if i starts off positive, then it stays positive. So we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWhen you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. By preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. Dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). Just as Dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nIn our example, the point of the loop is to build up the Fibonacci numbers one (well, two) at a time until we reach the desired number. After we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. We can use our assertion trick to check to see if Dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nWe find that this assertion fails. As far as Dafny knows, it is possible that i somehow became much larger than n at some point during the loop. All it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. In this case, this amounts to n <= i and 0 <= i. But this is not enough to guarantee that i == n, just that n <= i. Somehow we need to eliminate the possibility of i exceeding n. One first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThis does not verify, as Dafny complains that the invariant is not preserved (also known as not maintained) by the loop. We want to be able to say that after the loop exits, then all the invariants hold. Our invariant holds for every execution of the loop except for the very last one. Because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. Thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nNow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows Dafny to prove the assertion i == n. The challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nExercise 7. Change the loop invariant to 0 <= i <= n+2. Does the loop still verify? Does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExercise 8. With the original loop invariant, change the loop guard from i < n to i != n. Do the loop and the assertion after the loop still verify? Why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIn addition to the counter, our algorithm called for a pair of numbers which represent adjacent Fibonacci numbers in the sequence. Unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. To find these invariants, we employ a common Dafny trick: working backwards from the postconditions.\n\nOur postcondition for the Fibonacci method is that the return value b is equal to fib(n). But after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. This might make a good invariant, as it relates something to the loop counter. This observation is surprisingly common throughout Dafny programs. Often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. So we have that the variable b, which is conveniently our out parameter, will be the current Fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nWe also note that in our algorithm, we can compute any Fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. So we want a way of tracking the previous Fibonacci number, which we will call a. Another invariant will express that numberâs relation to the loop counter. The invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nAt each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. Using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nHere a is the trailing number, and b is the leading number. The parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. Thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nWe also have made a change to the loop counter i. Because we also want to track the trailing number, we canât start the counter at zero, as otherwise we would have to calculate a negative Fibonacci number. The problem with doing this is that the loop counter invariant may not hold when we enter the loop. The only problem is when n is zero. This can be eliminated as a special case, by testing for this condition at the beginning of the loop. The completed Fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nDafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. Dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nExercise 9. The ComputeFib method above is more complicated than necessary. Write a simpler program by not introducing a as the Fibonacci number that precedes b, but instead introducing a variable c that succeeds b. Verify your program is correct according to the mathematical definition of Fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nExercise 10. Starting with the completed ComputeFib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. Verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nOne of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. For example, we could have omitted the entire body of the loop in the previous program. The invariants would be correct, because they are still true upon entering the loop, and since the loop doesnât change anything, they would be preserved by the loop. We know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. Thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# Termination\n\nDafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. For many things, Dafny is able to guess the right annotations, but sometimes it needs to be made explicit. In fact, for all of the code we have seen so far, Dafny has been able to do this proof on its own, which is why we havenât seen the decreases annotation explicitly yet. There are two places Dafny proves termination: loops and recursion. Both of these situations require either an explicit annotation or a correct guess by Dafny.\n\nA decreases annotation, as its name suggests, gives Dafny an expression that decreases with every loop iteration or recursive call. There are two conditions that Dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. Many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (See the reference for details.) In the case of integers, the bound is assumed to be zero. For example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nHere Dafny has all the ingredients it needs to prove termination. The variable i gets smaller each loop iteration, and is bounded below by zero. This is fine, except the loop is backwards from most loops, which tend to count up instead of down. In this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. A simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis is actually Dafnyâs guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. The upper bound of the loop invariant implies that 0 <= n â i, and gives Dafny a lower bound on the quantity. This also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nExercise 11. In the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. Note that if the loop guard were instead written as i != n (as in Exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. Change the loop guard to i != n and delete the invariant annotation. Does the program verify? What happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe other situation that requires a termination proof is when methods or functions are recursive. Similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. When Dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nAs before, Dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where Dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# Arrays\n\nAll that we have considered is fine for toy functions and little mathematical exercises, but it really isnât helpful for real programs. So far we have only considered a handful of values at a time in local variables. Now we turn our attention to arrays of data. Arrays are a built-in part of the language, with their own type, array<T>, where T is another type. For now we only consider arrays of integers, array<int>. Arrays can be null, and have a built-in length field, a.Length. Element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. All array accesses must be proven to be within bounds, which is part of Dafnyâs no-runtime-errors safety guarantee. Because bounds checks are proven at verification time, no runtime checks need to be made. To create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (See the tutorial on memory for more on allocation.)\n\nOne of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. We have two outcomes for a search, with a different correctness condition for each. If the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. This might be expressed as follows:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe array index here is safe because the implication operator is short circuiting. Short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. Using the short circuiting property of the implication operator, along with the boolean âandâ (&&), which is also short circuiting, is a common Dafny practice. The condition index < a.Length is necessary because otherwise the method could return a large integer which is not an index into the array. Together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nIf the key is not in the array, then we would like the method to return a negative number. In this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. To express this property, we turn to another common Dafny tool: quantifiers.\n\n\n# Quantifiers\n\nA quantifier in Dafny most often takes the form of a forall expression, also called a universal quantifier. As its name suggests, this expression is true if some property holds for all elements of some set. For now, we will consider the set of integers. An example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\nA quantifier introduces a temporary name for each element of the set it is considering. This is called the bound variable, in this case k. The bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (In general, one can have any number of bound variables, a topic we will return to later.) A pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). In this case, the property is that adding one to any integer makes a strictly larger integer. Dafny is able to prove this simple property automatically. Generally it is not very useful to quantify over infinite sets, such as all the integers. Instead, quantifiers are typically used to quantify over all elements in an array or data structure. We do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n\n\n1\n\n\nThis says that some property holds for each element of the array. The implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. Dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nWith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.Length ==> a[k] != key\n\n\n1\n\n\nThus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nAs you can see, we have omitted the loop invariants on the while loop, so Dafny gives us a verification error on one of the postconditions. The reason we get an error is that Dafny does not know that the loop actually covers all the elements. In order to convince Dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). Just like the postcondition, we can use a quantifier to express this property:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThis says that everything before, but excluding, the current index is not the key. Notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. This common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. This means that it is true when entering the loop. We test the value of the array before we extend the non-key part of the array, so Dafny can prove that this invariant is preserved. One problem arises when we try to add this invariant: Dafny complains about the index being out of range for the array access within the invariant.\n\nThis code does not verify because there is no invariant on index, so it could be greater than the length of the array. Then the bound variable, k, could exceed the length of the array. To fix this, we put the standard bounds on index, 0 <= index <= a.Length. Note that because we say k < index, the array access is still protected from error even when index == a.Length. The use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. The complete method is given below:\n\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nExercise 12. Write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the arrayâs elements. Annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nA linear search is not very efficient, especially when many queries are made of the same data. If the array is sorted, then we can use the very efficient binary search procedure to find the key. But in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. We could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# Predicates\n\nA predicate is a function which returns a boolean. It is a simple but powerful idea that occurs throughout Dafny programs. For example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. The use of predicates makes our code shorter, as we do not need to write out a long property over and over. It can also make our code easier to read by giving a common property a name.\n\nThere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. We can write a quantifier that expresses the property, âif x is before y in the array, then x <= y,â as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n\n\n1\n\n\nHere we have two bound variables, j and k, which are both integers. The comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. Then the second part says that they are ordered properly with respect to one another. Quantifiers are just a type of boolean valued expression in Dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nNote that there is no return type, because predicates always return a boolean.\n\nDafny rejects this code as given, claiming that the predicate cannot read a. Fixing this issue requires another annotation, the reads annotation.\n\n\n# Framing\n\nThe sorted predicate is not able to access the array because the array was not included in the functionâs reading frame. The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. The reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. For example, we might have two arrays, one of which we know is sorted. If we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. While we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. In this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nA reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. Instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. The name of an array, like a in the above example, stands for all the elements of that array. One can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. Dafny will check that you do not read any memory location that is not stated in the reading frame. This means that function calls within a function must have reading frames that are a subset of the calling functionâs reading frame. One thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nFrames also affect methods. As you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. Methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. They are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. In combination with reads, modification restrictions allow Dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow Dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that Dafny can reason about.\n\nNote that framing only applies to the heap, or memory accessed through references. Local variables are not stored on the heap, so they cannot be mentioned in reads annotations. Note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. Arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nExercise 13. Modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nExercise 14. What happens if you remove the precondition a != null? Change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Binary Search\n\nPredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nWe have the same postconditions that we did for the linear search, as the goal is the same. The difference is that now we know the array is sorted. Because Dafny can unwrap functions, inside the body of the method it knows this too. We can then use that property to prove the correctness of the search. The method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nThis is a fairly standard binary search implementation. First we declare our range to search over. This can be thought of as the remaining space where the key could possibly be. The range is inclusive-exclusive, meaning it encompasses indices [low, high). The first invariant expresses the fact that this range is within the array. The second says that the key is not anywhere outside of this range. In the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. We need the addition of one when moving the lower end of the range because it is inclusive on the low side. If we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. We could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. In the above formulation, this is unnecessary because when low == high, the loop exits. But this means that no elements are left in the search range, so the key was not found. This can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nWhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). Thus the invariant says that all elements in the array are not the key, and the second postcondition holds. As you can see, it is easy to introduce subtle off by one errors in this code. With the invariants, not only can Dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nExercise 15. Change the assignments in the body of BinarySearch to set low to mid or to set high to mid - 1. In each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# Conclusion\n\nWeâve seen a whirlwind tour of the major features of Dafny, and used it for some interesting, if a little on the small side, examples of what Dafny can do. But to really take advantage of the power Dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. Now that you are familiar with the basics of Dafny, you can peruse the tutorials on each of these topics at your leisure. Each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. The examples are also a good place to look for model Dafny programs. Finally, the reference contains the gritty details of Dafny syntax and semantics, for when you just need to know what the disjoint set operator is (itâs !!, for those interested).\n\nEven if you do not use Dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. Invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. When modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. They also ensure that APIs are used correctly, by formalizing behavior and requirements and enforcing correct usage. Reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',normalizedContent:'dafny documentation\n\n\n#\n\n\n# getting started with dafny: a guide\n\nbe sure to follow along with the code examples by clicking the âload in editorâ link in the corner. see what the tool says, try to fix programs on your own, and experiment!\n\n\n# introduction\n\ndafny is a language that is designed to make it easy to write correct code. this means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. to accomplish this, dafny relies on high-level annotations to reason about and prove correctness of code. the effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). dafny lifts the burden of writing bug-free code into that of writing bug-free annotations. this is often easier than writing the code, because annotations are shorter and more direct. for example, the following fragment of annotation in dafny says that every element of the array is strictly positive:\n\nforall k: int :: 0 <= k < a.length ==> 0 < a[k]\n\n\n1\n\n\nthis says that for all integers k that are indices into the array, the value at that index is greater than zero. by writing these annotations, one is confident that the code is correct. further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.\n\nin addition to proving a correspondence to user supplied annotations, dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. this guarantee is a powerful one, and is a strong case in and of itself for the use of dafny and tools like it. dafny also proves the termination of code, except in specially designated loops.\n\nletâs get started writing some dafny programs.\n\n\n# methods\n\ndafny resembles a typical imperative programming language in many ways. there are methods, variables, types, loops, if statements, arrays, integers, and more. one of the basic units of any dafny program is the method. a method is a piece of imperative, executable code. in other languages, they might be called procedures, or functions, but in dafny the term âfunctionâ is reserved for a different concept that we will cover later. a method is declared in the following way:\n\nmethod abs(x: int) returns (y: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a method called âabsâ which takes a single integer parameter, called âxâ, and returns a single integer, called âyâ. note that the types are required for each parameter and return value, and follow each name after a colon (:). also, the return values are named, and there can be multiple return values, as in below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthe method body is the code contained within the braces, which until now has been cleverly represented as â...â (which is not dafny syntax). the body consists of a series of statements, such as the familiar imperative assignments, if statements, loops, other method calls, return statements, etc. for example, the multiplereturns method may be implemented as:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nassignments do not use â=â, but rather â:=â. (in fact, as dafny uses â==â for equality, there is no use of a single equals sign in dafny expressions.) simple statements must be followed by a semicolon, and whitespace and comments (// and /**/) are ignored. to return a value from a method, the value is assigned to one of the named return values sometime before a return statement. in fact, the return values act very much like local variables, and can be assigned to more than once. the input parameters, however, are read only. return statements are used when one wants to return before reaching the end of the body block of the method. return statements can be just the return keyword (where the current value of the out parameters are used), or they can take a list of values to return. there are also compound statements, such as if statements. if statements do not require parentheses around the boolean condition, and act as one would expect:\n\nmethod abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). here the if statement checks whether x is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (other comparison operators are <=, >, >=, != and ==, with the expected meaning. see the reference for more on operators.)\n\n\n# pre- and postconditions\n\nnone of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). the real power of dafny comes from the ability to annotate these methods to specify their behavior. for example, one property that we observe with the abs method is that the result is always greater than or equal to zero, regardless of the input. we could put this observation in a comment, but then we would have no way to know whether the method actually had this property. further, if someone came along and changed the method, we wouldnât be guaranteed that the comment was changed to match. with annotations, we can have dafny prove that the property we claim of the method is true. there are several ways to give annotations, but some of the most common, and most basic, are method pre- and postconditions.\n\nthis property of the abs method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. postconditions, declared with the ensures keyword, are given as part of the methodâs declaration, after the return values (if present) and before the method body. the keyword is followed by the boolean expression. like an if or while condition and most specifications, a postcondition is always a boolean expression: something that can be true or false. in the case of the abs method, a reasonable postcondition is the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nyou can see here why return values are given names. this makes them easy to refer to in the postcondition of a method. when the expression is true, we say that the postcondition holds. the postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). in this case, the only property we are expressing is that the return value is always at least zero.\n\nsometimes there are multiple properties that we would like to establish about our code. in this case, we have two options. we can either join the two conditions together with the boolean âandâ operator (&&), or we can write multiple ensures specifications. the latter is basically the same as the former, but it seperates distinct properties. for example, the return value names from the multiplereturns method might lead one to guess the following postconditions:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition can also be written:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nor even:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbecause of the chaining comparison operator syntax in dafny. (in general, most of the comparison operators can be chained, but only âin one directionâ, i.e. not mixing âgreater thanâ and âless thanâ. see the reference for details.)\n\nthe first way of expressing the postconditions separates the âlessâ part from the âmoreâ part, which may be desirable. another thing to note is that we have included one of the input parameters in the postcondition. this is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).\n\ndafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). this means that dafny wasnât able to prove that this annotation holds every time the method returns. in general, there are two main causes for dafny verification errors: specifications that are inconsistent with the code, and situations where it is not âcleverâ enough to prove the required properties. differentiating between these two possibilities can be a difficult task, but fortunately, dafny and the boogie/z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.\n\nin this situation, dafny is correct in saying there is an error with the code. the key to the problem is that y is an integer, so it can be negative. if y is negative (or zero), then more can actually be smaller than or equal to x. our method will not work as intended unless y is strictly larger than zero. this is precisely the idea of a precondition. a precondition is similar to a postcondition, except that it is something that must be true before a method is called. when you call a method, it is your job to establish (make true) the preconditions, something dafny will enforce using a proof. likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. the caller of the method then gets to assume that the postconditions hold after the method returns.\n\npreconditions have their own keyword, requires. we can give the necessary precondition to multiplereturns as below:\n\nmethod multiplereturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nlike postconditions, multiple preconditions can be written either with the boolean âandâ operator (&&), or by multiple requires keywords. traditionally, requires precede ensures in the source code, though this is not strictly necessary (although the order of the requires and ensures annotations with respect to others of the same type can sometimes matter, as we will see later). with the addition of this condition, dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.\n\nexercise 0. write a method max that takes two integer parameters and returns their maximum. add appropriate annotations and make sure your code verifies.\n\nmethod max(a: int, b: int) returns (c: int)\n  // what postcondition should go here, so that the function operates as expected?\n  // hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod max(a: int, b: int) returns (c: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnot all methods necessarily have preconditions. for example, the abs method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). even though it has no need of preconditions, the abs function as it stands now is not very useful. to investigate why, we need to make use of another kind of annotation, the assertion.\n\n\n# assertions\n\nunlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. like the previous two annotations, an assertion has a keyword, assert, followed by the boolean expression and the semicolon that terminates simple statements. an assertion says that a particular expression always holds when control reaches that part of the code. for example, the following is a trivial use of an assertion inside a dummy method:\n\nmethod testing()\n{\n   assert 2 < 3;\n   // try "asserting" something that is not true.\n   // what does dafny output?\n}\nmethod testing()\n{\n   assert 2 < 3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ndafny proves this method correct, as 2 is always less than 3. asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. you can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. assertions are a powerful tool for debugging annotations, by checking what dafny is able to prove about your code. for example, we can use it to investigate what dafny knows about the abs function.\n\nto do this, we need one more concept: local variables. local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (see the reference for details.) local variables are declared with the var keyword, and can optionally have type declarations. unlike method parameters, where types are required, dafny can infer the types of local variables in almost all situations. this is an example of an initialized, explicitly typed variable declaration:\n\nmethod m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n\n\n1\n2\n3\n4\n5\n\n\nthe type annotation can be dropped in this case:\n\nmethod m()\n{\n   var x := 5;\n}\n   var x := 5;\n\n\n1\n2\n3\n4\n5\n\n\nmultiple variables can be declared at once:\n\nmethod m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n\n\n1\n2\n3\n4\n5\n\n\nexplicit type declarations only apply to the immediately preceding variable, so here the bool declaration only applies to z, and not x or y, which are both inferred to be ints. we needed variables because we want to talk about the return value of the abs method. we cannot put abs inside a specification directly, as the method could change memory state, among other problems. so we capture the return value of a call to abs as follows:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n// use definition of abs() from before.\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is an example of a situation where we can ask dafny what it knows about the values in the code, in this case v. we do this by adding assertions, like the one above. every time dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. in this example, there is only one control path through the method, and dafny is able to prove the annotation easily because it is exactly the postcondition of the abs method. abs guarantees that the return value is non-negative, so it trivially follows that v, which is this value, is non-negative after the call to abs.\n\nexercise 1. write a test method that calls your max method from exercise 0 and then asserts something about the result.\n\nmethod max(a: int, b:int) returns (c: int)\n  // use your code from exercise 0\nmethod testing() {\n  // assert some things about max. does it operate as you expect?\n  // if it does not, can you think of a way to fix it?\n}\nmethod testing() { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nbut we know something stronger about the abs method. in particular, for non-negative x, abs(x) == x. specifically, in the above program, the value of v is 3. if we try adding an assertion (or changing the existing one) to say:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nwe find that dafny cannot prove our assertion, and gives an error. the reason this happens is that dafny âforgetsâ about the body of every method except the one it is currently working on. this simplifies dafnyâs job tremendously, and is one of the reasons it is able to operate at reasonable speeds. it also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). we donât care at all what happens inside each method when we call it, as long as it satisfies its annotations. this works because dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.\n\nfor the abs method, this means that the only thing dafny knows in the testing method about the value returned from abs is what the postconditions say about it, and nothing more. this means that dafny wonât know the nice property about abs and non-negative integers unless we tell it by putting this in the postcondition of the abs method. another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. in the abs case, we might have written:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nthis method satisfies the postconditions, but clearly the program fragment:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod testing()\n{\n   var v := abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := abs(3);\n   assert v == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwould not be true in this case. dafny is considering, in an abstract way, all methods with those annotations. the mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. we need stronger postconditions to eliminate these other possibilities, and âfixâ the method down to exactly the one we want. we can partially do this with the following:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. the second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean âandâ and comparisons, so the above says 0 <= x implies y == x). the left and right sides must both be boolean expressions.\n\nthe postcondition says that after abs is called, if the value of x was non-negative, then y is equal to x. one caveat of the implication is that it is still true if the left part (the antecedent) is false. so the second postcondition is trivially true when x is negative. in fact, the only thing that the annotations say when x is negative is that the result, y, is positive. but this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nthese annotations are enough to require that our method actually computes the absolute value of x. these postconditions are not the only way to express this property. for example, this is a different, and somewhat shorter, way of saying the same thing:\n\nmethod abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nin general, there can be many ways to write down a given property. most of the time it doesnât matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.\n\nbut we still have an issue: there seems to be a lot of duplication. the body of the method is reflected very closely in the annotations. while this is correct code, we want to eliminate this redundancy. as you might guess, dafny provides a means of doing this: functions.\n\nexercise 2. using a precondition, change abs to say it can only be called on negative values. simplify the body of abs into just one return statement and make sure the method still verifies.\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 3. keeping the postconditions of abs the same as above, change the body of abs to just y := x + 2. what precondition do you need to annotate the method with in order for the verification to go through? what precondition do you need if the body is y := x + 1? what does that precondition say about when you can call the method?\n\nmethod abs(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod abs2(x: int) returns (y: int)\n   // add a precondition here so that the method verifies.\n   // don\'t change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod abs(x: int) returns (y: int) { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# functions\n\nfunction abs(x: int): int\n{\n   ...\n}\n\n\n1\n2\n3\n4\n\n\nthis declares a function called abs which takes a single integer, and returns an integer (the second int). unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. here our body must be an integer expression. in order to implement the absolute value function, we need to use an if expression. an if expression is like the ternary operator in other languages.\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n\n\n1\n2\n3\n4\n\n\nobviously, the condition must be a boolean expression, and the two branches must have the same type. you might wonder why anyone would bother with functions, if they are so limited compared to methods. the power of functions comes from the fact that they can be used directly in specifications. so we can write:\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nin fact, not only can we write this statement directly without capturing to a local variable, we didnât even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). the limitations of functions are precisely what let dafny do this. unlike methods, dafny does not forget the body of a function when considering other functions. so it can expand the definition of abs in the above assertion and determine that the result is actually 3.\n\nexercise 4. write a function max that returns the larger of two given integer parameters. write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n   // fill in an expression here.\n}\nmethod testing() {\n  // add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\none caveat of functions is that not only can they appear in annotations, they can only appear in annotations. one cannot write:\n\n   var v := abs(3);\n\n\n1\n\n\nas this is not an annotation. functions are never part of the final compiled program, they are just tools to help us verify our code. sometimes it is convenient to use a function in real code, so one can define a function method, which can be called from real code. note that there are restrictions on what functions can be function methods (see the reference for details).\n\nexercise 5. change your test method from exercise 4 to capture the value of max to a variable, and then do the checks from exercise 4 using the variable. dafny will reject this program because you are calling max from real code. fix this problem using a function method.\n\nfunction max(a: int, b: int): int\n{\n   // use your code from exercise 4\n}\nmethod testing() {\n  // add assertions to check max here. be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexercise 6. now that we have an abs function, change the postcondition of method abs to make use of abs. after confirming the method still verifies, change the body of abs to also use abs. (after doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)\n\nfunction abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod abs(x: int) returns (y: int)\n  // use abs here, then confirm the method still verifies.\n{\n   // then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nunlike methods, functions can appear in expressions. thus we can do something like implement the mathematical fibonacci function:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nhere we use nats, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. it turns out that we could make this function a function method if we wanted to. but this would be extremely slow, as this version of calculating the fibonacci numbers has exponential complexity. there are much better ways to calculate the fibonacci function. but this function is still useful, as we can have dafny prove that a fast version really matches the mathematical definition. we can get the best of both worlds: the guarantee of correctness and the performance we want.\n\nwe can start by defining a method like the following:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwe havenât written the body yet, so dafny will complain that our postcondition doesnât hold. we need an algorithm to calculate the nth fibonacci number. the basic idea is to keep a counter, and repeatedly calculate adjacent pairs of fibonacci numbers until the desired number is reached. to do this, we need a loop. in dafny, this is done via a while loop. a while loop looks like the following:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nthis is a trivial loop that just increments i until it reaches n. this will form the core of our loop to calculate fibonacci numbers.\n\n\n# loop invariants\n\nwhile loops present a problem for dafny. there is no way for dafny to know in advance how many times the code will go around the loop. but dafny needs to consider all paths through a program, which could include going around the loop any number of times. to make it possible for dafny to work with loops, you need to provide loop invariants, another kind of annotation.\n\na loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. it captures something that is invariant, i.e. does not change, about every step of the loop. now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldnât need the loop. like pre- and postconditions, an invariant is a property that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. for example, we see in the above loop that if i starts off positive, then it stays positive. so we can add the invariant, using its own keyword, to the loop:\n\nmethod m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nwhen you specify an invariant, dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. by preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). just as dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.\n\nin our example, the point of the loop is to build up the fibonacci numbers one (well, two) at a time until we reach the desired number. after we exit the loop, we will have that i == n, because i will stop being incremented when it reaches n. we can use our assertion trick to check to see if dafny sees this fact as well:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nwe find that this assertion fails. as far as dafny knows, it is possible that i somehow became much larger than n at some point during the loop. all it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. in this case, this amounts to n <= i and 0 <= i. but this is not enough to guarantee that i == n, just that n <= i. somehow we need to eliminate the possibility of i exceeding n. one first guess for solving this problem might be the following:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthis does not verify, as dafny complains that the invariant is not preserved (also known as not maintained) by the loop. we want to be able to say that after the loop exits, then all the invariants hold. our invariant holds for every execution of the loop except for the very last one. because the loop body is executed only when the loop guard holds, in the last iteration i goes from n - 1 to n, but does not increase further, as the loop exits. thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nnow we can say both that n <= i from the loop guard and 0 <= i <= n from the invariant, which allows dafny to prove the assertion i == n. the challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.\n\nexercise 7. change the loop invariant to 0 <= i <= n+2. does the loop still verify? does the assertion i == n after the loop still verify?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // change this. what happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexercise 8. with the original loop invariant, change the loop guard from i < n to i != n. do the loop and the assertion after the loop still verify? why or why not?\n\nmethod m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // change this. what happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nin addition to the counter, our algorithm called for a pair of numbers which represent adjacent fibonacci numbers in the sequence. unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. to find these invariants, we employ a common dafny trick: working backwards from the postconditions.\n\nour postcondition for the fibonacci method is that the return value b is equal to fib(n). but after the loop, we have that i == n, so we need b == fib(i) at the end of the loop. this might make a good invariant, as it relates something to the loop counter. this observation is surprisingly common throughout dafny programs. often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. so we have that the variable b, which is conveniently our out parameter, will be the current fibonacci number:\n\n   invariant b == fib(i)\n\n\n1\n\n\nwe also note that in our algorithm, we can compute any fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. so we want a way of tracking the previous fibonacci number, which we will call a. another invariant will express that numberâs relation to the loop counter. the invariants are:\n\n   invariant a == fib(i - 1)\n\n\n1\n\n\nat each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. using a parallel assignment, we can write a loop that performs this operation:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nhere a is the trailing number, and b is the leading number. the parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. thus a will get the old value of b, and b will get the sum of the two old values, which is precisely the behavior we want.\n\nwe also have made a change to the loop counter i. because we also want to track the trailing number, we canât start the counter at zero, as otherwise we would have to calculate a negative fibonacci number. the problem with doing this is that the loop counter invariant may not hold when we enter the loop. the only problem is when n is zero. this can be eliminated as a special case, by testing for this condition at the beginning of the loop. the completed fibonacci method becomes:\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ndafny no longer complains about the loop invariant not holding, because if n were zero, it would return before reaching the loop. dafny is also able to use the loop invariants to prove that after the loop, i == n and b == fib(i), which together imply the postcondition, b == fib(n).\n\nexercise 9. the computefib method above is more complicated than necessary. write a simpler program by not introducing a as the fibonacci number that precedes b, but instead introducing a variable c that succeeds b. verify your program is correct according to the mathematical definition of fibonacci.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // do not change this postcondition\n{\n   // change the method body to instead use c as described.\n   // you will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nexercise 10. starting with the completed computefib method above, delete the if statement and initialize i to 0, a to 1, and b to 0. verify this new program by adjusting the loop invariants to match the new behavior.\n\nfunction fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod computefib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod computefib(n: nat) returns (b: nat)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\none of the problems with using invariants is that it is easy to forget to have the loop make progress, i.e. do work at each step. for example, we could have omitted the entire body of the loop in the previous program. the invariants would be correct, because they are still true upon entering the loop, and since the loop doesnât change anything, they would be preserved by the loop. we know that if we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is total correctness).\n\n\n# termination\n\ndafny proves that code terminates, i.e. does not loop forever, by using decreases annotations. for many things, dafny is able to guess the right annotations, but sometimes it needs to be made explicit. in fact, for all of the code we have seen so far, dafny has been able to do this proof on its own, which is why we havenât seen the decreases annotation explicitly yet. there are two places dafny proves termination: loops and recursion. both of these situations require either an explicit annotation or a correct guess by dafny.\n\na decreases annotation, as its name suggests, gives dafny an expression that decreases with every loop iteration or recursive call. there are two conditions that dafny needs to verify when using a decreases expression: that the expression actually gets smaller, and that it is bounded. many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (see the reference for details.) in the case of integers, the bound is assumed to be zero. for example, the following is a proper use of decreases on a loop (with its own keyword, of course):\n\nmethod m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nhere dafny has all the ingredients it needs to prove termination. the variable i gets smaller each loop iteration, and is bounded below by zero. this is fine, except the loop is backwards from most loops, which tend to count up instead of down. in this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. a simple trick for dealing with this situation is given below:\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis is actually dafnyâs guess for this situation, as it sees i < n and assumes that n - i is the quantity that decreases. the upper bound of the loop invariant implies that 0 <= n â i, and gives dafny a lower bound on the quantity. this also works when the bound n is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.\n\nexercise 11. in the loop above, the invariant i <= n and the negation of the loop guard allow us to conclude i == n after the loop (as we checked previously with an assert. note that if the loop guard were instead written as i != n (as in exercise 8), then the negation of the guard immediately gives i == n after the loop, regardless of the loop invariant. change the loop guard to i != n and delete the invariant annotation. does the program verify? what happened?\n\nmethod m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe other situation that requires a termination proof is when methods or functions are recursive. similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. when dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:\n\nfunction fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nas before, dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where dafny cannot find it on its own, and it requires an explicit annotation.\n\n\n# arrays\n\nall that we have considered is fine for toy functions and little mathematical exercises, but it really isnât helpful for real programs. so far we have only considered a handful of values at a time in local variables. now we turn our attention to arrays of data. arrays are a built-in part of the language, with their own type, array<t>, where t is another type. for now we only consider arrays of integers, array<int>. arrays can be null, and have a built-in length field, a.length. element access uses the standard bracket syntax and are indexed from zero, so a[3] is preceded by the 3 elements a[0], a[1], and a[2], in that order. all array accesses must be proven to be within bounds, which is part of dafnyâs no-runtime-errors safety guarantee. because bounds checks are proven at verification time, no runtime checks need to be made. to create a new array, it must be allocated with the new keyword, but for now we will only work with methods that take a previously allocated array as an argument. (see the tutorial on memory for more on allocation.)\n\none of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. we have two outcomes for a search, with a different correctness condition for each. if the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. this might be expressed as follows:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // can you write code that satisfies the postcondition?\n   // hint: you can do it with one statement.\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n{\n   // open in editor for a challenge...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe array index here is safe because the implication operator is short circuiting. short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. using the short circuiting property of the implication operator, along with the boolean âandâ (&&), which is also short circuiting, is a common dafny practice. the condition index < a.length is necessary because otherwise the method could return a large integer which is not an index into the array. together, the short circuiting behavior means that by the time control reaches the array access, index must be a valid index.\n\nif the key is not in the array, then we would like the method to return a negative number. in this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. to express this property, we turn to another common dafny tool: quantifiers.\n\n\n# quantifiers\n\na quantifier in dafny most often takes the form of a forall expression, also called a universal quantifier. as its name suggests, this expression is true if some property holds for all elements of some set. for now, we will consider the set of integers. an example universal quantifier, wrapped in an assertion, is given below:\n\nmethod m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n\n\n1\n2\n3\n4\n5\n\n\na quantifier introduces a temporary name for each element of the set it is considering. this is called the bound variable, in this case k. the bound variable has a type, which is almost always inferred rather than given explicitly and is usually int anyway. (in general, one can have any number of bound variables, a topic we will return to later.) a pair of colons (::) separates the bound variable and its optional type from the quantified property (which must be of type bool). in this case, the property is that adding one to any integer makes a strictly larger integer. dafny is able to prove this simple property automatically. generally it is not very useful to quantify over infinite sets, such as all the integers. instead, quantifiers are typically used to quantify over all elements in an array or data structure. we do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:\n\n   assert forall k :: 0 <= k < a.length ==> ...a[k]...;\n\n\n1\n\n\nthis says that some property holds for each element of the array. the implication makes sure that k is actually a valid index into the array before evaluating the second part of the expression. dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.\n\nwith a quantifier, saying the key is not in the array is straightforward:\n\n   forall k :: 0 <= k < a.length ==> a[k] != key\n\n\n1\n\n\nthus our method postconditions become (with the addition of the non-nullity precondition on a):\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   // there are many ways to fill this in. can you write one?\n}\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwe can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nas you can see, we have omitted the loop invariants on the while loop, so dafny gives us a verification error on one of the postconditions. the reason we get an error is that dafny does not know that the loop actually covers all the elements. in order to convince dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). just like the postcondition, we can use a quantifier to express this property:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthis says that everything before, but excluding, the current index is not the key. notice that upon entering the loop, i is zero, so the first part of the implication is always false, and thus the quantified property is always true. this common situation is known as vacuous truth: the quantifier holds because it is quantifying over an empty set of objects. this means that it is true when entering the loop. we test the value of the array before we extend the non-key part of the array, so dafny can prove that this invariant is preserved. one problem arises when we try to add this invariant: dafny complains about the index being out of range for the array access within the invariant.\n\nthis code does not verify because there is no invariant on index, so it could be greater than the length of the array. then the bound variable, k, could exceed the length of the array. to fix this, we put the standard bounds on index, 0 <= index <= a.length. note that because we say k < index, the array access is still protected from error even when index == a.length. the use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. the complete method is given below:\n\nmethod find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != key\n{\n   index := 0;\n   while index < a.length\n      invariant 0 <= index <= a.length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexercise 12. write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the arrayâs elements. annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.\n\nmethod findmax(a: array<int>) returns (i: int)\n   // annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // fill in the body that calculates the index of the maximum.\n}\nmethod findmax(a: array<int>) returns (i: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\na linear search is not very efficient, especially when many queries are made of the same data. if the array is sorted, then we can use the very efficient binary search procedure to find the key. but in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. we could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a predicate.\n\n\n# predicates\n\na predicate is a function which returns a boolean. it is a simple but powerful idea that occurs throughout dafny programs. for example, we define the sorted predicate over arrays of integers as a function that takes an array as an argument, and returns true if and only if that array is sorted in increasing order. the use of predicates makes our code shorter, as we do not need to write out a long property over and over. it can also make our code easier to read by giving a common property a name.\n\nthere are a number of ways we could write the sorted predicate, but the easiest is to use a quantifier over the indices of the array. we can write a quantifier that expresses the property, âif x is before y in the array, then x <= y,â as a quantifier over two bound variables:\n\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n\n\n1\n\n\nhere we have two bound variables, j and k, which are both integers. the comparisons between the two guarantee that they are both valid indices into the array, and that j is before k. then the second part says that they are ordered properly with respect to one another. quantifiers are just a type of boolean valued expression in dafny, so we can write the sorted predicate as:\n\npredicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\n\n\n1\n2\n3\n4\n5\n\n\nnote that there is no return type, because predicates always return a boolean.\n\ndafny rejects this code as given, claiming that the predicate cannot read a. fixing this issue requires another annotation, the reads annotation.\n\n\n# framing\n\nthe sorted predicate is not able to access the array because the array was not included in the functionâs reading frame. the reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. the reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. for example, we might have two arrays, one of which we know is sorted. if we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. while we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. in this case, framing is essential to making the verification process feasible.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na reads annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. the name of an array, like a in the above example, stands for all the elements of that array. one can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. dafny will check that you do not read any memory location that is not stated in the reading frame. this means that function calls within a function must have reading frames that are a subset of the calling functionâs reading frame. one thing to note is that parameters to the function that are not memory locations do not need to be declared.\n\nframes also affect methods. as you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no reads annotation. methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a modifies annotation. they are almost identical to their reads cousins, except they say what can be changed, rather than what the value of the function depends on. in combination with reads, modification restrictions allow dafny to prove properties of code that would otherwise be very difficult or impossible. reads and modifies are one of the tools that allow dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that dafny can reason about.\n\nnote that framing only applies to the heap, or memory accessed through references. local variables are not stored on the heap, so they cannot be mentioned in reads annotations. note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)\n\nexercise 13. modify the definition of the sorted predicate so that it returns true exactly when the array is sorted and all its elements are distinct.\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // fill in a new body here.\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexercise 14. what happens if you remove the precondition a != null? change the definition of sorted so that it allows its argument to be null but returns false if it is.\n\npredicate sorted(a: array<int>)\n   reads a\n{\n   // change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# binary search\n\npredicates are usually used to make other annotations clearer:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   // this one is a little harder. what should go here?\n}\nmethod binarysearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nwe have the same postconditions that we did for the linear search, as the goal is the same. the difference is that now we know the array is sorted. because dafny can unwrap functions, inside the body of the method it knows this too. we can then use that property to prove the correctness of the search. the method body is given below:\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nthis is a fairly standard binary search implementation. first we declare our range to search over. this can be thought of as the remaining space where the key could possibly be. the range is inclusive-exclusive, meaning it encompasses indices [low, high). the first invariant expresses the fact that this range is within the array. the second says that the key is not anywhere outside of this range. in the first two branches of the if chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. we need the addition of one when moving the lower end of the range because it is inclusive on the low side. if we do not add one, then the loop may continue forever when mid == low, which happens when low + 1 == high. we could change this to say that the loop exits when low and high are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. in the above formulation, this is unnecessary because when low == high, the loop exits. but this means that no elements are left in the search range, so the key was not found. this can be deduced from the loop invariant:\n\n   invariant forall i ::\n               0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n\n\n1\n2\n\n\nwhen low == high, the negated condition in the first part of the implication is always true (because no i can be both at least and strictly smaller than the same value). thus the invariant says that all elements in the array are not the key, and the second postcondition holds. as you can see, it is easy to introduce subtle off by one errors in this code. with the invariants, not only can dafny prove the code correct, but we can understand the operation of the code more easily ourselves.\n\nexercise 15. change the assignments in the body of binarysearch to set low to mid or to set high to mid - 1. in each case, what goes wrong?\n\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.length ==> a[j] <= a[k]\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.length && sorted(a)\n   ensures 0 <= index ==> index < a.length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.length ==> a[k] != value\n{\n   var low, high := 0, a.length;\n   while low < high\n      invariant 0 <= low <= high <= a.length\n      invariant forall i ::\n         0 <= i < a.length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod binarysearch(a: array<int>, value: int) returns (index: int)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# conclusion\n\nweâve seen a whirlwind tour of the major features of dafny, and used it for some interesting, if a little on the small side, examples of what dafny can do. but to really take advantage of the power dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. now that you are familiar with the basics of dafny, you can peruse the tutorials on each of these topics at your leisure. each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. the examples are also a good place to look for model dafny programs. finally, the reference contains the gritty details of dafny syntax and semantics, for when you just need to know what the disjoint set operator is (itâs !!, for those interested).\n\neven if you do not use dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. when modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. they also ensure that apis are used correctly, by formalizing behavior and requirements and enforcing correct usage. reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.',charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Dafny type system",frontmatter:{title:"Dafny type system",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/a9c4a5/",categories:["è¯­è¨","detailed-document"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/20.detailed-document/00.Dafny%20type%20system.html",relativePath:"80.è¯­è¨/20.detailed-document/00.Dafny type system.md",key:"v-508d0816",path:"/pages/a9c4a5/",headers:[{level:2,title:"0.âBasic types",slug:"_0-basic-types",normalizedTitle:"0.âbasic types",charIndex:355},{level:3,title:"0.0.âBooleans",slug:"_0-0-booleans",normalizedTitle:"0.0.âbooleans",charIndex:371},{level:3,title:"0.1.âNumeric types",slug:"_0-1-numeric-types",normalizedTitle:"0.1.ânumeric types",charIndex:386},{level:3,title:"0.2.âCharacters",slug:"_0-2-characters",normalizedTitle:"0.2.âcharacters",charIndex:406},{level:2,title:"1.âType parameters",slug:"_1-type-parameters",normalizedTitle:"1.âtype parameters",charIndex:423},{level:2,title:"2.âCollection types",slug:"_2-collection-types",normalizedTitle:"2.âcollection types",charIndex:443},{level:3,title:"2.0.âSets",slug:"_2-0-sets",normalizedTitle:"2.0.âsets",charIndex:464},{level:3,title:"2.1.âMultisets",slug:"_2-1-multisets",normalizedTitle:"2.1.âmultisets",charIndex:475},{level:3,title:"2.2.âSequences",slug:"_2-2-sequences",normalizedTitle:"2.2.âsequences",charIndex:491},{level:4,title:"2.2.0.âStrings",slug:"_2-2-0-strings",normalizedTitle:"2.2.0.âstrings",charIndex:507},{level:3,title:"2.3.âFinite and Infinite Maps",slug:"_2-3-finite-and-infinite-maps",normalizedTitle:"2.3.âfinite and infinite maps",charIndex:523},{level:2,title:"3.âTypes that stand for other types",slug:"_3-types-that-stand-for-other-types",normalizedTitle:"3.âtypes that stand for other types",charIndex:554},{level:3,title:"3.0.âType synonyms",slug:"_3-0-type-synonyms",normalizedTitle:"3.0.âtype synonyms",charIndex:591},{level:3,title:"3.1.âOpaque types",slug:"_3-1-opaque-types",normalizedTitle:"3.1.âopaque types",charIndex:611},{level:2,title:"4.âDatatypes",slug:"_4-datatypes",normalizedTitle:"4.âdatatypes",charIndex:630},{level:3,title:"4.0.âInductive datatypes",slug:"_4-0-inductive-datatypes",normalizedTitle:"4.0.âinductive datatypes",charIndex:644},{level:3,title:"4.1.âTuple types",slug:"_4-1-tuple-types",normalizedTitle:"4.1.âtuple types",charIndex:670},{level:3,title:"4.2.âCo-inductive datatypes",slug:"_4-2-co-inductive-datatypes",normalizedTitle:"4.2.âco-inductive datatypes",charIndex:688},{level:2,title:"5.âReference types",slug:"_5-reference-types",normalizedTitle:"5.âreference types",charIndex:717},{level:3,title:"5.0.âClasses",slug:"_5-0-classes",normalizedTitle:"5.0.âclasses",charIndex:737},{level:3,title:"5.1.âArrays",slug:"_5-1-arrays",normalizedTitle:"5.1.âarrays",charIndex:751},{level:4,title:"5.1.0.âOne-dimensional arrays",slug:"_5-1-0-one-dimensional-arrays",normalizedTitle:"5.1.0.âone-dimensional arrays",charIndex:764},{level:4,title:"5.1.1.âMulti-dimensional arrays",slug:"_5-1-1-multi-dimensional-arrays",normalizedTitle:"5.1.1.âmulti-dimensional arrays",charIndex:795},{level:3,title:"5.2.âTraits",slug:"_5-2-traits",normalizedTitle:"5.2.âtraits",charIndex:828},{level:3,title:"5.3.âType object",slug:"_5-3-type-object",normalizedTitle:"5.3.âtype object",charIndex:841},{level:3,title:"5.4.âIterator types",slug:"_5-4-iterator-types",normalizedTitle:"5.4.âiterator types",charIndex:859},{level:3,title:"5.5.âAsync-task types",slug:"_5-5-async-task-types",normalizedTitle:"5.5.âasync-task types",charIndex:880},{level:2,title:"6.âFunction types",slug:"_6-function-types",normalizedTitle:"6.âfunction types",charIndex:903},{level:3,title:"6.0.âLambda expressions",slug:"_6-0-lambda-expressions",normalizedTitle:"6.0.âlambda expressions",charIndex:922},{level:2,title:"7.âNewtypes",slug:"_7-newtypes",normalizedTitle:"7.ânewtypes",charIndex:947},{level:3,title:"7.0.âNumeric conversion operations",slug:"_7-0-numeric-conversion-operations",normalizedTitle:"7.0.ânumeric conversion operations",charIndex:960},{level:2,title:"8.âSubset types",slug:"_8-subset-types",normalizedTitle:"8.âsubset types",charIndex:996},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:58798}],headersStr:"0.âBasic types 0.0.âBooleans 0.1.âNumeric types 0.2.âCharacters 1.âType parameters 2.âCollection types 2.0.âSets 2.1.âMultisets 2.2.âSequences 2.2.0.âStrings 2.3.âFinite and Infinite Maps 3.âTypes that stand for other types 3.0.âType synonyms 3.1.âOpaque types 4.âDatatypes 4.0.âInductive datatypes 4.1.âTuple types 4.2.âCo-inductive datatypes 5.âReference types 5.0.âClasses 5.1.âArrays 5.1.0.âOne-dimensional arrays 5.1.1.âMulti-dimensional arrays 5.2.âTraits 5.3.âType object 5.4.âIterator types 5.5.âAsync-task types 6.âFunction types 6.0.âLambda expressions 7.âNewtypes 7.0.âNumeric conversion operations 8.âSubset types Acknowledgments",content:"# Types in Dafny\n\nManuscript KRML 243 27 February 2015\n\nK. Rustan M. Leinoleino@microsoft.com\n\nThis part of the Dafny language reference describes the types in the Dafny programming language. What is described is what is implemented in version 1.9.3.20107 of Dafny, with the exception of async-task types which have not yet made it into the main branch.\n\n0.âBasic types\n\n0.0.âBooleans\n\n0.1.âNumeric types\n\n0.2.âCharacters\n\n1.âType parameters\n\n2.âCollection types\n\n2.0.âSets\n\n2.1.âMultisets\n\n2.2.âSequences\n\n2.2.0.âStrings\n\n2.3.âFinite and Infinite Maps\n\n3.âTypes that stand for other types\n\n3.0.âType synonyms\n\n3.1.âOpaque types\n\n4.âDatatypes\n\n4.0.âInductive datatypes\n\n4.1.âTuple types\n\n4.2.âCo-inductive datatypes\n\n5.âReference types\n\n5.0.âClasses\n\n5.1.âArrays\n\n5.1.0.âOne-dimensional arrays\n\n5.1.1.âMulti-dimensional arrays\n\n5.2.âTraits\n\n5.3.âType object\n\n5.4.âIterator types\n\n5.5.âAsync-task types\n\n6.âFunction types\n\n6.0.âLambda expressions\n\n7.âNewtypes\n\n7.0.âNumeric conversion operations\n\n8.âSubset types\n\n\n# 0.âBasic types\n\nDafny offers three basic types, bool for booleans, int for integers, and real for reals.\n\n\n# 0.0.âBooleans\n\nThere are two boolean values and each has a corresponding literal in the language: false and true.\n\nIn addition to equality (==) and disequality (!=), which are defined on all types, type bool supports the following operations:\n\n           \noperator   description\n           \n<==>       equivalence (if and only if)\n           \n==>        implication (implies)\n<==        reverse implication (follows from)\n           \n&&         conjunction (and)\n||         disjunction (or)\n           \n!          negation (not)\n           \n\nNegation is unary; the others are binary. The table shows the operators in groups of increasing binding power, with equality binding stronger than conjunction and disjunction, and weaker than negation. Within each group, different operators do not associate, so parentheses need to be used. For example,\n\nA && B || C    // error\n\n\n1\n\n\nwould be ambiguous and instead has to be written as either\n\n(A && B) || C\n\n\n1\n\n\nor\n\nA && (B || C)\n\n\n1\n\n\ndepending on the intended meaning.\n\nThe expressions A <==> B and A == B give the same value, but note that <==> is associative whereas == is chaining. So,\n\nA <==> B <==> C\n\n\n1\n\n\nis the same as\n\nA <==> (B <==> C)\n\n\n1\n\n\nand\n\n(A <==> B) <==> C\n\n\n1\n\n\nwhereas\n\nA == B == C\n\n\n1\n\n\nis simply a shorthand for\n\nA == B && B == C\n\n\n1\n\n\nConjunction is associative and so is disjunction. These operators are are short circuiting (from left to right), meaning that their second argument is evaluated only if the evaluation of the first operand does not determine the value of the expression. Logically speaking, the expression A && B is defined when A is defined and either A evaluates to false or B is defined. When A && B is defined, its meaning is the same as the ordinary, symmetric mathematical conjunction â§. The same holds for || and â¨.\n\nImplication is right associative and is short-circuiting from left to right. Reverse implication B <== A is exactly the same as A ==> B, but gives the ability to write the operands in the opposite order. Consequently, reverse implication is left associative and is short-circuiting from right to left. To illustrate the associativity rules, each of the following four lines expresses the same property, for any A, B, and C of type bool:\n\nA ==> B ==> C\nA ==> (B ==> C)  // parentheses redundant, since ==> is right associative\nC <== B <== A\n(C <== B) <== A  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nTo illustrate the short-circuiting rules, note that the expression a.Length is defined for an array a only if a is not null (see Section 5), which means the following two expressions are well-formed:\n\na != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n\n\n1\n2\n\n\nThe contrapositive of these two expressions would be:\n\na.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n\n\n1\n2\n\n\nbut these expressions are not well-formed, since well-formedness requires the left (and right, respectively) operand, a.Length < 0, to be well-formed by itself.\n\nImplication A ==> B is equivalent to the disjunction !A || B, but is sometimes (especially in specifications) clearer to read. Since, || is short-circuiting from left to right, note that\n\na == null || 0 <= a.Length\n\n\n1\n\n\nis well-formed, whereas\n\n0 <= a.Length || a == null  // not well-formed\n\n\n1\n\n\nis not.\n\nIn addition, booleans support logical quantifiers (forall and exists), described in a different part of the Dafny language reference.\n\n\n# 0.1.âNumeric types\n\nDafny supports numeric types of two kinds, integer-based, which includes the basic type int of all integers, and real-based, which includes the basic type real of all real numbers. User-defined numeric types based on int and real, called newtypes, are described in Section 7. Also, the subset type nat, representing the non-negative subrange of int, is described in Section 8.\n\nThe language includes a literal for each non-negative integer, like 0, 13, and 1985. Integers can also be written in hexadecimal using the prefix â0xâ, as in 0x0, 0xD, and 0x7c1 (always with a lower case x, but the hexadecimal digits themselves are case insensitive). Leading zeros are allowed. To form negative integers, use the unary minus operator.\n\nThere are also literals for some of the non-negative reals. These are written as a decimal point with a nonempty sequence of decimal digits on both sides. For example, 1.0, 1609.344, and 0.5772156649.\n\nFor integers (in both decimal and hexidecimal form) and reals, any two digits in a literal may be separated by an underscore in order to improve human readability of the literals. For example:\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 ÃngstrÃ¶m\n\n\n1\n2\n3\n4\n\n\nIn addition to equality and disequality, numeric types support the following relational operations:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nLike equality and disequality, these operators are chaining, as long as they are chained in the âsame directionâ. That is,\n\nA <= B < C == D <= E\n\n\n1\n\n\nis simply a shorthand for\n\nA <= B && B < C && C == D && D <= E\n\n\n1\n\n\nwhereas\n\nA < B > C\n\n\n1\n\n\nis not allowed.\n\nThere are also operators on each numeric type:\n\n           \noperator   description\n           \n+          addition (plus)\n-          subtraction (minus)\n           \n*          multiplication (times)\n/          division (divided by)\n%          modulus (mod)\n           \n-          negation (unary minus)\n           \n\nThe binary operators are left associative, and they associate with each other in the two groups. The groups are listed in order of increasing binding power, with equality binding more strongly than the multiplicative operators and weaker than the unary operator. Modulus is supported only for integer-based numeric types. Integer division and modulus are the Euclidean division and modulus. This means that modulus always returns a non-negative, regardless of the signs of the two operands. More precisely, for any integer a and non-zero integer b,\n\na == a / b * b + a % b\n0 <= a % b < B\n\n\n1\n2\n\n\nwhere B denotes the absolute value of b.\n\nReal-based numeric types have a member Trunc that returns the floor of the real value, that is, the largest integer not exceeding the real value. For example, the following properties hold, for any r and r' of type real:\n\n3.14.Trunc == 3\n(-2.5).Trunc == -3\n-2.5.Trunc == -2\nreal(r.Trunc) <= r\nr <= r' ==> r.Trunc <= r'.Trunc\n\n\n1\n2\n3\n4\n5\n\n\nNote in the third line that member access (like .Trunc) binds stronger than unary minus. The fourth line uses the conversion function real from int to real, as described in Section 7.0.\n\n\n# 0.2.âCharacters\n\nDafny supports a type char of characters. Character literals are enclosed in single quotes, as in 'D'. To write a single quote as a character literal, it is necessary to use an escape sequence. Escape sequences can also be used to write other characters. The supported escape sequences are as follows:\n\n                  \nescape sequence   meaning\n                  \n\\'                the character '\n\"                 the character \"\n\\\\                the character \\\n\\0                the null character, same as \\u0000\n\\n                line feed\n\\r                carriage return\n\\t                horizontal tab\n\\u*xxxx*          universal character whose hexadecimal code is *xxxx*\n                  \n\nThe escape sequence for a double quote is redundant, because '\"' and '\"' denote the same characterâboth forms are provided in order to support the same escape sequences as for string literals (Section 2.2.0). In the form \\u*xxxx*, the u is always lower case, but the four hexadecimal digits are case insensitive.\n\nCharacter values are ordered and can be compared using the standard relational operators:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nSequences of characters represent strings, as described in Section 2.2.0.\n\n\n# 1.âType parameters\n\nMany of the types (as well as functions and methods) in Dafny can be parameterized by types. These type parameters are typically declared inside angle brackets and can stand for any type. It is sometimes necessary to restrict these type parameters so that they can only be instantiated by certain families of types. As such, Dafny distinguishes types that support the equality operation not only in ghost contexts but also in compiled contexts. To indicate that a type parameter is restricted to such equality supporting types, the name of the type parameter takes the suffix â(==)â.0 For example,\n\nmethod Compareâ©T(==)âª(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\nis a method whose type parameter is restricted to equality-supporting types. Again, note that all types support equality in ghost contexts; the difference is only for non-ghost (that is, compiled) code. Co-inductive datatypes, function types, as well as inductive datatypes with ghost parameters are examples of types that are not equality supporting.\n\nDafny has some inference support that makes certain signatures less cluttered (described in a different part of the Dafny language reference). In some cases, this support will infer that a type parameter must be restricted to equality-supporting types, in which case Dafny adds the â(==)â automatically.\n\n\n# 2.âCollection types\n\nDafny offers several built-in collection types.\n\n\n# 2.0.âSets\n\nFor any type T, each value of type setâ©Tâª is a finite set of T values. Set membership is determined by equality in the type T, so setâ©Tâª can be used in a non-ghost context only if T is equality supporting.\n\nA set can be formed using a set display expression, which is a possibly empty, unordered, duplicate-insensitive list of expressions enclosed in curly braces. To illustrate,\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of set displays. There is also a set comprehension expression (with a binder, like in logical quantifications), described in a different part of the Dafny language reference.\n\nIn addition to equality and disequality, set types support the following relational operations:\n\n           \noperator   description\n           \n<          proper subset\n<=         subset\n>=         superset\n>          proper superset\n           \n\nLike the arithmetic relational operators, these operators are chaining.\n\nSets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         disjointness\n           \n+          set union\n-          set difference\n           \n*          set intersection\n           \n\nThe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. The expression A !! B, whose binding power is the same as equality (but which neither associates nor chains with equality), says that sets A and B have no elements in common, that is, it is equivalent to\n\nA * B == {}\n\n\n1\n\n\nHowever, the disjointness operator is chaining, so A !! B !! C !! D means:\n\nA * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n\n\n1\n\n\nIn addition, for any set s of type setâ©Tâª and any expression e of type T, sets support the following operations:\n\n             \nexpression   description\n             \n|s|          set cardinality\ne in s       set membership\ne !in s      set non-membership\n             \n\nThe expression e !in s is a syntactic shorthand for !(e in s).\n\n\n# 2.1.âMultisets\n\nA multiset is similar to a set, but keeps track of the multiplicity of each element, not just its presence or absence. For any type T, each value of type multisetâ©Tâª is a map from T values to natural numbers denoting each element's multiplicity. Multisets in Dafny are finite, that is, they contain a finite number of each of a finite set of elements. Stated differently, a multiset maps only a finite number of elements to non-zero (finite) multiplicities.\n\nLike sets, multiset membership is determined by equality in the type T, so multisetâ©Tâª can be used in a non-ghost context only if T is equality supporting.\n\nA multiset can be formed using a multiset display expression, which is a possibly empty, unordered list of expressions enclosed in curly braces after the keyword multiset. To illustrate,\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of multiset displays. There is no multiset comprehension expression.\n\nIn addition to equality and disequality, multiset types support the following relational operations:\n\n           \noperator   description\n           \n<          proper multiset subset\n<=         multiset subset\n>=         multiset superset\n>          proper multiset superset\n           \n\nLike the arithmetic relational operators, these operators are chaining.\n\nMultisets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         multiset disjointness\n           \n+          multiset union\n-          multiset difference\n           \n*          multiset intersection\n           \n\nThe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. The expression A !! B says that multisets A and B have no elements in common, that is, it is equivalent to\n\nA * B == multiset{}\n\n\n1\n\n\nLike the analogous set operator, !! is chaining.\n\nIn addition, for any multiset s of type multisetâ©Tâª, expression e of type T, and non-negative integer-based numeric n, multisets support the following operations:\n\n             \nexpression   description\n             \n|s|          multiset cardinality\ne in s       multiset membership\ne !in s      multiset non-membership\ns[e]         multiplicity of e in s\ns[e := n]    multiset update (change of multiplicity)\n             \n\nThe expression e in s returns true if and only if s[e] != 0. The expression e !in s is a syntactic shorthand for !(e in s). The expression s[e := n] denotes a multiset like s, but where the multiplicity of element e is n. Note that the multiset update s[e := 0] results in a multiset like s but without any occurrences of e (whether or not s has occurrences of e in the first place). As another example, note that s - multiset{e} is equivalent to:\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2.âSequences\n\nFor any type T, a value of type seqâ©Tâª denotes a sequence of T elements, that is, a mapping from a finite set of consecutive natural numbers (called indicies) to T values. (Thinking of it as a map, a sequence is therefore something of a dual of a multiset.)\n\nA sequence can be formed using a sequence display expression, which is a possibly empty, ordered list of expressions enclosed in square brackets. To illustrate,\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\nare three examples of sequence displays. There is no sequence comprehension expression.\n\nIn addition to equality and disequality, sequence types support the following relational operations:\n\n           \noperator   description\n           \n<          proper prefix\n<=         prefix\n           \n\nLike the arithmetic relational operators, these operators are chaining. Note the absence of > and >=.\n\nSequences support the following binary operator:\n\n           \noperator   description\n           \n+          concatenation\n           \n\nOperator + is associative, like the arithmetic operator with the same name.\n\nIn addition, for any sequence s of type seqâ©Tâª, expression e of type T, integer-based numeric i satisfying 0 <= i < |s|, and integer-based numerics lo and hi satisfying 0 <= lo <= hi <= |s|, sequences support the following operations:\n\n              \nexpression    description\n              \n|s|           sequence length\ns[i]          sequence selection\ns[i := e]     sequence update\ne in s        sequence membership\ne !in s       sequence non-membership\ns[lo..hi]     subsequence\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   slice\nmultiset(s)   sequence conversion to a multisetâ©Tâª\n              \n\nExpression s[i := e] returns a sequence like s, except that the element at index i is e. The expression e in s says there exists an index i such that s[i] == e. It is allowed in non-ghost contexts only if the element type T is equality supporting. The expression e !in s is a syntactic shorthand for !(e in s).\n\nExpression s[lo..hi] yields a sequence formed by taking the first hi elements and then dropping the first lo elements. The resulting sequence thus has length hi - lo. Note that s[0..|s|] equals s. If the upper bound is omitted, it defaults to |s|, so s[lo..] yields the sequence formed by dropping the first lo elements of s. If the lower bound is omitted, it defaults to 0, so s[..hi] yields the sequence formed by taking the first hi elements of s.\n\nIn the sequence slice operation, *slices* is a nonempty list of length designators separated and optionally terminated by a colon, and there is at least one colon. Each length designator is a non-negative integer-based numeric, whose sum is no greater than |s|. If there are k colons, the operation produces k consecutive subsequences from s, each of the length indicated by the corresponding length designator, and returns these as a sequence of sequences.1 If *slices* is terminated by a colon, then the length of the last slice extends until the end of s, that is, its length is |s| minus the sum of the given length designators. For example, the following equalities hold, for any sequence s of length at least 10:\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe operation multiset(s) yields the multiset of elements of sequence s. It is allowed in non-ghost contexts only if the element type T is equality supporting.\n\n# 2.2.0.âStrings\n\nA special case of a sequence type is seqâ©charâª, for which Dafny provides a synonym: string. Strings are like other sequences, but provide additional syntax for sequence display expressions, namely string literals. There are two forms of the syntax for string literals: the standard form and the verbatim form.\n\nString literals of the standard form are enclosed in double quotes, as in \"Dafny\". To include a double quote in such a string literal, it is necessary to use an escape sequence. Escape sequences can also be used to include other characters. The supported escape sequences are the same as those for character literals, see Section 0.2. For example, the Dafny expression \"say \\\"yes\\\"\" represents the string say \"yes\". The escape sequence for a single quote is redundant, because \"'\" and \"'\" denote the same stringâboth forms are provided in order to support the same escape sequences as for character literals.\n\nString literals of the verbatim form are bracketed by @\" and \", as in @\"Dafny\". To include a double quote in such a string literal, it is necessary to use the escape sequence \"\", that is, to write the character twice. In the verbatim form, there are no other escape sequences. Even characters like newline can be written inside the string literal (hence spanning more than one line in the program text).\n\nFor example, the following three expressions denote the same string:\n\n\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nSince strings are sequences, the relational operators < and <= are defined on them. Note, however, that these operators still denote proper prefix and prefix, respectively, not some kind of alphabetic comparison as might be desireable, for example, when sorting strings.\n\n\n# 2.3.âFinite and Infinite Maps\n\nFor any types T and U, a value of type mapâ©T,Uâª denotes a (finite) map from T to U. In other words, it is a look-up table indexed by T. The domain of the map is a finite set of T values that have associated U values. Since the keys in the domain are compared using equality in the type T, type mapâ©T,Uâª can be used in a non-ghost context only if T is equality supporting.\n\nSimilarly, for any types T and U, a value of type imapâ©T,Uâª denotes a (possibly) infinite map. In most regards, imapâ©T,Uâª is like mapâ©T,Uâª, but a map of type imapâ©T,Uâª is allowed to have an infinite domain.\n\nA map can be formed using a map display expression, which is a possibly empty, ordered list of maplets, each maplet having the form t := u where t is an expression of type T and u is an expression of type U, enclosed in square brackets after the keyword map. To illustrate,\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\nare three examples of map displays. By using the keyword imap instead of map, the map produced will be of type imapâ©T,Uâª instead of mapâ©T,Uâª. Note that an infinite map (imap) is allowed to have a finite domain, whereas a finite map (map) is not allowed to have an infinite domain. If the same key occurs more than once, only the last occurrence appears in the resulting map.2 There is also a map comprehension expression, explained in a different part of the Dafny language reference.\n\nFor any map fm of type mapâ©T,Uâª, any map m of type mapâ©T,Uâª or imapâ©T,Uâª, any expression t of type T, any expression u of type U, and any d in the domain of m (that is, satisfying d in m), maps support the following operations:\n\n             \nexpression   description\n             \n|fm|         map cardinality\nm[d]         map selection\nm[t := u]    map update\nt in m       map domain membership\nt !in m      map domain non-membership\n             \n\n|fm| denotes the number of mappings in fm, that is, the cardinality of the domain of fm. Note that the cardinality operator is not supported for infinite maps. Expression m[d] returns the U value that m associates with d. Expression m[t := u] is a map like m, except that the element at key t is u. The expression t in m says t is in the domain of m and t !in m is a syntactic shorthand for !(t in m).3\n\nHere is a small example, where a map cache of type mapâ©int,realâª is used to cache computed values of Joule-Thomson coefficients for some fixed gas at a given temperature:\n\nif K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJouleThomsonCoefficient(K);  // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.âTypes that stand for other types\n\nIt is sometimes useful to know a type by several names or to treat a type abstractly.\n\n\n# 3.0.âType synonyms\n\nA type synonym declaration:\n\ntype Yâ©Tâª = G\n\n\n1\n\n\ndeclares Yâ©Tâª to be a synonym for the type G. Here, T is a nonempty list of type parameters (each of which is optionally designated with the suffix â(==)â), which can be used as free type variables in G. If the synonym has no type parameters, the ââ©Tâªâ is dropped. In all cases, a type synonym is just a synonym. That is, there is never a difference, other than possibly in error messages produced, between Yâ©Tâª and G.\n\nFor example, the names of the following type synonyms may improve the readability of a program:\n\ntype Replacementsâ©Tâª = mapâ©T,Tâª\ntype Vertex = int\n\n\n1\n2\n\n\nAs already described in Section 2.2.0, string is a built-in type synonym for seqâ©charâª, as if it would have been declared as follows:\n\ntype string = seqâ©charâª\n\n\n1\n\n\n\n# 3.1.âOpaque types\n\nA special case of a type synonym is one that is underspecified. Such a type is declared simply by:\n\ntype Yâ©Tâª\n\n\n1\n\n\nIt is a known as an opaque type. Its definition can be revealed in a refining module. To indicate that Y designates an equality-supporting type, â(==)â can be written immediately following the name âYâ.\n\nFor example, the declarations\n\ntype T\nfunction F(t: T): T\n\n\n1\n2\n\n\ncan be used to model an uninterpreted function F on some arbitrary type T. As another example,\n\ntype Monadâ©Tâª\n\n\n1\n\n\ncan be used abstractly to represent an arbitrary parameterized monad.\n\n\n# 4.âDatatypes\n\nDafny offers two kinds of algebraic datatypes, those defined inductively and those defined co-inductively. The salient property of every datatype is that each value of the type uniquely identifies one of the datatype's constructors and each constructor is injective in its parameters.\n\n\n# 4.0.âInductive datatypes\n\nThe values of inductive datatypes can be seen as finite trees where the leaves are values of basic types, numeric types, reference types, co-inductive datatypes, or function types. Indeed, values of inductive datatypes can be compared using Dafny's well-founded < ordering.\n\nAn inductive datatype is declared as follows:\n\ndatatype Dâ©Tâª = Ctors\n\n\n1\n\n\nwhere *Ctors* is a nonempty |-separated list of (datatype) constructors for the datatype. Each constructor has the form:\n\nC(params)\n\n\n1\n\n\nwhere *params* is a comma-delimited list of types, optionally preceded by a name for the parameter and a colon, and optionally preceded by the keyword ghost. If a constructor has no parameters, the parentheses after the constructor name can be omitted. If no constructor takes a parameter, the type is usually called an enumeration; for example:\n\ndatatype Friends = Agnes | Agatha | Jermaine | Jack\n\n\n1\n\n\nFor every constructor C, Dafny defines a discriminator C?, which is a member that returns true if and only if the datatype value has been constructed using C. For every named parameter p of a constructor C, Dafny defines a destructor p, which is a member that returns the p parameter from the C call used to construct the datatype value; its use requires that C? holds. For example, for the standard List type\n\ndatatype Listâ©Tâª = Nil | Cons(head: T, tail: Listâ©Tâª)\n\n\n1\n\n\nthe following holds:\n\nCons(5, Nil).Cons? && Cons(5, Nil).head == 5\n\n\n1\n\n\nNote that the expression\n\nCons(5, Nil).tail.head\n\n\n1\n\n\nis not well-formed, since Cons(5, Nil).tail does not satisfy Cons?.\n\nThe names of the destructors must be unique across all the constructors of the datatype. A constructor can have the same name as the enclosing datatype; this is especially useful for single-constructor datatypes, which are often called record types. For example, a record type for black-and-white pixels might be represented as follows:\n\ndatatype Pixel = Pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nTo call a constructor, it is usually necessary only to mention the name of the constructor, but if this is ambiguous, it is always possible to qualify the name of constructor by the name of the datatype. For example, Cons(5, Nil) above can be written\n\nList.Cons(5, List.Nil)\n\n\n1\n\n\nAs an alternative to calling a datatype constructor explicitly, a datatype value can be constructed as a change in one parameter from a given datatype value using the datatype update expression. For any d whose type is a datatype that includes a constructor C that has a parameter (destructor) named f of type T, and any expression t of type T,\n\nd[f := t]\n\n\n1\n\n\nconstructs a value like d but whose f parameter is t. The operation requires that d satisfies C?. For example, the following equality holds:\n\nCons(4, Nil)[tail := Cons(3, Nil)] == Cons(4, Cons(3, Nil))\n\n\n1\n\n\n\n# 4.1.âTuple types\n\nDafny builds in record types that correspond to tuples and gives these a convenient special syntax, namely parentheses. For example, what might have been declared as:\n\ndatatype Pairâ©T,Uâª = Pair(0: T, 1: U)\n\n\n1\n\n\nDafny provides as the type (T, U) and the constructor (t, u), as if the datatype's name were ââ and its type arguments are given in round parentheses, and as if the constructor name were ââ. Note that the destructor names are 0 and 1, which are legal identifier names for members. For example, showing the use of a tuple destructor, here is a property that holds of 2-tuples (that is, pairs):\n\n(5, true).1 == true\n\n\n1\n\n\nDafny declares n-tuples where n is 0 or 2 or up. There are no 1-tuples, since parentheses around a single type or a single value have no semantic meaning. The 0-tuple type, (), is often known as the unit type and its single value, also written (), is known as unit.\n\n\n# 4.2.âCo-inductive datatypes\n\nWhereas Dafny insists that there is a way to construct every inductive datatype value from the ground up, Dafny also supports co-inductive datatypes, whose constructors are evaluated lazily and hence allows infinite structures. A co-inductive datatype is declared using the keyword codatatype; other than that, it is declared and used like an inductive datatype.\n\nFor example,\n\ncodatatype IListâ©Tâª = Nil | Cons(head: T, tail: IListâ©Tâª)\ncodatatype Streamâ©Tâª = More(head: T, tail: Streamâ©Tâª)\ncodatatype Treeâ©Tâª = Node(left: Treeâ©Tâª, value: T, right: Treeâ©Tâª)\n\n\n1\n2\n3\n\n\ndeclare possibly infinite lists (that is, lists that can be either finite or infinite), infinite streams (that is, lists that are always infinite), and infinite binary trees (that is, trees where every branch goes on forever), respectively.\n\n\n# 5.âReference types\n\nDafny offers a host of reference types. These represent references to objects allocated dynamically in the program heap. To access the members of an object, a reference to (that is, a pointer to or object identity of) the object is dereferenced.\n\nThe special value null is part of every reference type.4\n\n\n# 5.0.âClasses\n\nA class C is a reference type declared as follows:\n\nclass Câ©Tâª extends J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere the list of type parameters T is optional and so is âextends Jâ, which says that the class extends a trait J. The members of a class are fields, functions, and methods. These are accessed or invoked by dereferencing a reference to a C instance. A function or method is invoked on an instance of C, unless the function or method is declared static. Mechanically, this just means the method takes an implicit receiver parameter, namely, the instance used to access the member. In the specification and body of an instance function or method, the receiver parameter can be referred to explicitly by the keyword this. However, in such places, members of this can also be mentioned without any qualification. To illustrate, the qualified this.f and the unqualified f refer to the same field of the same object in the following example:\n\nclass C {\n  var f: int;\n  method Example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nso the method body always assigns true to the out-parameter b. There is no semantic difference between qualified and unqualified accesses to the same receiver and member.\n\nA C instance is created using new, for example:\n\nc := new C;\n\n\n1\n\n\nNote that new simply allocates a C object and returns a reference to it; the initial values of its fields are arbitrary values of their respective types. Therefore, it is common to invoke a method, known as an initialization method, immediately after creation, for example:\n\nc := new C;\nc.InitFromList(xs, 3);\n\n\n1\n2\n\n\nWhen an initialization method has no out-parameters and modifies no more than this, then the two statements above can be combined into one:\n\nc := new C.InitFromList(xs, 3);\n\n\n1\n\n\nNote that a class can contain several initialization methods, that these methods can be invoked at any time, not just as part of a new, and that new does not require that an initialization method be invoked at creation.\n\nTo write structured object-oriented programs, one often relies on that objects are constructed only in certain ways. For this purpose, Dafny provides constructor (method)s, which are a restricted form of initialization methods. A constructor is declared with the keyword constructor instead of method. When a class contains a constructor, every call to new for that class must be accompanied with a call to one of the constructors. Moreover, a constructor cannot be called at other times, only during object creation. Other than these restrictions, there is no semantic difference between using ordinary initialization methods and using constructors.\n\nThe Dafny design allows the constructors to be named, which promotes using names like InitFromList above. Still, many classes have just one constructor or have a typical constructor. Therefore, Dafny allows one anonymous constructor, that is, a constructor whose name is essentially ââ. For example:\n\nclass Item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nWhen invoking this constructor, the â.â is dropped, as in:\n\nm := new Item(45, 29);\n\n\n1\n\n\nNote that an anonymous constructor is just one way to name a constructor; there can be other constructors as well.\n\n\n# 5.1.âArrays\n\nDafny supports mutable fixed-length array types of any positive dimension. Array types are reference types.\n\n# 5.1.0.âOne-dimensional arrays\n\nA one-dimensional array of n T elements is created as follows:\n\na := new T[n];\n\n\n1\n\n\nThe initial values of the array elements are arbitrary values of type T. The length of an array is retrieved using the immutable Length member. For example, the array allocated above satisfies:\n\na.Length == n\n\n\n1\n\n\nFor any integer-based numeric i in the range 0 <= i < a.Length, the array selection expression a[i] retrieves element i (that is, the element preceded by i elements in the array). The element stored at i can be changed to a value t using the array update statement:\n\na[i] := t;\n\n\n1\n\n\nCaveat: The type of the array created by new T[n] is arrayâ©Tâª. A mistake that is simple to make and that can lead to befuddlement is to write arrayâ©Tâª instead of T after new. For example, consider the following:\n\nvar a := new arrayâ©Tâª;\nvar b := new arrayâ©Tâª[n];\nvar c := new arrayâ©Tâª(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nThe first statement allocates an array of type arrayâ©Tâª, but of unknown length. The second allocates an array of type arrayâ©arrayâ©Tâªâª of length n, that is, an array that holds n values of type arrayâ©Tâª. The third statement allocates an array of type arrayâ©Tâª and then attempts to invoke an anonymous constructor on this array, passing argument n. Since array has no constructors, let alone an anonymous constructor, this statement gives rise to an error. If the type-parameter list is omitted for a type that expects type parameters, Dafny will attempt to fill these in, so as long as the array type parameter can be inferred, it is okay to leave off the ââ©Tâªâ in the fourth statement above. However, as with the third statement, array has no anonymous constructor, so an error message is generated.\n\nOne-dimensional arrays support operations that convert a stretch of consecutive elements into a sequence. For any array a of type arrayâ©Tâª, integer-based numerics lo and hi satisfying 0 <= lo <= hi <= a.Length, the following operations each yields a seqâ©Tâª:\n\n             \nexpression   description\n             \na[lo..hi]    subarray conversion to sequence\na[lo..]      drop\na[..hi]      take\na[..]        array conversion to sequence\n             \n\nThe expression a[lo..hi] takes the first hi elements of the array, then drops the first lo elements thereof and returns what remains as a sequence. The resulting sequence thus has length hi - lo. The other operations are special instances of the first. If lo is omitted, it defaults to 0 and if hi is omitted, it defaults to a.Length. In the last operation, both lo and hi have been omitted, thus a[..] returns the sequence consisting of all the array elements of a.\n\nThe subarray operations are especially useful in specifications. For example, the loop invariant of a binary search algorithm that uses variables lo and hi to delimit the subarray where the search key may be still found can be expressed as follows:\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nAnother use is to say that a certain range of array elements have not been changed since the beginning of a method:\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\nor since the beginning of a loop:\n\nghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nNote that the type of prevElements in this example is seqâ©Tâª, if a has type arrayâ©Tâª.\n\nA final example of the subarray operation lies in expressing that an array's elements are a permutation of the array's elements at the beginning of a method, as would be done in most sorting algorithms. Here, the subarray operation is combined with the sequence-to-multiset conversion:\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1.âMulti-dimensional arrays\n\nAn array of 2 or more dimensions is mostly like a one-dimensional array, except that new takes more length arguments (one for each dimension), and the array selection expression and the array update statement take more indices. For example:\n\nmatrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\ncreate a 2-dimensional array whose dimensions have lengths m and n, respectively, and then swaps the elements at i,j and x,y. The type of matrix is array2â©Tâª, and similarly for higher-dimensional arrays (array3â©Tâª, array4â©Tâª, etc.). Note, however, that there is no type array0â©Tâª, and what could have been array1â©Tâª is actually named just arrayâ©Tâª.\n\nThe new operation above requires m and n to be non-negative integer-based numerics. These lengths can be retrieved using the immutable fields Length0 and Length1. For example, the following holds of the array created above:\n\nmatrix.Length0 == m && matrix.Length1 == n\n\n\n1\n\n\nHigher-dimensional arrays are similar (Length0, Length1, Length2, â¦). The array selection expression and array update statement require that the indices are in bounds. For example, the swap statement above is well-formed only if:\n\n0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n\n\n1\n2\n\n\nIn contrast to one-dimensional arrays, there is no operation to convert stretches of elements from a multi-dimensional array to a sequence.\n\n\n# 5.2.âTraits\n\nA trait is an âabstract superclassâ, or call it an âinterfaceâ or âmixinâ. Traits are new to Dafny and are likely to evolve for a while.\n\nThe declaration of a trait is much like that of a class:\n\ntrait J\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere *members* can include fields, functions, and methods, but no constructor methods. The functions and methods are allowed to be declared static.\n\nA reference type C that extends a trait J is assignable to J, but not the other way around. The members of J are available as members of C. A member in J is not allowed to be redeclared in C, except if the member is a non-static function or method without a body in J. By doing so, type C can supply a stronger specification and a body for the member.\n\nnew is not allowed to be used with traits. Therefore, there is no object whose allocated type is a trait. But there can of course be objects of a class C that implements a trait J, and a reference to such a C object can be used as a value of type J.\n\nAs an example, the following trait represents movable geometric shapes:\n\ntrait Shape\n{\n  function method Width(): real\n    reads this\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMembers Width and Move are abstract (that is, body less) and can be implemented differently by different classes that extend the trait. The implementation of method MoveH is given in the trait and thus gets used by all classes that extend Shape. Here are two classes that each extends Shape:\n\nclass UnitSquare extends Shape\n{\n  var x: real, y: real;\n  function method Width(): real {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real;\n  function method Width(): real\n    reads this\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nNote that the classes can declare additional members, that they supply implementations for the abstract members of the trait, that they repeat the member signatures, and that they are responsible for providing their own member specifications that both strengthen the corresponding specification in the trait and are satisfied by the provided body. Finally, here is some code that creates two class instances and uses them together as shapes:\n\nvar myShapes: seqâ©Shapeâª;\nvar A := new UnitSquare;\nmyShapes := [A];\nvar tri := new LowerRightTriangle;\nmyShapes := myShapes + [tri];  // myShapes contains two Shape values, of different classes\nmyShapes[1].MoveH(myShapes[0].Width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.âType object\n\nThere is a built-in reference type object that is like a supertype of all reference types.5 The purpose of type object is to enable a uniform treatment of dynamic frames. In particular, it is useful to keep a ghost field (typically named Repr for ârepresentationâ) of type setâ©objectâª.\n\n\n# 5.4.âIterator types\n\nAn iterator provides a programming abstraction for writing code that iteratively returns elements. These CLU-style iterators are co-routines in the sense that they keep track of their own program counter and control can be transferred into and out of the iterator body.\n\nAn iterator is declared as follows:\n\niterator Iterâ©Tâª(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhere T is a list of type parameters (as usual, if there are no type parameters, ââ©Tâªâ is omitted). This declaration gives rise to a reference type with the same name, Iterâ©Tâª. In the signature, in-parameters and yield-parameters are the iterator's analog of a method's in-parameters and out-parameters. The difference is that the out-parameters of a method are returned to a caller just once, whereas the yield-parameters of an iterator are returned each time the iterator body performs a yield. The details of the specification are described in a different part of the Dafny language reference. The body consists of statements, like in a method body, but with the availability also of yield statements.\n\nFrom the perspective of an iterator client, the iterator declaration can be understood as generating a class Iterâ©Tâª with various members, a simplified version of which is described next.\n\nThe Iterâ©Tâª class contains an anonymous constructor whose parameters are the iterator's in-parameters:\n\npredicate Valid()\nconstructor (in-params)\n  modifies this\n  ensures Valid()\n\n\n1\n2\n3\n4\n\n\nAn iterator is created using new and this anonymous constructor. For example, an iterator willing to return ten consecutive integers from start can be declared as follows:\n\niterator Gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nAn instance of this iterator is created using:\n\niter := new Gen(30);\n\n\n1\n\n\nThe predicate Valid() says when the iterator is in a state where one can attempt to compute more elements. It is a postcondition of the constructor and occurs in the specification of the MoveNext member:\n\nmethod MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n\n\n1\n2\n3\n4\n\n\nNote that the iterator remains valid as long as MoveNext returns true. Once MoveNext returns false, the MoveNext method can no longer be called. Note, the client is under no obligation to keep calling MoveNext until it returns false, and the body of the iterator is allowed to keep returning elements forever.\n\nThe in-parameters of the iterator are stored in immutable fields of the iterator class. To illustrate in terms of the example above, the iterator class Gen contains the following field:\n\nvar start: int;\n\n\n1\n\n\nThe yield-parameters also result in members of the iterator class:\n\nvar x: int;\n\n\n1\n\n\nThese fields are set by the MoveNext method. If MoveNext returns true, the latest yield values are available in these fields and the client can read them from there.\n\nTo aid in writing specifications, the iterator class also contains ghost members that keep the history of values returned by MoveNext. The names of these ghost fields follow the names of the yield-parameters with an âsâ appended to the name (to suggest plural). Name checking rules make sure these names do not give rise to ambiguities. The iterator class for Gen above thus contains:\n\nghost var xs: seqâ©intâª;\n\n\n1\n\n\nThese history fields are changed automatically by MoveNext, but are not assignable by user code.\n\nFinally, the iterator class contains some special fields for use in specifications. In particular, the iterator specification gets recorded in the following immutable fields:\n\nghost var _reads: setâ©objectâª;\nghost var _modifies: setâ©objectâª;\nghost var _decreases0: T0;\nghost var _decreases1: T1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nwhere there is a _decreases*i*: T*i* field for each component of the iterator's decreases clause.6 In addition, there is a field:\n\nghost var _new: setâ©objectâª;\n\n\n1\n\n\nto which any objects allocated on behalf of the iterator body get added. The iterator body is allowed to remove elements from the _new set, but cannot by assignment to _new add any elements.\n\nNote, in the precondition of the iterator, which is to hold upon construction of the iterator, the in-parameters are indeed in-parameters, not fields of this.\n\n\n# 5.5.âAsync-task types\n\nAnother experimental feature in Dafny that is likely to undergo some evolution is asynchronous methods. When an asynchronous method is called, it does not return values for the out-parameters, but instead returns an instance of an async-task type. An asynchronous method declared in a class C with the following signature:\n\nasync method AMâ©Tâª(in-params) returns (out-params)\n\n\n1\n\n\nalso gives rise to an async-task type AMâ©Tâª (outside the enclosing class, the name of the type needs the qualification C.AMâ©Tâª). The async-task type is a reference type and can be understood as a class with various members, a simplified version of which is described next.\n\nEach in-parameter x of type X of the asynchronous method gives rise to a immutable ghost field of the async-task type:\n\nghost var x: X;\n\n\n1\n\n\nEach out-parameter y of type Y gives rise to a field\n\nvar y: Y;\n\n\n1\n\n\nThese fields are changed automatically by the time the asynchronous method is successfully awaited, but are not assignable by user code.\n\nThe async-task type also gets a number of special fields that are used to keep track of dependencies, outstanding tasks, newly allocated objects, etc. These fields will be described in more detail as the design of asynchronous methods evolves.\n\n\n# 6.âFunction types\n\nFunctions are first-class values in Dafny. Function types have the form (T) -> U where T is a comma-delimited list of types and U is a type. T is called the function's domain type(s) and U is its range type. For example, the type of a function\n\nfunction F(x: int, b: bool): real\n\n\n1\n\n\nis (int, bool) -> real. Parameters are not allowed to be ghost.\n\nTo simplify the appearance of the basic case where a function's domain consist of a list of exactly one type, the parentheses around the domain type can be dropped in this case, as in T -> U. This innocent simplification requires additional explanation in the case where that one type is a tuple type, since tuple types are also written with enclosing parentheses. If the function takes a single argument that is a tuple, an additional set of parentheses is needed. For example, the function\n\nfunction G(pair: (int, bool)): real\n\n\n1\n\n\nhas type ((int, bool)) -> real. Note the necessary double parentheses. Similarly, a function that takes no arguments is different from one that takes a 0-tuple as an argument. For instance, the functions\n\nfunction NoArgs(): real\nfunction Z(unit: ()): real\n\n\n1\n2\n\n\nhave types () -> real and (()) -> real, respectively.\n\nThe function arrow, ->, is right associative, so A -> B -> C means A -> (B -> C). The other association requires explicit parentheses: (A -> B) -> C.\n\nNote that the receiver parameter of a named function is not part of the type. Rather, it is used when looking up the function and can then be thought of as being captured into the function definition. For example, suppose function F above is declared in a class C and that c references an object of type C; then, the following is type correct:\n\nvar f: (int, bool) -> real := c.F;\n\n\n1\n\n\nwhereas it would have been incorrect to have written something like:\n\nvar f': (C, int, bool) -> real := F;  // not correct\n\n\n1\n\n\nOutside its type signature, each function value has three properties, described next.\n\nEvery function implicitly takes the heap as an argument. No function ever depends on the entire heap, however. A property of the function is its declared upper bound on the set of heap locations it depends on for a given input. This lets the verifier figure out that certain heap modifications have no effect on the value returned by a certain function. For a function f: T -> U and a value t of type T, the dependency set is denoted f.reads(t) and has type setâ©objectâª.\n\nThe second property of functions stems from that every function is potentially partial. In other words, a property of a function is its precondition. For a function f: T -> U, the precondition of f for a parameter value t of type T is denoted f.requires(t) and has type bool.\n\nThe third property of a function is more obviousâthe function's body. For a function f: T -> U, the value that the function yields for an input t of type T is denoted f(t) and has type U.\n\nNote that f.reads and f.requires are themselves functions. Suppose f has type T -> U and t has type T. Then, f.reads is a function of type T -> setâ©objectâª whose reads and requires properties are:\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires is a function of type T -> bool whose reads and requires properties are:\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0.âLambda expressions\n\nIn addition to named functions, Dafny supports expressions that define functions. These are called lambda (expression)s (some languages know them as anonymous functions). A lambda expression has the form:\n\n(params) specification => body\n\n\n1\n\n\nwhere *params* is a comma-delimited list of parameter declarations, each of which has the form x or x: T. The type T of a parameter can be omitted when it can be inferred. If the identifier x is not needed, it can be replaced by â_â. If *params* consists of a single parameter x (or _) without an explicit type, then the parentheses can be dropped; for example, the function that returns the successor of a given integer can be written as the following lambda expression:\n\nx => x + 1\n\n\n1\n\n\nThe *specification* is a list of clauses requires E or reads W, where E is a boolean expression and W is a frame expression.\n\n*body* is an expression that defines the function's return value. The body must be well-formed for all possible values of the parameters that satisfy the precondition (just like the bodies of named functions and methods). In some cases, this means it is necessary to write explicit requires and reads clauses. For example, the lambda expression\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nwould not be well-formed if the requires clause were omitted, because of the possibility of division-by-zero.\n\nIn settings where functions cannot be partial and there are no restrictions on reading the heap, the eta expansion of a function F: T -> U (that is, the wrapping of F inside a lambda expression in such a way that the lambda expression is equivalent to F) would be written x => F(x). In Dafny, eta expansion must also account for the precondition and reads set of the function, so the eta expansion of F looks like:\n\nx requires F.requires(x) reads F.reads(x) => F(x)\n\n\n1\n\n\n\n# 7.âNewtypes\n\nA new numeric type can be declared with the newtype declaration7\n\nnewtype N = x: M | Q\n\n\n1\n\n\nwhere M is a numeric type and Q is a boolean expression that can use x as a free variable. If M is an integer-based numeric type, then so is N; if M is real-based, then so is N. If the type M can be inferred from Q, the â: Mâ can be omitted. If Q is just true, then the declaration can be given simply as:\n\nnewtype N = M\n\n\n1\n\n\nType M is known as the base type of N.\n\nA newtype is a numeric type that supports the same operations as its base type. The newtype is distinct from and incompatible with other numeric types; in particular, it is not assignable to its base type without an explicit conversion. An important difference between the operations on a newtype and the operations on its base type is that the newtype operations are defined only if the result satisfies the predicate Q, and likewise for the literals of the newtype.8\n\nFor example, suppose lo and hi are integer-based numerics that satisfy 0 <= lo <= hi and consider the following code fragment:\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nIf lo and hi have type int, then the code fragment is legal; in particular, it never overflows, since int has no upper bound. In contrast, if lo and hi are variables of a newtype int32 declared as follows:\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\nthen the code fragment is erroneous, since the result of the addition may fail to satisfy the predicate in the definition of int32. The code fragment can be rewritten as\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nin which case it is legal for both int and int32.\n\nSince a newtype is incompatible with its base type and since all results of the newtype's operations are members of the newtype, a compiler for Dafny is free to specialize the run-time representation of the newtype. For example, by scrutinizing the definition of int32 above, a compiler may decide to store int32 values using signed 32-bit integers in the target hardware.\n\nNote that the bound variable x in Q has type M, not N. nConsequently, it may not be possible to state Q about the N value. For example, consider the following type of 8-bit 2's complement integers:\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nand consider a variable c of type int8. The expression\n\n-128 <= c < 128\n\n\n1\n\n\nis not well-defined, because the comparisons require each operand to have type int8, which means the literal 128 is checked to be of type int8, which it is not. A proper way to write this expression would be to use a conversion operation, described next, on c to convert it to the base type:\n\n-128 <= int(c) < 128\n\n\n1\n\n\nThere is a restriction that the value 0 must be part of every newtype.9\n\n\n# 7.0.âNumeric conversion operations\n\nFor every numeric type N, there is a conversion function with the same name. It is a partial identity function. It is defined when the given value, which can be of any numeric type, is a member of the type converted to. When the conversion is from a real-based numeric type to an integer-based numeric type, the operation requires that the real-based argument has no fractional part. (To round a real-based numeric value down to the nearest integer, use the .Trunc member, see Section 0.1.)\n\nTo illustrate using the example from above, if lo and hi have type int32, then the code fragment can legally be written as follows:\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nwhere the type of mid is inferred to be int. Since the result value of the division is a member of type int32, one can introduce yet another conversion operation to make the type of mid be int32:\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nIf the compiler does specialize the run-time representation for int32, then these statements come at the expense of two, respectively three, run-time conversions.\n\n\n# 8.âSubset types\n\nA subset type is a restricted use of an existing type, called the base type of the subset type. A subset type is like a combined use of the base type and a predicate on the base type.\n\nAn assignment from a subset type to its base type is always allowed. An assignment in the other direction, from the base type to a subset type, is allowed provided the value assigned does indeed satisfy the predicate of the subset type. (Note, in contrast, assignments between a newtype and its base type are never allowed, even if the value assigned is a value of the target type. For such assignments, an explicit conversion must be used, see Section 7.0.)\n\nDafny supports one subset type, namely the built-in type nat, whose base type is int.10 Type nat designates the non-negative subrange of int. A simple example that puts subset type nat to good use is the standard Fibonacci function:\n\nfunction Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\nAn equivalent, but clumsy, formulation of this function (modulo the wording of any error messages produced at call sites) would be to use type int and to write the restricting predicate in pre- and postconditions:\n\nfunction Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nType inference will never infer the type of a variable to be a subset type. It will instead infer the type to be the base type of the subset type. For example, the type of x in\n\nforall x :: P(x)\n\n\n1\n\n\nwill be int, even if predicate P declares its argument to have type nat.\n\n# Acknowledgments\n\nThis document has been improved as a result of helpful comments from Nadia Polikarpova and Paqui Lucio.\n\n----------------------------------------\n\n0.Being equality-supporting is just one of many modes that one can imagine types in a rich type system to have. For example, other modes could include having a total order, being zero-initializable, and possibly being uninhabited. If Dafny were to support more modes in the future, the â( )â-suffix syntax may be extended. For now, the suffix can only indicate the equality-supporting mode. â©\n\n1.Now that Dafny supports built-in tuples, the plan is to change the sequence slice operation to return not a sequence of subsequences, but a tuple of subsequences. â©\n\n2.This is likely to change in the future to disallow multiple occurrences of the same key. â©\n\n3.This is likely to change in the future as follows: The in and !in operations will no longer be supported on maps. Instead, for any map m, m.Domain will return its domain as a set and m.Range will return, also as a set, the image of m under its domain. â©\n\n4.This will change in a future version of Dafny that will support both nullable and (by default) non-null reference types. â©\n\n5.Soon, object will be made into a built-in trait rather than being a built-in special class. When this happens, it will no longer be possible to do new object. The current compiler restriction that object cannot be used as a type parameter will then also go away. â©\n\n6.It would make sense to rename the special fields _reads and _modifies to have the same names as the corresponding keywords, reads and modifies, as is done for function values. Also, the various _decreases*i* fields can combined into one field named decreases whose type is a n-tuple.\n\nâ©\n\n7.Should newtype perhaps be renamed to numtype? â©\n\n8.Would it be useful to also automatically define predicate N?(m: M) { Q }? â©\n\n9.The restriction is due to a current limitation in the compiler. This will change in the future and will also open up the possibility for subset types and non-null reference types. â©\n\n10.A future version of Dafny will support user-defined subset types. â©",normalizedContent:"# types in dafny\n\nmanuscript krml 243 27 february 2015\n\nk. rustan m. leinoleino@microsoft.com\n\nthis part of the dafny language reference describes the types in the dafny programming language. what is described is what is implemented in version 1.9.3.20107 of dafny, with the exception of async-task types which have not yet made it into the main branch.\n\n0.âbasic types\n\n0.0.âbooleans\n\n0.1.ânumeric types\n\n0.2.âcharacters\n\n1.âtype parameters\n\n2.âcollection types\n\n2.0.âsets\n\n2.1.âmultisets\n\n2.2.âsequences\n\n2.2.0.âstrings\n\n2.3.âfinite and infinite maps\n\n3.âtypes that stand for other types\n\n3.0.âtype synonyms\n\n3.1.âopaque types\n\n4.âdatatypes\n\n4.0.âinductive datatypes\n\n4.1.âtuple types\n\n4.2.âco-inductive datatypes\n\n5.âreference types\n\n5.0.âclasses\n\n5.1.âarrays\n\n5.1.0.âone-dimensional arrays\n\n5.1.1.âmulti-dimensional arrays\n\n5.2.âtraits\n\n5.3.âtype object\n\n5.4.âiterator types\n\n5.5.âasync-task types\n\n6.âfunction types\n\n6.0.âlambda expressions\n\n7.ânewtypes\n\n7.0.ânumeric conversion operations\n\n8.âsubset types\n\n\n# 0.âbasic types\n\ndafny offers three basic types, bool for booleans, int for integers, and real for reals.\n\n\n# 0.0.âbooleans\n\nthere are two boolean values and each has a corresponding literal in the language: false and true.\n\nin addition to equality (==) and disequality (!=), which are defined on all types, type bool supports the following operations:\n\n           \noperator   description\n           \n<==>       equivalence (if and only if)\n           \n==>        implication (implies)\n<==        reverse implication (follows from)\n           \n&&         conjunction (and)\n||         disjunction (or)\n           \n!          negation (not)\n           \n\nnegation is unary; the others are binary. the table shows the operators in groups of increasing binding power, with equality binding stronger than conjunction and disjunction, and weaker than negation. within each group, different operators do not associate, so parentheses need to be used. for example,\n\na && b || c    // error\n\n\n1\n\n\nwould be ambiguous and instead has to be written as either\n\n(a && b) || c\n\n\n1\n\n\nor\n\na && (b || c)\n\n\n1\n\n\ndepending on the intended meaning.\n\nthe expressions a <==> b and a == b give the same value, but note that <==> is associative whereas == is chaining. so,\n\na <==> b <==> c\n\n\n1\n\n\nis the same as\n\na <==> (b <==> c)\n\n\n1\n\n\nand\n\n(a <==> b) <==> c\n\n\n1\n\n\nwhereas\n\na == b == c\n\n\n1\n\n\nis simply a shorthand for\n\na == b && b == c\n\n\n1\n\n\nconjunction is associative and so is disjunction. these operators are are short circuiting (from left to right), meaning that their second argument is evaluated only if the evaluation of the first operand does not determine the value of the expression. logically speaking, the expression a && b is defined when a is defined and either a evaluates to false or b is defined. when a && b is defined, its meaning is the same as the ordinary, symmetric mathematical conjunction â§. the same holds for || and â¨.\n\nimplication is right associative and is short-circuiting from left to right. reverse implication b <== a is exactly the same as a ==> b, but gives the ability to write the operands in the opposite order. consequently, reverse implication is left associative and is short-circuiting from right to left. to illustrate the associativity rules, each of the following four lines expresses the same property, for any a, b, and c of type bool:\n\na ==> b ==> c\na ==> (b ==> c)  // parentheses redundant, since ==> is right associative\nc <== b <== a\n(c <== b) <== a  // parentheses redundant, since <== is left associative\n\n\n1\n2\n3\n4\n\n\nto illustrate the short-circuiting rules, note that the expression a.length is defined for an array a only if a is not null (see section 5), which means the following two expressions are well-formed:\n\na != null ==> 0 <= a.length\n0 <= a.length <== a != null\n\n\n1\n2\n\n\nthe contrapositive of these two expressions would be:\n\na.length < 0 ==> a == null  // not well-formed\na == null <== a.length < 0  // not well-formed\n\n\n1\n2\n\n\nbut these expressions are not well-formed, since well-formedness requires the left (and right, respectively) operand, a.length < 0, to be well-formed by itself.\n\nimplication a ==> b is equivalent to the disjunction !a || b, but is sometimes (especially in specifications) clearer to read. since, || is short-circuiting from left to right, note that\n\na == null || 0 <= a.length\n\n\n1\n\n\nis well-formed, whereas\n\n0 <= a.length || a == null  // not well-formed\n\n\n1\n\n\nis not.\n\nin addition, booleans support logical quantifiers (forall and exists), described in a different part of the dafny language reference.\n\n\n# 0.1.ânumeric types\n\ndafny supports numeric types of two kinds, integer-based, which includes the basic type int of all integers, and real-based, which includes the basic type real of all real numbers. user-defined numeric types based on int and real, called newtypes, are described in section 7. also, the subset type nat, representing the non-negative subrange of int, is described in section 8.\n\nthe language includes a literal for each non-negative integer, like 0, 13, and 1985. integers can also be written in hexadecimal using the prefix â0xâ, as in 0x0, 0xd, and 0x7c1 (always with a lower case x, but the hexadecimal digits themselves are case insensitive). leading zeros are allowed. to form negative integers, use the unary minus operator.\n\nthere are also literals for some of the non-negative reals. these are written as a decimal point with a nonempty sequence of decimal digits on both sides. for example, 1.0, 1609.344, and 0.5772156649.\n\nfor integers (in both decimal and hexidecimal form) and reals, any two digits in a literal may be separated by an underscore in order to improve human readability of the literals. for example:\n\n1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 angstrom\n\n\n1\n2\n3\n4\n\n\nin addition to equality and disequality, numeric types support the following relational operations:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nlike equality and disequality, these operators are chaining, as long as they are chained in the âsame directionâ. that is,\n\na <= b < c == d <= e\n\n\n1\n\n\nis simply a shorthand for\n\na <= b && b < c && c == d && d <= e\n\n\n1\n\n\nwhereas\n\na < b > c\n\n\n1\n\n\nis not allowed.\n\nthere are also operators on each numeric type:\n\n           \noperator   description\n           \n+          addition (plus)\n-          subtraction (minus)\n           \n*          multiplication (times)\n/          division (divided by)\n%          modulus (mod)\n           \n-          negation (unary minus)\n           \n\nthe binary operators are left associative, and they associate with each other in the two groups. the groups are listed in order of increasing binding power, with equality binding more strongly than the multiplicative operators and weaker than the unary operator. modulus is supported only for integer-based numeric types. integer division and modulus are the euclidean division and modulus. this means that modulus always returns a non-negative, regardless of the signs of the two operands. more precisely, for any integer a and non-zero integer b,\n\na == a / b * b + a % b\n0 <= a % b < b\n\n\n1\n2\n\n\nwhere b denotes the absolute value of b.\n\nreal-based numeric types have a member trunc that returns the floor of the real value, that is, the largest integer not exceeding the real value. for example, the following properties hold, for any r and r' of type real:\n\n3.14.trunc == 3\n(-2.5).trunc == -3\n-2.5.trunc == -2\nreal(r.trunc) <= r\nr <= r' ==> r.trunc <= r'.trunc\n\n\n1\n2\n3\n4\n5\n\n\nnote in the third line that member access (like .trunc) binds stronger than unary minus. the fourth line uses the conversion function real from int to real, as described in section 7.0.\n\n\n# 0.2.âcharacters\n\ndafny supports a type char of characters. character literals are enclosed in single quotes, as in 'd'. to write a single quote as a character literal, it is necessary to use an escape sequence. escape sequences can also be used to write other characters. the supported escape sequences are as follows:\n\n                  \nescape sequence   meaning\n                  \n\\'                the character '\n\"                 the character \"\n\\\\                the character \\\n\\0                the null character, same as \\u0000\n\\n                line feed\n\\r                carriage return\n\\t                horizontal tab\n\\u*xxxx*          universal character whose hexadecimal code is *xxxx*\n                  \n\nthe escape sequence for a double quote is redundant, because '\"' and '\"' denote the same characterâboth forms are provided in order to support the same escape sequences as for string literals (section 2.2.0). in the form \\u*xxxx*, the u is always lower case, but the four hexadecimal digits are case insensitive.\n\ncharacter values are ordered and can be compared using the standard relational operators:\n\n           \noperator   description\n           \n<          less than\n<=         at most\n>=         at least\n>          greater than\n           \n\nsequences of characters represent strings, as described in section 2.2.0.\n\n\n# 1.âtype parameters\n\nmany of the types (as well as functions and methods) in dafny can be parameterized by types. these type parameters are typically declared inside angle brackets and can stand for any type. it is sometimes necessary to restrict these type parameters so that they can only be instantiated by certain families of types. as such, dafny distinguishes types that support the equality operation not only in ghost contexts but also in compiled contexts. to indicate that a type parameter is restricted to such equality supporting types, the name of the type parameter takes the suffix â(==)â.0 for example,\n\nmethod compareãt(==)ã(a: t, b: t) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n\n\n1\n2\n3\n4\n\n\nis a method whose type parameter is restricted to equality-supporting types. again, note that all types support equality in ghost contexts; the difference is only for non-ghost (that is, compiled) code. co-inductive datatypes, function types, as well as inductive datatypes with ghost parameters are examples of types that are not equality supporting.\n\ndafny has some inference support that makes certain signatures less cluttered (described in a different part of the dafny language reference). in some cases, this support will infer that a type parameter must be restricted to equality-supporting types, in which case dafny adds the â(==)â automatically.\n\n\n# 2.âcollection types\n\ndafny offers several built-in collection types.\n\n\n# 2.0.âsets\n\nfor any type t, each value of type setãtã is a finite set of t values. set membership is determined by equality in the type t, so setãtã can be used in a non-ghost context only if t is equality supporting.\n\na set can be formed using a set display expression, which is a possibly empty, unordered, duplicate-insensitive list of expressions enclosed in curly braces. to illustrate,\n\n{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of set displays. there is also a set comprehension expression (with a binder, like in logical quantifications), described in a different part of the dafny language reference.\n\nin addition to equality and disequality, set types support the following relational operations:\n\n           \noperator   description\n           \n<          proper subset\n<=         subset\n>=         superset\n>          proper superset\n           \n\nlike the arithmetic relational operators, these operators are chaining.\n\nsets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         disjointness\n           \n+          set union\n-          set difference\n           \n*          set intersection\n           \n\nthe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. the expression a !! b, whose binding power is the same as equality (but which neither associates nor chains with equality), says that sets a and b have no elements in common, that is, it is equivalent to\n\na * b == {}\n\n\n1\n\n\nhowever, the disjointness operator is chaining, so a !! b !! c !! d means:\n\na * b == {} && (a + b) * c == {} && (a + b + c) * d == {}\n\n\n1\n\n\nin addition, for any set s of type setãtã and any expression e of type t, sets support the following operations:\n\n             \nexpression   description\n             \n|s|          set cardinality\ne in s       set membership\ne !in s      set non-membership\n             \n\nthe expression e !in s is a syntactic shorthand for !(e in s).\n\n\n# 2.1.âmultisets\n\na multiset is similar to a set, but keeps track of the multiplicity of each element, not just its presence or absence. for any type t, each value of type multisetãtã is a map from t values to natural numbers denoting each element's multiplicity. multisets in dafny are finite, that is, they contain a finite number of each of a finite set of elements. stated differently, a multiset maps only a finite number of elements to non-zero (finite) multiplicities.\n\nlike sets, multiset membership is determined by equality in the type t, so multisetãtã can be used in a non-ghost context only if t is equality supporting.\n\na multiset can be formed using a multiset display expression, which is a possibly empty, unordered list of expressions enclosed in curly braces after the keyword multiset. to illustrate,\n\nmultiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n\n\n1\n\n\nare three examples of multiset displays. there is no multiset comprehension expression.\n\nin addition to equality and disequality, multiset types support the following relational operations:\n\n           \noperator   description\n           \n<          proper multiset subset\n<=         multiset subset\n>=         multiset superset\n>          proper multiset superset\n           \n\nlike the arithmetic relational operators, these operators are chaining.\n\nmultisets support the following binary operators, listed in order of increasing binding power:\n\n           \noperator   description\n           \n!!         multiset disjointness\n           \n+          multiset union\n-          multiset difference\n           \n*          multiset intersection\n           \n\nthe associaivity rules of +, -, and * are like those of the arithmetic operators with the same names. the expression a !! b says that multisets a and b have no elements in common, that is, it is equivalent to\n\na * b == multiset{}\n\n\n1\n\n\nlike the analogous set operator, !! is chaining.\n\nin addition, for any multiset s of type multisetãtã, expression e of type t, and non-negative integer-based numeric n, multisets support the following operations:\n\n             \nexpression   description\n             \n|s|          multiset cardinality\ne in s       multiset membership\ne !in s      multiset non-membership\ns[e]         multiplicity of e in s\ns[e := n]    multiset update (change of multiplicity)\n             \n\nthe expression e in s returns true if and only if s[e] != 0. the expression e !in s is a syntactic shorthand for !(e in s). the expression s[e := n] denotes a multiset like s, but where the multiplicity of element e is n. note that the multiset update s[e := 0] results in a multiset like s but without any occurrences of e (whether or not s has occurrences of e in the first place). as another example, note that s - multiset{e} is equivalent to:\n\nif e in s then s[e := s[e] - 1] else s\n\n\n1\n\n\n\n# 2.2.âsequences\n\nfor any type t, a value of type seqãtã denotes a sequence of t elements, that is, a mapping from a finite set of consecutive natural numbers (called indicies) to t values. (thinking of it as a map, a sequence is therefore something of a dual of a multiset.)\n\na sequence can be formed using a sequence display expression, which is a possibly empty, ordered list of expressions enclosed in square brackets. to illustrate,\n\n[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n\n\n1\n\n\nare three examples of sequence displays. there is no sequence comprehension expression.\n\nin addition to equality and disequality, sequence types support the following relational operations:\n\n           \noperator   description\n           \n<          proper prefix\n<=         prefix\n           \n\nlike the arithmetic relational operators, these operators are chaining. note the absence of > and >=.\n\nsequences support the following binary operator:\n\n           \noperator   description\n           \n+          concatenation\n           \n\noperator + is associative, like the arithmetic operator with the same name.\n\nin addition, for any sequence s of type seqãtã, expression e of type t, integer-based numeric i satisfying 0 <= i < |s|, and integer-based numerics lo and hi satisfying 0 <= lo <= hi <= |s|, sequences support the following operations:\n\n              \nexpression    description\n              \n|s|           sequence length\ns[i]          sequence selection\ns[i := e]     sequence update\ne in s        sequence membership\ne !in s       sequence non-membership\ns[lo..hi]     subsequence\ns[lo..]       drop\ns[..hi]       take\ns[*slices*]   slice\nmultiset(s)   sequence conversion to a multisetãtã\n              \n\nexpression s[i := e] returns a sequence like s, except that the element at index i is e. the expression e in s says there exists an index i such that s[i] == e. it is allowed in non-ghost contexts only if the element type t is equality supporting. the expression e !in s is a syntactic shorthand for !(e in s).\n\nexpression s[lo..hi] yields a sequence formed by taking the first hi elements and then dropping the first lo elements. the resulting sequence thus has length hi - lo. note that s[0..|s|] equals s. if the upper bound is omitted, it defaults to |s|, so s[lo..] yields the sequence formed by dropping the first lo elements of s. if the lower bound is omitted, it defaults to 0, so s[..hi] yields the sequence formed by taking the first hi elements of s.\n\nin the sequence slice operation, *slices* is a nonempty list of length designators separated and optionally terminated by a colon, and there is at least one colon. each length designator is a non-negative integer-based numeric, whose sum is no greater than |s|. if there are k colons, the operation produces k consecutive subsequences from s, each of the length indicated by the corresponding length designator, and returns these as a sequence of sequences.1 if *slices* is terminated by a colon, then the length of the last slice extends until the end of s, that is, its length is |s| minus the sum of the given length designators. for example, the following equalities hold, for any sequence s of length at least 10:\n\nvar t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe operation multiset(s) yields the multiset of elements of sequence s. it is allowed in non-ghost contexts only if the element type t is equality supporting.\n\n# 2.2.0.âstrings\n\na special case of a sequence type is seqãcharã, for which dafny provides a synonym: string. strings are like other sequences, but provide additional syntax for sequence display expressions, namely string literals. there are two forms of the syntax for string literals: the standard form and the verbatim form.\n\nstring literals of the standard form are enclosed in double quotes, as in \"dafny\". to include a double quote in such a string literal, it is necessary to use an escape sequence. escape sequences can also be used to include other characters. the supported escape sequences are the same as those for character literals, see section 0.2. for example, the dafny expression \"say \\\"yes\\\"\" represents the string say \"yes\". the escape sequence for a single quote is redundant, because \"'\" and \"'\" denote the same stringâboth forms are provided in order to support the same escape sequences as for character literals.\n\nstring literals of the verbatim form are bracketed by @\" and \", as in @\"dafny\". to include a double quote in such a string literal, it is necessary to use the escape sequence \"\", that is, to write the character twice. in the verbatim form, there are no other escape sequences. even characters like newline can be written inside the string literal (hence spanning more than one line in the program text).\n\nfor example, the following three expressions denote the same string:\n\n\"c:\\\\tmp.txt\"\n@\"c:\\tmp.txt\"\n['c', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n\n\n1\n2\n3\n\n\nsince strings are sequences, the relational operators < and <= are defined on them. note, however, that these operators still denote proper prefix and prefix, respectively, not some kind of alphabetic comparison as might be desireable, for example, when sorting strings.\n\n\n# 2.3.âfinite and infinite maps\n\nfor any types t and u, a value of type mapãt,uã denotes a (finite) map from t to u. in other words, it is a look-up table indexed by t. the domain of the map is a finite set of t values that have associated u values. since the keys in the domain are compared using equality in the type t, type mapãt,uã can be used in a non-ghost context only if t is equality supporting.\n\nsimilarly, for any types t and u, a value of type imapãt,uã denotes a (possibly) infinite map. in most regards, imapãt,uã is like mapãt,uã, but a map of type imapãt,uã is allowed to have an infinite domain.\n\na map can be formed using a map display expression, which is a possibly empty, ordered list of maplets, each maplet having the form t := u where t is an expression of type t and u is an expression of type u, enclosed in square brackets after the keyword map. to illustrate,\n\nmap[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n\n\n1\n\n\nare three examples of map displays. by using the keyword imap instead of map, the map produced will be of type imapãt,uã instead of mapãt,uã. note that an infinite map (imap) is allowed to have a finite domain, whereas a finite map (map) is not allowed to have an infinite domain. if the same key occurs more than once, only the last occurrence appears in the resulting map.2 there is also a map comprehension expression, explained in a different part of the dafny language reference.\n\nfor any map fm of type mapãt,uã, any map m of type mapãt,uã or imapãt,uã, any expression t of type t, any expression u of type u, and any d in the domain of m (that is, satisfying d in m), maps support the following operations:\n\n             \nexpression   description\n             \n|fm|         map cardinality\nm[d]         map selection\nm[t := u]    map update\nt in m       map domain membership\nt !in m      map domain non-membership\n             \n\n|fm| denotes the number of mappings in fm, that is, the cardinality of the domain of fm. note that the cardinality operator is not supported for infinite maps. expression m[d] returns the u value that m associates with d. expression m[t := u] is a map like m, except that the element at key t is u. the expression t in m says t is in the domain of m and t !in m is a syntactic shorthand for !(t in m).3\n\nhere is a small example, where a map cache of type mapãint,realã is used to cache computed values of joule-thomson coefficients for some fixed gas at a given temperature:\n\nif k in cache {  // check if temperature is in domain of cache\n  coeff := cache[k];  // read result in cache\n} else {\n  coeff := computejoulethomsoncoefficient(k);  // do expensive computation\n  cache := cache[k := coeff];  // update the cache\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.âtypes that stand for other types\n\nit is sometimes useful to know a type by several names or to treat a type abstractly.\n\n\n# 3.0.âtype synonyms\n\na type synonym declaration:\n\ntype yãtã = g\n\n\n1\n\n\ndeclares yãtã to be a synonym for the type g. here, t is a nonempty list of type parameters (each of which is optionally designated with the suffix â(==)â), which can be used as free type variables in g. if the synonym has no type parameters, the âãtãâ is dropped. in all cases, a type synonym is just a synonym. that is, there is never a difference, other than possibly in error messages produced, between yãtã and g.\n\nfor example, the names of the following type synonyms may improve the readability of a program:\n\ntype replacementsãtã = mapãt,tã\ntype vertex = int\n\n\n1\n2\n\n\nas already described in section 2.2.0, string is a built-in type synonym for seqãcharã, as if it would have been declared as follows:\n\ntype string = seqãcharã\n\n\n1\n\n\n\n# 3.1.âopaque types\n\na special case of a type synonym is one that is underspecified. such a type is declared simply by:\n\ntype yãtã\n\n\n1\n\n\nit is a known as an opaque type. its definition can be revealed in a refining module. to indicate that y designates an equality-supporting type, â(==)â can be written immediately following the name âyâ.\n\nfor example, the declarations\n\ntype t\nfunction f(t: t): t\n\n\n1\n2\n\n\ncan be used to model an uninterpreted function f on some arbitrary type t. as another example,\n\ntype monadãtã\n\n\n1\n\n\ncan be used abstractly to represent an arbitrary parameterized monad.\n\n\n# 4.âdatatypes\n\ndafny offers two kinds of algebraic datatypes, those defined inductively and those defined co-inductively. the salient property of every datatype is that each value of the type uniquely identifies one of the datatype's constructors and each constructor is injective in its parameters.\n\n\n# 4.0.âinductive datatypes\n\nthe values of inductive datatypes can be seen as finite trees where the leaves are values of basic types, numeric types, reference types, co-inductive datatypes, or function types. indeed, values of inductive datatypes can be compared using dafny's well-founded < ordering.\n\nan inductive datatype is declared as follows:\n\ndatatype dãtã = ctors\n\n\n1\n\n\nwhere *ctors* is a nonempty |-separated list of (datatype) constructors for the datatype. each constructor has the form:\n\nc(params)\n\n\n1\n\n\nwhere *params* is a comma-delimited list of types, optionally preceded by a name for the parameter and a colon, and optionally preceded by the keyword ghost. if a constructor has no parameters, the parentheses after the constructor name can be omitted. if no constructor takes a parameter, the type is usually called an enumeration; for example:\n\ndatatype friends = agnes | agatha | jermaine | jack\n\n\n1\n\n\nfor every constructor c, dafny defines a discriminator c?, which is a member that returns true if and only if the datatype value has been constructed using c. for every named parameter p of a constructor c, dafny defines a destructor p, which is a member that returns the p parameter from the c call used to construct the datatype value; its use requires that c? holds. for example, for the standard list type\n\ndatatype listãtã = nil | cons(head: t, tail: listãtã)\n\n\n1\n\n\nthe following holds:\n\ncons(5, nil).cons? && cons(5, nil).head == 5\n\n\n1\n\n\nnote that the expression\n\ncons(5, nil).tail.head\n\n\n1\n\n\nis not well-formed, since cons(5, nil).tail does not satisfy cons?.\n\nthe names of the destructors must be unique across all the constructors of the datatype. a constructor can have the same name as the enclosing datatype; this is especially useful for single-constructor datatypes, which are often called record types. for example, a record type for black-and-white pixels might be represented as follows:\n\ndatatype pixel = pixel(x: int, y: int, on: bool)\n\n\n1\n\n\nto call a constructor, it is usually necessary only to mention the name of the constructor, but if this is ambiguous, it is always possible to qualify the name of constructor by the name of the datatype. for example, cons(5, nil) above can be written\n\nlist.cons(5, list.nil)\n\n\n1\n\n\nas an alternative to calling a datatype constructor explicitly, a datatype value can be constructed as a change in one parameter from a given datatype value using the datatype update expression. for any d whose type is a datatype that includes a constructor c that has a parameter (destructor) named f of type t, and any expression t of type t,\n\nd[f := t]\n\n\n1\n\n\nconstructs a value like d but whose f parameter is t. the operation requires that d satisfies c?. for example, the following equality holds:\n\ncons(4, nil)[tail := cons(3, nil)] == cons(4, cons(3, nil))\n\n\n1\n\n\n\n# 4.1.âtuple types\n\ndafny builds in record types that correspond to tuples and gives these a convenient special syntax, namely parentheses. for example, what might have been declared as:\n\ndatatype pairãt,uã = pair(0: t, 1: u)\n\n\n1\n\n\ndafny provides as the type (t, u) and the constructor (t, u), as if the datatype's name were ââ and its type arguments are given in round parentheses, and as if the constructor name were ââ. note that the destructor names are 0 and 1, which are legal identifier names for members. for example, showing the use of a tuple destructor, here is a property that holds of 2-tuples (that is, pairs):\n\n(5, true).1 == true\n\n\n1\n\n\ndafny declares n-tuples where n is 0 or 2 or up. there are no 1-tuples, since parentheses around a single type or a single value have no semantic meaning. the 0-tuple type, (), is often known as the unit type and its single value, also written (), is known as unit.\n\n\n# 4.2.âco-inductive datatypes\n\nwhereas dafny insists that there is a way to construct every inductive datatype value from the ground up, dafny also supports co-inductive datatypes, whose constructors are evaluated lazily and hence allows infinite structures. a co-inductive datatype is declared using the keyword codatatype; other than that, it is declared and used like an inductive datatype.\n\nfor example,\n\ncodatatype ilistãtã = nil | cons(head: t, tail: ilistãtã)\ncodatatype streamãtã = more(head: t, tail: streamãtã)\ncodatatype treeãtã = node(left: treeãtã, value: t, right: treeãtã)\n\n\n1\n2\n3\n\n\ndeclare possibly infinite lists (that is, lists that can be either finite or infinite), infinite streams (that is, lists that are always infinite), and infinite binary trees (that is, trees where every branch goes on forever), respectively.\n\n\n# 5.âreference types\n\ndafny offers a host of reference types. these represent references to objects allocated dynamically in the program heap. to access the members of an object, a reference to (that is, a pointer to or object identity of) the object is dereferenced.\n\nthe special value null is part of every reference type.4\n\n\n# 5.0.âclasses\n\na class c is a reference type declared as follows:\n\nclass cãtã extends j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere the list of type parameters t is optional and so is âextends jâ, which says that the class extends a trait j. the members of a class are fields, functions, and methods. these are accessed or invoked by dereferencing a reference to a c instance. a function or method is invoked on an instance of c, unless the function or method is declared static. mechanically, this just means the method takes an implicit receiver parameter, namely, the instance used to access the member. in the specification and body of an instance function or method, the receiver parameter can be referred to explicitly by the keyword this. however, in such places, members of this can also be mentioned without any qualification. to illustrate, the qualified this.f and the unqualified f refer to the same field of the same object in the following example:\n\nclass c {\n  var f: int;\n  method example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nso the method body always assigns true to the out-parameter b. there is no semantic difference between qualified and unqualified accesses to the same receiver and member.\n\na c instance is created using new, for example:\n\nc := new c;\n\n\n1\n\n\nnote that new simply allocates a c object and returns a reference to it; the initial values of its fields are arbitrary values of their respective types. therefore, it is common to invoke a method, known as an initialization method, immediately after creation, for example:\n\nc := new c;\nc.initfromlist(xs, 3);\n\n\n1\n2\n\n\nwhen an initialization method has no out-parameters and modifies no more than this, then the two statements above can be combined into one:\n\nc := new c.initfromlist(xs, 3);\n\n\n1\n\n\nnote that a class can contain several initialization methods, that these methods can be invoked at any time, not just as part of a new, and that new does not require that an initialization method be invoked at creation.\n\nto write structured object-oriented programs, one often relies on that objects are constructed only in certain ways. for this purpose, dafny provides constructor (method)s, which are a restricted form of initialization methods. a constructor is declared with the keyword constructor instead of method. when a class contains a constructor, every call to new for that class must be accompanied with a call to one of the constructors. moreover, a constructor cannot be called at other times, only during object creation. other than these restrictions, there is no semantic difference between using ordinary initialization methods and using constructors.\n\nthe dafny design allows the constructors to be named, which promotes using names like initfromlist above. still, many classes have just one constructor or have a typical constructor. therefore, dafny allows one anonymous constructor, that is, a constructor whose name is essentially ââ. for example:\n\nclass item {\n  constructor (x: int, y: int)\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nwhen invoking this constructor, the â.â is dropped, as in:\n\nm := new item(45, 29);\n\n\n1\n\n\nnote that an anonymous constructor is just one way to name a constructor; there can be other constructors as well.\n\n\n# 5.1.âarrays\n\ndafny supports mutable fixed-length array types of any positive dimension. array types are reference types.\n\n# 5.1.0.âone-dimensional arrays\n\na one-dimensional array of n t elements is created as follows:\n\na := new t[n];\n\n\n1\n\n\nthe initial values of the array elements are arbitrary values of type t. the length of an array is retrieved using the immutable length member. for example, the array allocated above satisfies:\n\na.length == n\n\n\n1\n\n\nfor any integer-based numeric i in the range 0 <= i < a.length, the array selection expression a[i] retrieves element i (that is, the element preceded by i elements in the array). the element stored at i can be changed to a value t using the array update statement:\n\na[i] := t;\n\n\n1\n\n\ncaveat: the type of the array created by new t[n] is arrayãtã. a mistake that is simple to make and that can lead to befuddlement is to write arrayãtã instead of t after new. for example, consider the following:\n\nvar a := new arrayãtã;\nvar b := new arrayãtã[n];\nvar c := new arrayãtã(n);  // resolution error\nvar d := new array(n);  // resolution error\n\n\n1\n2\n3\n4\n\n\nthe first statement allocates an array of type arrayãtã, but of unknown length. the second allocates an array of type arrayãarrayãtãã of length n, that is, an array that holds n values of type arrayãtã. the third statement allocates an array of type arrayãtã and then attempts to invoke an anonymous constructor on this array, passing argument n. since array has no constructors, let alone an anonymous constructor, this statement gives rise to an error. if the type-parameter list is omitted for a type that expects type parameters, dafny will attempt to fill these in, so as long as the array type parameter can be inferred, it is okay to leave off the âãtãâ in the fourth statement above. however, as with the third statement, array has no anonymous constructor, so an error message is generated.\n\none-dimensional arrays support operations that convert a stretch of consecutive elements into a sequence. for any array a of type arrayãtã, integer-based numerics lo and hi satisfying 0 <= lo <= hi <= a.length, the following operations each yields a seqãtã:\n\n             \nexpression   description\n             \na[lo..hi]    subarray conversion to sequence\na[lo..]      drop\na[..hi]      take\na[..]        array conversion to sequence\n             \n\nthe expression a[lo..hi] takes the first hi elements of the array, then drops the first lo elements thereof and returns what remains as a sequence. the resulting sequence thus has length hi - lo. the other operations are special instances of the first. if lo is omitted, it defaults to 0 and if hi is omitted, it defaults to a.length. in the last operation, both lo and hi have been omitted, thus a[..] returns the sequence consisting of all the array elements of a.\n\nthe subarray operations are especially useful in specifications. for example, the loop invariant of a binary search algorithm that uses variables lo and hi to delimit the subarray where the search key may be still found can be expressed as follows:\n\nkey !in a[..lo] && key !in a[hi..]\n\n\n1\n\n\nanother use is to say that a certain range of array elements have not been changed since the beginning of a method:\n\na[lo..hi] == old(a[lo..hi])\n\n\n1\n\n\nor since the beginning of a loop:\n\nghost var prevelements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevelements[lo..hi];\n{\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nnote that the type of prevelements in this example is seqãtã, if a has type arrayãtã.\n\na final example of the subarray operation lies in expressing that an array's elements are a permutation of the array's elements at the beginning of a method, as would be done in most sorting algorithms. here, the subarray operation is combined with the sequence-to-multiset conversion:\n\nmultiset(a[..]) == multiset(old(a[..]))\n\n\n1\n\n\n# 5.1.1.âmulti-dimensional arrays\n\nan array of 2 or more dimensions is mostly like a one-dimensional array, except that new takes more length arguments (one for each dimension), and the array selection expression and the array update statement take more indices. for example:\n\nmatrix := new t[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n\n\n1\n2\n\n\ncreate a 2-dimensional array whose dimensions have lengths m and n, respectively, and then swaps the elements at i,j and x,y. the type of matrix is array2ãtã, and similarly for higher-dimensional arrays (array3ãtã, array4ãtã, etc.). note, however, that there is no type array0ãtã, and what could have been array1ãtã is actually named just arrayãtã.\n\nthe new operation above requires m and n to be non-negative integer-based numerics. these lengths can be retrieved using the immutable fields length0 and length1. for example, the following holds of the array created above:\n\nmatrix.length0 == m && matrix.length1 == n\n\n\n1\n\n\nhigher-dimensional arrays are similar (length0, length1, length2, â¦). the array selection expression and array update statement require that the indices are in bounds. for example, the swap statement above is well-formed only if:\n\n0 <= i < matrix.length0 && 0 <= j < matrix.length1 &&\n0 <= x < matrix.length0 && 0 <= y < matrix.length1\n\n\n1\n2\n\n\nin contrast to one-dimensional arrays, there is no operation to convert stretches of elements from a multi-dimensional array to a sequence.\n\n\n# 5.2.âtraits\n\na trait is an âabstract superclassâ, or call it an âinterfaceâ or âmixinâ. traits are new to dafny and are likely to evolve for a while.\n\nthe declaration of a trait is much like that of a class:\n\ntrait j\n{\n  members\n}\n\n\n1\n2\n3\n4\n\n\nwhere *members* can include fields, functions, and methods, but no constructor methods. the functions and methods are allowed to be declared static.\n\na reference type c that extends a trait j is assignable to j, but not the other way around. the members of j are available as members of c. a member in j is not allowed to be redeclared in c, except if the member is a non-static function or method without a body in j. by doing so, type c can supply a stronger specification and a body for the member.\n\nnew is not allowed to be used with traits. therefore, there is no object whose allocated type is a trait. but there can of course be objects of a class c that implements a trait j, and a reference to such a c object can be used as a value of type j.\n\nas an example, the following trait represents movable geometric shapes:\n\ntrait shape\n{\n  function method width(): real\n    reads this\n  method move(dx: real, dy: real)\n    modifies this\n  method moveh(dx: real)\n    modifies this\n  {\n    move(dx, 0.0);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmembers width and move are abstract (that is, body less) and can be implemented differently by different classes that extend the trait. the implementation of method moveh is given in the trait and thus gets used by all classes that extend shape. here are two classes that each extends shape:\n\nclass unitsquare extends shape\n{\n  var x: real, y: real;\n  function method width(): real {  // note the empty reads clause\n    1.0\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass lowerrighttriangle extends shape\n{\n  var xnw: real, ynw: real, xse: real, yse: real;\n  function method width(): real\n    reads this\n  {\n    xse - xnw\n  }\n  method move(dx: real, dy: real)\n    modifies this\n  {\n    xnw, ynw, xse, yse := xnw + dx, ynw + dy, xse + dx, yse + dy;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nnote that the classes can declare additional members, that they supply implementations for the abstract members of the trait, that they repeat the member signatures, and that they are responsible for providing their own member specifications that both strengthen the corresponding specification in the trait and are satisfied by the provided body. finally, here is some code that creates two class instances and uses them together as shapes:\n\nvar myshapes: seqãshapeã;\nvar a := new unitsquare;\nmyshapes := [a];\nvar tri := new lowerrighttriangle;\nmyshapes := myshapes + [tri];  // myshapes contains two shape values, of different classes\nmyshapes[1].moveh(myshapes[0].width());  // move shape 1 to the right by the width of shape 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3.âtype object\n\nthere is a built-in reference type object that is like a supertype of all reference types.5 the purpose of type object is to enable a uniform treatment of dynamic frames. in particular, it is useful to keep a ghost field (typically named repr for ârepresentationâ) of type setãobjectã.\n\n\n# 5.4.âiterator types\n\nan iterator provides a programming abstraction for writing code that iteratively returns elements. these clu-style iterators are co-routines in the sense that they keep track of their own program counter and control can be transferred into and out of the iterator body.\n\nan iterator is declared as follows:\n\niterator iterãtã(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhere t is a list of type parameters (as usual, if there are no type parameters, âãtãâ is omitted). this declaration gives rise to a reference type with the same name, iterãtã. in the signature, in-parameters and yield-parameters are the iterator's analog of a method's in-parameters and out-parameters. the difference is that the out-parameters of a method are returned to a caller just once, whereas the yield-parameters of an iterator are returned each time the iterator body performs a yield. the details of the specification are described in a different part of the dafny language reference. the body consists of statements, like in a method body, but with the availability also of yield statements.\n\nfrom the perspective of an iterator client, the iterator declaration can be understood as generating a class iterãtã with various members, a simplified version of which is described next.\n\nthe iterãtã class contains an anonymous constructor whose parameters are the iterator's in-parameters:\n\npredicate valid()\nconstructor (in-params)\n  modifies this\n  ensures valid()\n\n\n1\n2\n3\n4\n\n\nan iterator is created using new and this anonymous constructor. for example, an iterator willing to return ten consecutive integers from start can be declared as follows:\n\niterator gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nan instance of this iterator is created using:\n\niter := new gen(30);\n\n\n1\n\n\nthe predicate valid() says when the iterator is in a state where one can attempt to compute more elements. it is a postcondition of the constructor and occurs in the specification of the movenext member:\n\nmethod movenext() returns (more: bool)\n  requires valid()\n  modifies this\n  ensures more ==> valid()\n\n\n1\n2\n3\n4\n\n\nnote that the iterator remains valid as long as movenext returns true. once movenext returns false, the movenext method can no longer be called. note, the client is under no obligation to keep calling movenext until it returns false, and the body of the iterator is allowed to keep returning elements forever.\n\nthe in-parameters of the iterator are stored in immutable fields of the iterator class. to illustrate in terms of the example above, the iterator class gen contains the following field:\n\nvar start: int;\n\n\n1\n\n\nthe yield-parameters also result in members of the iterator class:\n\nvar x: int;\n\n\n1\n\n\nthese fields are set by the movenext method. if movenext returns true, the latest yield values are available in these fields and the client can read them from there.\n\nto aid in writing specifications, the iterator class also contains ghost members that keep the history of values returned by movenext. the names of these ghost fields follow the names of the yield-parameters with an âsâ appended to the name (to suggest plural). name checking rules make sure these names do not give rise to ambiguities. the iterator class for gen above thus contains:\n\nghost var xs: seqãintã;\n\n\n1\n\n\nthese history fields are changed automatically by movenext, but are not assignable by user code.\n\nfinally, the iterator class contains some special fields for use in specifications. in particular, the iterator specification gets recorded in the following immutable fields:\n\nghost var _reads: setãobjectã;\nghost var _modifies: setãobjectã;\nghost var _decreases0: t0;\nghost var _decreases1: t1;\n// ...\n\n\n1\n2\n3\n4\n5\n\n\nwhere there is a _decreases*i*: t*i* field for each component of the iterator's decreases clause.6 in addition, there is a field:\n\nghost var _new: setãobjectã;\n\n\n1\n\n\nto which any objects allocated on behalf of the iterator body get added. the iterator body is allowed to remove elements from the _new set, but cannot by assignment to _new add any elements.\n\nnote, in the precondition of the iterator, which is to hold upon construction of the iterator, the in-parameters are indeed in-parameters, not fields of this.\n\n\n# 5.5.âasync-task types\n\nanother experimental feature in dafny that is likely to undergo some evolution is asynchronous methods. when an asynchronous method is called, it does not return values for the out-parameters, but instead returns an instance of an async-task type. an asynchronous method declared in a class c with the following signature:\n\nasync method amãtã(in-params) returns (out-params)\n\n\n1\n\n\nalso gives rise to an async-task type amãtã (outside the enclosing class, the name of the type needs the qualification c.amãtã). the async-task type is a reference type and can be understood as a class with various members, a simplified version of which is described next.\n\neach in-parameter x of type x of the asynchronous method gives rise to a immutable ghost field of the async-task type:\n\nghost var x: x;\n\n\n1\n\n\neach out-parameter y of type y gives rise to a field\n\nvar y: y;\n\n\n1\n\n\nthese fields are changed automatically by the time the asynchronous method is successfully awaited, but are not assignable by user code.\n\nthe async-task type also gets a number of special fields that are used to keep track of dependencies, outstanding tasks, newly allocated objects, etc. these fields will be described in more detail as the design of asynchronous methods evolves.\n\n\n# 6.âfunction types\n\nfunctions are first-class values in dafny. function types have the form (t) -> u where t is a comma-delimited list of types and u is a type. t is called the function's domain type(s) and u is its range type. for example, the type of a function\n\nfunction f(x: int, b: bool): real\n\n\n1\n\n\nis (int, bool) -> real. parameters are not allowed to be ghost.\n\nto simplify the appearance of the basic case where a function's domain consist of a list of exactly one type, the parentheses around the domain type can be dropped in this case, as in t -> u. this innocent simplification requires additional explanation in the case where that one type is a tuple type, since tuple types are also written with enclosing parentheses. if the function takes a single argument that is a tuple, an additional set of parentheses is needed. for example, the function\n\nfunction g(pair: (int, bool)): real\n\n\n1\n\n\nhas type ((int, bool)) -> real. note the necessary double parentheses. similarly, a function that takes no arguments is different from one that takes a 0-tuple as an argument. for instance, the functions\n\nfunction noargs(): real\nfunction z(unit: ()): real\n\n\n1\n2\n\n\nhave types () -> real and (()) -> real, respectively.\n\nthe function arrow, ->, is right associative, so a -> b -> c means a -> (b -> c). the other association requires explicit parentheses: (a -> b) -> c.\n\nnote that the receiver parameter of a named function is not part of the type. rather, it is used when looking up the function and can then be thought of as being captured into the function definition. for example, suppose function f above is declared in a class c and that c references an object of type c; then, the following is type correct:\n\nvar f: (int, bool) -> real := c.f;\n\n\n1\n\n\nwhereas it would have been incorrect to have written something like:\n\nvar f': (c, int, bool) -> real := f;  // not correct\n\n\n1\n\n\noutside its type signature, each function value has three properties, described next.\n\nevery function implicitly takes the heap as an argument. no function ever depends on the entire heap, however. a property of the function is its declared upper bound on the set of heap locations it depends on for a given input. this lets the verifier figure out that certain heap modifications have no effect on the value returned by a certain function. for a function f: t -> u and a value t of type t, the dependency set is denoted f.reads(t) and has type setãobjectã.\n\nthe second property of functions stems from that every function is potentially partial. in other words, a property of a function is its precondition. for a function f: t -> u, the precondition of f for a parameter value t of type t is denoted f.requires(t) and has type bool.\n\nthe third property of a function is more obviousâthe function's body. for a function f: t -> u, the value that the function yields for an input t of type t is denoted f(t) and has type u.\n\nnote that f.reads and f.requires are themselves functions. suppose f has type t -> u and t has type t. then, f.reads is a function of type t -> setãobjectã whose reads and requires properties are:\n\nf.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n\n\n1\n2\n\n\nf.requires is a function of type t -> bool whose reads and requires properties are:\n\nf.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n\n\n1\n2\n\n\n\n# 6.0.âlambda expressions\n\nin addition to named functions, dafny supports expressions that define functions. these are called lambda (expression)s (some languages know them as anonymous functions). a lambda expression has the form:\n\n(params) specification => body\n\n\n1\n\n\nwhere *params* is a comma-delimited list of parameter declarations, each of which has the form x or x: t. the type t of a parameter can be omitted when it can be inferred. if the identifier x is not needed, it can be replaced by â_â. if *params* consists of a single parameter x (or _) without an explicit type, then the parentheses can be dropped; for example, the function that returns the successor of a given integer can be written as the following lambda expression:\n\nx => x + 1\n\n\n1\n\n\nthe *specification* is a list of clauses requires e or reads w, where e is a boolean expression and w is a frame expression.\n\n*body* is an expression that defines the function's return value. the body must be well-formed for all possible values of the parameters that satisfy the precondition (just like the bodies of named functions and methods). in some cases, this means it is necessary to write explicit requires and reads clauses. for example, the lambda expression\n\nx requires x != 0 => 100 / x\n\n\n1\n\n\nwould not be well-formed if the requires clause were omitted, because of the possibility of division-by-zero.\n\nin settings where functions cannot be partial and there are no restrictions on reading the heap, the eta expansion of a function f: t -> u (that is, the wrapping of f inside a lambda expression in such a way that the lambda expression is equivalent to f) would be written x => f(x). in dafny, eta expansion must also account for the precondition and reads set of the function, so the eta expansion of f looks like:\n\nx requires f.requires(x) reads f.reads(x) => f(x)\n\n\n1\n\n\n\n# 7.ânewtypes\n\na new numeric type can be declared with the newtype declaration7\n\nnewtype n = x: m | q\n\n\n1\n\n\nwhere m is a numeric type and q is a boolean expression that can use x as a free variable. if m is an integer-based numeric type, then so is n; if m is real-based, then so is n. if the type m can be inferred from q, the â: mâ can be omitted. if q is just true, then the declaration can be given simply as:\n\nnewtype n = m\n\n\n1\n\n\ntype m is known as the base type of n.\n\na newtype is a numeric type that supports the same operations as its base type. the newtype is distinct from and incompatible with other numeric types; in particular, it is not assignable to its base type without an explicit conversion. an important difference between the operations on a newtype and the operations on its base type is that the newtype operations are defined only if the result satisfies the predicate q, and likewise for the literals of the newtype.8\n\nfor example, suppose lo and hi are integer-based numerics that satisfy 0 <= lo <= hi and consider the following code fragment:\n\nvar mid := (lo + hi) / 2;\n\n\n1\n\n\nif lo and hi have type int, then the code fragment is legal; in particular, it never overflows, since int has no upper bound. in contrast, if lo and hi are variables of a newtype int32 declared as follows:\n\nnewtype int32 = x | -0x80000000 <= x < 0x80000000\n\n\n1\n\n\nthen the code fragment is erroneous, since the result of the addition may fail to satisfy the predicate in the definition of int32. the code fragment can be rewritten as\n\nvar mid := lo + (hi - lo) / 2;\n\n\n1\n\n\nin which case it is legal for both int and int32.\n\nsince a newtype is incompatible with its base type and since all results of the newtype's operations are members of the newtype, a compiler for dafny is free to specialize the run-time representation of the newtype. for example, by scrutinizing the definition of int32 above, a compiler may decide to store int32 values using signed 32-bit integers in the target hardware.\n\nnote that the bound variable x in q has type m, not n. nconsequently, it may not be possible to state q about the n value. for example, consider the following type of 8-bit 2's complement integers:\n\nnewtype int8 = x: int | -128 <= x < 128\n\n\n1\n\n\nand consider a variable c of type int8. the expression\n\n-128 <= c < 128\n\n\n1\n\n\nis not well-defined, because the comparisons require each operand to have type int8, which means the literal 128 is checked to be of type int8, which it is not. a proper way to write this expression would be to use a conversion operation, described next, on c to convert it to the base type:\n\n-128 <= int(c) < 128\n\n\n1\n\n\nthere is a restriction that the value 0 must be part of every newtype.9\n\n\n# 7.0.ânumeric conversion operations\n\nfor every numeric type n, there is a conversion function with the same name. it is a partial identity function. it is defined when the given value, which can be of any numeric type, is a member of the type converted to. when the conversion is from a real-based numeric type to an integer-based numeric type, the operation requires that the real-based argument has no fractional part. (to round a real-based numeric value down to the nearest integer, use the .trunc member, see section 0.1.)\n\nto illustrate using the example from above, if lo and hi have type int32, then the code fragment can legally be written as follows:\n\nvar mid := (int(lo) + int(hi)) / 2;\n\n\n1\n\n\nwhere the type of mid is inferred to be int. since the result value of the division is a member of type int32, one can introduce yet another conversion operation to make the type of mid be int32:\n\nvar mid := int32((int(lo) + int(hi)) / 2);\n\n\n1\n\n\nif the compiler does specialize the run-time representation for int32, then these statements come at the expense of two, respectively three, run-time conversions.\n\n\n# 8.âsubset types\n\na subset type is a restricted use of an existing type, called the base type of the subset type. a subset type is like a combined use of the base type and a predicate on the base type.\n\nan assignment from a subset type to its base type is always allowed. an assignment in the other direction, from the base type to a subset type, is allowed provided the value assigned does indeed satisfy the predicate of the subset type. (note, in contrast, assignments between a newtype and its base type are never allowed, even if the value assigned is a value of the target type. for such assignments, an explicit conversion must be used, see section 7.0.)\n\ndafny supports one subset type, namely the built-in type nat, whose base type is int.10 type nat designates the non-negative subrange of int. a simple example that puts subset type nat to good use is the standard fibonacci function:\n\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n\n\nan equivalent, but clumsy, formulation of this function (modulo the wording of any error messages produced at call sites) would be to use type int and to write the restricting predicate in pre- and postconditions:\n\nfunction fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype inference will never infer the type of a variable to be a subset type. it will instead infer the type to be the base type of the subset type. for example, the type of x in\n\nforall x :: p(x)\n\n\n1\n\n\nwill be int, even if predicate p declares its argument to have type nat.\n\n# acknowledgments\n\nthis document has been improved as a result of helpful comments from nadia polikarpova and paqui lucio.\n\n----------------------------------------\n\n0.being equality-supporting is just one of many modes that one can imagine types in a rich type system to have. for example, other modes could include having a total order, being zero-initializable, and possibly being uninhabited. if dafny were to support more modes in the future, the â( )â-suffix syntax may be extended. for now, the suffix can only indicate the equality-supporting mode. â©\n\n1.now that dafny supports built-in tuples, the plan is to change the sequence slice operation to return not a sequence of subsequences, but a tuple of subsequences. â©\n\n2.this is likely to change in the future to disallow multiple occurrences of the same key. â©\n\n3.this is likely to change in the future as follows: the in and !in operations will no longer be supported on maps. instead, for any map m, m.domain will return its domain as a set and m.range will return, also as a set, the image of m under its domain. â©\n\n4.this will change in a future version of dafny that will support both nullable and (by default) non-null reference types. â©\n\n5.soon, object will be made into a built-in trait rather than being a built-in special class. when this happens, it will no longer be possible to do new object. the current compiler restriction that object cannot be used as a type parameter will then also go away. â©\n\n6.it would make sense to rename the special fields _reads and _modifies to have the same names as the corresponding keywords, reads and modifies, as is done for function values. also, the various _decreases*i* fields can combined into one field named decreases whose type is a n-tuple.\n\nâ©\n\n7.should newtype perhaps be renamed to numtype? â©\n\n8.would it be useful to also automatically define predicate n?(m: m) { q }? â©\n\n9.the restriction is due to a current limitation in the compiler. this will change in the future and will also open up the possibility for subset types and non-null reference types. â©\n\n10.a future version of dafny will support user-defined subset types. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Style Guide for Dafny programs",frontmatter:{title:"Style Guide for Dafny programs",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/c0c2c7/",categories:["è¯­è¨","detailed-document"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/20.detailed-document/10.Style%20Guide%20for%20Dafny%20programers.html",relativePath:"80.è¯­è¨/20.detailed-document/10.Style Guide for Dafny programers.md",key:"v-0789c349",path:"/pages/c0c2c7/",headers:[{level:3,title:"Naming Convention",slug:"naming-convention",normalizedTitle:"naming convention",charIndex:47},{level:4,title:"Method Prefix",slug:"method-prefix",normalizedTitle:"method prefix",charIndex:70},{level:3,title:"Code Layout",slug:"code-layout",normalizedTitle:"code layout",charIndex:87},{level:4,title:"Braces",slug:"braces",normalizedTitle:"braces",charIndex:104},{level:4,title:"Imports",slug:"imports",normalizedTitle:"imports",charIndex:116},{level:3,title:"Indentation and Line Breaks",slug:"indentation-and-line-breaks",normalizedTitle:"indentation and line breaks",charIndex:127},{level:4,title:"Tabs or Spaces?",slug:"tabs-or-spaces",normalizedTitle:"tabs or spaces?",charIndex:160},{level:4,title:"Maximum Character Limit",slug:"maximum-character-limit",normalizedTitle:"maximum character limit",charIndex:181},{level:4,title:"Newlines",slug:"newlines",normalizedTitle:"newlines",charIndex:210},{level:4,title:"Functions, Methods, Predicates, and Lemmas",slug:"functions-methods-predicates-and-lemmas",normalizedTitle:"functions, methods, predicates, and lemmas",charIndex:224},{level:3,title:"Things to Avoid",slug:"things-to-avoid",normalizedTitle:"things to avoid",charIndex:270},{level:4,title:"Parentheses",slug:"parentheses",normalizedTitle:"parentheses",charIndex:291},{level:4,title:"Whitespace",slug:"whitespace",normalizedTitle:"whitespace",charIndex:308},{level:5,title:"Type Declaration",slug:"type-declaration",normalizedTitle:"type declaration",charIndex:326},{level:5,title:"Function, Method, Predicate, and Lemma Declaration",slug:"function-method-predicate-and-lemma-declaration",normalizedTitle:"function, method, predicate, and lemma declaration",charIndex:350},{level:3,title:"Recommendations",slug:"recommendations",normalizedTitle:"recommendations",charIndex:404},{level:4,title:"Externs",slug:"externs",normalizedTitle:"externs",charIndex:425},{level:4,title:"Things to Consider",slug:"things-to-consider",normalizedTitle:"things to consider",charIndex:438}],headersStr:"Naming Convention Method Prefix Code Layout Braces Imports Indentation and Line Breaks Tabs or Spaces? Maximum Character Limit Newlines Functions, Methods, Predicates, and Lemmas Things to Avoid Parentheses Whitespace Type Declaration Function, Method, Predicate, and Lemma Declaration Recommendations Externs Things to Consider",content:'Dafny Documentation\n\n\n#\n\nDafny Style Guide\n\n * Naming Convention\n   * Method Prefix\n * Code Layout\n   * Braces\n   * Imports\n * Indentation and Line Breaks\n   * Tabs or Spaces?\n   * Maximum Character Limit\n   * Newlines\n   * Functions, Methods, Predicates, and Lemmas\n * Things to Avoid\n   * Parentheses\n   * Whitespace\n     * Type Declaration\n     * Function, Method, Predicate, and Lemma Declaration\n * Recommendations\n   * Externs\n   * Things to Consider\n\nThis style guide provides coding conventions for the Dafny code.\n\nThis documentation is still in progress. Please feel free to add more suggestions.\n\n\n# Naming Convention\n\nAny variables are named with camelCase.\n\nvar minValue := 1;\nvar cipherMessage := "Hello World";\n\n\n1\n2\n\n\nAny lemmas, predicates, functions, methods, classes, modules, datatypes, and newtypes are named with PascalCase.\n\nmethod FindIndex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nAny static or global constants are named with UPPERCASE_WITH_UNDERSCORES.\n\nstatic const MONTHS_IN_A_YEAR := 12\n\n\n1\n\n\n# Method Prefix\n\nAvoid redundant names when variables or methods are in a class/module.\n\nclass Integer {\n\n    // The following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to ToString()\n    // so that the method call is Integer.ToString(i)\n    // instead of Integer.IntegerToString(i).\n\n    // YES\n    method ToString(i: int) returns (s: string)\n        ...\n\n    // NO\n    method IntegerToString(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Code Layout\n\n# Braces\n\nOpening braces go on the same line by default.\n\nmodule M {\n    ...\n    method Met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nIn case the method (or function, lemma, etc) signature is too long to fit in one line, or in case the signature has at least one specification clause, the opening brace goes on a new line.\n\nmodule M {\n    ...\n    method Met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThis applies to every scope: module, class, predicate, if, while, and more.\n\n# Imports\n\nBy default, import modules without opening them.\n\nimport Coffee\n...\n\n\n1\n2\n\n\nHowever, if some members of a module are used very frequently, import it using opened:\n\nimport opened Donut\n...\n\n\n1\n2\n\n\nWhen a file uses two modules and both of them define a method of the same name, do not import them opened.\n\nimport MyModule\nimport YourModule\n...\nmethod MyMethod() {\n    MyModule.foo();\n    YourModule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIn this case, if you want to shorten the module name, import it with a shorthand name.\n\nimport M = MyModuleWithACumbersomeName\nimport Y = YourModuleWithACumbersomeName\n...\nmethod MyMethod() {\n    M.foo();\n    Y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nCommon imports, such as StandardLibrary and Native, should be grouped together, followed by custom module imports with a blank line in-between.\n\nimport opened StandardLibrary\nimport opened Native\n\nimport opened Donut\nimport Coffee\n\n\n1\n2\n3\n4\n5\n\n\nAlthough not required, itâs recommended to keep the order of imports and includes alphabetical, except when it makes more sense to group them logically.\n\n\n# Indentation and Line Breaks\n\n# Tabs or Spaces?\n\nSpaces are preferred over tabs. Tabs should only be used to remain consistent with existing code containing tabs.\n\nUse 2 spaces for each indentation.\n\n# Maximum Character Limit\n\nAlthough there is no strict requirement, it is generally recommended to have a maximum of 120 characters per line.\n\n# Newlines\n\nUse newlines between sequential functions, methods, predicates, and lemmas to increase readability.\n\nEnd each file with a newline.\n\n# Functions, Methods, Predicates, and Lemmas\n\nEvery Dafny method has the following signature.\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type) returns (ret: Type)\n    requires P()\n    modifies param2\n    ensures Q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nWhen possible, put MethodName and the returns statement on the same line, as the keyword returns is distinct from other method specification clauses, such as requires, modifies, ensures, and decreases, which should appear in this order. Each method specification clause should be on a separate line, indented.\n\nIn case the Method signature is too long, we can break it down.\n\nmethod {:<attributes>} MethodName(param1: Type, param2: Type,\n        param3: Type, param4: Type, param5: Type)\n    returns (ret1: Type, ret2: Type, ret3: Type, ret4: Type,\n        ret5: Type)\n    requires P1()\n    requires P2()\n    requires P3()\n    modifies param2\n    modifies param3\n    ensures Q1()\n    ensures Q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMultiple requires or ensures can be combined into one:\n\nrequires\n    && P1()\n    && P2()\n    && P3()\n\n\n1\n2\n3\n4\n\n\nThe same rules apply to function, predicate, and lemma definitions.\n\n\n# Things to Avoid\n\n# Parentheses\n\nIn many cases, Dafny does not require parentheses around expressions. Here are some examples.\n\n * If-Else-While Statements\n\n// YES\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// NO\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * Statements That Take Expression Arguments\n\n// YES\nassert x < 100;\nprint x;\n\n// NO\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Simple Boolean/Arithmetic Expressions\n\n// YES\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// NO\nmethod Collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# Whitespace\n\nAvoid unnecessary whitespace inside expressions.\n\n# Type Declaration\n\nA type declaration should have a form of variableName: variableType.\n\n// YES\nconst one: int := 1\nclass {:extern} Util {\n    var {:extern} Exception: System.String\n}\n\n// NO\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} Util {\n    var {:extern} Exception : System.String // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nIf the type can be inferred by Dafny, leave it out, unless you think it provides useful documentation in the program. So, constant one above is better declared as\n\nconst one := 1\n\n\n1\n\n\n# Function, Method, Predicate, and Lemma Declaration\n\nThe function, method, predicate, and lemma definitions should have the form FunctionName(parameterName: parameterType, ...).\n\n// YES\nfunction method Foo<int>(i: int): int\n\n// NO\nfunction method Foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\nAvoid too little or too much whitespace that reduces the overall readability.\n\n// YES\nlemma MyLemma<A, B>(x: seq<seq<A>>, y: B) {\n    ...\n}\n\n// NO\nlemma MyLemma <A,B> ( x : seq<seq<A>> , y :B){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Recommendations\n\nThis section describes a few recommendations that can help make code more readable and easy to follow, although not strictly enforced.\n\n# Externs\n\nTry to name them the same in Dafny and the target language (e.g. C#, Java, etc) whenever possible, so that in Dafny we only have to write {:extern}, not {:extern "<name>"}.\n\n# Things to Consider\n\nAsk these questions before designing / implementing a program in Dafny.\n\n * Is this variable name / function name X a good name?\n * Does it make sense that this method M is in module X? Shouldnât it be in module Y instead?\n * Does the definition X belong to the file Y.dfy?\n * Is X.dfy a good filename?',normalizedContent:'dafny documentation\n\n\n#\n\ndafny style guide\n\n * naming convention\n   * method prefix\n * code layout\n   * braces\n   * imports\n * indentation and line breaks\n   * tabs or spaces?\n   * maximum character limit\n   * newlines\n   * functions, methods, predicates, and lemmas\n * things to avoid\n   * parentheses\n   * whitespace\n     * type declaration\n     * function, method, predicate, and lemma declaration\n * recommendations\n   * externs\n   * things to consider\n\nthis style guide provides coding conventions for the dafny code.\n\nthis documentation is still in progress. please feel free to add more suggestions.\n\n\n# naming convention\n\nany variables are named with camelcase.\n\nvar minvalue := 1;\nvar ciphermessage := "hello world";\n\n\n1\n2\n\n\nany lemmas, predicates, functions, methods, classes, modules, datatypes, and newtypes are named with pascalcase.\n\nmethod findindex(arr: seq<int>, k: int)\n    ...\n\n\n1\n2\n\n\nany static or global constants are named with uppercase_with_underscores.\n\nstatic const months_in_a_year := 12\n\n\n1\n\n\n# method prefix\n\navoid redundant names when variables or methods are in a class/module.\n\nclass integer {\n\n    // the following method converts the given integer\n    // to a string.\n    //\n    // this method name can be simplified to tostring()\n    // so that the method call is integer.tostring(i)\n    // instead of integer.integertostring(i).\n\n    // yes\n    method tostring(i: int) returns (s: string)\n        ...\n\n    // no\n    method integertostring(i: int) returns (s: string)\n        ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# code layout\n\n# braces\n\nopening braces go on the same line by default.\n\nmodule m {\n    ...\n    method met() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nin case the method (or function, lemma, etc) signature is too long to fit in one line, or in case the signature has at least one specification clause, the opening brace goes on a new line.\n\nmodule m {\n    ...\n    method met(i: int) returns (j: int)\n        requires i % 2 == 0\n        ensures j > 10\n    {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nthis applies to every scope: module, class, predicate, if, while, and more.\n\n# imports\n\nby default, import modules without opening them.\n\nimport coffee\n...\n\n\n1\n2\n\n\nhowever, if some members of a module are used very frequently, import it using opened:\n\nimport opened donut\n...\n\n\n1\n2\n\n\nwhen a file uses two modules and both of them define a method of the same name, do not import them opened.\n\nimport mymodule\nimport yourmodule\n...\nmethod mymethod() {\n    mymodule.foo();\n    yourmodule.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nin this case, if you want to shorten the module name, import it with a shorthand name.\n\nimport m = mymodulewithacumbersomename\nimport y = yourmodulewithacumbersomename\n...\nmethod mymethod() {\n    m.foo();\n    y.foo();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ncommon imports, such as standardlibrary and native, should be grouped together, followed by custom module imports with a blank line in-between.\n\nimport opened standardlibrary\nimport opened native\n\nimport opened donut\nimport coffee\n\n\n1\n2\n3\n4\n5\n\n\nalthough not required, itâs recommended to keep the order of imports and includes alphabetical, except when it makes more sense to group them logically.\n\n\n# indentation and line breaks\n\n# tabs or spaces?\n\nspaces are preferred over tabs. tabs should only be used to remain consistent with existing code containing tabs.\n\nuse 2 spaces for each indentation.\n\n# maximum character limit\n\nalthough there is no strict requirement, it is generally recommended to have a maximum of 120 characters per line.\n\n# newlines\n\nuse newlines between sequential functions, methods, predicates, and lemmas to increase readability.\n\nend each file with a newline.\n\n# functions, methods, predicates, and lemmas\n\nevery dafny method has the following signature.\n\nmethod {:<attributes>} methodname(param1: type, param2: type) returns (ret: type)\n    requires p()\n    modifies param2\n    ensures q()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n\n\nwhen possible, put methodname and the returns statement on the same line, as the keyword returns is distinct from other method specification clauses, such as requires, modifies, ensures, and decreases, which should appear in this order. each method specification clause should be on a separate line, indented.\n\nin case the method signature is too long, we can break it down.\n\nmethod {:<attributes>} methodname(param1: type, param2: type,\n        param3: type, param4: type, param5: type)\n    returns (ret1: type, ret2: type, ret3: type, ret4: type,\n        ret5: type)\n    requires p1()\n    requires p2()\n    requires p3()\n    modifies param2\n    modifies param3\n    ensures q1()\n    ensures q2()\n    decreases param1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmultiple requires or ensures can be combined into one:\n\nrequires\n    && p1()\n    && p2()\n    && p3()\n\n\n1\n2\n3\n4\n\n\nthe same rules apply to function, predicate, and lemma definitions.\n\n\n# things to avoid\n\n# parentheses\n\nin many cases, dafny does not require parentheses around expressions. here are some examples.\n\n * if-else-while statements\n\n// yes\nvar i := 1;\nwhile i < 10 {\n    ...\n    if 1 < i {\n        ...\n    }\n    ...\n}\n\n// no\nvar i := 1;\nwhile (i < 10) {\n    ...\n    if (1 < i) {\n        ...\n    }\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * statements that take expression arguments\n\n// yes\nassert x < 100;\nprint x;\n\n// no\nassert(x < 100);\nprint(x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * simple boolean/arithmetic expressions\n\n// yes\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while 1 < n\n        decreases *\n    {\n        n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n    }\n}\n\n// no\nmethod collatz(num: nat)\n    decreases *\n{\n    var n := num;\n    while (1 < n) // unnecessary parentheses\n        decreases *\n    {\n        n := if ((n % 2) == 0) then (n / 2) else ((n * 3) + 1); // unnecessary parentheses\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# whitespace\n\navoid unnecessary whitespace inside expressions.\n\n# type declaration\n\na type declaration should have a form of variablename: variabletype.\n\n// yes\nconst one: int := 1\nclass {:extern} util {\n    var {:extern} exception: system.string\n}\n\n// no\nconst one : int := 1 // unnecessary whitespace\nclass {:extern} util {\n    var {:extern} exception : system.string // unnecessary whitespace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nif the type can be inferred by dafny, leave it out, unless you think it provides useful documentation in the program. so, constant one above is better declared as\n\nconst one := 1\n\n\n1\n\n\n# function, method, predicate, and lemma declaration\n\nthe function, method, predicate, and lemma definitions should have the form functionname(parametername: parametertype, ...).\n\n// yes\nfunction method foo<int>(i: int): int\n\n// no\nfunction method foo<int> (i : int) : int // unnecessary whitespace\n\n\n1\n2\n3\n4\n5\n\n\navoid too little or too much whitespace that reduces the overall readability.\n\n// yes\nlemma mylemma<a, b>(x: seq<seq<a>>, y: b) {\n    ...\n}\n\n// no\nlemma mylemma <a,b> ( x : seq<seq<a>> , y :b){\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# recommendations\n\nthis section describes a few recommendations that can help make code more readable and easy to follow, although not strictly enforced.\n\n# externs\n\ntry to name them the same in dafny and the target language (e.g. c#, java, etc) whenever possible, so that in dafny we only have to write {:extern}, not {:extern "<name>"}.\n\n# things to consider\n\nask these questions before designing / implementing a program in dafny.\n\n * is this variable name / function name x a good name?\n * does it make sense that this method m is in module x? shouldnât it be in module y instead?\n * does the definition x belong to the file y.dfy?\n * is x.dfy a good filename?',charsets:{},lastUpdated:"2022/03/26, 23:17:20",lastUpdatedTimestamp:164830784e4},{title:"Automatic Induction",frontmatter:{title:"Automatic Induction",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/a9363c/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/00.Automatic%20Induction.html",relativePath:"80.è¯­è¨/30.publication-lecture/00.Automatic Induction.md",key:"v-4069c5f8",path:"/pages/a9363c/",headers:[{level:2,title:"0.âRunning example",slug:"_0-running-example",normalizedTitle:"0.ârunning example",charIndex:702},{level:3,title:"0.0.âList and function definitions",slug:"_0-0-list-and-function-definitions",normalizedTitle:"0.0.âlist and function definitions",charIndex:725},{level:3,title:"0.1.âA lemma and proof",slug:"_0-1-a-lemma-and-proof",normalizedTitle:"0.1.âa lemma and proof",charIndex:1360},{level:3,title:"0.2.âTermination in more detail",slug:"_0-2-termination-in-more-detail",normalizedTitle:"0.2.âtermination in more detail",charIndex:4848},{level:3,title:"0.3.âOther termination metrics for RangeLength",slug:"_0-3-other-termination-metrics-for-rangelength",normalizedTitle:"0.3.âother termination metrics for rangelength",charIndex:7999},{level:3,title:"0.4.âA shorter proof",slug:"_0-4-a-shorter-proof",normalizedTitle:"0.4.âa shorter proof",charIndex:10684},{level:3,title:"0.5.âStrong induction",slug:"_0-5-strong-induction",normalizedTitle:"0.5.âstrong induction",charIndex:11781},{level:2,title:"1.âAutomatic induction",slug:"_1-automatic-induction",normalizedTitle:"1.âautomatic induction",charIndex:14076},{level:3,title:"1.0.âThe detailed recipe for automatic induction",slug:"_1-0-the-detailed-recipe-for-automatic-induction",normalizedTitle:"1.0.âthe detailed recipe for automatic induction",charIndex:14772},{level:3,title:"1.1.âExample: missing decreases",slug:"_1-1-example-missing-decreases",normalizedTitle:"1.1.âexample: missing decreases",charIndex:17045},{level:3,title:"1.2.âExample: quantifying over just len",slug:"_1-2-example-quantifying-over-just-len",normalizedTitle:"1.2.âexample: quantifying over just len",charIndex:17738},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:19139},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:19291}],headersStr:"0.âRunning example 0.0.âList and function definitions 0.1.âA lemma and proof 0.2.âTermination in more detail 0.3.âOther termination metrics for RangeLength 0.4.âA shorter proof 0.5.âStrong induction 1.âAutomatic induction 1.0.âThe detailed recipe for automatic induction 1.1.âExample: missing decreases 1.2.âExample: quantifying over just len Acknowledgments References",content:"Dafny Power User: Automatic Induction\n\nK. Rustan M. Leino\n\nManuscript KRML 269, 31 May 2019\n\nAbstract. For simple examples, Dafny's automatic induction is powerful enough to prove some lemmas without manual input and helps reduce the manual input required to prove others. This note explains how automatic induction is applied and how the two main knobs are used to adjust what the automation does.\n\nDafny not only supports manually written lemmas, but also provides some automation that assists in proving lemmas by induction [0]. Let's start with variations of a manual proof, then see how automatic induction provides or fails to provide a proof, and finally how to adjust what automation does.\n\n\n# 0.âRunning example\n\n\n# 0.0.âList and function definitions\n\nConsider the following standard definition of recursively defined lists along with a Length function and a function that constructs a list of increasing integers.\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Range(start: int, len: nat): List<int>\n  decreases len\n{\n  if len == 0 then Nil else Cons(start, Range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWith these definitions, let's set out to prove that the length of the list Range(start, len) is len.\n\n\n# 0.1.âA lemma and proof\n\nSo, we're going to prove that the length of the list Range(start, len) is len. We start with a manual proof. To be sure that automatic induction does not help us along in this first example, I have marked with lemmas with the attribute {:induction false}.\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      Length(Range(start, len));\n    ==  // def. Range, since len > 0\n      Length(Cons(start, Range(start+1, len-1)));\n    ==  // def. Length on Cons\n      1 + Length(Range(start+1, len-1));\n    ==  { RangeLength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nFor the purpose of this note, I assume you have a basic understanding of how to write proof like this manually, either in Dafny or on paper. I will describe the elements of the proof here, but won't try to explain all possible considerations.\n\nThe lemma is called RangeLength and is parameterized by start and len, just like the Range function is. The property that the lemma proves is stated in the ensures clause. It is also called the proof goal.\n\nThe signature part of the lemma also defines a decreases clause, which says that the expression len is to be used as the termination metric for any recursive calls of the lemma. This termination metric is the same as the one of the Range function. This is common, because the structure of a proof typically follows the structure of a function in the lemma's proof goal.\n\nThe body of the lemma is divided up into two cases, following the cases in the definition of Range. The first case is len == 0 and gives rise to a very simple proof: when len == 0, Range returns Nil whose length is 0.\n\nThe other case makes use of a verified calculation, commonly known as a calc statement [1]. This calculation starts with the expression Length(Range(start, len)) and uses equality-preserving transformations to arrive at len, which is exactly what the proof goal says the lemma has to prove. The first two steps of the calculation apply the definitions of Range and Length to rewrite the expression into a form where we see the expression\n\nLength(Range(start+1, len-1))\n\n\n1\n\n\nThis is where the one interesting step of the proof takes place. We want to replace this expression with len - 1, which requires a justification that the expression indeed equals len - 1. With the right parameterization, this is exactly what the lemma we're trying to prove says. Therefore, we use a calc-statement hint and call the lemma:\n\nRangeLength(start+1, len-1);\n\n\n1\n\n\nBecause this is a recursive call to the lemma we're trying to prove, we must prove termination. A recursive call to a lemma is commonly known as an application of the induction hypothesis. In that way, our termination check corresponds to making sure that the induction is well-founded. In Dafny, termination is proved by showing that every recursive call decreases some termination metric, which is to say that some expression evaluates to a smaller value for the recursive call than it does for the caller. What is this termination-metric expression that is to be smaller and what does âsmallerâ mean? The expression is len, as given by the decreases clause, and since len is an integer, Dafny uses \"integer less-than, bounded below by 0\" as the order.\n\n\n# 0.2.âTermination in more detail\n\nThat was a mouthful. Let's review that last part again, the part about termination.\n\nTo prove that recursive calls to a (function or method or) lemma terminate, we associate each invocation of the lemma with a value in a well-founded order. Being well-founded means that there are no infinite descending chains. That is, there is fixed ordering and every sequence of successively smaller values in that ordering is finite. For example, in the \"integer less-than, bounded below by 0\" ordering, one descending chain is\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nThis chain is finite. No matter what descending chain you write down, it will be finite in this ordering (otherwise, you would eventually get a negative number, but remember we said \"bounded below by 0\"0).\n\nDafny builds in a fixed well-founded order for every type.1 It also supports lexicographic tuples of values, and the well-founded order for such tuples is the lexicographic ordering of the types on each component.\n\nThe way we associate a lemma invocation with a value in this fixed well-founded order is that we declare a decreases clause. It takes as its argument a list of expressions, and these form a lexicographic tuple. For our RangeLength lemma, we used decreases len. This says that each invocation of the lemma will be associated with the same value as is passed in as parameter len.\n\nFunction Range is also recursive, and for its invocations, we also used len as the termination metric. Function Length is recursive, too, but evidently we didn't give a decreases clause for it. In the absence of a decreases clause, Dafny provides one for us, namely the lexicographic tuple consisting of the function/method/lemma's parameters, in the order given.2 So, the termination metric of Length is list (and Dafny's well-founded order for inductive datatypes is structural inclusion). Dafny's IDEs provide a tool tip (which you can see by hovering over the function/method/lemma declaration) that tells you which decreases clause it picks for recursive functions/methods/lemmas.\n\nSo far, I've said that Dafny defines a fixed well-founded ordering and the way to associate lemma invocation with a value in that ordering is to declare a decreases clause. How does the verifier use these things to prove termination? It proves that the value associated with a callee is strictly below the value associated with the caller. In other words, it proves that every recursive call takes a step in a descending chain. Because every chain is finite, it follows that there is no infinite recursion. In other words, the recursive calls terminate.\n\nIn the example, there's a recursive call from RangeLength(start, len) to RangeLength(start+1, len-1). The lemma uses decreases len, so the verifier checks that len-1 < len, which proves termination.\n\nSimilarly, there is a recursive call from Range(start, len) to Range(start+1, len-1). The verifier checks len-1 < len and this proves termination.\n\nFinally, there is a recursive call from Length(list) to Length(tail), where tail is structurally included in list. Thus, the verifier is able to prove termination here as well.\n\n\n# 0.3.âOther termination metrics for RangeLength\n\nIt is instructive to consider what would happen if we had chosen a different termination metric for RangeLength. For each one we consider, the proof obligation is constructed the same way: the value for RangeLength(start+1, len-1) must be smaller than the value for RangeLength(start, len).\n\nSuppose we declared RangeLength with decreases 10*len + 28. Yes, this termination metric is good enough to prove termination, because 10*len + 18 is less than 10*len + 28.\n\nWhat about decreases len - 6? No, Dafny will complain about not being able to prove termination if you give it this termination metric. It will fail to prove that len-7 is below len-6 in the integer ordering, because these could be negative.3\n\nLet's try decreases start + len. No, because start+1 + len-1 is not less than start + len.\n\nHow about decreases start + 2*len. Yes, this proves termination, because start+1 + 2*(len-1) is less than start + 2*len.\n\nWhat about using the lexicographic tuple decreases start, len? No, this won't prove termination, because start+1, len-1 is not lexicographically smaller than start, len (in fact, it is lexicographically larger). Had we left off the decreases clause from RangeLength altogether, Dafny would have generated one for us. It generates it to be decreases start, len, because the parameters of RangeLength are start and len, in that order. So, without an explicit decreases clause, Dafny would complain about not being able to prove termination.\n\nHow about switching the order of the arguments, as in decreases len, start? Yes, this proves termination, because len-1, start+1 is smaller than len, start.\n\nIf you change RangeLength to swap its parameters start and len (and do the same swapping for the recursive call to RangeLength), then you could have left off the decreases clause. In this case, Dafny would generate decreases len, start, and that proves termination. However, it's usually advisable to stick with the parameter ordering that is most natural for the function/method/lemma at hand.\n\nLastly, how about this quirky termination metric: decreases 7, len? When you first read this out loud, you might say\n\n> Decreases 7? How can anything decrease 7? 7 is what it was when my great-grandparents were alive, and 7 will always be just that. There is no way to decrease 7!\n\nYou are right, but that's not what the decreases clause says. The decreases clause simply says how to map each lemma invocation to a value in the well-founded order. So, with this quirky termination metric, the proof obligation is to check that 7, len-1 is lexicographically smaller than 7, len, which it is. Not so quirky after all.\n\n\n# 0.4.âA shorter proof\n\nLet's simplify the manual proof we wrote for RangeLength. The calc statement is helpful when we write a proof in the first place, and it also gives a readable presentation of the proof. But once we have figured out a proof, we sometimes choose to shorten it, perhaps because in retrospect we found we were too punctilious even for our own taste.\n\nThe calc statement we wrote above really just has one non-trivial step, the application of the induction hypothesis. In fact, we can replace the entire calc statement with just that one call:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSince the âthenâ branch of the if is empty, we can of course also negate the guard, swap the branches, and omit the empty else:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    RangeLength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 0.5.âStrong induction\n\nCan we do even better than that one if statement? Well, that depends on what you think is better, but there is a way in Dafny to eliminate this branch. We can do that by replacing the entire if statement and its one call to RangeLength by a forall statement that calls RangeLength for a whole bunch of values.\n\nTo get this started, suppose we tried using the following as the body of RangeLength:\n\nforall start', len' {\n  RangeLength(start', len');\n}\n\n\n1\n2\n3\n\n\nThis rather cavalier statement calls RangeLength for all possible values of start' and len'. Well, this doesn't work, because many of those recursive calls won't terminate. We need to restrict ourselves to values of start' and len' that decrease the termination metric.\n\nSo, let's try this:\n\nlemma {:induction false} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n  forall start', len' | 0 <= len' < len {\n    RangeLength(start', len');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThis calls RangeLength for all values of start' and all values of len' smaller than len. That is, this forall statement makes an infinite number of recursive calls to RangeLength, all at once. Each of these infinitely many calls terminates, because the value of len' is smaller than len.4\n\nThis version of RangeLength verifies. The mathematical name for calling an induction hypothesis for all smaller values like this is called strong induction.\n\nWell, values of start' can be larger than start (in that, it is crucial for the proof that start + 1 is one of those values). So, you may opine that the forall statement above does more than just strong induction. Indeed, some may argue that this forall statement also performs what is called generalizing the lemma to all values of start'. But if you consider the ordering that determines âsmallerâ to be one that just compares the len component, then start', len' is indeed smaller than start, len, as long as len' is smaller than len. However you want to think about it or whatever mathematical name you want to give to it, Dafny accepts the forall statement above as a proof. In programming terms, all we're doing is proving that each recursive call terminates, and that follows from the way we defined the termination metric by decreases len.\n\n\n# 1.âAutomatic induction\n\nWith all that background, we are finally ready to learn what Dafny does to automate induction. Here's the short of it: if you remove the attribute {:induction false} (which I introduced only to disable automatic induction while we were discussing what makes a proof in the first place), then what Dafny does by default is insert the forall statement we just saw. This means you can remove the manually inserted forall statement, because Dafny will add it for you. In other words, Dafny accepts the following as a proof of the lemma:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nShort and sweet.\n\n\n# 1.0.âThe detailed recipe for automatic induction\n\nDafny automated induction all comes down to the maneuver of automatically generating one forall statement at the beginning of every lemma. This does not solve all problems of induction, but I'm amazed at how many simple problems of induction that this simple maneuver does solve. Let's look at the ingredients that go into the maneuver.\n\nFor a lemma L with formal arguments args, precondition P(args),5 and termination metric T(args), Dafny automatic induction inserts the following forall statement at the beginning of the body of L:\n\nforall aa' | P(args') && T(args') < T(args) {\n  L(args');\n}\n\n\n1\n2\n3\n\n\nwhere\n\n * aa is a subset of the formal parameters args,\n * aa' is aa, suitably renamed to have fresh names,\n * args' denotes args but with every variable in aa replaced by the corresponding one in aa', and\n * < denotes Dafny's well-founded lexicographic order.\n\nThe subset aa of the variables args can be customized by placing the attribute {:induction aa} on the lemma. If no such attribute is given, then Dafny picks aa heuristically. Dafny reports what it picks in a tool tip that the Dafny IDEs show when you hover over the name of the lemma.\n\nWe might think of {:induction x} as saying we're \"doing induction over xâ, but be a little bit careful with this. I find that common mathematical usage of the phrase âdo induction over â¦\" conflates several ideas. So, to be precise about it, what the {:induction aa} attribute specifies is which parameters are to be universally quantified over.\n\nThere is one more subtlety that is easy to forget: the decreases clause matters. When we write a lemma like RangeLength, we might expect the proof to be simple enough that Dafny's automatic induction will take care of it automatically. If so, we might just write down the type signature of the lemma and the (pre- and) postcondition. This often is all that's needed, but in the case of RangeLength, it is also necessary to supply a decreases clause. Usually, if the main function that the lemma is about (Range in the running example) needs an explicit decreases clause, then the lemma does, too. Alas, this can be easy to forget.\n\nNext, let's consider some ways of customizing the automatic induction for RangeLength.\n\n\n# 1.1.âExample: missing decreases\n\nWhat happens if you do forget the decreases clause of RangeLength? The lemma then looks like this:\n\nlemma RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nFor this lemma, Dafny comes up with {:induction start, len} and decreases start, len.6 That means the implicit forall statement that the induction maneuver inserts is\n\nforall start': nat, len': nat |\n  start' < start || (start' == start && len' < len)\n{\n  RangeLength(start', len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nAs we explored in the previous section, this does not prove the lemma, because the crucial call RangeLength(start+1, len-1) is not among the calls performed.\n\n\n# 1.2.âExample: quantifying over just len\n\nWhat if we manually override the quantified variables and list only len?\n\nlemma {:induction len} RangeLength(start: nat, len: nat)\n  ensures Length(Range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nWe then get the following forall statement:\n\nforall len': nat |\n  start < start || (start == start && len' < len)\n{\n  RangeLength(start, len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nNotice how there is no start' in this example. Rather, the original formal parameter start is used in the formulaic range expression\n\nP(start, len') && T(start, len') < T(start, len)\n\n\n1\n\n\nThere is no precondition in the example, so the P part is true. Because we didn't supply an explicit decreases clause, Dafny generates decreases start, len. Therefore, the range expression that restricts the universally quantified variables (that is, len') is\n\nstart < start || (start == start && len' < len)\n\n\n1\n\n\nwhich simplifies to len' < len.\n\nAgain, since the recursive calls entailed by this forall statement does not include the crucial call RangeLength(start+1, len-1), Dafny will report an error that the lemma's postcondition might not hold.\n\nThe result would be the same even if we supplied a decreases clause manually. That would still restrict len' to values that are smaller than len, which is fine, but the problem is still that the inductive hypothesis is only considered for the given value of start.\n\n# Acknowledgments\n\nI'm grateful to Sean McLaughlin, who provided both the running example and the question about automatic induction for RangeLength.\n\n\n# References\n\n[0]K. Rustan M. Leino. Automating induction with an SMT solver. In Viktor Kuncak and Andrey Rybalchenko, editors, Verification, Model Checking, and Abstract Interpretation â 13th International Conference, VMCAI 2012, volume 7148 of Lecture Notes in Computer Science, pages 315â331. Springer, January 2012. ð\n\n[1]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments â 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170â190. Springer, 2014. ð\n\n----------------------------------------\n\n0.I'm simplifying a little bit. Dafny's well-founded order on integers is actually âinteger less-than, with no more than one negative valueâ. So, a chain is allowed to dip down below 0, but once the chain includes a negative number, it must stop. This extension is a well-founded order, because there is still no way to make an infinite descending chain. â©\n\n1.I'm simplifying a little bit. Dafny's fixed well-founded order also orders some values across different types. â©\n\n2.This is a slight simplification. Dafny's heuristic for coming up with a decreases clause for a recursive function/method/lemma omits parameters whose types aren't helpful in letting you prove termination. For example, a parameter whose type is a type parameter is omitted from automatically generated decreases clauses. â©\n\n3.I was fast and loose in the previous example, because I should have also pointed out that 10*len + 18 is non-negative.) â©\n\n4.âAn infinite number of calls?!â, you say to yourself. âHow is that termination, even if each such call terminates?â I won't delve into that here, but I will at least point out that we're calling a lemma, not a compiled method. So, you don't need to worry about having enough computational resources to make an infinite number of calls. â©\n\n5.A precondition of a lemma is declared using the keyword requires. It is like an antecedent of the lemma, and it is checked to hold at every call site. The running example does not include a precondition. A simple way to include one would be to change the type of start from nat to int and to add requires 0 <= start. â©\n\n6.I mentioned that tool tips in the Dafny IDEs show you what decreases clause Dafny picks. As of this writing, such a tool tip is shown only when the body of the function/method/lemma includes an explicit recursive call. In particular, if the body of the lemma is empty, there is no tool tip that shows you what decreases clause is generated. â©",normalizedContent:"dafny power user: automatic induction\n\nk. rustan m. leino\n\nmanuscript krml 269, 31 may 2019\n\nabstract. for simple examples, dafny's automatic induction is powerful enough to prove some lemmas without manual input and helps reduce the manual input required to prove others. this note explains how automatic induction is applied and how the two main knobs are used to adjust what the automation does.\n\ndafny not only supports manually written lemmas, but also provides some automation that assists in proving lemmas by induction [0]. let's start with variations of a manual proof, then see how automatic induction provides or fails to provide a proof, and finally how to adjust what automation does.\n\n\n# 0.ârunning example\n\n\n# 0.0.âlist and function definitions\n\nconsider the following standard definition of recursively defined lists along with a length function and a function that constructs a list of increasing integers.\n\ndatatype list<a> = nil | cons(a, list<a>)\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method range(start: int, len: nat): list<int>\n  decreases len\n{\n  if len == 0 then nil else cons(start, range(start+1, len-1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwith these definitions, let's set out to prove that the length of the list range(start, len) is len.\n\n\n# 0.1.âa lemma and proof\n\nso, we're going to prove that the length of the list range(start, len) is len. we start with a manual proof. to be sure that automatic induction does not help us along in this first example, i have marked with lemmas with the attribute {:induction false}.\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n    // trivial\n  } else {\n    calc {\n      length(range(start, len));\n    ==  // def. range, since len > 0\n      length(cons(start, range(start+1, len-1)));\n    ==  // def. length on cons\n      1 + length(range(start+1, len-1));\n    ==  { rangelength(start+1, len-1); }  // apply induction hypothesis\n      1 + len - 1;\n    ==  // arithmetic\n      len;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nfor the purpose of this note, i assume you have a basic understanding of how to write proof like this manually, either in dafny or on paper. i will describe the elements of the proof here, but won't try to explain all possible considerations.\n\nthe lemma is called rangelength and is parameterized by start and len, just like the range function is. the property that the lemma proves is stated in the ensures clause. it is also called the proof goal.\n\nthe signature part of the lemma also defines a decreases clause, which says that the expression len is to be used as the termination metric for any recursive calls of the lemma. this termination metric is the same as the one of the range function. this is common, because the structure of a proof typically follows the structure of a function in the lemma's proof goal.\n\nthe body of the lemma is divided up into two cases, following the cases in the definition of range. the first case is len == 0 and gives rise to a very simple proof: when len == 0, range returns nil whose length is 0.\n\nthe other case makes use of a verified calculation, commonly known as a calc statement [1]. this calculation starts with the expression length(range(start, len)) and uses equality-preserving transformations to arrive at len, which is exactly what the proof goal says the lemma has to prove. the first two steps of the calculation apply the definitions of range and length to rewrite the expression into a form where we see the expression\n\nlength(range(start+1, len-1))\n\n\n1\n\n\nthis is where the one interesting step of the proof takes place. we want to replace this expression with len - 1, which requires a justification that the expression indeed equals len - 1. with the right parameterization, this is exactly what the lemma we're trying to prove says. therefore, we use a calc-statement hint and call the lemma:\n\nrangelength(start+1, len-1);\n\n\n1\n\n\nbecause this is a recursive call to the lemma we're trying to prove, we must prove termination. a recursive call to a lemma is commonly known as an application of the induction hypothesis. in that way, our termination check corresponds to making sure that the induction is well-founded. in dafny, termination is proved by showing that every recursive call decreases some termination metric, which is to say that some expression evaluates to a smaller value for the recursive call than it does for the caller. what is this termination-metric expression that is to be smaller and what does âsmallerâ mean? the expression is len, as given by the decreases clause, and since len is an integer, dafny uses \"integer less-than, bounded below by 0\" as the order.\n\n\n# 0.2.âtermination in more detail\n\nthat was a mouthful. let's review that last part again, the part about termination.\n\nto prove that recursive calls to a (function or method or) lemma terminate, we associate each invocation of the lemma with a value in a well-founded order. being well-founded means that there are no infinite descending chains. that is, there is fixed ordering and every sequence of successively smaller values in that ordering is finite. for example, in the \"integer less-than, bounded below by 0\" ordering, one descending chain is\n\n57, 56, 48, 39, 20, 4\n\n\n1\n\n\nthis chain is finite. no matter what descending chain you write down, it will be finite in this ordering (otherwise, you would eventually get a negative number, but remember we said \"bounded below by 0\"0).\n\ndafny builds in a fixed well-founded order for every type.1 it also supports lexicographic tuples of values, and the well-founded order for such tuples is the lexicographic ordering of the types on each component.\n\nthe way we associate a lemma invocation with a value in this fixed well-founded order is that we declare a decreases clause. it takes as its argument a list of expressions, and these form a lexicographic tuple. for our rangelength lemma, we used decreases len. this says that each invocation of the lemma will be associated with the same value as is passed in as parameter len.\n\nfunction range is also recursive, and for its invocations, we also used len as the termination metric. function length is recursive, too, but evidently we didn't give a decreases clause for it. in the absence of a decreases clause, dafny provides one for us, namely the lexicographic tuple consisting of the function/method/lemma's parameters, in the order given.2 so, the termination metric of length is list (and dafny's well-founded order for inductive datatypes is structural inclusion). dafny's ides provide a tool tip (which you can see by hovering over the function/method/lemma declaration) that tells you which decreases clause it picks for recursive functions/methods/lemmas.\n\nso far, i've said that dafny defines a fixed well-founded ordering and the way to associate lemma invocation with a value in that ordering is to declare a decreases clause. how does the verifier use these things to prove termination? it proves that the value associated with a callee is strictly below the value associated with the caller. in other words, it proves that every recursive call takes a step in a descending chain. because every chain is finite, it follows that there is no infinite recursion. in other words, the recursive calls terminate.\n\nin the example, there's a recursive call from rangelength(start, len) to rangelength(start+1, len-1). the lemma uses decreases len, so the verifier checks that len-1 < len, which proves termination.\n\nsimilarly, there is a recursive call from range(start, len) to range(start+1, len-1). the verifier checks len-1 < len and this proves termination.\n\nfinally, there is a recursive call from length(list) to length(tail), where tail is structurally included in list. thus, the verifier is able to prove termination here as well.\n\n\n# 0.3.âother termination metrics for rangelength\n\nit is instructive to consider what would happen if we had chosen a different termination metric for rangelength. for each one we consider, the proof obligation is constructed the same way: the value for rangelength(start+1, len-1) must be smaller than the value for rangelength(start, len).\n\nsuppose we declared rangelength with decreases 10*len + 28. yes, this termination metric is good enough to prove termination, because 10*len + 18 is less than 10*len + 28.\n\nwhat about decreases len - 6? no, dafny will complain about not being able to prove termination if you give it this termination metric. it will fail to prove that len-7 is below len-6 in the integer ordering, because these could be negative.3\n\nlet's try decreases start + len. no, because start+1 + len-1 is not less than start + len.\n\nhow about decreases start + 2*len. yes, this proves termination, because start+1 + 2*(len-1) is less than start + 2*len.\n\nwhat about using the lexicographic tuple decreases start, len? no, this won't prove termination, because start+1, len-1 is not lexicographically smaller than start, len (in fact, it is lexicographically larger). had we left off the decreases clause from rangelength altogether, dafny would have generated one for us. it generates it to be decreases start, len, because the parameters of rangelength are start and len, in that order. so, without an explicit decreases clause, dafny would complain about not being able to prove termination.\n\nhow about switching the order of the arguments, as in decreases len, start? yes, this proves termination, because len-1, start+1 is smaller than len, start.\n\nif you change rangelength to swap its parameters start and len (and do the same swapping for the recursive call to rangelength), then you could have left off the decreases clause. in this case, dafny would generate decreases len, start, and that proves termination. however, it's usually advisable to stick with the parameter ordering that is most natural for the function/method/lemma at hand.\n\nlastly, how about this quirky termination metric: decreases 7, len? when you first read this out loud, you might say\n\n> decreases 7? how can anything decrease 7? 7 is what it was when my great-grandparents were alive, and 7 will always be just that. there is no way to decrease 7!\n\nyou are right, but that's not what the decreases clause says. the decreases clause simply says how to map each lemma invocation to a value in the well-founded order. so, with this quirky termination metric, the proof obligation is to check that 7, len-1 is lexicographically smaller than 7, len, which it is. not so quirky after all.\n\n\n# 0.4.âa shorter proof\n\nlet's simplify the manual proof we wrote for rangelength. the calc statement is helpful when we write a proof in the first place, and it also gives a readable presentation of the proof. but once we have figured out a proof, we sometimes choose to shorten it, perhaps because in retrospect we found we were too punctilious even for our own taste.\n\nthe calc statement we wrote above really just has one non-trivial step, the application of the induction hypothesis. in fact, we can replace the entire calc statement with just that one call:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len == 0 {\n  } else {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsince the âthenâ branch of the if is empty, we can of course also negate the guard, swap the branches, and omit the empty else:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  if len != 0 {\n    rangelength(start+1, len-1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 0.5.âstrong induction\n\ncan we do even better than that one if statement? well, that depends on what you think is better, but there is a way in dafny to eliminate this branch. we can do that by replacing the entire if statement and its one call to rangelength by a forall statement that calls rangelength for a whole bunch of values.\n\nto get this started, suppose we tried using the following as the body of rangelength:\n\nforall start', len' {\n  rangelength(start', len');\n}\n\n\n1\n2\n3\n\n\nthis rather cavalier statement calls rangelength for all possible values of start' and len'. well, this doesn't work, because many of those recursive calls won't terminate. we need to restrict ourselves to values of start' and len' that decrease the termination metric.\n\nso, let's try this:\n\nlemma {:induction false} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n  forall start', len' | 0 <= len' < len {\n    rangelength(start', len');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthis calls rangelength for all values of start' and all values of len' smaller than len. that is, this forall statement makes an infinite number of recursive calls to rangelength, all at once. each of these infinitely many calls terminates, because the value of len' is smaller than len.4\n\nthis version of rangelength verifies. the mathematical name for calling an induction hypothesis for all smaller values like this is called strong induction.\n\nwell, values of start' can be larger than start (in that, it is crucial for the proof that start + 1 is one of those values). so, you may opine that the forall statement above does more than just strong induction. indeed, some may argue that this forall statement also performs what is called generalizing the lemma to all values of start'. but if you consider the ordering that determines âsmallerâ to be one that just compares the len component, then start', len' is indeed smaller than start, len, as long as len' is smaller than len. however you want to think about it or whatever mathematical name you want to give to it, dafny accepts the forall statement above as a proof. in programming terms, all we're doing is proving that each recursive call terminates, and that follows from the way we defined the termination metric by decreases len.\n\n\n# 1.âautomatic induction\n\nwith all that background, we are finally ready to learn what dafny does to automate induction. here's the short of it: if you remove the attribute {:induction false} (which i introduced only to disable automatic induction while we were discussing what makes a proof in the first place), then what dafny does by default is insert the forall statement we just saw. this means you can remove the manually inserted forall statement, because dafny will add it for you. in other words, dafny accepts the following as a proof of the lemma:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n  decreases len\n{\n}\n\n\n1\n2\n3\n4\n5\n\n\nshort and sweet.\n\n\n# 1.0.âthe detailed recipe for automatic induction\n\ndafny automated induction all comes down to the maneuver of automatically generating one forall statement at the beginning of every lemma. this does not solve all problems of induction, but i'm amazed at how many simple problems of induction that this simple maneuver does solve. let's look at the ingredients that go into the maneuver.\n\nfor a lemma l with formal arguments args, precondition p(args),5 and termination metric t(args), dafny automatic induction inserts the following forall statement at the beginning of the body of l:\n\nforall aa' | p(args') && t(args') < t(args) {\n  l(args');\n}\n\n\n1\n2\n3\n\n\nwhere\n\n * aa is a subset of the formal parameters args,\n * aa' is aa, suitably renamed to have fresh names,\n * args' denotes args but with every variable in aa replaced by the corresponding one in aa', and\n * < denotes dafny's well-founded lexicographic order.\n\nthe subset aa of the variables args can be customized by placing the attribute {:induction aa} on the lemma. if no such attribute is given, then dafny picks aa heuristically. dafny reports what it picks in a tool tip that the dafny ides show when you hover over the name of the lemma.\n\nwe might think of {:induction x} as saying we're \"doing induction over xâ, but be a little bit careful with this. i find that common mathematical usage of the phrase âdo induction over â¦\" conflates several ideas. so, to be precise about it, what the {:induction aa} attribute specifies is which parameters are to be universally quantified over.\n\nthere is one more subtlety that is easy to forget: the decreases clause matters. when we write a lemma like rangelength, we might expect the proof to be simple enough that dafny's automatic induction will take care of it automatically. if so, we might just write down the type signature of the lemma and the (pre- and) postcondition. this often is all that's needed, but in the case of rangelength, it is also necessary to supply a decreases clause. usually, if the main function that the lemma is about (range in the running example) needs an explicit decreases clause, then the lemma does, too. alas, this can be easy to forget.\n\nnext, let's consider some ways of customizing the automatic induction for rangelength.\n\n\n# 1.1.âexample: missing decreases\n\nwhat happens if you do forget the decreases clause of rangelength? the lemma then looks like this:\n\nlemma rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nfor this lemma, dafny comes up with {:induction start, len} and decreases start, len.6 that means the implicit forall statement that the induction maneuver inserts is\n\nforall start': nat, len': nat |\n  start' < start || (start' == start && len' < len)\n{\n  rangelength(start', len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nas we explored in the previous section, this does not prove the lemma, because the crucial call rangelength(start+1, len-1) is not among the calls performed.\n\n\n# 1.2.âexample: quantifying over just len\n\nwhat if we manually override the quantified variables and list only len?\n\nlemma {:induction len} rangelength(start: nat, len: nat)\n  ensures length(range(start, len)) == len\n{\n}\n\n\n1\n2\n3\n4\n\n\nwe then get the following forall statement:\n\nforall len': nat |\n  start < start || (start == start && len' < len)\n{\n  rangelength(start, len');\n}\n\n\n1\n2\n3\n4\n5\n\n\nnotice how there is no start' in this example. rather, the original formal parameter start is used in the formulaic range expression\n\np(start, len') && t(start, len') < t(start, len)\n\n\n1\n\n\nthere is no precondition in the example, so the p part is true. because we didn't supply an explicit decreases clause, dafny generates decreases start, len. therefore, the range expression that restricts the universally quantified variables (that is, len') is\n\nstart < start || (start == start && len' < len)\n\n\n1\n\n\nwhich simplifies to len' < len.\n\nagain, since the recursive calls entailed by this forall statement does not include the crucial call rangelength(start+1, len-1), dafny will report an error that the lemma's postcondition might not hold.\n\nthe result would be the same even if we supplied a decreases clause manually. that would still restrict len' to values that are smaller than len, which is fine, but the problem is still that the inductive hypothesis is only considered for the given value of start.\n\n# acknowledgments\n\ni'm grateful to sean mclaughlin, who provided both the running example and the question about automatic induction for rangelength.\n\n\n# references\n\n[0]k. rustan m. leino. automating induction with an smt solver. in viktor kuncak and andrey rybalchenko, editors, verification, model checking, and abstract interpretation â 13th international conference, vmcai 2012, volume 7148 of lecture notes in computer science, pages 315â331. springer, january 2012. ð\n\n[1]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments â 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170â190. springer, 2014. ð\n\n----------------------------------------\n\n0.i'm simplifying a little bit. dafny's well-founded order on integers is actually âinteger less-than, with no more than one negative valueâ. so, a chain is allowed to dip down below 0, but once the chain includes a negative number, it must stop. this extension is a well-founded order, because there is still no way to make an infinite descending chain. â©\n\n1.i'm simplifying a little bit. dafny's fixed well-founded order also orders some values across different types. â©\n\n2.this is a slight simplification. dafny's heuristic for coming up with a decreases clause for a recursive function/method/lemma omits parameters whose types aren't helpful in letting you prove termination. for example, a parameter whose type is a type parameter is omitted from automatically generated decreases clauses. â©\n\n3.i was fast and loose in the previous example, because i should have also pointed out that 10*len + 18 is non-negative.) â©\n\n4.âan infinite number of calls?!â, you say to yourself. âhow is that termination, even if each such call terminates?â i won't delve into that here, but i will at least point out that we're calling a lemma, not a compiled method. so, you don't need to worry about having enough computational resources to make an infinite number of calls. â©\n\n5.a precondition of a lemma is declared using the keyword requires. it is like an antecedent of the lemma, and it is checked to hold at every call site. the running example does not include a precondition. a simple way to include one would be to change the type of start from nat to int and to add requires 0 <= start. â©\n\n6.i mentioned that tool tips in the dafny ides show you what decreases clause dafny picks. as of this writing, such a tool tip is shown only when the body of the function/method/lemma includes an explicit recursive call. in particular, if the body of the lemma is empty, there is no tool tip that shows you what decreases clause is generated. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Calling Lemmas Automatically",frontmatter:{title:"Calling Lemmas Automatically",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/30441e/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/05.Calling%20Lemmas%20Automatically.html",relativePath:"80.è¯­è¨/30.publication-lecture/05.Calling Lemmas Automatically.md",key:"v-4d8171d5",path:"/pages/30441e/",headers:[{level:3,title:"Uber Lemmas",slug:"uber-lemmas",normalizedTitle:"uber lemmas",charIndex:2196},{level:3,title:"Aggregate Lemma Invocations",slug:"aggregate-lemma-invocations",normalizedTitle:"aggregate lemma invocations",charIndex:2705},{level:3,title:"Function Postconditions",slug:"function-postconditions",normalizedTitle:"function postconditions",charIndex:3843},{level:3,title:"Basic/premium function pairs",slug:"basic-premium-function-pairs",normalizedTitle:"basic/premium function pairs",charIndex:5460},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:6928}],headersStr:"Uber Lemmas Aggregate Lemma Invocations Function Postconditions Basic/premium function pairs Acknowledgments",content:"Dafny Power User: Calling Lemmas Automatically\n\nK. Rustan M. Leino\n\nManuscript KRML 265, 8 June 2019\n\nAbstract. Some properties of a function are more useful than others. If you have proved such a property as a lemma, you may want to have it be applied automatically. This note considers ways to achieve something like that in Dafny.\n\nOn https://github.com/Microsoft/dafny/issues/231, a Dafny user asked:\n\n> Is there a way in Dafny to mark a lemma as âautomaticâ and add it to the knowledge base of z3 ?\n> \n> For student homeworks, we often stumble on specifications that are just a bit too complex for Dafny to prove, and require some hand-crafted asserts or lemmas.\n> \n> It would be nice if we could define those lemmas to augment boogie/z3 search space with domain-specific knowledge, avoiding the need to explain to our students how lemmas work, and the tedious and difficult task to find and use the required lemmas.\n> \n> Is something like an {:auto} annotation feasible ? Can we augment the .bpl axiomatization ?\n\nHere is an example that shows the issue. Suppose you declare a function and prove a property about it:\n\nfunction FibFib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else FibFib(n-2) + FibFib(n-1)\n}\n\nlemma FibFibIsEven(n: nat)\n  ensures FibFib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nFor your application, it may be crucial that FibFib always returns an even number. Using the declarations above, you would then have to call the lemma FibFibIsEven every time you use the function. This is tedious. Is there some way to instruct Dafny to automatically apply FibFibIsEven whenever it's needed?\n\nNo, there's no such feature in Dafny. (VCC had such a feature, for example.) In some situations, such automation may work well. In other situations, it may cause the lemma to be invoked too many times (say, an infinite number of times), which is problematic.\n\nIf you have an interest in trying out some kind of {:autoLemma} feature, please feel free to play around with the open Dafny sources. In the present state, I have four suggestions that you may try, and which may alleviate some of the tedium you're experiencing.\n\n\n# Uber Lemmas\n\nOne suggestion is to create an âuber lemmaâ that collects the statements of several other lemmas. For example, if you already have:\n\nlemma Lemma0(x: X) ensures P0(x) { ... }\nlemma Lemma1(x: X) ensures P1(x) { ... }\nlemma Lemma2(x: X) ensures P2(x) { ... }\n\n\n1\n2\n3\n\n\nthen you can combine them into one:\n\nlemma Everything(x: X)\n  ensures P0(x) && P1(x) && P2(x)\n{\n  Lemma0(x: X);\n  Lemma1(x: X);\n  Lemma2(x: X);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThis lets you get all 3 properties by calling a single lemma.\n\n\n# Aggregate Lemma Invocations\n\nAnother suggestion is to invoke a lemma on many values at the same time. Given:\n\nlemma LemmaForOneX(x: X) ensures P(x) { ... }\n\n\n1\n\n\nyou can invoke this lemma for all values of X simultaneously:\n\nforall x {\n  LemmaForOneX(x);\n}\n\n\n1\n2\n3\n\n\nBy placing this forall statement at the beginning of some code you're trying to prove, you have in effect called it for every imaginable value of X. You can of course also tuck this statement into a lemma of its own and then call this one lemma:\n\nlemma LemmaForEveryX()\n  ensures forall x :: P(x)\n{\n  forall x {\n    LemmaForOneX(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIn many cases, this will work fine. In other cases, the verifier may not realize that you have called the lemma on the value that needs the individual lemma, so you may still need to invoke LemmaForOneX manually. Also, Dafny takes measure to avoid âmatching loopsâ in the quantifiers generated for the lemma calls above (âmatching loopsâ are what can cause an infinite number of uses of the lemmas). However, the mechanism is not perfect, so this added automation may in some cases cause degraded performance.\n\n\n# Function Postconditions\n\nA third suggestion is to declare some of the most useful properties of a function in the postcondition of the function, rather than in a separate lemma. For example, instead of:\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nyou can declare:\n\nfunction F(x: X): int\n  ensures F(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nTo obtain the property stated by the lemma, you must call the lemma. In contrast, any property stated in the postcondition of a function is automatically applied every time you call the function.\n\nAs I've mentioned, more information can help the verifier do more things automatically, but too much information can also overwhelm and confuse the verifier. Therefore, my suggestion is to use function postconditions only for those properties that you think every user of the function will need. Properties needed more rarely are better off declared in lemmas that have to be manually invoked.\n\nAlso, there are limits to what you can write in a function postcondition. In particular, what you write must âterminateâ. In practice, this means you may have problems mentioning the function applied to other arguments in the postcondition. For example,\n\npredicate R(x: X, y: X)\n  // commutativity:\n  ensures R(x, y) <==> R(y, x)\n  // transitivity:\n  ensures forall z :: R(x, z) && R(z, y) ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nis not admitted, because there are self-referential non-terminating (that is, infinitely recursive) calls in the postcondition. Thus, properties like commutativity and transitivity always need to be stated as separate lemmas.\n\n\n# Basic/premium function pairs\n\nA function postcondition conveniently provides all users of a function with the property that it states, alleviating the need to call the lemma explicitly. If the property is not interesting for all users, a fourth suggestion is to declare two functions. The basic function gives the actual definition of the function and an accompanying lemma states the property about it. The premium function calls the basic function and states the property as its postcondition, which is proved by a call to the lemma.\n\nfunction F(x: X): int { ... }\nlemma AboutF(x: X)\n  ensures F(x) % 2 == 0\n{ ... }\n\nfunction F_premium(x: X): int\n  ensures F_premium(x) % 2 == 0\n{ AboutF(x); F(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nUsers can now choose: a call to F_premium obtains both the value of the function and the proved property, whereas a call to F obtains only the value. If you expect the premium version to be more popular than the basic version, you can of course rename F and F_premium to F_basic and F, respectively.\n\nOther than the postcondition, the two functions are synonyms. Semantically. A note of caution is that the mechanism the verifier uses as a guide to its use of quantifiers is syntactic. Therefore, which of the two functions you use in the body of a quantifier can make a difference in when the verifier decides to instantiate the quantifier. For this reason, I suggest you use the basic version of the function inside any quantifier you write.\n\n# Acknowledgments\n\nBryan Parno provided the fourth suggestion of wrapping a basic version of a function and its lemma into a premium version of the function.",normalizedContent:"dafny power user: calling lemmas automatically\n\nk. rustan m. leino\n\nmanuscript krml 265, 8 june 2019\n\nabstract. some properties of a function are more useful than others. if you have proved such a property as a lemma, you may want to have it be applied automatically. this note considers ways to achieve something like that in dafny.\n\non https://github.com/microsoft/dafny/issues/231, a dafny user asked:\n\n> is there a way in dafny to mark a lemma as âautomaticâ and add it to the knowledge base of z3 ?\n> \n> for student homeworks, we often stumble on specifications that are just a bit too complex for dafny to prove, and require some hand-crafted asserts or lemmas.\n> \n> it would be nice if we could define those lemmas to augment boogie/z3 search space with domain-specific knowledge, avoiding the need to explain to our students how lemmas work, and the tedious and difficult task to find and use the required lemmas.\n> \n> is something like an {:auto} annotation feasible ? can we augment the .bpl axiomatization ?\n\nhere is an example that shows the issue. suppose you declare a function and prove a property about it:\n\nfunction fibfib(n: nat): nat {\n  if n == 0 then 0\n  else if n == 1 then 2\n  else fibfib(n-2) + fibfib(n-1)\n}\n\nlemma fibfibiseven(n: nat)\n  ensures fibfib(n) % 2 == 0\n{\n  // automatically proved by induction\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nfor your application, it may be crucial that fibfib always returns an even number. using the declarations above, you would then have to call the lemma fibfibiseven every time you use the function. this is tedious. is there some way to instruct dafny to automatically apply fibfibiseven whenever it's needed?\n\nno, there's no such feature in dafny. (vcc had such a feature, for example.) in some situations, such automation may work well. in other situations, it may cause the lemma to be invoked too many times (say, an infinite number of times), which is problematic.\n\nif you have an interest in trying out some kind of {:autolemma} feature, please feel free to play around with the open dafny sources. in the present state, i have four suggestions that you may try, and which may alleviate some of the tedium you're experiencing.\n\n\n# uber lemmas\n\none suggestion is to create an âuber lemmaâ that collects the statements of several other lemmas. for example, if you already have:\n\nlemma lemma0(x: x) ensures p0(x) { ... }\nlemma lemma1(x: x) ensures p1(x) { ... }\nlemma lemma2(x: x) ensures p2(x) { ... }\n\n\n1\n2\n3\n\n\nthen you can combine them into one:\n\nlemma everything(x: x)\n  ensures p0(x) && p1(x) && p2(x)\n{\n  lemma0(x: x);\n  lemma1(x: x);\n  lemma2(x: x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthis lets you get all 3 properties by calling a single lemma.\n\n\n# aggregate lemma invocations\n\nanother suggestion is to invoke a lemma on many values at the same time. given:\n\nlemma lemmaforonex(x: x) ensures p(x) { ... }\n\n\n1\n\n\nyou can invoke this lemma for all values of x simultaneously:\n\nforall x {\n  lemmaforonex(x);\n}\n\n\n1\n2\n3\n\n\nby placing this forall statement at the beginning of some code you're trying to prove, you have in effect called it for every imaginable value of x. you can of course also tuck this statement into a lemma of its own and then call this one lemma:\n\nlemma lemmaforeveryx()\n  ensures forall x :: p(x)\n{\n  forall x {\n    lemmaforonex(x);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nin many cases, this will work fine. in other cases, the verifier may not realize that you have called the lemma on the value that needs the individual lemma, so you may still need to invoke lemmaforonex manually. also, dafny takes measure to avoid âmatching loopsâ in the quantifiers generated for the lemma calls above (âmatching loopsâ are what can cause an infinite number of uses of the lemmas). however, the mechanism is not perfect, so this added automation may in some cases cause degraded performance.\n\n\n# function postconditions\n\na third suggestion is to declare some of the most useful properties of a function in the postcondition of the function, rather than in a separate lemma. for example, instead of:\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n4\n\n\nyou can declare:\n\nfunction f(x: x): int\n  ensures f(x) % 2 == 0\n{ ... }\n\n\n1\n2\n3\n\n\nto obtain the property stated by the lemma, you must call the lemma. in contrast, any property stated in the postcondition of a function is automatically applied every time you call the function.\n\nas i've mentioned, more information can help the verifier do more things automatically, but too much information can also overwhelm and confuse the verifier. therefore, my suggestion is to use function postconditions only for those properties that you think every user of the function will need. properties needed more rarely are better off declared in lemmas that have to be manually invoked.\n\nalso, there are limits to what you can write in a function postcondition. in particular, what you write must âterminateâ. in practice, this means you may have problems mentioning the function applied to other arguments in the postcondition. for example,\n\npredicate r(x: x, y: x)\n  // commutativity:\n  ensures r(x, y) <==> r(y, x)\n  // transitivity:\n  ensures forall z :: r(x, z) && r(z, y) ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n\n\nis not admitted, because there are self-referential non-terminating (that is, infinitely recursive) calls in the postcondition. thus, properties like commutativity and transitivity always need to be stated as separate lemmas.\n\n\n# basic/premium function pairs\n\na function postcondition conveniently provides all users of a function with the property that it states, alleviating the need to call the lemma explicitly. if the property is not interesting for all users, a fourth suggestion is to declare two functions. the basic function gives the actual definition of the function and an accompanying lemma states the property about it. the premium function calls the basic function and states the property as its postcondition, which is proved by a call to the lemma.\n\nfunction f(x: x): int { ... }\nlemma aboutf(x: x)\n  ensures f(x) % 2 == 0\n{ ... }\n\nfunction f_premium(x: x): int\n  ensures f_premium(x) % 2 == 0\n{ aboutf(x); f(x) }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nusers can now choose: a call to f_premium obtains both the value of the function and the proved property, whereas a call to f obtains only the value. if you expect the premium version to be more popular than the basic version, you can of course rename f and f_premium to f_basic and f, respectively.\n\nother than the postcondition, the two functions are synonyms. semantically. a note of caution is that the mechanism the verifier uses as a guide to its use of quantifiers is syntactic. therefore, which of the two functions you use in the body of a quantifier can make a difference in when the verifier decides to instantiate the quantifier. for this reason, i suggest you use the basic version of the function inside any quantifier you write.\n\n# acknowledgments\n\nbryan parno provided the fourth suggestion of wrapping a basic version of a function and its lemma into a premium version of the function.",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Case study of definitions, proofs, algorithm correctness GCD",frontmatter:{title:"Case study of definitions, proofs, algorithm correctness GCD",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/746026/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/10.Case%20study%20of%20definitions,%20proofs,%20algorithm%20correctness%20GCD.html",relativePath:"80.è¯­è¨/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md",key:"v-0c0b63a6",path:"/pages/746026/",headers:[{level:2,title:"0.âProblem description",slug:"_0-problem-description",normalizedTitle:"0.âproblem description",charIndex:507},{level:2,title:"1.âPositive integers",slug:"_1-positive-integers",normalizedTitle:"1.âpositive integers",charIndex:1254},{level:2,title:"2.âFactors",slug:"_2-factors",normalizedTitle:"2.âfactors",charIndex:2184},{level:2,title:"3.âMax of a set",slug:"_3-max-of-a-set",normalizedTitle:"3.âmax of a set",charIndex:4838},{level:2,title:"4.âGCD",slug:"_4-gcd",normalizedTitle:"4.âgcd",charIndex:8306},{level:2,title:"5.âProperties of GCD",slug:"_5-properties-of-gcd",normalizedTitle:"5.âproperties of gcd",charIndex:9854},{level:2,title:"6.âEuclid's algorithm",slug:"_6-euclid-s-algorithm",normalizedTitle:"6.âeuclid's algorithm",charIndex:12775},{level:2,title:"7.âGCD subtract property",slug:"_7-gcd-subtract-property",normalizedTitle:"7.âgcd subtract property",charIndex:15740},{level:2,title:"8.âMore symmetry",slug:"_8-more-symmetry",normalizedTitle:"8.âmore symmetry",charIndex:17850},{level:2,title:"9.âMain",slug:"_9-main",normalizedTitle:"9.âmain",charIndex:19872},{level:2,title:"10.âConclusions",slug:"_10-conclusions",normalizedTitle:"10.âconclusions",charIndex:20470},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:21343},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:21436}],headersStr:"0.âProblem description 1.âPositive integers 2.âFactors 3.âMax of a set 4.âGCD 5.âProperties of GCD 6.âEuclid's algorithm 7.âGCD subtract property 8.âMore symmetry 9.âMain 10.âConclusions Acknowledgments References",content:"Dafny Power User: Case study of definitions, proofs, algorithm correctness: GCD\n\nK. Rustan M. Leino\n\nManuscript KRML 279, 22 June 2021\n\nAbstract. The purpose of this note is to show an example development of a program, introducing definitions that support the specification of the program, stating and proving lemmas about those definitions, and using the lemmas in proving the correctness of the program. Euclid's subtractive algorithm for computing the greatest common divisor is used as the example.\n\n\n# 0.âProblem description\n\nLet's specify and verify an algorithm to compute the greatest common divisor (GCD) of two numbers. For the specification, we will introduce a function whose definition is intended to be âobviously correctâ. We won't use that function to compute the GCD, because the âobviously correctâ definition would give really inefficient code if compiled directly. Instead, we'll use Euclid's algorithm for computing the value that the âobviously correctâ function defines. We'll prove that the algorithm does compute that value.\n\nIn essence, we'll have\n\nfunction Gcd(x: pos, y: pos): pos\n\nmethod EuclidGcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nwhere pos denotes the type of positive integers.\n\n\n# 1.âPositive integers\n\nEverything we do will concern (strictly) positive integers. Dafny builds in a type for natural numbers (that is, non-negative integers), but not positive integers. We can define these using a subset type in Dafny:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\nDafny wants to know if this type has any inhabitants, and it doesn't figure that out by itself. This doesn't matter for our example, but we do need to address the error we're getting. To do that, we supply a witness clause:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nIf we really didn't care to exhibit a witness that shows the type to be nonempty, we could have written witness *, which causes Dafny to treat the type pos as possibly empty. For our example, you can do either, but since it's easy to supply an actual witness, we do that.\n\nIn the sequel, I will just say number when I mean positive integer.\n\n\n# 2.âFactors\n\nThe divisors of a number are its factors. We define a predicate that says what it means for a number p to be a factor of a number x:\n\npredicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\nIn words, p is a factor of x iff there is a multiplicand q such that x is the product p * q.\n\nTo talk about all the factors of a number, we introduce a function Factors that we define using a set comprehension. A straightforward definition would be:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | IsFactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\nA set in Dafny denotes a finite set (for possibly infinite sets, use iset). In this case, Dafny doesn't immediately see that the comprehension would generate a finite set. Luckily, it is simple for us to add another conjunct to the comprehension that lets Dafny see that the set is finite:\n\nfunction Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\n\n\n1\n2\n3\n\n\nIn adding this conjunct, there's a risk we're making a mistake, because perhaps the new set doesn't include all the factors we'd like. Our conjunct p <= x certainly looks innocent enough, but why not prove that adding it does not accidentally leave out any factors. We can do that by proving that this set has the same elements as the possibly infinite set:\n\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nThe proof of a lemma is given in the lemma's body (that is, between the pair of curly braces that follow the lemma's specification). In this case, the proof is empty, because Dafny proves the lemma automatically without any further help from us.\n\nBefore leaving the definition of factors, let's state and prove two simple lemmas. These lemmas act as sanity checks on our definitions, and they will also be helpful later in our development.\n\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nTo prove that a number n (here, 1 or x) is in the set Factors(x), we need to establish that n satisfies the condition in the set comprehension (in the body of Factors(x)). The conjunct n <= x is proved automatically, but the conjunct IsFactor(n, x) is not. By the definition of IsFactor, we need to prove the existence of a multiplicand q for which n * q == x. Such a proof typically involves demonstrating a witness, which is what the assert statements in the two lemmas above do. From those assertions, the verifier completes the proofs of the lemmas.\n\n\n# 3.âMax of a set\n\nTo talk about the greatest common divisor, we need a function that picks out the largest number in a set. A somewhat declarative way to do that is to use the such-that construct. In particular, for a set s, the let-such-that expression\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nsays to bind x to a value satisfying the condition x in s && forall y :: y in s ==> y <= x, and then return the value of the expression x. The condition says that x is in the set s, and that, among all the numbers in s, x is the largest.\n\nUse of a such-that construct comes with a proof obligation that a value satisfying the given condition exists. If we require s to be nonempty, then the x in s condition is easily satisfied, but it takes more work to convince the verifier that a value for x satisfies the quantifier. We'll define a lemma for that purpose. We'll name the lemma MaxExists and then we can write our function Max as follows:\n\nfunction Max(s: set<pos>): pos\n  requires s != {}\n{\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nDafny uses the lemma invocation MaxExists(s) in establishing the well-formedness of the subsequent expression. Note, by the way, that Max (and lemma MaxExists, too) has a precondition s != {} (keyword requires). This means that the function (and the lemma, too) can only be called for a nonempty set.\n\nAlright, so then how do we prove MaxExists? The most straightforward way to prove the existence of such an x is to compute an x satisfying the desired properties. We'll introduce another function for computing the max, call it FindMax, and use it in the proof of the MaxExists lemma. Function FindMax will be implemented recursively.\n\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := FindMax(s);\n}\n \nfunction FindMax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= FindMax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nAren't we going in circles now? Yes, in some ways we're making life more difficult than necessary. If we have FindMax, we don't need Max, and then we also don't need lemma MaxExists. Indeed, we could have written and used just FindMax and never introduced Max or MaxExists. But for this example, I wanted the primary definitions to be as clear as possible without concern for how things are computed. In that sense, the body of Max is more declarative than the body we are about to write for FindMax.\n\nHere is the full definition of FindMax:\n\nfunction FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := FindMax(s');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWhen a function postcondition wants to mention the result value of the function, you can just use the function itself, with the arguments given: FindMax(s). I did this when I first introduced FindMax above. In the full definition, I show an alternative way of doing this, which is to introduce a name for the result value: max. That name is usable only in the postcondition of the function. Many times, introducing such a name for the result leads to a shorter specification.\n\n\n# 4.âGCD\n\nWith the functions we defined, we're now ready to define GCD. Take the factors of x and the factors of y, intersect them to get their common factors, and then take the maximum thereof:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  Max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nFor this simple definition, the verifier reports a precondition violation, because it's unable to prove that common satisfies the precondition of Max. We know that common is nonempty, because we know that 1 is a common factor of any two numbers x and y. To bring that information to the verifier's attention, we write an assertion:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common;  // error: assertion violation\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nAlas, the verifier is not able to prove this assertion. But we can see that the presence of the assertion is enough to eliminate the precondition violation. So, we now focus on proving the assertion. This is where we use the FactorsContains1 lemma we introduced earlier. Two calls to that lemma will prove the assertion, which is best captured in the program text by changing the assert to an assert by and giving the proof of the assertion in the by block:\n\nfunction Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThat does it! We have now given a well-formed definition of Gcd.\n\n\n# 5.âProperties of GCD\n\nWe'll prove three properties of our Gcd functionâcall them sanity checks, if you will. (We'll need a fourth property as well, but I'll introduce it later.)\n\nAs a first sanity check, we expect Gcd(x, y) to return a number that is a factor of both x and y. Furthermore, among all the numbers that are factors of both x and y, what Gcd(x, y) returns should be the largest.\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nThe first two postconditions of this lemma are proved automatically, but not the third. How do we go about proving that a universal quantifier (that is, a forall expression) holds? We use Dafny's forall statement. When used in a proof, the forall statement corresponds to the âuniversal introductionâ rule in logic. This is the rule that says \"if you want to prove forall x :: P(x), then all you need to do is pick an arbitrary x and prove P(x) for that x.\n\nWe introduce the forall statement like this:\n\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n\n\n1\n2\n\n\nTo prove it, we only need to bring up the fact that p, which is a factor of both x and y, is in the intersection of factors of x and y. The verifier is then able to complete the proof.\n\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThe Dafny verifier often needs help with properties like this. To prove them, just write them as an assertion. In other words, the verifier knows this property about set intersection, but it isn't creative enough the bring that property into the proof. By asserting the property, we're asking the verifier to confirm the property (which it's able to do) and then to use that property in the rest of the proof (which in this case completes the proof).\n\nAs a second sanity check, we prove that Gcd is symmetric.\n\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nThe proof comes down to the fact that set intersection is symmetric, which we bring to the verifier's attention by writing it as a lemma.\n\nAs a third sanity check, we prove that Gcd is idempotent. That is, if you give it the same argument twice, it will return that argument.\n\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThe proof of this property comes down to the fact that set intersection is idempotent, as well as the property that a number is one of its own factors.\n\n\n# 6.âEuclid's algorithm\n\nEuclid's subtractive algorithm for finding the GCD of two numbers is to repeatedly subtract the smaller of the numbers from the larger until they are both equal. Each such subtraction preserves the GCDâan invariant that we will need to proveâand the GCD of two equal numbers is that numberâwhich we established by lemma GcdIdempotent above.\n\nThe algorithm, with the loop invariant and idempotence lemma, thus looks like this:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nThis method uses a while-case loop. (If you're familiar with Dijkstra's guarded commands [1], this is the do-od loop.) Each iteration of this loop chooses one of the cases to execute. The case chosen must be one whose guard condition evaluates to true (and if the guards of several cases evaluate to true, the loop chooses arbitrarily between those cases) . If no such guard condition evaluates to true, then the loop stops iterating. The loop in EuclidGcd could of course be an ordinary while x != y loop, but the symmetry of the two cases afforded by the while-case loop makes it aesthetically pleasing.\n\nIn addition to a loop invariant, the loop also declares a termination metric (keyword decreases). Proving that the loop terminates comes down to proving that each iteration makes the value of the termination metric decrease (in Dafny's built-in well-founded order on integers).\n\nThe EuclidGcd method above does not verify, because the verifier is unable to prove that each iteration maintains the loop invariant. For this, we need the fourth property of GCD that I alluded to above:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n\n\n1\n2\n3\n\n\nUsing this lemma and the symmetry of GCD, we can complete the proof of Gcd:\n\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x, y := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nThis version adds a call to GcdSubtract in the first branch of the loop. In the second branch of the loop, the proof calculation uses equality-preserving steps to transform the expression Gcd(x, y) into Gcd(x - y, y). The hints given in the steps appeal to the GcdSubtract and GcdSymmetric lemmas.\n\n\n# 7.âGCD subtract property\n\nThe proof of GcdSubtract is more involved than any of the other definitions and lemmas in this case study.\n\nThe proof starts by introducing a name for Gcd(x, y):\n\n  var p := Gcd(x, y);\n\n\n1\n\n\nWe know from the definition of Gcd that p is a factor of both x and y, and we can prove that p is also a factor of y - x:\n\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nTo prove IsFactor(p, y - x), we introduce names a and b for the multiplicands that the definition of IsFactor tells us exist (since p is a factor of both x and y). A simple calculation using basic arithmetic steps then gives us that p can be multiplied another number (namely, b - a) to get y - x.\n\nSince p is a factor of both x and y - x, we have that it's in the common factors of x and y - x. We write two lines to make sure the verifier is on board with this property, phrased in terms of set intersection:\n\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\nLastly, we need to show that p is the largest such common factor. We state this property using a forall statement:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nTo prove this property, we fill in the body of the forall statement. For q, which denotes an arbitrary number in the set common, we give names to the multiplicands that yield the products x and y - x, respectively:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nUsing simple arithmetic steps, we can use a proof calculation to establish that q is also a factor of y:\n\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nSo, since q is a factor of both x and y, the definition of Gcd(x, y) tells us q <= Gcd(x, y). By giving yet another hint about set intersection:\n\n    assert q in Factors(x) * Factors(y);\n  }\n\n\n1\n2\n\n\nthe verifier completes the proof.\n\n\n# 8.âMore symmetry\n\nWhile we now have a full proof of the GCD algorithm, your aesthetic sense may be bothered by the asymmetry in how we supplied the proofs in the two cases of the loop. Since the while-case loop affords us a symmetric rendition of the two cases, it would be nice if we could make the proofs of the two cases more similar as well.\n\nThere are several ways we can improve on this situation. One is to refactor the proof calculation of the second case into its own lemma. Then, then each case would have one line of proof.\n\nJust for fun, let me describe another âtrickâ to make the two cases (not entirely symmetric, but at least) more similar. The trick is to make the (already asymmetric) GcdSubtract lemma also swap the arguments to Gcd. We rewrite it into:\n\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x)\n{\n  GcdSymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that the left-hand side of the postcondition is now Gcd(y, x), not Gcd(x, y) as it had been in our first version of this lemma. The only change required for the proof is to appeal to the symmetry of Gcd, which we can do by one lemma call immediately inside the body of the lemma. This gives us a proof of our reformulated GcdSubtract lemma.\n\nWith this reformulation, we can simplify the second case of EuclidGcd, at the expense of making the first case more complicated. Essentially, we're moving one lemma call from the second case to the first, so instead of having 1 and 3 lemma calls in the two respective cases, we'll have 2 and 2.\n\n    case x < y =>\n      GcdSubtract(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIt's not entirely symmetric, but perhaps you still like it. Or perhaps you'll remember this trick for another situation where the shoe fits perfectly. If nothing else, you can stick with the first complete proof we developed above.\n\n\n# 9.âMain\n\nIf the proof itself doesn't satisfy you and still want to see the algorithm in action, you can write a Main method and compile and run the program. (A simple way of doing that from the command line is to use the /compile:3 option with the dafny tool. It will verify and then run the program.)\n\nHere is a sample Main:\n\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\n\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 10.âConclusions\n\nThis case study shows how to define a domain of interest (here, factors of numbers, leading up to the definition of GCD), state and prove some lemmas about those definitions, and then use these in the proof of a small program.\n\nThe program, including all lemmas and other proof obligations associated with the definitions, takes the Dafny verifier less than 3 seconds to verify. You can find the entire program in the Dafny test suite [3].\n\nEuclid's GCD algorithm is a familiar textbook example. It's proved in different forms in various verifiers. For example, the TLA+ tutorial uses this program as an example [0]. It assumes the mathematical properties of GCD that we proved here. The gallery of Why3 programs contains a version of Euclid's GCD algorithm that uses modulo instead of subtraction with each step, which results in fewer iterations [2].\n\n# Acknowledgments\n\nI thank Reto Kramer for suggesting this problem as a useful case study.\n\n\n# References\n\n[0]TLA proof system. https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html. ð\n\n[1]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. ð\n\n[2]Jean-Christophe FilliÃ¢tre and Claude MarchÃ©. Greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. ð\n\n[3]K. Rustan M. Leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy, June 2021. ð",normalizedContent:"dafny power user: case study of definitions, proofs, algorithm correctness: gcd\n\nk. rustan m. leino\n\nmanuscript krml 279, 22 june 2021\n\nabstract. the purpose of this note is to show an example development of a program, introducing definitions that support the specification of the program, stating and proving lemmas about those definitions, and using the lemmas in proving the correctness of the program. euclid's subtractive algorithm for computing the greatest common divisor is used as the example.\n\n\n# 0.âproblem description\n\nlet's specify and verify an algorithm to compute the greatest common divisor (gcd) of two numbers. for the specification, we will introduce a function whose definition is intended to be âobviously correctâ. we won't use that function to compute the gcd, because the âobviously correctâ definition would give really inefficient code if compiled directly. instead, we'll use euclid's algorithm for computing the value that the âobviously correctâ function defines. we'll prove that the algorithm does compute that value.\n\nin essence, we'll have\n\nfunction gcd(x: pos, y: pos): pos\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nwhere pos denotes the type of positive integers.\n\n\n# 1.âpositive integers\n\neverything we do will concern (strictly) positive integers. dafny builds in a type for natural numbers (that is, non-negative integers), but not positive integers. we can define these using a subset type in dafny:\n\ntype pos = x | 1 <= x  // error: cannot find witness to show type is inhabited\n\n\n1\n\n\ndafny wants to know if this type has any inhabitants, and it doesn't figure that out by itself. this doesn't matter for our example, but we do need to address the error we're getting. to do that, we supply a witness clause:\n\ntype pos = x | 1 <= x witness 1\n\n\n1\n\n\nif we really didn't care to exhibit a witness that shows the type to be nonempty, we could have written witness *, which causes dafny to treat the type pos as possibly empty. for our example, you can do either, but since it's easy to supply an actual witness, we do that.\n\nin the sequel, i will just say number when i mean positive integer.\n\n\n# 2.âfactors\n\nthe divisors of a number are its factors. we define a predicate that says what it means for a number p to be a factor of a number x:\n\npredicate isfactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\n\n\n1\n2\n3\n\n\nin words, p is a factor of x iff there is a multiplicand q such that x is the product p * q.\n\nto talk about all the factors of a number, we introduce a function factors that we define using a set comprehension. a straightforward definition would be:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | isfactor(p, x)  // error: set constructed must be finite\n}\n\n\n1\n2\n3\n\n\na set in dafny denotes a finite set (for possibly infinite sets, use iset). in this case, dafny doesn't immediately see that the comprehension would generate a finite set. luckily, it is simple for us to add another conjunct to the comprehension that lets dafny see that the set is finite:\n\nfunction factors(x: pos): set<pos> {\n  set p: pos | p <= x && isfactor(p, x)\n}\n\n\n1\n2\n3\n\n\nin adding this conjunct, there's a risk we're making a mistake, because perhaps the new set doesn't include all the factors we'd like. our conjunct p <= x certainly looks innocent enough, but why not prove that adding it does not accidentally leave out any factors. we can do that by proving that this set has the same elements as the possibly infinite set:\n\nlemma factorshasallfactors(x: pos)\n  ensures forall n :: n in factors(x) <==> n in iset p: pos | isfactor(p, x)\n{\n}\n\n\n1\n2\n3\n4\n\n\nthe proof of a lemma is given in the lemma's body (that is, between the pair of curly braces that follow the lemma's specification). in this case, the proof is empty, because dafny proves the lemma automatically without any further help from us.\n\nbefore leaving the definition of factors, let's state and prove two simple lemmas. these lemmas act as sanity checks on our definitions, and they will also be helpful later in our development.\n\nlemma factorscontains1(x: pos)\n  ensures 1 in factors(x)\n{\n  assert 1 * x == x;\n}\n\nlemma factorscontainsself(x: pos)\n  ensures x in factors(x)\n{\n  assert x * 1 == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nto prove that a number n (here, 1 or x) is in the set factors(x), we need to establish that n satisfies the condition in the set comprehension (in the body of factors(x)). the conjunct n <= x is proved automatically, but the conjunct isfactor(n, x) is not. by the definition of isfactor, we need to prove the existence of a multiplicand q for which n * q == x. such a proof typically involves demonstrating a witness, which is what the assert statements in the two lemmas above do. from those assertions, the verifier completes the proofs of the lemmas.\n\n\n# 3.âmax of a set\n\nto talk about the greatest common divisor, we need a function that picks out the largest number in a set. a somewhat declarative way to do that is to use the such-that construct. in particular, for a set s, the let-such-that expression\n\nvar x :| x in s && forall y :: y in s ==> y <= x;\nx\n\n\n1\n2\n\n\nsays to bind x to a value satisfying the condition x in s && forall y :: y in s ==> y <= x, and then return the value of the expression x. the condition says that x is in the set s, and that, among all the numbers in s, x is the largest.\n\nuse of a such-that construct comes with a proof obligation that a value satisfying the given condition exists. if we require s to be nonempty, then the x in s condition is easily satisfied, but it takes more work to convince the verifier that a value for x satisfies the quantifier. we'll define a lemma for that purpose. we'll name the lemma maxexists and then we can write our function max as follows:\n\nfunction max(s: set<pos>): pos\n  requires s != {}\n{\n  maxexists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ndafny uses the lemma invocation maxexists(s) in establishing the well-formedness of the subsequent expression. note, by the way, that max (and lemma maxexists, too) has a precondition s != {} (keyword requires). this means that the function (and the lemma, too) can only be called for a nonempty set.\n\nalright, so then how do we prove maxexists? the most straightforward way to prove the existence of such an x is to compute an x satisfying the desired properties. we'll introduce another function for computing the max, call it findmax, and use it in the proof of the maxexists lemma. function findmax will be implemented recursively.\n\nlemma maxexists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := findmax(s);\n}\n \nfunction findmax(s: set<pos>): pos\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= findmax(s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\naren't we going in circles now? yes, in some ways we're making life more difficult than necessary. if we have findmax, we don't need max, and then we also don't need lemma maxexists. indeed, we could have written and used just findmax and never introduced max or maxexists. but for this example, i wanted the primary definitions to be as clear as possible without concern for how things are computed. in that sense, the body of max is more declarative than the body we are about to write for findmax.\n\nhere is the full definition of findmax:\n\nfunction findmax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := findmax(s');\n    if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwhen a function postcondition wants to mention the result value of the function, you can just use the function itself, with the arguments given: findmax(s). i did this when i first introduced findmax above. in the full definition, i show an alternative way of doing this, which is to introduce a name for the result value: max. that name is usable only in the postcondition of the function. many times, introducing such a name for the result leads to a shorter specification.\n\n\n# 4.âgcd\n\nwith the functions we defined, we're now ready to define gcd. take the factors of x and the factors of y, intersect them to get their common factors, and then take the maximum thereof:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  max(common)  // error: common must be nonempty\n}\n\n\n1\n2\n3\n4\n\n\nfor this simple definition, the verifier reports a precondition violation, because it's unable to prove that common satisfies the precondition of max. we know that common is nonempty, because we know that 1 is a common factor of any two numbers x and y. to bring that information to the verifier's attention, we write an assertion:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common;  // error: assertion violation\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n\n\nalas, the verifier is not able to prove this assertion. but we can see that the presence of the assertion is enough to eliminate the precondition violation. so, we now focus on proving the assertion. this is where we use the factorscontains1 lemma we introduced earlier. two calls to that lemma will prove the assertion, which is best captured in the program text by changing the assert to an assert by and giving the proof of the assertion in the by block:\n\nfunction gcd(x: pos, y: pos): pos {\n  var common := factors(x) * factors(y);\n  assert 1 in common by {\n    factorscontains1(x);\n    factorscontains1(y);\n  }\n  max(common)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthat does it! we have now given a well-formed definition of gcd.\n\n\n# 5.âproperties of gcd\n\nwe'll prove three properties of our gcd functionâcall them sanity checks, if you will. (we'll need a fourth property as well, but i'll introduce it later.)\n\nas a first sanity check, we expect gcd(x, y) to return a number that is a factor of both x and y. furthermore, among all the numbers that are factors of both x and y, what gcd(x, y) returns should be the largest.\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n\n\n1\n2\n3\n4\n\n\nthe first two postconditions of this lemma are proved automatically, but not the third. how do we go about proving that a universal quantifier (that is, a forall expression) holds? we use dafny's forall statement. when used in a proof, the forall statement corresponds to the âuniversal introductionâ rule in logic. this is the rule that says \"if you want to prove forall x :: p(x), then all you need to do is pick an arbitrary x and prove p(x) for that x.\n\nwe introduce the forall statement like this:\n\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n\n\n1\n2\n\n\nto prove it, we only need to bring up the fact that p, which is a factor of both x and y, is in the intersection of factors of x and y. the verifier is then able to complete the proof.\n\nlemma aboutgcd(x: pos, y: pos)\n  ensures isfactor(gcd(x, y), x)\n  ensures isfactor(gcd(x, y), y)\n  ensures forall p: pos :: isfactor(p, x) && isfactor(p, y) ==> p <= gcd(x, y)\n{\n  forall p: pos | isfactor(p, x) && isfactor(p, y)\n    ensures p <= gcd(x, y)\n  {\n    assert p in factors(x) * factors(y);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthe dafny verifier often needs help with properties like this. to prove them, just write them as an assertion. in other words, the verifier knows this property about set intersection, but it isn't creative enough the bring that property into the proof. by asserting the property, we're asking the verifier to confirm the property (which it's able to do) and then to use that property in the rest of the proof (which in this case completes the proof).\n\nas a second sanity check, we prove that gcd is symmetric.\n\nlemma gcdsymmetric(x: pos, y: pos)\n  ensures gcd(x, y) == gcd(y, x)\n{\n  assert factors(x) * factors(y) == factors(y) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n\n\nthe proof comes down to the fact that set intersection is symmetric, which we bring to the verifier's attention by writing it as a lemma.\n\nas a third sanity check, we prove that gcd is idempotent. that is, if you give it the same argument twice, it will return that argument.\n\nlemma gcdidempotent(x: pos)\n  ensures gcd(x, x) == x\n{\n  factorscontainsself(x);\n  assert x in factors(x) * factors(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthe proof of this property comes down to the fact that set intersection is idempotent, as well as the property that a number is one of its own factors.\n\n\n# 6.âeuclid's algorithm\n\neuclid's subtractive algorithm for finding the gcd of two numbers is to repeatedly subtract the smaller of the numbers from the larger until they are both equal. each such subtraction preserves the gcdâan invariant that we will need to proveâand the gcd of two equal numbers is that numberâwhich we established by lemma gcdidempotent above.\n\nthe algorithm, with the loop invariant and idempotence lemma, thus looks like this:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)  // error: invariant not maintained\n    decreases x + y\n  {\n    case x < y =>\n      y := y - x;\n    case y < x =>\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nthis method uses a while-case loop. (if you're familiar with dijkstra's guarded commands [1], this is the do-od loop.) each iteration of this loop chooses one of the cases to execute. the case chosen must be one whose guard condition evaluates to true (and if the guards of several cases evaluate to true, the loop chooses arbitrarily between those cases) . if no such guard condition evaluates to true, then the loop stops iterating. the loop in euclidgcd could of course be an ordinary while x != y loop, but the symmetry of the two cases afforded by the while-case loop makes it aesthetically pleasing.\n\nin addition to a loop invariant, the loop also declares a termination metric (keyword decreases). proving that the loop terminates comes down to proving that each iteration makes the value of the termination metric decrease (in dafny's built-in well-founded order on integers).\n\nthe euclidgcd method above does not verify, because the verifier is unable to prove that each iteration maintains the loop invariant. for this, we need the fourth property of gcd that i alluded to above:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(x, y) == gcd(x, y - x)\n\n\n1\n2\n3\n\n\nusing this lemma and the symmetry of gcd, we can complete the proof of gcd:\n\nmethod euclidgcd(x: pos, y: pos) returns (gcd: pos)\n  ensures gcd == gcd(x, y)\n{\n  var x, y := x, y;\n  while\n    invariant gcd(x, y) == gcd(x, y)\n    decreases x + y\n  {\n    case x < y =>\n      gcdsubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        gcd(x, y);\n      ==  { gcdsymmetric(x, y); }\n        gcd(y, x);\n      ==  { gcdsubtract(y, x); }\n        gcd(y, x - y);\n      ==  { gcdsymmetric(y, x - y); }\n        gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  gcdidempotent(x);\n  return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nthis version adds a call to gcdsubtract in the first branch of the loop. in the second branch of the loop, the proof calculation uses equality-preserving steps to transform the expression gcd(x, y) into gcd(x - y, y). the hints given in the steps appeal to the gcdsubtract and gcdsymmetric lemmas.\n\n\n# 7.âgcd subtract property\n\nthe proof of gcdsubtract is more involved than any of the other definitions and lemmas in this case study.\n\nthe proof starts by introducing a name for gcd(x, y):\n\n  var p := gcd(x, y);\n\n\n1\n\n\nwe know from the definition of gcd that p is a factor of both x and y, and we can prove that p is also a factor of y - x:\n\n  assert isfactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nto prove isfactor(p, y - x), we introduce names a and b for the multiplicands that the definition of isfactor tells us exist (since p is a factor of both x and y). a simple calculation using basic arithmetic steps then gives us that p can be multiplied another number (namely, b - a) to get y - x.\n\nsince p is a factor of both x and y - x, we have that it's in the common factors of x and y - x. we write two lines to make sure the verifier is on board with this property, phrased in terms of set intersection:\n\n  var common := factors(x) * factors(y - x);\n  assert p in common;\n\n\n1\n2\n\n\nlastly, we need to show that p is the largest such common factor. we state this property using a forall statement:\n\n  forall q | q in common\n    ensures q <= p\n\n\n1\n2\n\n\nto prove this property, we fill in the body of the forall statement. for q, which denotes an arbitrary number in the set common, we give names to the multiplicands that yield the products x and y - x, respectively:\n\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n\n\n1\n2\n3\n\n\nusing simple arithmetic steps, we can use a proof calculation to establish that q is also a factor of y:\n\n    assert isfactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nso, since q is a factor of both x and y, the definition of gcd(x, y) tells us q <= gcd(x, y). by giving yet another hint about set intersection:\n\n    assert q in factors(x) * factors(y);\n  }\n\n\n1\n2\n\n\nthe verifier completes the proof.\n\n\n# 8.âmore symmetry\n\nwhile we now have a full proof of the gcd algorithm, your aesthetic sense may be bothered by the asymmetry in how we supplied the proofs in the two cases of the loop. since the while-case loop affords us a symmetric rendition of the two cases, it would be nice if we could make the proofs of the two cases more similar as well.\n\nthere are several ways we can improve on this situation. one is to refactor the proof calculation of the second case into its own lemma. then, then each case would have one line of proof.\n\njust for fun, let me describe another âtrickâ to make the two cases (not entirely symmetric, but at least) more similar. the trick is to make the (already asymmetric) gcdsubtract lemma also swap the arguments to gcd. we rewrite it into:\n\nlemma gcdsubtract(x: pos, y: pos)\n  requires x < y\n  ensures gcd(y, x) == gcd(x, y - x)\n{\n  gcdsymmetric(x, y);\n  // ... the proof continues as before\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that the left-hand side of the postcondition is now gcd(y, x), not gcd(x, y) as it had been in our first version of this lemma. the only change required for the proof is to appeal to the symmetry of gcd, which we can do by one lemma call immediately inside the body of the lemma. this gives us a proof of our reformulated gcdsubtract lemma.\n\nwith this reformulation, we can simplify the second case of euclidgcd, at the expense of making the first case more complicated. essentially, we're moving one lemma call from the second case to the first, so instead of having 1 and 3 lemma calls in the two respective cases, we'll have 2 and 2.\n\n    case x < y =>\n      gcdsubtract(x, y);\n      gcdsymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      gcdsymmetric(x - y, y);\n      gcdsubtract(y, x);\n      x := x - y;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nit's not entirely symmetric, but perhaps you still like it. or perhaps you'll remember this trick for another situation where the shoe fits perfectly. if nothing else, you can stick with the first complete proof we developed above.\n\n\n# 9.âmain\n\nif the proof itself doesn't satisfy you and still want to see the algorithm in action, you can write a main method and compile and run the program. (a simple way of doing that from the command line is to use the /compile:3 option with the dafny tool. it will verify and then run the program.)\n\nhere is a sample main:\n\nmethod main() {\n  test(15, 9);\n  test(14, 22);\n  test(371, 1);\n  test(1, 2);\n  test(1, 1);\n  test(13, 13);\n  test(60, 60);\n}\n\nmethod test(x: pos, y: pos) {\n  var gcd := euclidgcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 10.âconclusions\n\nthis case study shows how to define a domain of interest (here, factors of numbers, leading up to the definition of gcd), state and prove some lemmas about those definitions, and then use these in the proof of a small program.\n\nthe program, including all lemmas and other proof obligations associated with the definitions, takes the dafny verifier less than 3 seconds to verify. you can find the entire program in the dafny test suite [3].\n\neuclid's gcd algorithm is a familiar textbook example. it's proved in different forms in various verifiers. for example, the tla+ tutorial uses this program as an example [0]. it assumes the mathematical properties of gcd that we proved here. the gallery of why3 programs contains a version of euclid's gcd algorithm that uses modulo instead of subtraction with each step, which results in fewer iterations [2].\n\n# acknowledgments\n\ni thank reto kramer for suggesting this problem as a useful case study.\n\n\n# references\n\n[0]tla proof system. https://tla.msr-inria.inria.fr/tlaps/content/documentation/tutorial/the_example.html. ð\n\n[1]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. ð\n\n[2]jean-christophe filliatre and claude marche. greatest common divisor, using the euclidean algorithm. http://toccata.lri.fr/gallery/gcd.en.html. ð\n\n[3]k. rustan m. leino. gcd.dfy. https://github.com/dafny-lang/dafny/blob/master/test/dafny4/gcd.dfy, june 2021. ð",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Comprehensions",frontmatter:{title:"Comprehensions",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/da6921/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/15.Comprehensions.html",relativePath:"80.è¯­è¨/30.publication-lecture/15.Comprehensions.md",key:"v-4470a5a9",path:"/pages/da6921/",headers:[{level:2,title:"0.âQuantifiers",slug:"_0-quantifiers",normalizedTitle:"0.âquantifiers",charIndex:863},{level:3,title:"Basic quantifier syntax",slug:"basic-quantifier-syntax",normalizedTitle:"basic quantifier syntax",charIndex:882},{level:3,title:"Types of bound variables",slug:"types-of-bound-variables",normalizedTitle:"types of bound variables",charIndex:2238},{level:3,title:"Multiple bound variables",slug:"multiple-bound-variables",normalizedTitle:"multiple bound variables",charIndex:3110},{level:3,title:"The typical forms of quantifier bodies",slug:"the-typical-forms-of-quantifier-bodies",normalizedTitle:"the typical forms of quantifier bodies",charIndex:4085},{level:3,title:"Range predicates",slug:"range-predicates",normalizedTitle:"range predicates",charIndex:5949},{level:2,title:"1.âProgram Statements for Quantifier Reasoning",slug:"_1-program-statements-for-quantifier-reasoning",normalizedTitle:"1.âprogram statements for quantifier reasoning",charIndex:8013},{level:3,title:"Aggregate statements",slug:"aggregate-statements",normalizedTitle:"aggregate statements",charIndex:8264},{level:3,title:"Existential introduction and elimination",slug:"existential-introduction-and-elimination",normalizedTitle:"existential introduction and elimination",charIndex:9966},{level:3,title:"Lemmas with out-parameters",slug:"lemmas-with-out-parameters",normalizedTitle:"lemmas with out-parameters",charIndex:14075},{level:3,title:"Binding guards",slug:"binding-guards",normalizedTitle:"binding guards",charIndex:15486},{level:2,title:"2.âSets and Maps",slug:"_2-sets-and-maps",normalizedTitle:"2.âsets and maps",charIndex:16410},{level:3,title:"Set comprehensions",slug:"set-comprehensions",normalizedTitle:"set comprehensions",charIndex:655},{level:3,title:"Simplified set comprehensions",slug:"simplified-set-comprehensions",normalizedTitle:"simplified set comprehensions",charIndex:20013},{level:3,title:"Map comprehensions",slug:"map-comprehensions",normalizedTitle:"map comprehensions",charIndex:20842},{level:3,title:"Lambda expressions",slug:"lambda-expressions",normalizedTitle:"lambda expressions",charIndex:22995},{level:2,title:"3.âSummary",slug:"_3-summary",normalizedTitle:"3.âsummary",charIndex:23595},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:23954},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:24041}],headersStr:"0.âQuantifiers Basic quantifier syntax Types of bound variables Multiple bound variables The typical forms of quantifier bodies Range predicates 1.âProgram Statements for Quantifier Reasoning Aggregate statements Existential introduction and elimination Lemmas with out-parameters Binding guards 2.âSets and Maps Set comprehensions Simplified set comprehensions Map comprehensions Lambda expressions 3.âSummary Acknowledgments References",content:"Dafny Power User: Comprehensions\n\nK. Rustan M. Leino\n\nManuscript KRML 267, 27 May 2019\n\nAbstract. Dafny has a number of comprehension-like constructs. This note describes and compares these constructs, showing how they compare both syntactically and semantically.\n\nDafny supports universal and existential quantifications, along with constructs used to prove a universally quantified expression or make use of an existentially quantified expression. Section 0 describes these logical quantifiers in Dafny. Section 1 shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.\n\nSet comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. Section 2 shows the general and common forms of these comprehensions.\n\n\n# 0.âQuantifiers\n\n\n# Basic quantifier syntax\n\nIn mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . It says that the predicate holds for all values of . In programming-language lingo, we say that is a bound variable whose scope is the body of the quantifier, . That is, any free occurrences of in are bound to the introduced by the quantifier.\n\nIn Dafny, the same universal quantifier is written forall x :: P. From a parsing perspective, the body of the quantifier extends âas far as possibleâ. Thus, the program snippet\n\nforall x :: R ==> Q\n\n\n1\n\n\nis parsed as\n\n(forall x :: (R ==> Q))\n\n\n1\n\n\nnot as\n\n(forall x :: R) ==> Q\n\n\n1\n\n\nNote that âas far as possibleâ does not stop at line endings. For example, a common pitfall is to write (here shown for a precondition)\n\nrequires\n  forall x :: R ==> Q &&\n  S\n\n\n1\n2\n3\n\n\nwith the intention that forall x :: R ==> Q and S are two separate preconditions. Contrary to this expectation, the meaning of declaration, as written here, is\n\nrequires (forall x :: (R ==> (Q && S)))\n\n\n1\n\n\nIf you intended to write the conjunction of the quantifier and S, then the proper syntax is\n\nrequires\n  (forall x :: R ==> Q) &&\n  S\n\n\n1\n2\n3\n\n\nA familiar mathematical notation for an existential quantifier is . It says that the predicate holds for some value of . In Dafny, the syntax is exists x :: P.0\n\n\n# Types of bound variables\n\nEach variable in Dafny has a type. Typically, the type of a bound variable is inferred, but Dafny also allows the type to be declared explicitly. For example,\n\nforall x: X :: P\n\n\n1\n\n\ndeclares the type of x to be X. For brevity, and to show the typical ways of writing quantifiers and comprehensions, I will leave off types throughout this note, but remember that you can always include them if you want to.\n\nA common mathematical notation for quantifiers when the bound variables are drawn from some set is . A Dafny-like rendering of this expression is\n\nforall x in S :: P  // error: syntax error\n\n\n1\n\n\nHowever, this is incorrect Dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. The proper way to write such a quantifier in Dafny is\n\nforall x :: x in S ==> P\n\n\n1\n\n\n\n# Multiple bound variables\n\nA quantifier can have more than one bound variable. For example,\n\nforall x, y :: P\n\n\n1\n\n\nsays that P holds for all values of x and y. It is logically equivalent to the nested quantifiers\n\nforall x :: forall y :: P\n\n\n1\n\n\nFor that matter, it is logically equivalent also to\n\nforall y :: forall x :: P\n\n\n1\n\n\nCommon practice in Dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise.1\n\nIn the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. For example,\n\nforall x: X, y: Y :: P\n\n\n1\n\n\nsays that x has type X and y has type Y. If you only include the type of y, as in\n\nforall x, y: Y :: P\n\n\n1\n\n\nthen you are saying that y has type Y and that the type of x is to be inferred. In other words, you can think of this \":â as having strong binding power than the â,\".\n\n\n# The typical forms of quantifier bodies\n\nThe body of a universal quantifier is typically an implication, as in\n\nforall x :: R ==> P\n\n\n1\n\n\nYou can read this in one of the following ways:\n\n> \"for all x, the implication R ==> P holds\"\n> \n> \"for all x, R implies P\"\n> \n> \"for all x, if R holds, then so does P\"\n\nHowever, the antecedent of this implication (R) often serves the role of restricting (beyond just the type of x) the values of x under consideration. In other words, R tells you which values x ranges over. In that light, you would read the quantifier above in one of the following ways:\n\n> \"for all x satisfying R, P holds\n> \n> \"for all x such that R holds, P\"\n> \n> \"for all x (where x satisfies R), P holds\"\n> \n> \"for all x [insert your own descriptive phase for R], P\"\n\nAs a concrete instance of the last phrase, you may read forall x :: x in S ==> x % 2 == 0 as\n\n> \"for all x in S, x is even\"\n\nand you may read forall i :: 0 <= i < a.Length ==> a[i] == 5 as\n\n> \"for every index i of array a, a-sub-i is 5\"\n\nIn analogy to what I just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in\n\nexists x :: R && P\n\n\n1\n\n\nFor example:\n\nexists x :: x in S && x % 2 == 0\n\nexists i :: 0 <= i < a.Length && a[i] == 5\n\n\n1\n2\n3\n\n\nAgain thinking of R as telling you which values x ranges over, you may read these existential quantifiers as\n\n> \"there is an x in S for which x % 2 == 0 holds\"\n> \n> \"there is an index i into a such that a-sub-i is 5\"\n\nFollowing Why3 [1], Dafny issues a warning if you write R ==> P as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). If this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:\n\nexists x :: (R ==> P)\nexists x :: !R || P\nexists x :: P <== R\n\n\n1\n2\n3\n\n\n\n# Range predicates\n\nWhy did I just spend a page telling you ways to pronounce your quantifiers? Because that discussion spotlights the fact that the condition R, in either of\n\nforall x :: R ==> P\nexists x :: R && P\n\n\n1\n2\n\n\nplays a special role, even though R is really just a part of the body of these quantifiers. In fact, others have adopted a notation for quantifier that feature a special place for this range predicate R. Here are some examples:\n\n                                                \nUniversal quantifier   Existential quantifier   Source\n                                                \n                                                Dijkstra [3]\n                                                Chandy and Misra [2]\n                                                Gries and Schneider [4]\n\\forall X x; R; P      \\exists X x; R; P        JML [5]\n                                                \n\n(In the case of JML above, X denotes the type of x.) In textbooks using these notations, it is often remarked that \"for brevity, if R is true or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted\". These shortened forms are:\n\n                                                  \nRange listed separately   Range true or omitted   Source\n                                                  \n                                                  Dijkstra [3]\n                                                  Chandy and Misra [2]\n                                                  Gries and Schneider [4]\n\\forall X x; R; P         \\forall X x;; P         JML [5]\n                                                  \n\nThere's more. By using some notation that separates the R from P, the De Morgan's Law for quantifiers looks especially nice:\n\nBack to Dafny. If you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in Dafny, too. The syntax is:\n\nforall x | R :: P\nexists x | R :: P\n\n\n1\n2\n\n\n\n# 1.âProgram Statements for Quantifier Reasoning\n\nDafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. These have a syntax similar to those of quantifiers, but there are differences.\n\n\n# Aggregate statements\n\nThe forall statement in Dafny is an aggregate statement: it has the effect of performing a number of simultaneous operations. When used in proofs, the statement has the form:\n\nforall x | R\n  ensures P\n{\n  S;\n}\n\n\n1\n2\n3\n4\n5\n\n\nIt is used to establish the property forall x | R :: P, that is, forall x :: R ==> P. It does so by checking that the statement S establishes P for any x that satisfies R. In logic, the effect of this statement is called universal introduction.\n\nAs a simple example, suppose you have a lemma that proves n <= Fib(n) for any n at least 5, where Fib is the usual Fibonacci function:\n\nfunction Fib(n: nat): nat {\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\nlemma FibProperty(n: nat)\n  requires 5 <= n\n  ensures n <= Fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThis lemma gives you the property n <= Fib(n) for a given n. But suppose you want to have this property in the universally quantified form. That is, you'd like to prove the following lemma:\n\nlemma FibPropertyAll()\n  ensures forall n :: 5 <= n ==> n <= Fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nHow would we write this proof?2\n\nThe answer is to call FibProperty once for each n. All at once. For an infinite number of different values for n. That's what you do with the aggregate statement forall:\n\nforall n | 5 <= n\n  ensures n <= Fib(n)\n{\n  FibProperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nIn general, the body of a forall statement is more complicated than just one single lemma call. But for when the body is just one lemma call or just one calc statement, then Dafny infers the ensures clause automatically, so you can omit it:\n\nforall n | 5 <= n {\n  FibProperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# Existential introduction and elimination\n\nWorking with existential quantifications also uses a repertoire of proof features. I will demonstrate these by writing a proof that shows Fibonacci numbers can be arbitrarily large:\n\nlemma EverBigger(k: nat)\n  ensures exists n :: k <= Fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nLet's start the proof with some cases we can easily do, namely when k is small, let's say 0 or 1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\nDafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.\n\nTo prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular n for which the existential quantifier holds. That is, we want to give a witness to the existential quantifier. One such witness is 1, since k <= 1 == Fib(1). Another such witness is 12, since k <= 144 == Fib(12). Yet another such witness is k, since k <= k == Fib(k) in our simple case. Let's go with this one, so we add an assertion to the âthenâ branch of the if statement in the lemma body:\n\nassert k <= Fib(k);\n\n\n1\n\n\nDafny will prove this assertion3 and will then notice that k is an existential witness that proves the postcondition. In logic, this is called existential introduction. All that means is that if you have a value that satisfies a particular property, then such a value exists. Stated different, if you have a value âin your handsâ, then a value existsâthis seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that this is what you did for a living).\n\nSo what about the difficult case? We can prove it by induction, by first obtaining an n whose Fibonacci value is at least k-1 and then building an even larger Fibonacci value from there. To start this off, we call the lemma recursively on k-1:\n\nEverBigger(k-1);\n\n\n1\n\n\nThis lets us obtain the postcondition of EverBigger(k-1). To write that down explicitly in our proofâto check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property isâwe can write an assertion:\n\nassert exists n' :: k-1 <= Fib(n');\n\n\n1\n\n\nGood so far. Next, we want to construct a Fibonacci number that is at least 1 larger than Fib(n'), because that would complete the proof. But what is this n' that i just mentioned? All the assertion above tells us that some such n' exists. We'd like to have such an n' âin our handsâ so that we can work with it.\n\nGoing from something we know exists to something âin our handsâ is called Skolemization or existential elimination. You achieve it in Dafny by the assign-such-that statement:\n\nvar m: nat :| k-1 <= Fib(m);\n\n\n1\n\n\nThis statement introduce a local variable m and gives it some arbitrary value that satisfies k-1 <= Fib(m). Of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an m exists. This proof obligation follows from the property we asserted just above.\n\nAlmost there. All that remains of our plan to establish the lemma's postcondition is to construct a Fibonacci number strictly larger than Fib(m). We observe that Fib(m) + Fib(m+1) is strictly larger than Fib(m), and thus we have that Fib(m+2) is strictly larger than Fib(m). Boom!\n\nOkay, let's be frank. Maybe we didn't so much âobserveâ this as we did âwishâ or âconjectureâ or âloosely thinkâ that it may hold. Well, it does hold. (Phew!) We can check that by asking the verifier if it can prove it for us:\n\nassert k <= Fib(m) + Fib(m + 1) == Fib(m + 2);\n\n\n1\n\n\nThe verifier immediately prove this assertion.4 Moreover, by writing down this assertion, we are also showing the verifier the witness m+2, which proves the existential quantifier in the lemma's postcondition.\n\nThe point I set out to illustrate with this example is that you can Skolemize a quantifier\n\nexists x :: P\n\n\n1\n\n\nby the assign-such-that statement\n\nvar x :| P;\n\n\n1\n\n\nNotice the difference in punctuation.\n\n\n# Lemmas with out-parameters\n\nI just showed you an example that involves existential quantifiers. The example showed that the proof of the EverBigger lemma used existential introduction twice (Fib(k) in the simple case and Fib(m+2) in the difficult case), thus converting the k and the m+2 âin ours handsâ into existential quantifications. The example also showed that the invocation of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an m âin our handsâ. As impressive it is that Dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.\n\nIn mathematics, lemmas are parameterized by the variables they mention. These are like in-parameters. Rarely or never would a mathematical lemma be thought of as having out-parameters. In Dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. This can be quite useful. Instead of a lemma proving the existence of some value, it may as well just return some such value.\n\nHere is the EverBigger lemma from above, but with n declared as an out-parameter:\n\nlemma EverBigger(k: nat) returns (n: nat)\n  ensures k <= Fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := EverBigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Binding guards\n\nDafny includes one other feature that makes working with quantifiers more streamlined: if statements with binding guards. Such a statement answers the order âif there is one, gimmie one in my handâ.\n\nSuppose we write a proof that splits into two cases according whether or not the value y is a Fibonacci number. We could then write:\n\nif exists n :: y == Fib(n) {\n  var n :| y == Fib(n);\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThis expresses what we want, but feels a little clumsy, since we are repeating the condition y == Fib(n). Instead using a binding guard, we can write this if statement as\n\nif n :| y == Fib(n) {\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\nThe punctuation :| is the same as in the assign-such-that statement, not the :: in the similar position of the existential quantifier.\n\n\n# 2.âSets and Maps\n\nLogical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. This is also the case with set comprehensions and map comprehensions.\n\n\n# Set comprehensions\n\nIt is easy to write down a set in Dafny. For example,\n\n{ 2, 3, 5 }\n\n\n1\n\n\nis the set of the three smallest prime numbers. Such an expression, where the elements of the set are listed explicitly, is called a set display. But what if the set you want to define cannot be written as a set display?\n\nA set comprehension defines a set of elements in a schematic way. An example of a set comprehension in common mathematical notation is\n\nwhich defines the set of the smallest 100 natural numbers. Another example is\n\nwhich defines the 100 smallest perfect squares. The bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . Letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . That is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .\n\nMore generally, the mathematical notation takes some shape like . The reader is supposed to understand that is the bound variable. With the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :\n\nOr, to use the notation where the existential's range is given separately:\n\nIn Dafny, the same set comprehension has the following form:\n\nset x | R :: f(x)\n\n\n1\n\n\nx is the bound variable (or, more generally, a list of bound variables), R is the range predicate for the bound variables, and f(x) is the term expression of the set comprehension. The bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. The two example sets given above are written as follows in Dafny:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nAlthough at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.\n\nOne nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:\n\ny in (set x | R :: f(x))   <==>   exists x | R :: y == f(x)\n\n\n1\n\n\nAnother nicety is that one can easily list additional bound variables. Supposing that R is a predicate over both x and z, then here are two examples:\n\nset x,n | Fib(n) <= x < Fib(n) + n :: f(x)\nset x,n | Fib(n) <= x < Fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nThe first of these sets contains f(x) for every x that is within n of Fib(n) for some n. An equivalent way to write it in common mathematical notation is:\n\nThe second set contains g(x,n) for every x and n such that x is within n of Fib(n). Here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:\n\nDafny's general notation of making the bound variable explicit is also used by many authors (e.g., [3, 4]). It is also similar to the list-comprehension notation used in some other languages. For example, the Dafny set\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nwhich contains the pairs of natural numbers that sum to 100, contains the same elements as the Python list:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nand the Haskell list:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# Simplified set comprehensions\n\nI just spent many words describing the general set-comprehension notation in Dafny. However, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. For example, as we have seen, the set of the smallest 100 natural numbers is:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nFor this common case, Dafny lets you omit the term expression and simply write:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nThis expression looks like the common mathematical notation . Indeed, for these simplified set comprehensions, it is easy to âunderstandâ what the mathematical notation intends to be the bound variables.\n\nAs a note about the verifier in Dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.\n\n\n# Map comprehensions\n\nA map is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). Like the display expressions for sets, a map can be defined by a map display. For example,\n\nmap[2 := 'c', 137 := 'a']\n\n\n1\n\n\nmaps the integer 2 to the character 'c' and maps the integer 137 to the character 'a'. Each pair like 2 := 'c' can be called a maplet. Also, the left-element of the maplet is called a key and the right-element gets the nondescript name value.\n\nLike the comprehensions for sets, a map can be defined by a map comprehension. It has the form:\n\nmap x | R :: f(x) := g(x)\n\n\n1\n\n\nFor example,\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\nis the map from each of the first 100 perfect squares to their respective square roots.\n\nIf you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. Nevertheless, I will offer some notes and point out some features specific to maps.\n\nOne thing to note is that the maplets must have unique keys. For example, the verifier will complain if you try to write a map comprehension like\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nbecause it says to map 4 to both 2 and -2, which is not functional.\n\nThe general map-comprehension expression is quite flexible. For example, suppose m is a map from numbers to characters, and suppose we want to create a new map n from a subset of the keys in m to some other characters. More precisely, whenever a key in m is in the image of a function f, say a key f(x) for some x, then we want n to map that key to h(x). We then define n as\n\nmap x | f(x) in m.Keys :: f(x) := h(x)\n\n\n1\n\n\nMost of the time, however, the map comprehensions we tend to write have the form\n\nmap x | R :: x := g(x)\n\n\n1\n\n\nFor these common maps, Dafny allows us to omit the \"x :=\" and write just\n\nmap x | R :: g(x)\n\n\n1\n\n\nAlmost all map comprehensions in practice can be written in this simplified form. But for when the simplified form is not sufficient (like in the example above with the maplets f(x) := h(x)), the general form is available.\n\n\n# Lambda expressions\n\nFinally, a note about the difference between maps and functions. You may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. For comparison, let's consider writing the map\n\nmap x | R :: g(x)\n\n\n1\n\n\nas a function.\n\nTypically, a function is declared with a name. The map above is then written along the lines of\n\nfunction F(x: X): Y\n  requires R\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\nA function can also be anonymous, in which case it is usually called a lambda expression. The example map is then written\n\nx requires R => g(x)\n\n\n1\n\n\n\n# 3.âSummary\n\nHere is a listing of the syntactic forms discussed in this note:\n\nforall x :: P\nforall x | R :: P\nforall x | R ensures P { S; }\nexists x :: P\nexists x | R :: P\nvar x :| P;\nif x :| P { S; }\nset x | R :: f(x)\nset x | R\nmap x | R :: f(x) := h(x)\nmap x | R :: g(x)\nfunction F(x: X): Y { g(x) }\nx requires R => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# Acknowledgments\n\nI'm grateful to Jay Lorch for many helpful comments on this note.\n\n\n# References\n\n[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, Tests and Proofs â 8th International Conference, TAP 2014, volume 8570 of Lecture Notes in Computer Science, pages 20â35. Springer, July 2014. ð\n\n[1]FranÃ§ois Bobot, Jean-Christophe FilliÃ¢tre, Claude MarchÃ©, and Andrei Paskevich. Why3: Shepherd your herd of provers. In Boogie 2011: First International Workshop on Intermediate Verification Languages, pages 53â64, WrocÅaw, Poland, August 2011. https://hal.inria.fr/hal-00790310. ð\n\n[2]K. Mani Chandy and Jayadev Misra. Parallel Program Design: A Foundation. Addison-Wesley, 1988. ð\n\n[3]Edsger W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cliffs, NJ, 1976. ð\n\n[4]David Gries and Fred B. Schneider. A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. Springer-Verlag, 1994. ð\n\n[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems, pages 175â188. Kluwer Academic Publishers, 1999. ð\n\n[6]K. Rustan M. Leino and ClÃ©ment Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361â381. Springer, 2016. ð\n\n----------------------------------------\n\n0.The Emacs IDE for Dafny typesets certain Dafny constructs in the notation you're more likely to see in a paper. By default, it shows forall x :: P as and shows exists x :: P as . â©\n\n1.Internally, the Dafny verifier works more effectively with certain quantifiers. The verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically [6]. For example, it may choose to un-nest some quantifiers. The goal of such rewrites is to support natural-looking programs while getting good prover performance. â©\n\n2.As it turns out, Dafny's automatic induction will prove both FibProperty and FibPropertyAll automatically. If these were the only lemmas we cared about, there would be nothing else to say or do. Nevertheless, I'm using this example to show the forall statement. If you want to make sure what I'm about to say gives a proof, you can turn off automatic induction for FibPropertyAll by marking it with the attribute {:induction false}. â©\n\n3.Dafny can also prove an assertion like assert Fib(12) == 144;. Internally, Dafny uses a âdual-rail encodingâ of functions that lets it obtain the value of Fib(12) (since 12 is a literal constant) and Fib(k) (where k is a variable). If you're interested in how this is done, I refer you to [0]. â©\n\n4.Here is a proof of the assertion k <= Fib(m) + Fib(m+1). The âdifficult caseâ in our proof applies when k is at least 2, so k-1 is at least 1, so we know about Fib(m) that it is at least 1. From this, it follows that m cannot be 0, for Fib(0) == 0. This is important, because it means that m+1 is at least 2 and therefore the inductive case of the definition of Fib applies. In other words, we have Fib(m+1) == Fib(m) + Fib(m-1). We already concluded that Fib(m) is at least 1. On behalf of Fib returning a nat, we have that Fib(m-1) is at least 0. So, Fib(m+1) is at least 1. In other words, Fib(m) + Fib(m+1) is at least 1 more than Fib(m), which in turn is at least k-1. Thus, Fib(m) + Fib(m+1) is at least k.\n\nHad we split the âsimple caseâ and âdifficult caseâ up so that the âsimple caseâ only covered k == 0, then we could not have concluded m != 0 in the argument above. Some users of other interactive proof assistants may be bothered by this, because they would say k has type nat and therefore the induction on k should use k == 0 as the base case. Mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of EverBigger into k < 2 and 2 <= k. â©",normalizedContent:"dafny power user: comprehensions\n\nk. rustan m. leino\n\nmanuscript krml 267, 27 may 2019\n\nabstract. dafny has a number of comprehension-like constructs. this note describes and compares these constructs, showing how they compare both syntactically and semantically.\n\ndafny supports universal and existential quantifications, along with constructs used to prove a universally quantified expression or make use of an existentially quantified expression. section 0 describes these logical quantifiers in dafny. section 1 shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.\n\nset comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. section 2 shows the general and common forms of these comprehensions.\n\n\n# 0.âquantifiers\n\n\n# basic quantifier syntax\n\nin mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . it says that the predicate holds for all values of . in programming-language lingo, we say that is a bound variable whose scope is the body of the quantifier, . that is, any free occurrences of in are bound to the introduced by the quantifier.\n\nin dafny, the same universal quantifier is written forall x :: p. from a parsing perspective, the body of the quantifier extends âas far as possibleâ. thus, the program snippet\n\nforall x :: r ==> q\n\n\n1\n\n\nis parsed as\n\n(forall x :: (r ==> q))\n\n\n1\n\n\nnot as\n\n(forall x :: r) ==> q\n\n\n1\n\n\nnote that âas far as possibleâ does not stop at line endings. for example, a common pitfall is to write (here shown for a precondition)\n\nrequires\n  forall x :: r ==> q &&\n  s\n\n\n1\n2\n3\n\n\nwith the intention that forall x :: r ==> q and s are two separate preconditions. contrary to this expectation, the meaning of declaration, as written here, is\n\nrequires (forall x :: (r ==> (q && s)))\n\n\n1\n\n\nif you intended to write the conjunction of the quantifier and s, then the proper syntax is\n\nrequires\n  (forall x :: r ==> q) &&\n  s\n\n\n1\n2\n3\n\n\na familiar mathematical notation for an existential quantifier is . it says that the predicate holds for some value of . in dafny, the syntax is exists x :: p.0\n\n\n# types of bound variables\n\neach variable in dafny has a type. typically, the type of a bound variable is inferred, but dafny also allows the type to be declared explicitly. for example,\n\nforall x: x :: p\n\n\n1\n\n\ndeclares the type of x to be x. for brevity, and to show the typical ways of writing quantifiers and comprehensions, i will leave off types throughout this note, but remember that you can always include them if you want to.\n\na common mathematical notation for quantifiers when the bound variables are drawn from some set is . a dafny-like rendering of this expression is\n\nforall x in s :: p  // error: syntax error\n\n\n1\n\n\nhowever, this is incorrect dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. the proper way to write such a quantifier in dafny is\n\nforall x :: x in s ==> p\n\n\n1\n\n\n\n# multiple bound variables\n\na quantifier can have more than one bound variable. for example,\n\nforall x, y :: p\n\n\n1\n\n\nsays that p holds for all values of x and y. it is logically equivalent to the nested quantifiers\n\nforall x :: forall y :: p\n\n\n1\n\n\nfor that matter, it is logically equivalent also to\n\nforall y :: forall x :: p\n\n\n1\n\n\ncommon practice in dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise.1\n\nin the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. for example,\n\nforall x: x, y: y :: p\n\n\n1\n\n\nsays that x has type x and y has type y. if you only include the type of y, as in\n\nforall x, y: y :: p\n\n\n1\n\n\nthen you are saying that y has type y and that the type of x is to be inferred. in other words, you can think of this \":â as having strong binding power than the â,\".\n\n\n# the typical forms of quantifier bodies\n\nthe body of a universal quantifier is typically an implication, as in\n\nforall x :: r ==> p\n\n\n1\n\n\nyou can read this in one of the following ways:\n\n> \"for all x, the implication r ==> p holds\"\n> \n> \"for all x, r implies p\"\n> \n> \"for all x, if r holds, then so does p\"\n\nhowever, the antecedent of this implication (r) often serves the role of restricting (beyond just the type of x) the values of x under consideration. in other words, r tells you which values x ranges over. in that light, you would read the quantifier above in one of the following ways:\n\n> \"for all x satisfying r, p holds\n> \n> \"for all x such that r holds, p\"\n> \n> \"for all x (where x satisfies r), p holds\"\n> \n> \"for all x [insert your own descriptive phase for r], p\"\n\nas a concrete instance of the last phrase, you may read forall x :: x in s ==> x % 2 == 0 as\n\n> \"for all x in s, x is even\"\n\nand you may read forall i :: 0 <= i < a.length ==> a[i] == 5 as\n\n> \"for every index i of array a, a-sub-i is 5\"\n\nin analogy to what i just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in\n\nexists x :: r && p\n\n\n1\n\n\nfor example:\n\nexists x :: x in s && x % 2 == 0\n\nexists i :: 0 <= i < a.length && a[i] == 5\n\n\n1\n2\n3\n\n\nagain thinking of r as telling you which values x ranges over, you may read these existential quantifiers as\n\n> \"there is an x in s for which x % 2 == 0 holds\"\n> \n> \"there is an index i into a such that a-sub-i is 5\"\n\nfollowing why3 [1], dafny issues a warning if you write r ==> p as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). if this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:\n\nexists x :: (r ==> p)\nexists x :: !r || p\nexists x :: p <== r\n\n\n1\n2\n3\n\n\n\n# range predicates\n\nwhy did i just spend a page telling you ways to pronounce your quantifiers? because that discussion spotlights the fact that the condition r, in either of\n\nforall x :: r ==> p\nexists x :: r && p\n\n\n1\n2\n\n\nplays a special role, even though r is really just a part of the body of these quantifiers. in fact, others have adopted a notation for quantifier that feature a special place for this range predicate r. here are some examples:\n\n                                                \nuniversal quantifier   existential quantifier   source\n                                                \n                                                dijkstra [3]\n                                                chandy and misra [2]\n                                                gries and schneider [4]\n\\forall x x; r; p      \\exists x x; r; p        jml [5]\n                                                \n\n(in the case of jml above, x denotes the type of x.) in textbooks using these notations, it is often remarked that \"for brevity, if r is true or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted\". these shortened forms are:\n\n                                                  \nrange listed separately   range true or omitted   source\n                                                  \n                                                  dijkstra [3]\n                                                  chandy and misra [2]\n                                                  gries and schneider [4]\n\\forall x x; r; p         \\forall x x;; p         jml [5]\n                                                  \n\nthere's more. by using some notation that separates the r from p, the de morgan's law for quantifiers looks especially nice:\n\nback to dafny. if you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in dafny, too. the syntax is:\n\nforall x | r :: p\nexists x | r :: p\n\n\n1\n2\n\n\n\n# 1.âprogram statements for quantifier reasoning\n\ndafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. these have a syntax similar to those of quantifiers, but there are differences.\n\n\n# aggregate statements\n\nthe forall statement in dafny is an aggregate statement: it has the effect of performing a number of simultaneous operations. when used in proofs, the statement has the form:\n\nforall x | r\n  ensures p\n{\n  s;\n}\n\n\n1\n2\n3\n4\n5\n\n\nit is used to establish the property forall x | r :: p, that is, forall x :: r ==> p. it does so by checking that the statement s establishes p for any x that satisfies r. in logic, the effect of this statement is called universal introduction.\n\nas a simple example, suppose you have a lemma that proves n <= fib(n) for any n at least 5, where fib is the usual fibonacci function:\n\nfunction fib(n: nat): nat {\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n\nlemma fibproperty(n: nat)\n  requires 5 <= n\n  ensures n <= fib(n)\n{\n  // some proof goes here\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthis lemma gives you the property n <= fib(n) for a given n. but suppose you want to have this property in the universally quantified form. that is, you'd like to prove the following lemma:\n\nlemma fibpropertyall()\n  ensures forall n :: 5 <= n ==> n <= fib(n)\n{\n  // some proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nhow would we write this proof?2\n\nthe answer is to call fibproperty once for each n. all at once. for an infinite number of different values for n. that's what you do with the aggregate statement forall:\n\nforall n | 5 <= n\n  ensures n <= fib(n)\n{\n  fibproperty(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\nin general, the body of a forall statement is more complicated than just one single lemma call. but for when the body is just one lemma call or just one calc statement, then dafny infers the ensures clause automatically, so you can omit it:\n\nforall n | 5 <= n {\n  fibproperty(n);\n}\n\n\n1\n2\n3\n\n\n\n# existential introduction and elimination\n\nworking with existential quantifications also uses a repertoire of proof features. i will demonstrate these by writing a proof that shows fibonacci numbers can be arbitrarily large:\n\nlemma everbigger(k: nat)\n  ensures exists n :: k <= fib(n)\n{\n  // proof to go here\n}\n\n\n1\n2\n3\n4\n5\n\n\nlet's start the proof with some cases we can easily do, namely when k is small, let's say 0 or 1:\n\nif k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n\n\n1\n2\n3\n4\n5\n\n\ndafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.\n\nto prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular n for which the existential quantifier holds. that is, we want to give a witness to the existential quantifier. one such witness is 1, since k <= 1 == fib(1). another such witness is 12, since k <= 144 == fib(12). yet another such witness is k, since k <= k == fib(k) in our simple case. let's go with this one, so we add an assertion to the âthenâ branch of the if statement in the lemma body:\n\nassert k <= fib(k);\n\n\n1\n\n\ndafny will prove this assertion3 and will then notice that k is an existential witness that proves the postcondition. in logic, this is called existential introduction. all that means is that if you have a value that satisfies a particular property, then such a value exists. stated different, if you have a value âin your handsâ, then a value existsâthis seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that this is what you did for a living).\n\nso what about the difficult case? we can prove it by induction, by first obtaining an n whose fibonacci value is at least k-1 and then building an even larger fibonacci value from there. to start this off, we call the lemma recursively on k-1:\n\neverbigger(k-1);\n\n\n1\n\n\nthis lets us obtain the postcondition of everbigger(k-1). to write that down explicitly in our proofâto check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property isâwe can write an assertion:\n\nassert exists n' :: k-1 <= fib(n');\n\n\n1\n\n\ngood so far. next, we want to construct a fibonacci number that is at least 1 larger than fib(n'), because that would complete the proof. but what is this n' that i just mentioned? all the assertion above tells us that some such n' exists. we'd like to have such an n' âin our handsâ so that we can work with it.\n\ngoing from something we know exists to something âin our handsâ is called skolemization or existential elimination. you achieve it in dafny by the assign-such-that statement:\n\nvar m: nat :| k-1 <= fib(m);\n\n\n1\n\n\nthis statement introduce a local variable m and gives it some arbitrary value that satisfies k-1 <= fib(m). of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an m exists. this proof obligation follows from the property we asserted just above.\n\nalmost there. all that remains of our plan to establish the lemma's postcondition is to construct a fibonacci number strictly larger than fib(m). we observe that fib(m) + fib(m+1) is strictly larger than fib(m), and thus we have that fib(m+2) is strictly larger than fib(m). boom!\n\nokay, let's be frank. maybe we didn't so much âobserveâ this as we did âwishâ or âconjectureâ or âloosely thinkâ that it may hold. well, it does hold. (phew!) we can check that by asking the verifier if it can prove it for us:\n\nassert k <= fib(m) + fib(m + 1) == fib(m + 2);\n\n\n1\n\n\nthe verifier immediately prove this assertion.4 moreover, by writing down this assertion, we are also showing the verifier the witness m+2, which proves the existential quantifier in the lemma's postcondition.\n\nthe point i set out to illustrate with this example is that you can skolemize a quantifier\n\nexists x :: p\n\n\n1\n\n\nby the assign-such-that statement\n\nvar x :| p;\n\n\n1\n\n\nnotice the difference in punctuation.\n\n\n# lemmas with out-parameters\n\ni just showed you an example that involves existential quantifiers. the example showed that the proof of the everbigger lemma used existential introduction twice (fib(k) in the simple case and fib(m+2) in the difficult case), thus converting the k and the m+2 âin ours handsâ into existential quantifications. the example also showed that the invocation of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an m âin our handsâ. as impressive it is that dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.\n\nin mathematics, lemmas are parameterized by the variables they mention. these are like in-parameters. rarely or never would a mathematical lemma be thought of as having out-parameters. in dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. this can be quite useful. instead of a lemma proving the existence of some value, it may as well just return some such value.\n\nhere is the everbigger lemma from above, but with n declared as an out-parameter:\n\nlemma everbigger(k: nat) returns (n: nat)\n  ensures k <= fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := everbigger(k-1);\n    n := m + 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# binding guards\n\ndafny includes one other feature that makes working with quantifiers more streamlined: if statements with binding guards. such a statement answers the order âif there is one, gimmie one in my handâ.\n\nsuppose we write a proof that splits into two cases according whether or not the value y is a fibonacci number. we could then write:\n\nif exists n :: y == fib(n) {\n  var n :| y == fib(n);\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthis expresses what we want, but feels a little clumsy, since we are repeating the condition y == fib(n). instead using a binding guard, we can write this if statement as\n\nif n :| y == fib(n) {\n  // y is the nth fibonacci number\n} else {\n  // y is not a fibonacci number\n}\n\n\n1\n2\n3\n4\n5\n\n\nthe punctuation :| is the same as in the assign-such-that statement, not the :: in the similar position of the existential quantifier.\n\n\n# 2.âsets and maps\n\nlogical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. this is also the case with set comprehensions and map comprehensions.\n\n\n# set comprehensions\n\nit is easy to write down a set in dafny. for example,\n\n{ 2, 3, 5 }\n\n\n1\n\n\nis the set of the three smallest prime numbers. such an expression, where the elements of the set are listed explicitly, is called a set display. but what if the set you want to define cannot be written as a set display?\n\na set comprehension defines a set of elements in a schematic way. an example of a set comprehension in common mathematical notation is\n\nwhich defines the set of the smallest 100 natural numbers. another example is\n\nwhich defines the 100 smallest perfect squares. the bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . that is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .\n\nmore generally, the mathematical notation takes some shape like . the reader is supposed to understand that is the bound variable. with the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :\n\nor, to use the notation where the existential's range is given separately:\n\nin dafny, the same set comprehension has the following form:\n\nset x | r :: f(x)\n\n\n1\n\n\nx is the bound variable (or, more generally, a list of bound variables), r is the range predicate for the bound variables, and f(x) is the term expression of the set comprehension. the bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. the two example sets given above are written as follows in dafny:\n\nset x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n\n\n1\n2\n\n\nalthough at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.\n\none nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:\n\ny in (set x | r :: f(x))   <==>   exists x | r :: y == f(x)\n\n\n1\n\n\nanother nicety is that one can easily list additional bound variables. supposing that r is a predicate over both x and z, then here are two examples:\n\nset x,n | fib(n) <= x < fib(n) + n :: f(x)\nset x,n | fib(n) <= x < fib(n) + n :: g(x,n)\n\n\n1\n2\n\n\nthe first of these sets contains f(x) for every x that is within n of fib(n) for some n. an equivalent way to write it in common mathematical notation is:\n\nthe second set contains g(x,n) for every x and n such that x is within n of fib(n). here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:\n\ndafny's general notation of making the bound variable explicit is also used by many authors (e.g., [3, 4]). it is also similar to the list-comprehension notation used in some other languages. for example, the dafny set\n\nset x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n\n\n1\n\n\nwhich contains the pairs of natural numbers that sum to 100, contains the same elements as the python list:\n\n[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n\n\n1\n\n\nand the haskell list:\n\n[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n\n\n1\n\n\n\n# simplified set comprehensions\n\ni just spent many words describing the general set-comprehension notation in dafny. however, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. for example, as we have seen, the set of the smallest 100 natural numbers is:\n\nset x | 0 <= x < 100 :: x\n\n\n1\n\n\nfor this common case, dafny lets you omit the term expression and simply write:\n\nset x | 0 <= x < 100\n\n\n1\n\n\nthis expression looks like the common mathematical notation . indeed, for these simplified set comprehensions, it is easy to âunderstandâ what the mathematical notation intends to be the bound variables.\n\nas a note about the verifier in dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.\n\n\n# map comprehensions\n\na map is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). like the display expressions for sets, a map can be defined by a map display. for example,\n\nmap[2 := 'c', 137 := 'a']\n\n\n1\n\n\nmaps the integer 2 to the character 'c' and maps the integer 137 to the character 'a'. each pair like 2 := 'c' can be called a maplet. also, the left-element of the maplet is called a key and the right-element gets the nondescript name value.\n\nlike the comprehensions for sets, a map can be defined by a map comprehension. it has the form:\n\nmap x | r :: f(x) := g(x)\n\n\n1\n\n\nfor example,\n\nmap x | 0 <= x < 100 :: x*x := x\n\n\n1\n\n\nis the map from each of the first 100 perfect squares to their respective square roots.\n\nif you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. nevertheless, i will offer some notes and point out some features specific to maps.\n\none thing to note is that the maplets must have unique keys. for example, the verifier will complain if you try to write a map comprehension like\n\nmap x | -10 <= x <= 10 :: x*x := x\n\n\n1\n\n\nbecause it says to map 4 to both 2 and -2, which is not functional.\n\nthe general map-comprehension expression is quite flexible. for example, suppose m is a map from numbers to characters, and suppose we want to create a new map n from a subset of the keys in m to some other characters. more precisely, whenever a key in m is in the image of a function f, say a key f(x) for some x, then we want n to map that key to h(x). we then define n as\n\nmap x | f(x) in m.keys :: f(x) := h(x)\n\n\n1\n\n\nmost of the time, however, the map comprehensions we tend to write have the form\n\nmap x | r :: x := g(x)\n\n\n1\n\n\nfor these common maps, dafny allows us to omit the \"x :=\" and write just\n\nmap x | r :: g(x)\n\n\n1\n\n\nalmost all map comprehensions in practice can be written in this simplified form. but for when the simplified form is not sufficient (like in the example above with the maplets f(x) := h(x)), the general form is available.\n\n\n# lambda expressions\n\nfinally, a note about the difference between maps and functions. you may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. for comparison, let's consider writing the map\n\nmap x | r :: g(x)\n\n\n1\n\n\nas a function.\n\ntypically, a function is declared with a name. the map above is then written along the lines of\n\nfunction f(x: x): y\n  requires r\n{\n  g(x)\n}\n\n\n1\n2\n3\n4\n5\n\n\na function can also be anonymous, in which case it is usually called a lambda expression. the example map is then written\n\nx requires r => g(x)\n\n\n1\n\n\n\n# 3.âsummary\n\nhere is a listing of the syntactic forms discussed in this note:\n\nforall x :: p\nforall x | r :: p\nforall x | r ensures p { s; }\nexists x :: p\nexists x | r :: p\nvar x :| p;\nif x :| p { s; }\nset x | r :: f(x)\nset x | r\nmap x | r :: f(x) := h(x)\nmap x | r :: g(x)\nfunction f(x: x): y { g(x) }\nx requires r => g(x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# acknowledgments\n\ni'm grateful to jay lorch for many helpful comments on this note.\n\n\n# references\n\n[0]nada amin, k. rustan m. leino, and tiark rompf. computing with an smt solver. in martina seidl and nikolai tillmann, editors, tests and proofs â 8th international conference, tap 2014, volume 8570 of lecture notes in computer science, pages 20â35. springer, july 2014. ð\n\n[1]francois bobot, jean-christophe filliatre, claude marche, and andrei paskevich. why3: shepherd your herd of provers. in boogie 2011: first international workshop on intermediate verification languages, pages 53â64, wrocÅaw, poland, august 2011. https://hal.inria.fr/hal-00790310. ð\n\n[2]k. mani chandy and jayadev misra. parallel program design: a foundation. addison-wesley, 1988. ð\n\n[3]edsger w. dijkstra. a discipline of programming. prentice hall, englewood cliffs, nj, 1976. ð\n\n[4]david gries and fred b. schneider. a logical approach to discrete math. texts and monographs in computer science. springer-verlag, 1994. ð\n\n[5]gary t. leavens, albert l. baker, and clyde ruby. jml: a notation for detailed design. in haim kilov, bernhard rumpe, and ian simmonds, editors, behavioral specifications of businesses and systems, pages 175â188. kluwer academic publishers, 1999. ð\n\n[6]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361â381. springer, 2016. ð\n\n----------------------------------------\n\n0.the emacs ide for dafny typesets certain dafny constructs in the notation you're more likely to see in a paper. by default, it shows forall x :: p as and shows exists x :: p as . â©\n\n1.internally, the dafny verifier works more effectively with certain quantifiers. the verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically [6]. for example, it may choose to un-nest some quantifiers. the goal of such rewrites is to support natural-looking programs while getting good prover performance. â©\n\n2.as it turns out, dafny's automatic induction will prove both fibproperty and fibpropertyall automatically. if these were the only lemmas we cared about, there would be nothing else to say or do. nevertheless, i'm using this example to show the forall statement. if you want to make sure what i'm about to say gives a proof, you can turn off automatic induction for fibpropertyall by marking it with the attribute {:induction false}. â©\n\n3.dafny can also prove an assertion like assert fib(12) == 144;. internally, dafny uses a âdual-rail encodingâ of functions that lets it obtain the value of fib(12) (since 12 is a literal constant) and fib(k) (where k is a variable). if you're interested in how this is done, i refer you to [0]. â©\n\n4.here is a proof of the assertion k <= fib(m) + fib(m+1). the âdifficult caseâ in our proof applies when k is at least 2, so k-1 is at least 1, so we know about fib(m) that it is at least 1. from this, it follows that m cannot be 0, for fib(0) == 0. this is important, because it means that m+1 is at least 2 and therefore the inductive case of the definition of fib applies. in other words, we have fib(m+1) == fib(m) + fib(m-1). we already concluded that fib(m) is at least 1. on behalf of fib returning a nat, we have that fib(m-1) is at least 0. so, fib(m+1) is at least 1. in other words, fib(m) + fib(m+1) is at least 1 more than fib(m), which in turn is at least k-1. thus, fib(m) + fib(m+1) is at least k.\n\nhad we split the âsimple caseâ and âdifficult caseâ up so that the âsimple caseâ only covered k == 0, then we could not have concluded m != 0 in the argument above. some users of other interactive proof assistants may be bothered by this, because they would say k has type nat and therefore the induction on k should use k == 0 as the base case. mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of everbigger into k < 2 and 2 <= k. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Different Styles of Proofs",frontmatter:{title:"Different Styles of Proofs",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/8d8607/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/20.Different%20Styles%20of%20Proofs.html",relativePath:"80.è¯­è¨/30.publication-lecture/20.Different Styles of Proofs.md",key:"v-111c7b94",path:"/pages/8d8607/",headers:[{level:2,title:"0.âA sample problem",slug:"_0-a-sample-problem",normalizedTitle:"0.âa sample problem",charIndex:477},{level:2,title:"1.âProof calculation",slug:"_1-proof-calculation",normalizedTitle:"1.âproof calculation",charIndex:2332},{level:2,title:"2.âDirection and line-type of calculations",slug:"_2-direction-and-line-type-of-calculations",normalizedTitle:"2.âdirection and line-type of calculations",charIndex:5528},{level:2,title:"3.âA minimal proof",slug:"_3-a-minimal-proof",normalizedTitle:"3.âa minimal proof",charIndex:8007},{level:2,title:"4.âStructured assertions",slug:"_4-structured-assertions",normalizedTitle:"4.âstructured assertions",charIndex:9243},{level:2,title:"5.âScopes",slug:"_5-scopes",normalizedTitle:"5.âscopes",charIndex:10129},{level:2,title:"6.âAssert by",slug:"_6-assert-by",normalizedTitle:"6.âassert by",charIndex:12174},{level:2,title:"7.âProof by explicit ancestors",slug:"_7-proof-by-explicit-ancestors",normalizedTitle:"7.âproof by explicit ancestors",charIndex:13321},{level:2,title:"8.âSummary",slug:"_8-summary",normalizedTitle:"8.âsummary",charIndex:17801},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:18782}],headersStr:"0.âA sample problem 1.âProof calculation 2.âDirection and line-type of calculations 3.âA minimal proof 4.âStructured assertions 5.âScopes 6.âAssert by 7.âProof by explicit ancestors 8.âSummary References",content:"Dafny Power User: Different Styles of Proofs\n\nK. Rustan M. Leino\n\nManuscript KRML 276, 9 March 2020\n\nAbstract. Just like there are different sentence structures for expressing various ideas in writing and speaking, there are different proof structures to express proofs. This note shows some variations that are possible in Dafny.\n\nLet's consider various styles of writing proofs. As a running example, I'll start by defining a function and some axioms about its behavior.\n\n\n# 0.âA sample problem\n\nConsider an integer function f with two arguments:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nSince I didn't provide a body for this function, Dafny treats it as an uninterpreted function. That means we don't know anything about it. Well, we do know it's a function, which means that its result value is determined entirely by its inputs. For example, we don't know which integer f(7, 3) evaluates to, but we know that if you call f again with those same arguments, you'll keep on getting the same value back.\n\nTo prove something about f, we'd like to know a little more of f's properties. Here are declarations of three lemmas that express such properties:\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nLike the function itself, these lemmas don't have bodies. It's the body of a lemma to justifies the postcondition of the lemma. In other words, the body is what gives the proof of the lemma. Since these lemmas don't have proofs, they are effectively axioms (that is, a claim you have to accept without proof).\n\nIf you run this function and these lemmas through the Dafny compiler, you'll get complaints that they don't have bodies. But for the purpose of this note, we don't care about getting executing code from the compiler. Our focus is on proofs, and the Dafny verifier has no objections about body-less declarations. As far as the verifier is concerned, a body-less declaration just says there is nothing to check.\n\nThe property we'll set out to prove, in various styles, is:\n\n> For any a, b, c, and x, if c <= x == f(a, b), then f(a, f(b, c)) <= x.\n\nThe proof of this property uses the three axioms from above.\n\n\n# 1.âProof calculation\n\nSometimes, one simple assert statement is enough of a hint for the Dafny verifier to complete a proof. Other times, what you need is a call to a lemma. When the situation isn't quite as simple as that, the most common way to write a proof in Dafny is a proof calculation [0, 3].\n\nA proof calculation is a chain of proof steps. Each step justifies one equality (e.g., A == B), inequality (e.g., A <= B), or logical consequence (e.g., A ==> B).\n\nA step is written vertically, to give some room to justify why the step holds. Here is a prototypical step:\n\n  A;\n==  // explain why A equals B\n  B;\n\n\n1\n2\n3\n\n\nAs this step illustrates, each formula in the chain is terminated with a semi-colon.\n\nIn the prototypical step above, I wrote the justification, also called the hint, as a comment. Such a comment is useful documentation. If the verifier cannot check your step without help, the hint needs to be more than a comment. Then, you write a block of code in curly braces, where the knowledge gained from that code is used by the verifier in proving the step. For example,\n\n  A;\n==  { LemmaThatJustifiesABEquality();  }\n  B;\n\n\n1\n2\n3\n\n\nIt's time to write our proof. Here it is:\n\nlemma CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nLet me read this proof calculation.\n\nThe first step says that, on account of associativity, the expression f(a, f(b, c)) equals f(f(a, b), c). Note that the hint calls the Associativity lemma with the particular parameters a, b, and c.\n\nThe second step says that f(f(a, b), c) is the same as f(x, c), because the antecedent (i.e., precondition) of the lemma we're proving says that x equals f(a, b). The verifier knows the equality x == f(a, b) from the precondition of the lemma we're proving, so the verifier does not need an explicit hint for this proof step. However, it can sometimes be nice to make such a statement in a machine-checked way, which you can do with an assert statement, like I showed here.\n\nThe third step proves f(x, c) <= f(x, x). The justification given for this step is that c <= x holds (it is given in the lemma precondition) and therefore it's okay to call the lemma Monotonicity (which requires c <= x as a precondition). The call to the Monotonicity(c, x) lemma gives us\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\nThe verifier figures out that instantiating this quantifier with x for w gives the inequality we're trying to prove in this step.\n\nThe fourth step proves f(x, x) to be equal to x. This property follows directly from axiom DiagonalIdentity, called with parameter x.\n\nOur four proof steps have justified the following four respective properties:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\nBy transitivity of == and <=, these four properties give us\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwhich is what we set out to prove.\n\n\n# 2.âDirection and line-type of calculations\n\nGenerally speaking, I find proof calculations to be convincing and easy to read. You can check each step separately, and you can see how the formula is âtransformedâ from line to line.\n\nMany times, but far from always, I also find proof calculations to be straightforward to author. In the example above, we start the calculation with the left-hand side of the formula\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwe're trying to prove. Then, we look at the current line of the proof to figure out what properties we know about that expression, and what transformation we can apply next. To get more guidance in this process, it is generally best to start with the more complicated side of the formula we're trying to prove. Case in point, if you start with\n\ncalc {\n  x;\n\n\n1\n2\n\n\nit is far from obvious that a good next step is\n\n==  { DiagonalIdentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\nWe could continue this proof, writing the steps from the previous section in reverse order and reversing the direction of the operator in each step (for example, changing <= to >=):\n\n>=  { assert c <= x; Monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nRegardless of which direction we go in, each line in the calculations I have shown so far have type int. It also also possible to write the proof with a boolean formula in each line. Here is one such example:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { DiagonalIdentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { Associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; Monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nBy transitivity of ==, this proof calculation shows that formula f(a, f(b, c)) <= x has the value true.\n\nIf you choose such boolean expressions for the lines of your proof calculation, the operator in each step often turns out to be logical implication (==>, that is, âlogical weakeningâ) or logical âexplicationâ (<==, âlogical strengtheningâ, or âfollows fromâ). Of course, you must choose one of those two directions, not use both, or else your proof calculation wouldn't make any sense. Of these directions, <== usually gives you a nicer starting point, because you'd start from the formula you're trying to prove and you'd end up with true. However, in my experience, I see that many beginners are confused by the <== direction and write calculations as if they were in in the ==> direction. Use whichever direction makes sense to you.\n\n\n# 3.âA minimal proof\n\nA proof calculation is a way to structure proof steps. It often contains more information than the verifier needs, especially if you, for your own benefit, write the proof in small steps. If you think a proof has too much detail, you can delete some of what is not needed. Whether or not that's a good ideaâor, when it is, how much to deleteâis mostly a matter of taste. If you come back to the proof later, the additional detail may provide useful documentation for how the proof was constructed in the first place.\n\nIf you were to reduce the hints in the proof calculations above, the first thing you'd probably do is delete the two assert statements that are part of the proofs, or at least the assertion c <= x. But you can do more.\n\nWith the above calculation in front of us, we can easily see which lemmas are used and, importantly, which values those lemmas are instantiated with. Once you know that, then you can leave off the proof calculation altogether. The whole proof would then look like this:\n\nlemma MinimalProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  Monotonicity(c, x);\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.âStructured assertions\n\nFor the purpose of this note, it is instructive to write the calculational proof without the calc statement. Here's what it would look like:\n\nlemma AssertProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  Associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; Monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  DiagonalIdentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nEach of these four groups of statements corresponds to one step in the calculation in Section 1. What was the hint in the calc statement precedes the assertion that concludes the equality or inequality that the step proves. The verifier then glues together the four conclusions to prove the postcondition of the lemma.\n\n\n# 5.âScopes\n\nThere is a difference between the calc statement in Section 1 and the broken-out assert statements in Section 4. The difference is that each hint in the calculation is local to the proof step. That is, the scope of a hint is just the step itself. For example, suppose you moved all the hints of the calc statement in Section 1 to the first proof step. Then, two of the proof steps would no longer verify:\n\ncalc {\n  f(a, f(b, c));\n==  { Associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; Monotonicity(c, x);\n      DiagonalIdentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThat is, the information gained from calling the three lemmas in the hint in the first step does not rub off on the other steps. In contrast, if you collected the hint at the start of the lemma body, the four equality and inequalities would verify fine:\n\n// hints\nAssociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; Monotonicity(c, x);\nDiagonalIdentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nYou can think of each step of a calc statement as being a little lemma in its own right, where the proof of that lemma is placed in the hint for that step. This makes a difference in writing your proof, not just because it tells the human reader that a certain hint applies to a particular proof step, but also because it limits where the verifier is able to apply a hint. For complicated proofs, this can make a big difference in practice, because the verifier can get âconfusedâ with too much informationâthis manifests itself in poor verifier performance or some âbutterfly effectâ [2].\n\nIn conclusion, it's good to compartmentalize hints in a proof. The calc statement is good at that, but you can also do it with a form of the assert statement. Let's look at that next.\n\n\n# 6.âAssert by\n\nThe statement assert E; says three things:\n\n 1. it declares that you expect condition E to hold\n 2. it asks the verifier to prove E\n 3. it lets what follows the assertion assume E\n\nYou may not have thought to separate these three aspects of an assertion, but it's useful to do that, because Dafny provides alternatives to (1) and (2).\n\nThe statement\n\nassert E by { Hint }\n\n\n1\n\n\nchanges aspect (1) to say that E is proved under the given hint, where Hint is a statement. The scope of the hint is just the assertion itself, so it is not available downstream of the assert. In this way, the assert by statement is equivalent to:\n\ncalc {\n  E;\n==  { Hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\nWe can rewrite the proof from Section 4 using assert by:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  Associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; Monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  DiagonalIdentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis provides better compartmentalization, and thus more directly expresses why each asserted condition holds.\n\n\n# 7.âProof by explicit ancestors\n\nThe proof in the Section 6 contains two assertions that restate what's written in the precondition. The idea behind those assertions is to make explicit where those preconditions are used. However, this has two shortcomings.\n\nOne shortcoming is that you have to compare the expression in the assertion with other expressions in the proof to realize that the assertion is just restating a previously available assumption. It would be nice if we could label the condition instead and then refer to the label.\n\nThe other shortcoming is that the preconditions are available regardless of if we restate the condition in an assertion. If we forget to write the assertion (perhaps because we don't realize that we're depending on this condition) or if we accidentally write the wrong precondition, then the proof still goes through. That is, the verifier is already able to use the precondition, so it doesn't care if you restate the condition, state a different (true) condition, or state nothing more. It would be nice if we could be more explicit about the scope of these assumptions.\n\nThere is one more form of the assert by statement. It relaxes aspect (2) from Section 6. This form looks like this:\n\nassert Label: E { Hint }\n\n\n1\n\n\nThis labeled assert statement says you expect condition E to hold and it offers statement Hint as a proof for E. The use of a label before the condition has the effect of suppressing the use of E as a downstream assumption.\n\nFor example, to prove f(12, 12) == 12 requires a use of axiom DiagonalIdentity. If you use a labeled assert by to prove this fact, then the proved fact is still not available after the labeled assert:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nWhy would you use such a statement if you can't use the fact you proved? Well, I should rather have said that the fact isn't automatically available after the labeled assertion. But you can explicitly request it. You do that with a reveal statement, in which you mention the label.\n\nHere is the example again, but with a reveal statement:\n\nassert Label: f(12, 12) == 12 by {\n  DiagonalIdentity(12);\n}\nreveal Label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nYou can play the same trick on preconditions. That is, usually in a lemma (or method or function), a precondition\n\nrequires E\n\n\n1\n\n\nis available throughout the body of the lemma. But if you label it, you have to use a reveal statement to bring out this assumption:\n\nrequires Label: E\n\n\n1\n\n\nBefore we see this in action, let me say something about labels. A label in Dafny can be any identifier, but it can also be something that, textually, looks like a numeric literal. Here are five example labels:\n\nMyLabel    Label57    L57    57    000_057\n\n\n1\n\n\nThese are five distinct labelsâthe fact that, as numerical literals, 57 and 000_057 represent the same number does not make them the same label. If they look different on the printed page, they are different labels. (This is also true for field names in classes, destructors of datatypes, and other type members, which also have the extended syntax of allowing literal-looking identifiers.)\n\nAlright, now we're ready to use labeled assertions in our running example:\n\nlemma DifferentStyleOfProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nIn this style of proof, which is common in some texts on logic, each assertion is explicitly justified by through its dependencies. If you think of the dependencies among assertions as forming a proof DAG, then this style of proof is being explicit about the ancestors in the DAG. You can use the hierarchical structuring of nested assert by statements and labeled assertions to approximate a Lamport-style proof [1].\n\n\n# 8.âSummary\n\nThere are different styles of writing proofs. The absolutely simplest proofs are the ones that are done automatically and don't have to be further justified. Other simple proofs require an assert statement or a call to a lemma. Proof steps can be organized using calc statements and assert by statements. By labeling an assert by statement or a precondition, the condtion is suppressed from the proof until you explicitly ask for it back using a reveal statement.\n\nStructuring proofs is a good idea, for readability and clarity, as well as for improved mechanical-prover performance. You can think of a proof statement as having some number of input conditions. These are the conditions and labels that are available in the context of the proof statement. The output of a proof statement is the transitive connection of the first and last lines of a calc statement, the condition in an unlabeled assert or assert by statement, and the label of a labeled assertion.\n\n\n# References\n\n[0]Edsger W. Dijkstra and W. H. J. Feijen. A Method of Programming. Addison-Wesley, July 1988. ð\n\n[1]Leslie Lamport. How to write a 21st century proof. Technical report, Microsoft Research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. ð\n\n[2]K. Rustan M. Leino and ClÃ©ment Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I, volume 9779 of Lecture Notes in Computer Science, pages 361â381. Springer, 2016. ð\n\n[3]K. Rustan M. Leino and Nadia Polikarpova. Verified calculations. In Ernie Cohen and Andrey Rybalchenko, editors, Verified Software: Theories, Tools, Experiments â 5th International Conference, VSTTE 2013, Revised Selected Papers, volume 8164 of Lecture Notes in Computer Science, pages 170â190. Springer, 2014. ð",normalizedContent:"dafny power user: different styles of proofs\n\nk. rustan m. leino\n\nmanuscript krml 276, 9 march 2020\n\nabstract. just like there are different sentence structures for expressing various ideas in writing and speaking, there are different proof structures to express proofs. this note shows some variations that are possible in dafny.\n\nlet's consider various styles of writing proofs. as a running example, i'll start by defining a function and some axioms about its behavior.\n\n\n# 0.âa sample problem\n\nconsider an integer function f with two arguments:\n\nfunction f(x: int, y: int): int\n\n\n1\n\n\nsince i didn't provide a body for this function, dafny treats it as an uninterpreted function. that means we don't know anything about it. well, we do know it's a function, which means that its result value is determined entirely by its inputs. for example, we don't know which integer f(7, 3) evaluates to, but we know that if you call f again with those same arguments, you'll keep on getting the same value back.\n\nto prove something about f, we'd like to know a little more of f's properties. here are declarations of three lemmas that express such properties:\n\nlemma associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall w :: f(w, y) <= f(w, z)\n\nlemma diagonalidentity(x: int)\n  ensures f(x, x) == x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nlike the function itself, these lemmas don't have bodies. it's the body of a lemma to justifies the postcondition of the lemma. in other words, the body is what gives the proof of the lemma. since these lemmas don't have proofs, they are effectively axioms (that is, a claim you have to accept without proof).\n\nif you run this function and these lemmas through the dafny compiler, you'll get complaints that they don't have bodies. but for the purpose of this note, we don't care about getting executing code from the compiler. our focus is on proofs, and the dafny verifier has no objections about body-less declarations. as far as the verifier is concerned, a body-less declaration just says there is nothing to check.\n\nthe property we'll set out to prove, in various styles, is:\n\n> for any a, b, c, and x, if c <= x == f(a, b), then f(a, f(b, c)) <= x.\n\nthe proof of this property uses the three axioms from above.\n\n\n# 1.âproof calculation\n\nsometimes, one simple assert statement is enough of a hint for the dafny verifier to complete a proof. other times, what you need is a call to a lemma. when the situation isn't quite as simple as that, the most common way to write a proof in dafny is a proof calculation [0, 3].\n\na proof calculation is a chain of proof steps. each step justifies one equality (e.g., a == b), inequality (e.g., a <= b), or logical consequence (e.g., a ==> b).\n\na step is written vertically, to give some room to justify why the step holds. here is a prototypical step:\n\n  a;\n==  // explain why a equals b\n  b;\n\n\n1\n2\n3\n\n\nas this step illustrates, each formula in the chain is terminated with a semi-colon.\n\nin the prototypical step above, i wrote the justification, also called the hint, as a comment. such a comment is useful documentation. if the verifier cannot check your step without help, the hint needs to be more than a comment. then, you write a block of code in curly braces, where the knowledge gained from that code is used by the verifier in proving the step. for example,\n\n  a;\n==  { lemmathatjustifiesabequality();  }\n  b;\n\n\n1\n2\n3\n\n\nit's time to write our proof. here it is:\n\nlemma calculationalstyleproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; monotonicity(c, x); }\n    f(x, x);\n  ==  { diagonalidentity(x); }\n    x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nlet me read this proof calculation.\n\nthe first step says that, on account of associativity, the expression f(a, f(b, c)) equals f(f(a, b), c). note that the hint calls the associativity lemma with the particular parameters a, b, and c.\n\nthe second step says that f(f(a, b), c) is the same as f(x, c), because the antecedent (i.e., precondition) of the lemma we're proving says that x equals f(a, b). the verifier knows the equality x == f(a, b) from the precondition of the lemma we're proving, so the verifier does not need an explicit hint for this proof step. however, it can sometimes be nice to make such a statement in a machine-checked way, which you can do with an assert statement, like i showed here.\n\nthe third step proves f(x, c) <= f(x, x). the justification given for this step is that c <= x holds (it is given in the lemma precondition) and therefore it's okay to call the lemma monotonicity (which requires c <= x as a precondition). the call to the monotonicity(c, x) lemma gives us\n\nforall w :: f(w, c) <= f(w, x)\n\n\n1\n\n\nthe verifier figures out that instantiating this quantifier with x for w gives the inequality we're trying to prove in this step.\n\nthe fourth step proves f(x, x) to be equal to x. this property follows directly from axiom diagonalidentity, called with parameter x.\n\nour four proof steps have justified the following four respective properties:\n\nf(a, f(b, c)) == f(f(a, b), c)\nf(f(a, b), c) == f(x, c)\nf(x, c) <= f(x, x)\nf(x, x) == x\n\n\n1\n2\n3\n4\n\n\nby transitivity of == and <=, these four properties give us\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwhich is what we set out to prove.\n\n\n# 2.âdirection and line-type of calculations\n\ngenerally speaking, i find proof calculations to be convincing and easy to read. you can check each step separately, and you can see how the formula is âtransformedâ from line to line.\n\nmany times, but far from always, i also find proof calculations to be straightforward to author. in the example above, we start the calculation with the left-hand side of the formula\n\nf(a, f(b, c)) <= x\n\n\n1\n\n\nwe're trying to prove. then, we look at the current line of the proof to figure out what properties we know about that expression, and what transformation we can apply next. to get more guidance in this process, it is generally best to start with the more complicated side of the formula we're trying to prove. case in point, if you start with\n\ncalc {\n  x;\n\n\n1\n2\n\n\nit is far from obvious that a good next step is\n\n==  { diagonalidentity(x); }\n  f(x, x);\n\n\n1\n2\n\n\nwe could continue this proof, writing the steps from the previous section in reverse order and reversing the direction of the operator in each step (for example, changing <= to >=):\n\n>=  { assert c <= x; monotonicity(c, x); }\n  f(x, c);\n\n\n1\n2\n\n\nregardless of which direction we go in, each line in the calculations i have shown so far have type int. it also also possible to write the proof with a boolean formula in each line. here is one such example:\n\ncalc {\n  f(a, f(b, c)) <= x;\n==  { diagonalidentity(x); }\n  f(a, f(b, c)) <= f(x, x);\n==  { associativity(a, b, c); }\n  f(f(a, b), c) <= f(x, x);\n==  { assert f(a, b) == x; }\n  f(x, c) <= f(x, x);\n==  { assert c <= x; monotonicity(c, x); }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nby transitivity of ==, this proof calculation shows that formula f(a, f(b, c)) <= x has the value true.\n\nif you choose such boolean expressions for the lines of your proof calculation, the operator in each step often turns out to be logical implication (==>, that is, âlogical weakeningâ) or logical âexplicationâ (<==, âlogical strengtheningâ, or âfollows fromâ). of course, you must choose one of those two directions, not use both, or else your proof calculation wouldn't make any sense. of these directions, <== usually gives you a nicer starting point, because you'd start from the formula you're trying to prove and you'd end up with true. however, in my experience, i see that many beginners are confused by the <== direction and write calculations as if they were in in the ==> direction. use whichever direction makes sense to you.\n\n\n# 3.âa minimal proof\n\na proof calculation is a way to structure proof steps. it often contains more information than the verifier needs, especially if you, for your own benefit, write the proof in small steps. if you think a proof has too much detail, you can delete some of what is not needed. whether or not that's a good ideaâor, when it is, how much to deleteâis mostly a matter of taste. if you come back to the proof later, the additional detail may provide useful documentation for how the proof was constructed in the first place.\n\nif you were to reduce the hints in the proof calculations above, the first thing you'd probably do is delete the two assert statements that are part of the proofs, or at least the assertion c <= x. but you can do more.\n\nwith the above calculation in front of us, we can easily see which lemmas are used and, importantly, which values those lemmas are instantiated with. once you know that, then you can leave off the proof calculation altogether. the whole proof would then look like this:\n\nlemma minimalproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  monotonicity(c, x);\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 4.âstructured assertions\n\nfor the purpose of this note, it is instructive to write the calculational proof without the calc statement. here's what it would look like:\n\nlemma assertproof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  associativity(a, b, c);\n  assert f(a, f(b, c)) == f(f(a, b), c);\n\n  assert f(a, b) == x;\n  assert f(f(a, b), c) == f(x, c);\n\n  assert c <= x; monotonicity(c, x);\n  assert f(x, c) <= f(x, x);\n\n  diagonalidentity(x);\n  assert f(x, x) == x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\neach of these four groups of statements corresponds to one step in the calculation in section 1. what was the hint in the calc statement precedes the assertion that concludes the equality or inequality that the step proves. the verifier then glues together the four conclusions to prove the postcondition of the lemma.\n\n\n# 5.âscopes\n\nthere is a difference between the calc statement in section 1 and the broken-out assert statements in section 4. the difference is that each hint in the calculation is local to the proof step. that is, the scope of a hint is just the step itself. for example, suppose you moved all the hints of the calc statement in section 1 to the first proof step. then, two of the proof steps would no longer verify:\n\ncalc {\n  f(a, f(b, c));\n==  { associativity(a, b, c);\n      assert f(a, b) == x;\n      assert c <= x; monotonicity(c, x);\n      diagonalidentity(x);\n    }\n  f(f(a, b), c);\n==\n  f(x, c);\n<=  // error: step not verified\n  f(x, x);\n==  // error: step not verified\n  x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthat is, the information gained from calling the three lemmas in the hint in the first step does not rub off on the other steps. in contrast, if you collected the hint at the start of the lemma body, the four equality and inequalities would verify fine:\n\n// hints\nassociativity(a, b, c);\nassert f(a, b) == x;\nassert c <= x; monotonicity(c, x);\ndiagonalidentity(x);\n// equalities and inequalities\nassert f(a, f(b, c)) == f(f(a, b), c);\nassert f(f(a, b), c) == f(x, c);\nassert f(x, c) <= f(x, x);\nassert f(x, x) == x;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nyou can think of each step of a calc statement as being a little lemma in its own right, where the proof of that lemma is placed in the hint for that step. this makes a difference in writing your proof, not just because it tells the human reader that a certain hint applies to a particular proof step, but also because it limits where the verifier is able to apply a hint. for complicated proofs, this can make a big difference in practice, because the verifier can get âconfusedâ with too much informationâthis manifests itself in poor verifier performance or some âbutterfly effectâ [2].\n\nin conclusion, it's good to compartmentalize hints in a proof. the calc statement is good at that, but you can also do it with a form of the assert statement. let's look at that next.\n\n\n# 6.âassert by\n\nthe statement assert e; says three things:\n\n 1. it declares that you expect condition e to hold\n 2. it asks the verifier to prove e\n 3. it lets what follows the assertion assume e\n\nyou may not have thought to separate these three aspects of an assertion, but it's useful to do that, because dafny provides alternatives to (1) and (2).\n\nthe statement\n\nassert e by { hint }\n\n\n1\n\n\nchanges aspect (1) to say that e is proved under the given hint, where hint is a statement. the scope of the hint is just the assertion itself, so it is not available downstream of the assert. in this way, the assert by statement is equivalent to:\n\ncalc {\n  e;\n==  { hint }\n  true;\n}\n\n\n1\n2\n3\n4\n5\n\n\nwe can rewrite the proof from section 4 using assert by:\n\nassert f(a, f(b, c)) == f(f(a, b), c) by {\n  associativity(a, b, c);\n}\nassert f(f(a, b), c) == f(x, c) by {\n  assert f(a, b) == x;\n}\nassert f(x, c) <= f(x, x) by {\n  assert c <= x; monotonicity(c, x);\n}\nassert f(x, x) == x by {\n  diagonalidentity(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nthis provides better compartmentalization, and thus more directly expresses why each asserted condition holds.\n\n\n# 7.âproof by explicit ancestors\n\nthe proof in the section 6 contains two assertions that restate what's written in the precondition. the idea behind those assertions is to make explicit where those preconditions are used. however, this has two shortcomings.\n\none shortcoming is that you have to compare the expression in the assertion with other expressions in the proof to realize that the assertion is just restating a previously available assumption. it would be nice if we could label the condition instead and then refer to the label.\n\nthe other shortcoming is that the preconditions are available regardless of if we restate the condition in an assertion. if we forget to write the assertion (perhaps because we don't realize that we're depending on this condition) or if we accidentally write the wrong precondition, then the proof still goes through. that is, the verifier is already able to use the precondition, so it doesn't care if you restate the condition, state a different (true) condition, or state nothing more. it would be nice if we could be more explicit about the scope of these assumptions.\n\nthere is one more form of the assert by statement. it relaxes aspect (2) from section 6. this form looks like this:\n\nassert label: e { hint }\n\n\n1\n\n\nthis labeled assert statement says you expect condition e to hold and it offers statement hint as a proof for e. the use of a label before the condition has the effect of suppressing the use of e as a downstream assumption.\n\nfor example, to prove f(12, 12) == 12 requires a use of axiom diagonalidentity. if you use a labeled assert by to prove this fact, then the proved fact is still not available after the labeled assert:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nassert f(12, 12) == 12;  // error: assertion not verified\n\n\n1\n2\n3\n4\n\n\nwhy would you use such a statement if you can't use the fact you proved? well, i should rather have said that the fact isn't automatically available after the labeled assertion. but you can explicitly request it. you do that with a reveal statement, in which you mention the label.\n\nhere is the example again, but with a reveal statement:\n\nassert label: f(12, 12) == 12 by {\n  diagonalidentity(12);\n}\nreveal label;  // this recalls the condition from the prior assertion\nassert f(12, 12) == 12;\n\n\n1\n2\n3\n4\n5\n\n\nyou can play the same trick on preconditions. that is, usually in a lemma (or method or function), a precondition\n\nrequires e\n\n\n1\n\n\nis available throughout the body of the lemma. but if you label it, you have to use a reveal statement to bring out this assumption:\n\nrequires label: e\n\n\n1\n\n\nbefore we see this in action, let me say something about labels. a label in dafny can be any identifier, but it can also be something that, textually, looks like a numeric literal. here are five example labels:\n\nmylabel    label57    l57    57    000_057\n\n\n1\n\n\nthese are five distinct labelsâthe fact that, as numerical literals, 57 and 000_057 represent the same number does not make them the same label. if they look different on the printed page, they are different labels. (this is also true for field names in classes, destructors of datatypes, and other type members, which also have the extended syntax of allowing literal-looking identifiers.)\n\nalright, now we're ready to use labeled assertions in our running example:\n\nlemma differentstyleofproof(a: int, b: int, c: int, x: int)\n  requires a: c <= x\n  requires b: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal b;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal a; }\n    monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    diagonalidentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nin this style of proof, which is common in some texts on logic, each assertion is explicitly justified by through its dependencies. if you think of the dependencies among assertions as forming a proof dag, then this style of proof is being explicit about the ancestors in the dag. you can use the hierarchical structuring of nested assert by statements and labeled assertions to approximate a lamport-style proof [1].\n\n\n# 8.âsummary\n\nthere are different styles of writing proofs. the absolutely simplest proofs are the ones that are done automatically and don't have to be further justified. other simple proofs require an assert statement or a call to a lemma. proof steps can be organized using calc statements and assert by statements. by labeling an assert by statement or a precondition, the condtion is suppressed from the proof until you explicitly ask for it back using a reveal statement.\n\nstructuring proofs is a good idea, for readability and clarity, as well as for improved mechanical-prover performance. you can think of a proof statement as having some number of input conditions. these are the conditions and labels that are available in the context of the proof statement. the output of a proof statement is the transitive connection of the first and last lines of a calc statement, the condition in an unlabeled assert or assert by statement, and the label of a labeled assertion.\n\n\n# references\n\n[0]edsger w. dijkstra and w. h. j. feijen. a method of programming. addison-wesley, july 1988. ð\n\n[1]leslie lamport. how to write a 21st century proof. technical report, microsoft research, 2011. https://lamport.azurewebsites.net/pubs/proof.pdf. ð\n\n[2]k. rustan m. leino and clement pit-claudel. trigger selection strategies to stabilize program verifiers. in swarat chaudhuri and azadeh farzan, editors, computer aided verification - 28th international conference, cav 2016, proceedings, part i, volume 9779 of lecture notes in computer science, pages 361â381. springer, 2016. ð\n\n[3]k. rustan m. leino and nadia polikarpova. verified calculations. in ernie cohen and andrey rybalchenko, editors, verified software: theories, tools, experiments â 5th international conference, vstte 2013, revised selected papers, volume 8164 of lecture notes in computer science, pages 170â190. springer, 2014. ð",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Functions over Set Elements",frontmatter:{title:"Functions over Set Elements",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/097ba0/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/30.Functions%20over%20Set%20Elements.html",relativePath:"80.è¯­è¨/30.publication-lecture/30.Functions over Set Elements.md",key:"v-57bcc112",path:"/pages/097ba0/",headers:[{level:2,title:"0.âSumming the elements of a set",slug:"_0-summing-the-elements-of-a-set",normalizedTitle:"0.âsumming the elements of a set",charIndex:583},{level:2,title:"1.âRecursive definition of Sum",slug:"_1-recursive-definition-of-sum",normalizedTitle:"1.ârecursive definition of sum",charIndex:1163},{level:2,title:"2.âThe proof that fails",slug:"_2-the-proof-that-fails",normalizedTitle:"2.âthe proof that fails",charIndex:1868},{level:2,title:"3.âPicking something else",slug:"_3-picking-something-else",normalizedTitle:"3.âpicking something else",charIndex:2638},{level:2,title:"4.âInlining Pick",slug:"_4-inlining-pick",normalizedTitle:"4.âinlining pick",charIndex:4243},{level:2,title:"5.âLet such that",slug:"_5-let-such-that",normalizedTitle:"5.âlet such that",charIndex:5436},{level:2,title:"6.âDifferent choices",slug:"_6-different-choices",normalizedTitle:"6.âdifferent choices",charIndex:8483},{level:2,title:"7.âSummary",slug:"_7-summary",normalizedTitle:"7.âsummary",charIndex:9935}],headersStr:"0.âSumming the elements of a set 1.âRecursive definition of Sum 2.âThe proof that fails 3.âPicking something else 4.âInlining Pick 5.âLet such that 6.âDifferent choices 7.âSummary",content:"Dafny Power User: Functions over Set Elements\n\nK. Rustan M. Leino\n\nManuscript KRML 274, 16 February 2020\n\nAbstract. In natural language, it is easy to say and understand a phrase like âthe sum of the numbers in a setâ. Defining and working with such functions in a formal settings is more work. The problem has to do with how a recursively defined function picks the next element from a set. This note describes a representative example and describes how to make the formal mumbo-jumbo work out. The solution can be applied to any commutative and associative operation on a set.\n\n\n# 0.âSumming the elements of a set\n\nSuppose we have a function that returns the sum of the integers in a set:\n\nfunction Sum(s: set<int>): int\n\n\n1\n\n\nIf we add an element y to a set, we expect its sum to go up by y. That is, we expect that the following method is correctly implemented:\n\nmethod AddElement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == Sum(s) && y !in s\n  ensures t == s + {x} && b == Sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nIt turns out, the proof is not automatic. Let's look at the details and fill in the proof.\n\n\n# 1.âRecursive definition of Sum\n\nFunction Sum is defined recursively. The sum of the empty set is 0. If the set is nonempty, pick one of its elements, say x. Then, add x to the recursively computed sum of the remaining elements.\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nThis definition uses a function Pick, which returns an arbitrary element from a given set. Here is its definition:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nI'll come back to Pick later. All you need to understand at this time is that the caller of Pick has no control over which element of s is returned.\n\n\n# 2.âThe proof that fails\n\nTo prove AddElement, we need to show b == Sum(t) holds in its final state. Working backwards over the assignments, this means we need to show\n\na + y == Sum(s + {y})\n\n\n1\n\n\nin the initial state. Since a is Sum(s), our proof obligation comes down to\n\nSum(s) + y == Sum(s + {y})\n\n\n1\n\n\nwhere we are given that y is not in s.\n\nSuppose Pick(s + {y}) returns y. Then, we have\n\n  Sum(s + {y});\n==  // def. Sum\n  var x := Pick(s + {y}); x + Sum(s + {y} - {x});\n==  // using the assumption Pick(s + {y}) == y\n  y + Sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + Sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThat was easy and straightforward. But for this proof, we assumed that the relevant call to Pick returned y. What if Pick returns a different element from s?\n\n\n# 3.âPicking something else\n\nBefore you realize Pick can choose a different element than the one you have in mind, the clouds start to clear. What we need is a lemma that says the choice is immaterial. That is, the lemma will let us treat Sum as if it picks, when doing its recursive call, an element that we specify.\n\nHere is that lemma. The proof is also a little tricky at first. It comes down to letting Pick choose whatever element it chooses, and then applying the induction hypothesis on the smaller set that Sum recurses on.\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x := Pick(s);\n  if y == x {\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nI stated the lemma to look like the expressions in the body of Sum, so the two arguments to Sum are s and s - {y}. Alternatively, we can state the property in terms of calls to Sum with the arguments s + {y} and s. This alternative is a simple corollary of the lemma above:\n\nlemma AddToSum(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  SumMyWay(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nUsing the lemma\n\nEquipped with the useful lemma, it's easy to get the proof of AddElement go through: change its body to\n\nt := s + {y};\nb := a + y;\nAddToSum(s, y);\n\n\n1\n2\n3\n\n\n\n# 4.âInlining Pick\n\nIn the development above, I define Pick as a separate function. Reading the word âpickâ in the program text may help understand what Sum and SumMyWay do. But it's such a small function, so why not just inline it in the two places where it's used. Let's try it:\n\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to Pick\n    x + Sum(s - {x})\n}\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to Pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      Sum(s);\n    ==  // def. Sum        // error: this step might not hold\n      x + Sum(s - {x});\n    ==  { SumMyWay(s - {x}, y); }\n      x + y + Sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + Sum(s - {y} - {x});\n    ==  { SumMyWay(s - {y}, x); }\n      y + Sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nWe now get two errors!\n\nTo explain what's going on, let me say a little more about :| and what makes it unusual.\n\n\n# 5.âLet such that\n\nThe let-such-that construct in Dafny has the form\n\nvar x :| P; E\n\n\n1\n\n\nIt evaluates to E, where x is bound to some value satisfying P. For example,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nevaluates to 14, 16, or 18. As the programmer, you have no control over which value of x is chosen. But you do get to know two important things. One is that x will be chosen to be a value that satisfies P. (The Dafny verifier gives an error if it cannot prove such a value to exist.) The other is that you will get the same value every time you evaluate the expression with the same inputs. In other words, the operator is deterministic.\n\nHere is another example to illustrate the point about determinism:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nThis expression chooses x to be one of the three smallest primes (2, 3, or 5) and then returns it. You don't know which of the three values you get, but you are guaranteed that every time this expression is evaluated within one run of a program, you will get the same value.\n\nLet's be more precise about what I mean by âthis expressionâ. In Dafny, every textual occurrence of a let-such-that expression gets to make its own choices. One way to think about this is to go through the text of your program and to color each :| operator with a unique color. Then, you can rely on choices being the same only if they are performed by the same-color :|.\n\nHere is an illustrative example.\n\nlemma Choices(s: set<int>)\n  requires s != {}\n{\n  var a := Pick(s);\n  var b := Pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe first values assigned to a and b originate from the same :| operator. They are the results of choices of the same color. Therefore, they are known to be the same. In contrast, the next values assigned to a and b originate from different :| operatorsâones of different colors. Therefore, you cannot be sure a and b are equal.\n\nActually, if you think about it a little more (or, maybe, a little less), then you realize that we know the first values assigned to a and b to be equal even without knowing anything about the body of Pick. After all, Pick is a function, and if you call a function twice on the same arguments, it will give you back the same value. Mathematics guarantees this, and so does Dafny. So, then what about the second assignments to a and b; aren't the :| operators in those expressions also functions? Yes, they are, but they are different functions. They are functions of different colors, to follow that analogy. As long as you think of every occurrence of :| in your program as being a different function, then all mathematics work out as you'd expect.\n\nThis is why it was easier for me to describe the Sum situation if I could use just one :|. To reuse that same :|, I placed it in a function, which I named Pick. I recommend you do the same if you're working with ghost functions that involve choices that you want to prove properties about.\n\n\n# 6.âDifferent choices\n\nIf you tried to define Sum and use it in AddElement before understanding these issues, you would be perplexed. Now, you know that it is easier to put :| into a function by itself, and you know that you'll need to write a lemma like SumMyWay. You may be curious if it's possible to do without the Pick function. That is, you may wonder if there's any way to use one :| operator in Sum and another :| operator in SumMyWay. Yes, it is possible. Let me show you how.\n\nSuppose we inline Pick in function Sum. That is, suppose we define Sum as in Section 4 above. In that section, I mentioned that you'll get a couple of errors if you also inline Pick in SumMyWay. Both of those errors stem from the fact that Sum and SumMyWay make different choices. But we can be more specific in the lemma, to force it to choose the same element as the one chosen in Sum.\n\nYou can do that by saying you want x not just to be in s, but to be a value that makes\n\nSum(s) == x + Sum(s - {x})\n\n\n1\n\n\nhold true. Only one such x exists, and it's the one that Sum chooses. So, if you write lemma as follows:\n\nlemma SumMyWay(s: set<int>, y: int)\n  requires y in s\n  ensures Sum(s) == y + Sum(s - {y})\n{\n  var x :| x in s && Sum(s) == x + Sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthen it verifies! This is good to know, but it seems cleaner to introduce the function Pick around your :|.\n\n\n# 7.âSummary\n\nBeware that every textual occurrence of :| in your program is a different function. You'll have a simpler time working with :| if you roll it into a function that you name, because then you reduce the chance of becoming confused because of different kinds (different âcolorsâ) of choices.\n\nAlso, beware that the choice made by :| may not be the choice you need. You'll probably want to prove a lemma that says any choice gives the same result in the end. Use lemma SumMyWay above as a template for your proof.",normalizedContent:"dafny power user: functions over set elements\n\nk. rustan m. leino\n\nmanuscript krml 274, 16 february 2020\n\nabstract. in natural language, it is easy to say and understand a phrase like âthe sum of the numbers in a setâ. defining and working with such functions in a formal settings is more work. the problem has to do with how a recursively defined function picks the next element from a set. this note describes a representative example and describes how to make the formal mumbo-jumbo work out. the solution can be applied to any commutative and associative operation on a set.\n\n\n# 0.âsumming the elements of a set\n\nsuppose we have a function that returns the sum of the integers in a set:\n\nfunction sum(s: set<int>): int\n\n\n1\n\n\nif we add an element y to a set, we expect its sum to go up by y. that is, we expect that the following method is correctly implemented:\n\nmethod addelement(s: set<int>, a: int, y: int) returns (t: set<int>, b: int)\n  requires a == sum(s) && y !in s\n  ensures t == s + {x} && b == sum(t)\n{\n  t := s + {y};\n  b := a + y;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nit turns out, the proof is not automatic. let's look at the details and fill in the proof.\n\n\n# 1.ârecursive definition of sum\n\nfunction sum is defined recursively. the sum of the empty set is 0. if the set is nonempty, pick one of its elements, say x. then, add x to the recursively computed sum of the remaining elements.\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := pick(s);\n    x + sum(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n\n\nthis definition uses a function pick, which returns an arbitrary element from a given set. here is its definition:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\ni'll come back to pick later. all you need to understand at this time is that the caller of pick has no control over which element of s is returned.\n\n\n# 2.âthe proof that fails\n\nto prove addelement, we need to show b == sum(t) holds in its final state. working backwards over the assignments, this means we need to show\n\na + y == sum(s + {y})\n\n\n1\n\n\nin the initial state. since a is sum(s), our proof obligation comes down to\n\nsum(s) + y == sum(s + {y})\n\n\n1\n\n\nwhere we are given that y is not in s.\n\nsuppose pick(s + {y}) returns y. then, we have\n\n  sum(s + {y});\n==  // def. sum\n  var x := pick(s + {y}); x + sum(s + {y} - {x});\n==  // using the assumption pick(s + {y}) == y\n  y + sum(s + {y} - {y});\n==  // sets, since y !in s\n  y + sum(s);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthat was easy and straightforward. but for this proof, we assumed that the relevant call to pick returned y. what if pick returns a different element from s?\n\n\n# 3.âpicking something else\n\nbefore you realize pick can choose a different element than the one you have in mind, the clouds start to clear. what we need is a lemma that says the choice is immaterial. that is, the lemma will let us treat sum as if it picks, when doing its recursive call, an element that we specify.\n\nhere is that lemma. the proof is also a little tricky at first. it comes down to letting pick choose whatever element it chooses, and then applying the induction hypothesis on the smaller set that sum recurses on.\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x := pick(s);\n  if y == x {\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\ni stated the lemma to look like the expressions in the body of sum, so the two arguments to sum are s and s - {y}. alternatively, we can state the property in terms of calls to sum with the arguments s + {y} and s. this alternative is a simple corollary of the lemma above:\n\nlemma addtosum(s: set<int>, y: int)\n  requires y !in s\n  ensures sum(s + {y}) == sum(s) + y\n{\n  summyway(s + {y}, y);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nusing the lemma\n\nequipped with the useful lemma, it's easy to get the proof of addelement go through: change its body to\n\nt := s + {y};\nb := a + y;\naddtosum(s, y);\n\n\n1\n2\n3\n\n\n\n# 4.âinlining pick\n\nin the development above, i define pick as a separate function. reading the word âpickâ in the program text may help understand what sum and summyway do. but it's such a small function, so why not just inline it in the two places where it's used. let's try it:\n\nfunction sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x :| x in s;  // this line takes the place of a call to pick\n    x + sum(s - {x})\n}\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s;  // this line takes the place of a call to pick\n  if y == x {  // error: postcondition might not hold on this path\n  } else {\n    calc {\n      sum(s);\n    ==  // def. sum        // error: this step might not hold\n      x + sum(s - {x});\n    ==  { summyway(s - {x}, y); }\n      x + y + sum(s - {x} - {y});\n    ==  { assert s - {x} - {y} == s - {y} - {x}; }\n      y + x + sum(s - {y} - {x});\n    ==  { summyway(s - {y}, x); }\n      y + sum(s - {y});\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nwe now get two errors!\n\nto explain what's going on, let me say a little more about :| and what makes it unusual.\n\n\n# 5.âlet such that\n\nthe let-such-that construct in dafny has the form\n\nvar x :| p; e\n\n\n1\n\n\nit evaluates to e, where x is bound to some value satisfying p. for example,\n\nvar x :| 7 <= x < 10; 2 * x\n\n\n1\n\n\nevaluates to 14, 16, or 18. as the programmer, you have no control over which value of x is chosen. but you do get to know two important things. one is that x will be chosen to be a value that satisfies p. (the dafny verifier gives an error if it cannot prove such a value to exist.) the other is that you will get the same value every time you evaluate the expression with the same inputs. in other words, the operator is deterministic.\n\nhere is another example to illustrate the point about determinism:\n\nvar x :| x in {2, 3, 5}; x\n\n\n1\n\n\nthis expression chooses x to be one of the three smallest primes (2, 3, or 5) and then returns it. you don't know which of the three values you get, but you are guaranteed that every time this expression is evaluated within one run of a program, you will get the same value.\n\nlet's be more precise about what i mean by âthis expressionâ. in dafny, every textual occurrence of a let-such-that expression gets to make its own choices. one way to think about this is to go through the text of your program and to color each :| operator with a unique color. then, you can rely on choices being the same only if they are performed by the same-color :|.\n\nhere is an illustrative example.\n\nlemma choices(s: set<int>)\n  requires s != {}\n{\n  var a := pick(s);\n  var b := pick(s);\n  assert a == b;  // this is provable\n  a := var x :| x in s; x;\n  b := var x :| x in s; x;\n  assert a == b;  // error: not provable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe first values assigned to a and b originate from the same :| operator. they are the results of choices of the same color. therefore, they are known to be the same. in contrast, the next values assigned to a and b originate from different :| operatorsâones of different colors. therefore, you cannot be sure a and b are equal.\n\nactually, if you think about it a little more (or, maybe, a little less), then you realize that we know the first values assigned to a and b to be equal even without knowing anything about the body of pick. after all, pick is a function, and if you call a function twice on the same arguments, it will give you back the same value. mathematics guarantees this, and so does dafny. so, then what about the second assignments to a and b; aren't the :| operators in those expressions also functions? yes, they are, but they are different functions. they are functions of different colors, to follow that analogy. as long as you think of every occurrence of :| in your program as being a different function, then all mathematics work out as you'd expect.\n\nthis is why it was easier for me to describe the sum situation if i could use just one :|. to reuse that same :|, i placed it in a function, which i named pick. i recommend you do the same if you're working with ghost functions that involve choices that you want to prove properties about.\n\n\n# 6.âdifferent choices\n\nif you tried to define sum and use it in addelement before understanding these issues, you would be perplexed. now, you know that it is easier to put :| into a function by itself, and you know that you'll need to write a lemma like summyway. you may be curious if it's possible to do without the pick function. that is, you may wonder if there's any way to use one :| operator in sum and another :| operator in summyway. yes, it is possible. let me show you how.\n\nsuppose we inline pick in function sum. that is, suppose we define sum as in section 4 above. in that section, i mentioned that you'll get a couple of errors if you also inline pick in summyway. both of those errors stem from the fact that sum and summyway make different choices. but we can be more specific in the lemma, to force it to choose the same element as the one chosen in sum.\n\nyou can do that by saying you want x not just to be in s, but to be a value that makes\n\nsum(s) == x + sum(s - {x})\n\n\n1\n\n\nhold true. only one such x exists, and it's the one that sum chooses. so, if you write lemma as follows:\n\nlemma summyway(s: set<int>, y: int)\n  requires y in s\n  ensures sum(s) == y + sum(s - {y})\n{\n  var x :| x in s && sum(s) == x + sum(s - {x});\n  if y == x {\n  } else {\n    // same calc statement as before...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthen it verifies! this is good to know, but it seems cleaner to introduce the function pick around your :|.\n\n\n# 7.âsummary\n\nbeware that every textual occurrence of :| in your program is a different function. you'll have a simpler time working with :| if you roll it into a function that you name, because then you reduce the chance of becoming confused because of different kinds (different âcolorsâ) of choices.\n\nalso, beware that the choice made by :| may not be the choice you need. you'll probably want to prove a lemma that says any choice gives the same result in the end. use lemma summyway above as a template for your proof.",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Iterating over a Collection",frontmatter:{title:"Iterating over a Collection",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c4484e/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/35.Iterating%20over%20a%20Collection.html",relativePath:"80.è¯­è¨/30.publication-lecture/35.Iterating over a Collection.md",key:"v-6754fb32",path:"/pages/c4484e/",headers:[{level:2,title:"0.âMap to sequence",slug:"_0-map-to-sequence",normalizedTitle:"0.âmap to sequence",charIndex:830},{level:2,title:"1.âA ghost function",slug:"_1-a-ghost-function",normalizedTitle:"1.âa ghost function",charIndex:2422},{level:2,title:"2.âMaking the function compilable",slug:"_2-making-the-function-compilable",normalizedTitle:"2.âmaking the function compilable",charIndex:2944},{level:2,title:"3.âChoosing the smallest integer",slug:"_3-choosing-the-smallest-integer",normalizedTitle:"3.âchoosing the smallest integer",charIndex:3844},{level:2,title:"4.âProving there's a minimum",slug:"_4-proving-there-s-a-minimum",normalizedTitle:"4.âproving there's a minimum",charIndex:5155},{level:2,title:"5.âTotal orders",slug:"_5-total-orders",normalizedTitle:"5.âtotal orders",charIndex:7175},{level:2,title:"6.âGeneric set to sequence",slug:"_6-generic-set-to-sequence",normalizedTitle:"6.âgeneric set to sequence",charIndex:9034},{level:2,title:"7.âTotal order has minimum",slug:"_7-total-order-has-minimum",normalizedTitle:"7.âtotal order has minimum",charIndex:9899},{level:2,title:"8.âComing back to map to sequence",slug:"_8-coming-back-to-map-to-sequence",normalizedTitle:"8.âcoming back to map to sequence",charIndex:13500},{level:2,title:"9.âConclusion",slug:"_9-conclusion",normalizedTitle:"9.âconclusion",charIndex:14195},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:14306}],headersStr:"0.âMap to sequence 1.âA ghost function 2.âMaking the function compilable 3.âChoosing the smallest integer 4.âProving there's a minimum 5.âTotal orders 6.âGeneric set to sequence 7.âTotal order has minimum 8.âComing back to map to sequence 9.âConclusion References",content:"Dafny Power User: Iterating over a Collection\n\nK. Rustan M. Leino\n\nManuscript KRML 275, 17 February 2020\n\nAbstract. Processing the contents of a set or map in a deterministic way takes some work. Using a representative example, this note shows a way to do it.\n\nMathematical collection types include sets, multisets, sequences, and maps. These are essential to specifications as well as programs. Defining functions over the elements of such collections is more difficult (or at least more labor intensive) than one would expect. In this note, I develop the program and proof for an example that converts a map to a sequence of pairs. The central part of the work concerns getting a compilable function that returns a set's elements into a predictable order.\n\nThroughout this note, the goal is to produce compilable functions.\n\n\n# 0.âMap to sequence\n\nA map is set of key-value pairs, where no key is repeated. We can convert a map to a sequence by putting its keys into a sequence and then making pairs by retrieving the value for each key:\n\nfunction method MapToSequence<A,B>(m: map<A,B>): seq<(A,B)> {\n  var keys := SetToSequence(m.Keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor a map m, the expression m.Keys gives the set of keys. Function MapToSequence passes this set of keys to SetToSequence to obtain a sequence of these keys. Then, the sequence constructor\n\nseq(n, f)\n\n\n1\n\n\nproduces a sequence of length n, where the element with index i is specified to be f(i). In MapToSequence, the second argument to the sequence comprehension is a partial function given by the lambda expression\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nFor an index in the given range, this function returns a pair consisting of the key keys[i] and its corresponding value in m. It is necessary to give the range of i in the function's precondition, or else the expression keys[i] would give rise to an index-of-out-bounds error.\n\nTo avoid a key-is-not-in-map error in the expression m[keys[i]], we need to know that keys[i] is a key of m. That requires us to know a connection between m.Keys and keys, which is stated in the postcondition of the (not yet implemented) function SetToSequence.\n\nWe now need to implement SetToSequence.\n\n\n# 1.âA ghost function\n\nLet's start easy. We'll define SetToSequence as a ghost function. The definition is recursive. When the given set is nonempty, the function uses the choose operator, aka the let-such-that operator and written :|, to pick an element from the set.\n\nfunction SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThat wasn't too bad.\n\n\n# 2.âMaking the function compilable\n\nTo make the SetToSequence we wrote above compilable, we change the keyword function to the keyword phrase function method. This generates an error message:\n\n> to be compilable, the value of a let-such-that expression must be uniquely determined\n\nExpressionsâand functions, whose bodies are expressionsâmust be deterministic in Dafny. This means that\n\nvar x :| x in s;\n\n\n1\n\n\nalways needs to pick the same value for x when given the same s. This would be computationally expensive to do at run time, so Dafny instead puts this burden on the programmer (see [0]).\n\nOne idea is for us to strengthen the condition x in s to always pick âthe minimumâ value from s. This would uniquely determine the value of the let-such-that expression. But what does âminimumâ mean? Let's start with integers, where we know what minimum is, and then work up to a general situation.\n\n\n# 3.âChoosing the smallest integer\n\nFor now, we'll restrict our attention to integer sets. This lets us strengthen the condition in the let-such-that expression to uniquely talk about the minimum element of the set:\n\nfunction method SetToSequence(s: set<int>): seq<int>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + SetToSequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nThe âuniquely determinedâ requirement is now satisfied. However, since our new such-that predicate is more complicated, the verifier issues a different complaint:\n\n> cannot establish the existence of a LHS value that satisfies the such-that predicate\n\nIt may seem clear to us that a nonempty set has a minimum element, but we need to convince the verifier of it. Let's do this in a separate lemma, which we declare as follows:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\nWe'll insert a call to this lemma just before the let-such-expression in SetToSequence. The body of that function thus becomes\n\nif s == {} then [] else\n  ThereIsAMinimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + SetToSequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4.âProving there's a minimum\n\nOur next task is to give a proof for the ThereIsAMinimum lemma. Here is an annotated proof:\n\nlemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // The minimum in s might be x, or it might be the minimum\n    // in s - {x}. If we knew the minimum of the latter, then\n    // we could compare the two.\n    // Let's start by giving a name to the smaller set:\n    var s' := s - {x};\n    // So, s is the union of s' and {x}:\n    assert s == s' + {x};\n    // The following lemma call establishes that there is a\n    // minimum in s'.\n    ThereIsAMinimum(s');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThe proof starts by picking an arbitrary element, x, from s. It is the minimum if it's the only element in s. Otherwise, the proof brings out the fact that s is s' + {x}. The recursive call to the lemma gives us, through its postcondition, that there exists a minimum element in s'. The verifier automatically supplies the remaining proof glue, so we're done.\n\nThe assertion in the proof may seem silly. We just defined s' to be s - {x}. Since x is in s, the property s == s' + {x} follows immediately. Yes, it does. The verifier can easily confirm this, but verifier is not creative enough to realize that this is a good property to know. This is typical when working with collections. For example, if you're working with a sequence q, you may consider q[0] separately and do a recursive call on q[1..]. If so, you're likely to need to manually supply\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nAs with the set property, the verifier easily proves this property, but wouldn't have thought of it by itself.\n\nThe moral of the proof is that it's a good idea, when you split a collection into smaller pieces that you want to reason about separately, to assert that the whole collection equals the combination of the smaller pieces.\n\n\n# 5.âTotal orders\n\nThe restriction to integer sets above was nice to work with, because the minimum of a set of integers is easy to define and gives a unique element. To apply the same trick other types, we need to be able to define a âminimumâ for those types, too. To define a minimum, you need a total order. Let's review what that means.\n\nA relation over a type A is a function (A, A) -> bool. Such a relation, call it R, is known as a partial order when the following three conditions hold:\n\n * R is reflexive, that is, forall a :: R(a, a)\n * R is antisymmetric, that is, forall a, b :: R(a, b) && R(b, a) ==> a == b\n * R is transitive, that is, forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c)\n\nA total order is a partial order that additionally satisfies the following condition:\n\n * R is connex (closely connected), that is, forall a, b :: R(a, b) || R(b, a)\n\nNote that connexity implies reflexivity.\n\nHere is a predicate that says whether or not a given relation is a total order:\n\npredicate IsTotalOrder<A(!new)>(R: (A, A) -> bool) {\n  // connexity\n  && (forall a, b :: R(a, b) || R(b, a))\n  // antisymmetry\n  && (forall a, b :: R(a, b) && R(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nDafny won't allow us to write these quantifiers in the predicate, unless it knows a little more about type A. If A were a class type, then forall in Dafny means quantifying over the allocated instances of class A. That would mean that allocating another A instance could cause IsTotalOrder(R) to change values. To prevent this, Dafny insists that unbounded quantifications like those in IsTotalOrder be over types that do not depend on the allocated state. We express that with the type characteristic (!new), which is written as a suffix of the type name in the type-parameter declaration.\n\n\n# 6.âGeneric set to sequence\n\nWe revise SetToSequence to also take a relation, R, which we require to be a total order. In doing so, we change the total order <= on integers to R, and we also add R as a parameter to the ThereIsAMinimum lemma:\n\nfunction method SetToSequence<A(!new)>(s: set<A>, R: (A, A) -> bool): seq<A>\n  requires IsTotalOrder(R)\n  ensures var q := SetToSequence(s, R);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    ThereIsAMinimum(s, R);\n    var x :| x in s && forall y :: y in s ==> R(x, y);\n    [x] + SetToSequence(s - {x}, R)\n}\n\nlemma ThereIsAMinimum<A(!new)>(s: set<A>, R: (A, A) -> bool)\n  requires s != {} && IsTotalOrder(R)\n  ensures exists x :: x in s && forall y :: y in s ==> R(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nThe revised SetToSequence lemma verifies. Our remaining task is to prove the lemma.\n\n\n# 7.âTotal order has minimum\n\nWe start the proof of our generic ThereIsAMinimum like the analogous proof for integer sets above:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nThe case that was âobviousâ before is causing the verifier trouble this time. Let's help it out. Our proof obligation is to show there's some element in s that is as small as any element in s. If s is the singleton set {x}, then the element we're looking for can only be x. Now, if y is an element in s, we need to prove R(x, y). Since s is a singleton, we have y == x, and then R(x, y) follows from connexity. The verifier is missing one of both of these facts. Let's add an assertion about the first fact:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nAh, yes, the verifier can prove this assertion and can then do the rest of the proof.\n\nOn to the non-singleton case. We'll start like in the integer-set proof above:\n\n  } else {\n    var s' := s - {x};\n    assert s == s' + {x};\n    ThereIsAMinimum(s', R);\n\n\n1\n2\n3\n4\n\n\nThe verifier complains the lemma's postcondition might not hold, so we'll give the verifier more help.\n\nThe recursive call to the lemma (which, by the way, is known as âthe induction hypothesisâ) says there is a minimum in s'. Let's give it a name, which we do by introducing a local variable whose value we constrain to satisfy the condition in the lemma's postcondition's existential quantifier:\n\n    var z :| z in s' && forall y :: y in s' ==> R(z, y);\n\n\n1\n\n\nSince s is s' + {x}, the minimum we're looking for is either z or x. Let's treat these cases separately. We do that by using an if statement. Since the two cases are so symmetric, I think it looks nice to use Dafny's if-case statement:\n\n    // by connexity, one of the two cases below applies\n    if\n    case R(z, x) =>\n      // prove z is the minimum not just of s', but of s\n      // ...\n    case R(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nLet's do the R(z, x) case first. The hard part is likely to be the quantifier in the postcondition, so let's start with it. To give a proof of a universal quantifier, you use a forall statement.\n\n      forall y | y in s\n        ensures R(z, y)\n      {\n\n\n1\n2\n3\n\n\nFrom y in s, we know either y is x or y is in s'. For the former, the proof follows from the guard R(z, x). For the latter, the proof follows from the quantification in the such-that condition we used to introduce z. Somehow, the verifier is not picking up on this, so let's help it along. We start here:\n\n        assert x == y || y in s';\n      }\n\n\n1\n2\n\n\nLo and behold! That's all the verifier needed.\n\nIn the R(x, z) case, we'll lay down the analogous forall statement to prove the quantifier in the lemma's postcondition:\n\n      forall y | y in s\n        ensures R(x, y)\n      {\n\n\n1\n2\n3\n\n\nIf y is x, then R(x, y) follows from connexity. On the other hand, if y is in s', then the such-that condition that introduced z tells us R(z, y), so we get R(x, y) by transitivity. You may add these hints in various ways to make the proof go through. Here is one way:\n\n        assert y in s' ==> R(z, y);\n      }\n\n\n1\n2\n\n\nA final remark. When we proved ThereIsAMinimum for integer sets, I argued that it's often useful to include an assertion like:\n\n    assert s == s' + {x};\n\n\n1\n\n\nI included it in the generic ThereIsAMinimum as well. But as it turns out, it's not actually needed there (because we made up for it in the additional hints we gave in the two cases), so you can delete it, if you want.\n\n\n# 8.âComing back to map to sequence\n\nWe did it!\n\nWell, before we declare success, let's just make sure we can use our functions and lemmas to write the MapToSequence function that we set out to write. Here's the generic version, which needs a given total order:\n\nfunction method MapToSequence<A(!new),B>(m: map<A,B>, R: (A, A) -> bool): seq<(A,B)>\n  requires IsTotalOrder(R)\n{\n  var keys := SetToSequence(m.Keys, (a,a') => R(a, a'));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nWe can also specialize it for integer sets:\n\nfunction method IntMapToSequence<B>(m: map<int,B>): seq<(int,B)> {\n  MapToSequence(m, (a, a') => a <= a')\n}\n\n\n1\n2\n3\n\n\nWe did it!\n\n\n# 9.âConclusion\n\nI hope this long journey showed you a thing or two about working with collections in Dafny.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning â Short Presentations, volume 35 of EPiC Series in Computing, pages 106â118. EasyChair, 2015. ð",normalizedContent:"dafny power user: iterating over a collection\n\nk. rustan m. leino\n\nmanuscript krml 275, 17 february 2020\n\nabstract. processing the contents of a set or map in a deterministic way takes some work. using a representative example, this note shows a way to do it.\n\nmathematical collection types include sets, multisets, sequences, and maps. these are essential to specifications as well as programs. defining functions over the elements of such collections is more difficult (or at least more labor intensive) than one would expect. in this note, i develop the program and proof for an example that converts a map to a sequence of pairs. the central part of the work concerns getting a compilable function that returns a set's elements into a predictable order.\n\nthroughout this note, the goal is to produce compilable functions.\n\n\n# 0.âmap to sequence\n\na map is set of key-value pairs, where no key is repeated. we can convert a map to a sequence by putting its keys into a sequence and then making pairs by retrieving the value for each key:\n\nfunction method maptosequence<a,b>(m: map<a,b>): seq<(a,b)> {\n  var keys := settosequence(m.keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor a map m, the expression m.keys gives the set of keys. function maptosequence passes this set of keys to settosequence to obtain a sequence of these keys. then, the sequence constructor\n\nseq(n, f)\n\n\n1\n\n\nproduces a sequence of length n, where the element with index i is specified to be f(i). in maptosequence, the second argument to the sequence comprehension is a partial function given by the lambda expression\n\ni requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n\n\n1\n\n\nfor an index in the given range, this function returns a pair consisting of the key keys[i] and its corresponding value in m. it is necessary to give the range of i in the function's precondition, or else the expression keys[i] would give rise to an index-of-out-bounds error.\n\nto avoid a key-is-not-in-map error in the expression m[keys[i]], we need to know that keys[i] is a key of m. that requires us to know a connection between m.keys and keys, which is stated in the postcondition of the (not yet implemented) function settosequence.\n\nwe now need to implement settosequence.\n\n\n# 1.âa ghost function\n\nlet's start easy. we'll define settosequence as a ghost function. the definition is recursive. when the given set is nonempty, the function uses the choose operator, aka the let-such-that operator and written :|, to pick an element from the set.\n\nfunction settosequence<a>(s: set<a>): seq<a>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthat wasn't too bad.\n\n\n# 2.âmaking the function compilable\n\nto make the settosequence we wrote above compilable, we change the keyword function to the keyword phrase function method. this generates an error message:\n\n> to be compilable, the value of a let-such-that expression must be uniquely determined\n\nexpressionsâand functions, whose bodies are expressionsâmust be deterministic in dafny. this means that\n\nvar x :| x in s;\n\n\n1\n\n\nalways needs to pick the same value for x when given the same s. this would be computationally expensive to do at run time, so dafny instead puts this burden on the programmer (see [0]).\n\none idea is for us to strengthen the condition x in s to always pick âthe minimumâ value from s. this would uniquely determine the value of the let-such-that expression. but what does âminimumâ mean? let's start with integers, where we know what minimum is, and then work up to a general situation.\n\n\n# 3.âchoosing the smallest integer\n\nfor now, we'll restrict our attention to integer sets. this lets us strengthen the condition in the let-such-that expression to uniquely talk about the minimum element of the set:\n\nfunction method settosequence(s: set<int>): seq<int>\n  ensures var q := settosequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + settosequence(s - {x})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nthe âuniquely determinedâ requirement is now satisfied. however, since our new such-that predicate is more complicated, the verifier issues a different complaint:\n\n> cannot establish the existence of a lhs value that satisfies the such-that predicate\n\nit may seem clear to us that a nonempty set has a minimum element, but we need to convince the verifier of it. let's do this in a separate lemma, which we declare as follows:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n\n\n1\n2\n3\n\n\nwe'll insert a call to this lemma just before the let-such-expression in settosequence. the body of that function thus becomes\n\nif s == {} then [] else\n  thereisaminimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + settosequence(s - {x})\n\n\n1\n2\n3\n4\n\n\n\n# 4.âproving there's a minimum\n\nour next task is to give a proof for the thereisaminimum lemma. here is an annotated proof:\n\nlemma thereisaminimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // the minimum in s might be x, or it might be the minimum\n    // in s - {x}. if we knew the minimum of the latter, then\n    // we could compare the two.\n    // let's start by giving a name to the smaller set:\n    var s' := s - {x};\n    // so, s is the union of s' and {x}:\n    assert s == s' + {x};\n    // the following lemma call establishes that there is a\n    // minimum in s'.\n    thereisaminimum(s');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthe proof starts by picking an arbitrary element, x, from s. it is the minimum if it's the only element in s. otherwise, the proof brings out the fact that s is s' + {x}. the recursive call to the lemma gives us, through its postcondition, that there exists a minimum element in s'. the verifier automatically supplies the remaining proof glue, so we're done.\n\nthe assertion in the proof may seem silly. we just defined s' to be s - {x}. since x is in s, the property s == s' + {x} follows immediately. yes, it does. the verifier can easily confirm this, but verifier is not creative enough to realize that this is a good property to know. this is typical when working with collections. for example, if you're working with a sequence q, you may consider q[0] separately and do a recursive call on q[1..]. if so, you're likely to need to manually supply\n\nassert [q[0]] + q[1..] == q;\n\n\n1\n\n\nas with the set property, the verifier easily proves this property, but wouldn't have thought of it by itself.\n\nthe moral of the proof is that it's a good idea, when you split a collection into smaller pieces that you want to reason about separately, to assert that the whole collection equals the combination of the smaller pieces.\n\n\n# 5.âtotal orders\n\nthe restriction to integer sets above was nice to work with, because the minimum of a set of integers is easy to define and gives a unique element. to apply the same trick other types, we need to be able to define a âminimumâ for those types, too. to define a minimum, you need a total order. let's review what that means.\n\na relation over a type a is a function (a, a) -> bool. such a relation, call it r, is known as a partial order when the following three conditions hold:\n\n * r is reflexive, that is, forall a :: r(a, a)\n * r is antisymmetric, that is, forall a, b :: r(a, b) && r(b, a) ==> a == b\n * r is transitive, that is, forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c)\n\na total order is a partial order that additionally satisfies the following condition:\n\n * r is connex (closely connected), that is, forall a, b :: r(a, b) || r(b, a)\n\nnote that connexity implies reflexivity.\n\nhere is a predicate that says whether or not a given relation is a total order:\n\npredicate istotalorder<a(!new)>(r: (a, a) -> bool) {\n  // connexity\n  && (forall a, b :: r(a, b) || r(b, a))\n  // antisymmetry\n  && (forall a, b :: r(a, b) && r(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: r(a, b) && r(b, c) ==> r(a, c))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ndafny won't allow us to write these quantifiers in the predicate, unless it knows a little more about type a. if a were a class type, then forall in dafny means quantifying over the allocated instances of class a. that would mean that allocating another a instance could cause istotalorder(r) to change values. to prevent this, dafny insists that unbounded quantifications like those in istotalorder be over types that do not depend on the allocated state. we express that with the type characteristic (!new), which is written as a suffix of the type name in the type-parameter declaration.\n\n\n# 6.âgeneric set to sequence\n\nwe revise settosequence to also take a relation, r, which we require to be a total order. in doing so, we change the total order <= on integers to r, and we also add r as a parameter to the thereisaminimum lemma:\n\nfunction method settosequence<a(!new)>(s: set<a>, r: (a, a) -> bool): seq<a>\n  requires istotalorder(r)\n  ensures var q := settosequence(s, r);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    thereisaminimum(s, r);\n    var x :| x in s && forall y :: y in s ==> r(x, y);\n    [x] + settosequence(s - {x}, r)\n}\n\nlemma thereisaminimum<a(!new)>(s: set<a>, r: (a, a) -> bool)\n  requires s != {} && istotalorder(r)\n  ensures exists x :: x in s && forall y :: y in s ==> r(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthe revised settosequence lemma verifies. our remaining task is to prove the lemma.\n\n\n# 7.âtotal order has minimum\n\nwe start the proof of our generic thereisaminimum like the analogous proof for integer sets above:\n\n{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nthe case that was âobviousâ before is causing the verifier trouble this time. let's help it out. our proof obligation is to show there's some element in s that is as small as any element in s. if s is the singleton set {x}, then the element we're looking for can only be x. now, if y is an element in s, we need to prove r(x, y). since s is a singleton, we have y == x, and then r(x, y) follows from connexity. the verifier is missing one of both of these facts. let's add an assertion about the first fact:\n\n  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n\n\n1\n2\n\n\nah, yes, the verifier can prove this assertion and can then do the rest of the proof.\n\non to the non-singleton case. we'll start like in the integer-set proof above:\n\n  } else {\n    var s' := s - {x};\n    assert s == s' + {x};\n    thereisaminimum(s', r);\n\n\n1\n2\n3\n4\n\n\nthe verifier complains the lemma's postcondition might not hold, so we'll give the verifier more help.\n\nthe recursive call to the lemma (which, by the way, is known as âthe induction hypothesisâ) says there is a minimum in s'. let's give it a name, which we do by introducing a local variable whose value we constrain to satisfy the condition in the lemma's postcondition's existential quantifier:\n\n    var z :| z in s' && forall y :: y in s' ==> r(z, y);\n\n\n1\n\n\nsince s is s' + {x}, the minimum we're looking for is either z or x. let's treat these cases separately. we do that by using an if statement. since the two cases are so symmetric, i think it looks nice to use dafny's if-case statement:\n\n    // by connexity, one of the two cases below applies\n    if\n    case r(z, x) =>\n      // prove z is the minimum not just of s', but of s\n      // ...\n    case r(x, z) =>\n      // prove x is the minimum of s\n      // ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlet's do the r(z, x) case first. the hard part is likely to be the quantifier in the postcondition, so let's start with it. to give a proof of a universal quantifier, you use a forall statement.\n\n      forall y | y in s\n        ensures r(z, y)\n      {\n\n\n1\n2\n3\n\n\nfrom y in s, we know either y is x or y is in s'. for the former, the proof follows from the guard r(z, x). for the latter, the proof follows from the quantification in the such-that condition we used to introduce z. somehow, the verifier is not picking up on this, so let's help it along. we start here:\n\n        assert x == y || y in s';\n      }\n\n\n1\n2\n\n\nlo and behold! that's all the verifier needed.\n\nin the r(x, z) case, we'll lay down the analogous forall statement to prove the quantifier in the lemma's postcondition:\n\n      forall y | y in s\n        ensures r(x, y)\n      {\n\n\n1\n2\n3\n\n\nif y is x, then r(x, y) follows from connexity. on the other hand, if y is in s', then the such-that condition that introduced z tells us r(z, y), so we get r(x, y) by transitivity. you may add these hints in various ways to make the proof go through. here is one way:\n\n        assert y in s' ==> r(z, y);\n      }\n\n\n1\n2\n\n\na final remark. when we proved thereisaminimum for integer sets, i argued that it's often useful to include an assertion like:\n\n    assert s == s' + {x};\n\n\n1\n\n\ni included it in the generic thereisaminimum as well. but as it turns out, it's not actually needed there (because we made up for it in the additional hints we gave in the two cases), so you can delete it, if you want.\n\n\n# 8.âcoming back to map to sequence\n\nwe did it!\n\nwell, before we declare success, let's just make sure we can use our functions and lemmas to write the maptosequence function that we set out to write. here's the generic version, which needs a given total order:\n\nfunction method maptosequence<a(!new),b>(m: map<a,b>, r: (a, a) -> bool): seq<(a,b)>\n  requires istotalorder(r)\n{\n  var keys := settosequence(m.keys, (a,a') => r(a, a'));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nwe can also specialize it for integer sets:\n\nfunction method intmaptosequence<b>(m: map<int,b>): seq<(int,b)> {\n  maptosequence(m, (a, a') => a <= a')\n}\n\n\n1\n2\n3\n\n\nwe did it!\n\n\n# 9.âconclusion\n\ni hope this long journey showed you a thing or two about working with collections in dafny.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning â short presentations, volume 35 of epic series in computing, pages 106â118. easychair, 2015. ð",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"old and unchanged",frontmatter:{title:"old and unchanged",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/7fe522/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/40.old%20and%20unchanged.html",relativePath:"80.è¯­è¨/30.publication-lecture/40.old and unchanged.md",key:"v-6cd0ba1b",path:"/pages/7fe522/",headers:[{level:2,title:"0.âThe essence",slug:"_0-the-essence",normalizedTitle:"0.âthe essence",charIndex:195},{level:2,title:"1.âmodifies",slug:"_1-modifies",normalizedTitle:"1.âmodifies",charIndex:803},{level:2,title:"2.âFrame expressions",slug:"_2-frame-expressions",normalizedTitle:"2.âframe expressions",charIndex:2397},{level:3,title:"2.0.âold",slug:"_2-0-old",normalizedTitle:"2.0.âold",charIndex:2974},{level:3,title:"2.1.âunchanged",slug:"_2-1-unchanged",normalizedTitle:"2.1.âunchanged",charIndex:3807},{level:2,title:"3.âThe fine print",slug:"_3-the-fine-print",normalizedTitle:"3.âthe fine print",charIndex:4848},{level:3,title:"3.0.âmodifies determined in pre-state",slug:"_3-0-modifies-determined-in-pre-state",normalizedTitle:"3.0.âmodifies determined in pre-state",charIndex:4870},{level:3,title:"3.1.âold only affects the heap",slug:"_3-1-old-only-affects-the-heap",normalizedTitle:"3.1.âold only affects the heap",charIndex:6255},{level:3,title:"3.2.âmodifies permission is checked immediately",slug:"_3-2-modifies-permission-is-checked-immediately",normalizedTitle:"3.2.âmodifies permission is checked immediately",charIndex:9909},{level:2,title:"4.âAdvanced features",slug:"_4-advanced-features",normalizedTitle:"4.âadvanced features",charIndex:10738},{level:3,title:"4.0.âMore precise frame expressions",slug:"_4-0-more-precise-frame-expressions",normalizedTitle:"4.0.âmore precise frame expressions",charIndex:10763},{level:3,title:"4.1.âState labels",slug:"_4-1-state-labels",normalizedTitle:"4.1.âstate labels",charIndex:13095}],headersStr:"0.âThe essence 1.âmodifies 2.âFrame expressions 2.0.âold 2.1.âunchanged 3.âThe fine print 3.0.âmodifies determined in pre-state 3.1.âold only affects the heap 3.2.âmodifies permission is checked immediately 4.âAdvanced features 4.0.âMore precise frame expressions 4.1.âState labels",content:"Dafny Power User: old and unchanged\n\nK. Rustan M. Leino\n\nManuscript KRML 273, 15 February 2020\n\nAbstract. This note addresses the question \"What's the difference between old and unchanged?\".\n\n\n# 0.âThe essence\n\nIn a nutshell, the expression old(E) denotes the value of expression E evaluated in the pre-state of the enclosing method. The expression unchanged(R) says that the values of the fields of the object denoted by expression R are the same as in the pre-state.\n\nFor instance, consider the following classes, which I will use throughout this note:\n\nclass C {\n  var x: int\n  var y: D\n  // ...\n}\nclass D {\n  var z: int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIf c is a parameter of type C, then the expression unchanged(c)means\n\nold(c.x) == c.x && old(c.y) == c.y\n\n\n1\n\n\nBut there's more, if you want to know it.\n\n\n# 1.âmodifies\n\nLet's review modifies clauses on methods.\n\nA method must declare the set of (previously allocated) objects whose fields it might modify. So, if a method method M(c: C) wants to do an assignment like\n\nc.x := 10;\n\n\n1\n\n\nor\n\nc.x := c.x + 2;\n\n\n1\n\n\nthen its specification must include the object reference c in its modifies clause, like so:\n\nmethod M(c: C)\n  modifies c\n\n\n1\n2\n\n\nThis specification gives M permission to modify the fields of c.\n\nExercise 0. What does the following specification mean?\n\nmethod M(c: C, d: D)\n  modifies c.y\n\n\n1\n2\n\n\nAnswer. It gives M permission to modify the fields of c.y. For example, the body of M can do the following assignment:\n\nc.y.z := 15;\n\n\n1\n\n\nIt does not give M the permission to modify the y field of object c. For example, the following is not allowed:\n\nc.y := d;  // error: not allowed by modifies clause \n\n\n1\n\n\nA modifies clause is not transitive. That is, modifies c gives permission to modify the fields of c, but not their fields. In particular, the assignment\n\nc.y.z := 20;\n\n\n1\n\n\nis not allowed by the specification modifies c.\n\nMethods are always allowed to allocate new objects and modify their fields, even without any mention in the modifies clause. So, here's a way to ensure that c.y.z has a post-value of 20:\n\nmethod M(c: C)\n  modifies c\n  ensures c.y.z == 20\n{\n  c.y := new D;  // allowed because c is in the modifies clause\n  c.y.z := 20;   // allowed because c.y is newly allocated\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that this program swap out c.y for a new object. The object previously referenced by c.y is not changed by method M.\n\n\n# 2.âFrame expressions\n\nWhat follows the modifies keyword is a list of frame expressions. A frame expression denotes a set of objects (or arrays).\n\nFor convenience, a frame expression can be given as a set of object or as a single object. The latter is shorthand for the singleton set containing that object. The modifies clause denotes the set union of the objects denoted by each frame expression in the list. For example,\n\nmethod P(c: C, d: D, S: set<object>)\n  modifies c, d, S\n\n\n1\n2\n\n\nis the same as\n\nmethod P(c: C, d: D, S: set<object>)\n  modifies {c} + {d} + S\n\n\n1\n2\n\n\n\n# 2.0.âold\n\nIf you want to say that M has the effect of increasing the value of c.x, then you write a two-state postcondition that mentions the value of c.x in both the method's pre-state and the method's post-state. The former is notated by old(c.x), and the latter simply by c.x:\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) < c.x\n\n\n1\n2\n3\n\n\nThis specification says nothing about the post-value of c.y. More precisely, the modifies clause gives M permission to update all of the fields of c and the ensures clause does not constrain the final value of c.y.\n\nIf you want to specify that the value of c.y is not changed, then you can add another postcondition:\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) < c.x && old(c.y) == c.y\n\n\n1\n2\n3\n\n\nThis postcondition constrains the post-value of c.y to be the same as its pre-value.\n\n\n# 2.1.âunchanged\n\nIf you want to say that all fields of an object are unchanged, you can use an unchanged expression. For example,\n\nmethod M(c: C, k: int)\n  modifies c\n  ensures k < 0 ==> unchanged(c)\n\n\n1\n2\n3\n\n\nThis specification gives M license to modify the fields of c. However, the postcondition constrains the fields to have the initial values if k is negative.\n\nAn unchanged expression accepts a variable number of arguments, each a frame expression. In other words, what you put inside the parentheses that follow the unchanged keyword has the same syntax as modifies clauses. For example,\n\nmethod P(c: C, d: D, S: set<object>, k: int)\n  modifies c, d, S\n  ensures k < 0 ==> unchanged(c, S)\n{\n  if d !in S {\n    d.z := 5;\n  }\n  if 0 <= k {\n    c.x := c.x + 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nis a method that verifies. Note that if d is in the set S and k is negative, then the postcondition says the fields of d must have their initial values, because unchanged(S) says that all fields of all objects in S must not have changed.\n\n\n# 3.âThe fine print\n\n\n# 3.0.âmodifies determined in pre-state\n\nA modifies clause is evaluated in the method's pre-state.\n\nmethod R(c: C, d: D)\n  modifies c, c.y\n{\n  var prevCY := c.y;\n  c.y := d;  // allowed by \"modifies c\"\n  prevCY.z := 9;  // allowed by \"modifies c.y\"\n  c.y.z := 9;  // not allowed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor the last assignment to be legal, the object denoted by c.y at the time of the assignment (namely, d) would have to be in the original modifies clause.\n\nExercise 1. Write a precondition for R that makes all assignments legal.\n\nAnswer.\n\nrequires c.y == d\n\n\n1\n\n\nThe frame expressions given in an unchanged expression are evaluated where the the unchanged is given. For example, the following method satisfies its specification, because the postcondition talks about the fields of the post-state value of c.y.\n\nmethod S(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(c.y)\n{\n  c.y.z := 12;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nIf you change unchanged(c.y) to unchanged(old(c.y)), then the postcondition says that the fields of the object denoted by the pre-state value of c.y must not have changed:\n\nmethod S'(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(old(c.y))\n{\n  c.y := d;\n  d.z := d.z + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSo, the body of S' verifies. If the swap the implementations of methods S and S', then neither of them verifies.\n\n\n# 3.1.âold only affects the heap\n\nold applies only to heap dereferences. If you want to think of it syntactically, then this means the . (dot) in field dereferences (including the . in this.x when you write just x and leave this implicit) and the [ ] (brackets) in array dereferences. In particular, in- and out-parameters, and local and bound variables are unaffected by old.\n\nFor example, consider\n\nmethod W0(c: C, d: D) returns (k: int)\n  modifies c\n  ensures old(k == c.y.z)  // k refers to the final value of k\n{\n  k := c.y.z;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThe postcondition of W0 holds, because k refers to the output value for k (not the arbitrary value that k starts off with inside the body, which would be meaningless to a caller, anyhow). Also, c inside the old expression refers to (constant) value of in-parameter c.\n\nHere is another example method that verifies:\n\nmethod W1(c: C, a: array<int>)\n  requires 0 <= c.x < a.Length\n  modifies c, a\n{\n  var m := a[c.x];\n  a[c.x] := m + 5;\n  c.x := c.x + 1;\n  m := m + 2;\n  assert old(m == a[c.x] + 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThe assertion in the body could equally well have been written\n\nassert m == old(a[c.x]) + 2;\n\n\n1\n\n\nExercise 2. What error message does Dafny produce for the following method?\n\nmethod W2() {\n  var d := new D;\n  d.z := 7;\n  assert old(d.z) == 7;  // error\n}\n\n\n1\n2\n3\n4\n5\n\n\nAnswer. The error is\n\n> receiver must be allocated in the state in which its fields are accessed\n\nThe expression old(d.z) tries to get pre-state value of the z field of (the current value of) d. But the object referenced by d was not allocated in the pre-state of the method, so it makes no sense to ask for the value of d.z in the method's pre-state. Dafny detects this and produces an error.\n\nExercise 3. Consider the following method:\n\nmethod W3(c: C, a: array<int>)\n  requires 100 <= c.x < a.Length\n  requires forall i :: 0 <= i < c.x ==> a[i] == 5\n  requires forall i :: c.x <= i < a.Length ==> a[i] == 6\n  modifies c, a\n  ensures 0 <= c.x < a.Length\n{\n  a[c.x] := 16;\n  c.x := c.x - 1;\n  a[c.x] := 15;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nThis method takes an array with more than 100 elements. The first c.x of elements start off as 5, and the rest equal 6. The modifies clause and postcondition say that the method is allowed to modify both the fields of c and the elements of a. You can see that the method's implementation satisfies that specification.\n\nHow do you write a postcondition that refers to\n\na) the final (that is, post-state) value of the array element at the index given by the final value of c.x?\n\nb) the initial (that is, pre-state) value of the array element at the index given by the initial value of c.x?\n\nc) the final value of the array element at the index given by the initial value of c.x?\n\nd) (tricky!) the initial value of the array element at the index given by the final value of c.x?\n\nAnswer. a) Easy peasy:\n\nensures a[c.x] == 15\n\n\n1\n\n\nb) Easy peasy:\n\nensures old(a[c.x]) == 6\n\n\n1\n\n\nc) By wrapping old around c.x, the dereference (that is, the dot) picks up the initial value of c.x. By making sure you don't wrap the array dereference (that is, the brackets) inside old, the expression a[...] will pick up the final value of teh array element.\n\nensures a[old(c.x)] == 16\n\n\n1\n\n\nd) If we could, we'd wrap old around the brackets, but not the .. But that doesn't work, because what goes between the parentheses of old must syntactically be an expression, not just some random characters. Instead, we can use a let expression: let the bound variable k be the final value of c.x, and then use this bound variable inside old:\n\nensures var k := c.x; old(a[k]) == 5\n\n\n1\n\n\n\n# 3.2.âmodifies permission is checked immediately\n\nFor every heap assignment in a method, Dafny checks that the method has license to modify the indicated heap location. That is, the heap location must either be allowed by the modifies clause or be newly allocated (that is, allocated since the start of the enclosing method). If the method does not have this license, then the heap assignment is illegal, even if the method later restores the previous value. For example, the following is illegal:\n\nmethod M(c: C) {\n  c.x := c.x + 1;  // error\n  c.x := c.x - 1;\n}\n\n\n1\n2\n3\n4\n\n\nIn fact, this is also illegal:\n\nmethod M(c: C) {\n  c.x := c.x;  // error\n}\n\n\n1\n2\n3\n\n\nBut for a method with the following specification:\n\nmethod M(c: C)\n  modifies c\n  ensures unchanged(c)\n\n\n1\n2\n3\n\n\nboth of the method implementations above are legal.\n\n\n# 4.âAdvanced features\n\n\n# 4.0.âMore precise frame expressions\n\nIt is appropriate to think of Dafny's frame expressions as operating at the object granularity. That is, modifies clauses (and also unchanged expressions, as well as the reads clauses of functions) take a set of objects and give permission to modify the fields of those objects (or, for unchanged, say that the fields of those objects are not changed, or, for reads, say that the function is allowed to depend on the fields of those objects).\n\nIt can happen that you want to be more precise. For example, suppose you want to say that a method may modify the y field of a given parameter c, but not the x field. You can specify this behavior by\n\nmethod M(c: C)\n  modifies c\n  ensures old(c.x) == c.x\n\n\n1\n2\n3\n\n\nThis works well if you want to modify most of the fields of c, but want to call out that some fields stay the same. (If a field never changes after construction, it is best to declare it as immutable, which you do with const.) But if instead most fields remain the same and you only want to modify one or two, then the use of old will feel verbose.\n\nDafny provides a way to give some frame expressions at the object-field granularity. You do this by appending a back-tick and the expression that denotes the object. For example, to specify that only the y field of c may change, you can write\n\nmethod M(c: C)\n  modifies c`y\n\n\n1\n2\n\n\nThis says M is not allowed to modify all fields of c, but only the y field. Note that this is quite different from saying modifies c.y, which gives M permission to modify all fields of the object denoted by c.y.\n\nThe object-field granularity can also be used in unchanged expressions (and reads clauses). For example, yet another way to specify the method M is\n\nmethod M(c: C)\n  modifies c\n  ensures unchanged(c`x)\n\n\n1\n2\n3\n\n\nJust like you can abbreviate this.x by just x (if there is no ambiguity with other local names), you can also abbreviate thisxby just ``x.\n\nRegrettably, Dafny does allow this back-tick notation for array elements, for it would be mighty nice to be able to write specifications like\n\nmethod P(a: array<int>, i: int, m: int, n: int)\n  requires 0 <= i < a.Length\n  requires 0 <= m <= n <= a.Length\n  modifies a`[i], a`[m..n]  // error: this syntax is not supported\n\n\n1\n2\n3\n4\n\n\nA future version of Dafny may support this syntax.\n\n\n# 4.1.âState labels\n\nold and unchanged are examples of two-state predicates. That means they talk not just about the current state, but also about a previous stateânamely, the pre-state of the enclosing method, in all the examples we've seen so far. (Well, old only talks about the previous state, not the current state, but it's still a two-state predicate, because it doesn't just talk about the current state.)\n\nThe primary use of two-state expressions is in postconditions. However, you can also use them, for example, in assertions in a method body, like so:\n\nmethod L(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.x := c.x + 3;\n  c.x := c.x + 4;\n  assert c.x == old(c.x) + 9 && unchanged(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSometimes, you want to talk about a heap value in some intermediate state. One way to do that is to use ghost variables. For example:\n\nmethod L1(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  ghost var g := c.x;\n  c.x := c.x + 3;\n  ghost var h := c.x;\n  c.x := c.x + 4;\n  assert c.x == h + 4 == g + 7 == old(c.x) + 9;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nIf you want to refer to many values in the heap from an previous intermediate state, then you can use labels. These are the same labels as you would use to do a control-flow break out of a loop or other statement. Like in many other languages, the declaration of a label in Dafny ends with a : (colon). Unlike many other languages, Dafny also requires the declaration to start with the keyword label, which is intended to make the placement more prominent.\n\nold and unchanged can be followed with @ and a label, which makes them two-state predicates that refer to the current state and the previous state. Here is an example:\n\nmethod L2(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.y := new D;\n  label G:\n  c.x := c.x + 3;\n  label H:\n  c.x := c.x + 4;\n  assert c.x == old@H(c.x) + 4 == old@G(c.x) + 7 == old(c.x) + 9;\n  assert unchanged@G(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nHere's a more stimulating example:\n\nmethod Inc(c: C, m: nat, n: nat)\n  modifies c\n  ensures c.x == old(c.x) + 3 * m + 2 * n\n{\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant c.x == old(c.x) + 3 * i\n  {\n    c.x, i := c.x + 3, i + 1;\n  }\n  label Middle:\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c.x == old@Middle(c.x) + 2 * i\n  {\n    c.x, i := c.x + 2, i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"dafny power user: old and unchanged\n\nk. rustan m. leino\n\nmanuscript krml 273, 15 february 2020\n\nabstract. this note addresses the question \"what's the difference between old and unchanged?\".\n\n\n# 0.âthe essence\n\nin a nutshell, the expression old(e) denotes the value of expression e evaluated in the pre-state of the enclosing method. the expression unchanged(r) says that the values of the fields of the object denoted by expression r are the same as in the pre-state.\n\nfor instance, consider the following classes, which i will use throughout this note:\n\nclass c {\n  var x: int\n  var y: d\n  // ...\n}\nclass d {\n  var z: int\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif c is a parameter of type c, then the expression unchanged(c)means\n\nold(c.x) == c.x && old(c.y) == c.y\n\n\n1\n\n\nbut there's more, if you want to know it.\n\n\n# 1.âmodifies\n\nlet's review modifies clauses on methods.\n\na method must declare the set of (previously allocated) objects whose fields it might modify. so, if a method method m(c: c) wants to do an assignment like\n\nc.x := 10;\n\n\n1\n\n\nor\n\nc.x := c.x + 2;\n\n\n1\n\n\nthen its specification must include the object reference c in its modifies clause, like so:\n\nmethod m(c: c)\n  modifies c\n\n\n1\n2\n\n\nthis specification gives m permission to modify the fields of c.\n\nexercise 0. what does the following specification mean?\n\nmethod m(c: c, d: d)\n  modifies c.y\n\n\n1\n2\n\n\nanswer. it gives m permission to modify the fields of c.y. for example, the body of m can do the following assignment:\n\nc.y.z := 15;\n\n\n1\n\n\nit does not give m the permission to modify the y field of object c. for example, the following is not allowed:\n\nc.y := d;  // error: not allowed by modifies clause \n\n\n1\n\n\na modifies clause is not transitive. that is, modifies c gives permission to modify the fields of c, but not their fields. in particular, the assignment\n\nc.y.z := 20;\n\n\n1\n\n\nis not allowed by the specification modifies c.\n\nmethods are always allowed to allocate new objects and modify their fields, even without any mention in the modifies clause. so, here's a way to ensure that c.y.z has a post-value of 20:\n\nmethod m(c: c)\n  modifies c\n  ensures c.y.z == 20\n{\n  c.y := new d;  // allowed because c is in the modifies clause\n  c.y.z := 20;   // allowed because c.y is newly allocated\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that this program swap out c.y for a new object. the object previously referenced by c.y is not changed by method m.\n\n\n# 2.âframe expressions\n\nwhat follows the modifies keyword is a list of frame expressions. a frame expression denotes a set of objects (or arrays).\n\nfor convenience, a frame expression can be given as a set of object or as a single object. the latter is shorthand for the singleton set containing that object. the modifies clause denotes the set union of the objects denoted by each frame expression in the list. for example,\n\nmethod p(c: c, d: d, s: set<object>)\n  modifies c, d, s\n\n\n1\n2\n\n\nis the same as\n\nmethod p(c: c, d: d, s: set<object>)\n  modifies {c} + {d} + s\n\n\n1\n2\n\n\n\n# 2.0.âold\n\nif you want to say that m has the effect of increasing the value of c.x, then you write a two-state postcondition that mentions the value of c.x in both the method's pre-state and the method's post-state. the former is notated by old(c.x), and the latter simply by c.x:\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) < c.x\n\n\n1\n2\n3\n\n\nthis specification says nothing about the post-value of c.y. more precisely, the modifies clause gives m permission to update all of the fields of c and the ensures clause does not constrain the final value of c.y.\n\nif you want to specify that the value of c.y is not changed, then you can add another postcondition:\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) < c.x && old(c.y) == c.y\n\n\n1\n2\n3\n\n\nthis postcondition constrains the post-value of c.y to be the same as its pre-value.\n\n\n# 2.1.âunchanged\n\nif you want to say that all fields of an object are unchanged, you can use an unchanged expression. for example,\n\nmethod m(c: c, k: int)\n  modifies c\n  ensures k < 0 ==> unchanged(c)\n\n\n1\n2\n3\n\n\nthis specification gives m license to modify the fields of c. however, the postcondition constrains the fields to have the initial values if k is negative.\n\nan unchanged expression accepts a variable number of arguments, each a frame expression. in other words, what you put inside the parentheses that follow the unchanged keyword has the same syntax as modifies clauses. for example,\n\nmethod p(c: c, d: d, s: set<object>, k: int)\n  modifies c, d, s\n  ensures k < 0 ==> unchanged(c, s)\n{\n  if d !in s {\n    d.z := 5;\n  }\n  if 0 <= k {\n    c.x := c.x + 4;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nis a method that verifies. note that if d is in the set s and k is negative, then the postcondition says the fields of d must have their initial values, because unchanged(s) says that all fields of all objects in s must not have changed.\n\n\n# 3.âthe fine print\n\n\n# 3.0.âmodifies determined in pre-state\n\na modifies clause is evaluated in the method's pre-state.\n\nmethod r(c: c, d: d)\n  modifies c, c.y\n{\n  var prevcy := c.y;\n  c.y := d;  // allowed by \"modifies c\"\n  prevcy.z := 9;  // allowed by \"modifies c.y\"\n  c.y.z := 9;  // not allowed\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor the last assignment to be legal, the object denoted by c.y at the time of the assignment (namely, d) would have to be in the original modifies clause.\n\nexercise 1. write a precondition for r that makes all assignments legal.\n\nanswer.\n\nrequires c.y == d\n\n\n1\n\n\nthe frame expressions given in an unchanged expression are evaluated where the the unchanged is given. for example, the following method satisfies its specification, because the postcondition talks about the fields of the post-state value of c.y.\n\nmethod s(c: c, d: d)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(c.y)\n{\n  c.y.z := 12;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nif you change unchanged(c.y) to unchanged(old(c.y)), then the postcondition says that the fields of the object denoted by the pre-state value of c.y must not have changed:\n\nmethod s'(c: c, d: d)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(old(c.y))\n{\n  c.y := d;\n  d.z := d.z + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nso, the body of s' verifies. if the swap the implementations of methods s and s', then neither of them verifies.\n\n\n# 3.1.âold only affects the heap\n\nold applies only to heap dereferences. if you want to think of it syntactically, then this means the . (dot) in field dereferences (including the . in this.x when you write just x and leave this implicit) and the [ ] (brackets) in array dereferences. in particular, in- and out-parameters, and local and bound variables are unaffected by old.\n\nfor example, consider\n\nmethod w0(c: c, d: d) returns (k: int)\n  modifies c\n  ensures old(k == c.y.z)  // k refers to the final value of k\n{\n  k := c.y.z;\n  c.y := d;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthe postcondition of w0 holds, because k refers to the output value for k (not the arbitrary value that k starts off with inside the body, which would be meaningless to a caller, anyhow). also, c inside the old expression refers to (constant) value of in-parameter c.\n\nhere is another example method that verifies:\n\nmethod w1(c: c, a: array<int>)\n  requires 0 <= c.x < a.length\n  modifies c, a\n{\n  var m := a[c.x];\n  a[c.x] := m + 5;\n  c.x := c.x + 1;\n  m := m + 2;\n  assert old(m == a[c.x] + 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthe assertion in the body could equally well have been written\n\nassert m == old(a[c.x]) + 2;\n\n\n1\n\n\nexercise 2. what error message does dafny produce for the following method?\n\nmethod w2() {\n  var d := new d;\n  d.z := 7;\n  assert old(d.z) == 7;  // error\n}\n\n\n1\n2\n3\n4\n5\n\n\nanswer. the error is\n\n> receiver must be allocated in the state in which its fields are accessed\n\nthe expression old(d.z) tries to get pre-state value of the z field of (the current value of) d. but the object referenced by d was not allocated in the pre-state of the method, so it makes no sense to ask for the value of d.z in the method's pre-state. dafny detects this and produces an error.\n\nexercise 3. consider the following method:\n\nmethod w3(c: c, a: array<int>)\n  requires 100 <= c.x < a.length\n  requires forall i :: 0 <= i < c.x ==> a[i] == 5\n  requires forall i :: c.x <= i < a.length ==> a[i] == 6\n  modifies c, a\n  ensures 0 <= c.x < a.length\n{\n  a[c.x] := 16;\n  c.x := c.x - 1;\n  a[c.x] := 15;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nthis method takes an array with more than 100 elements. the first c.x of elements start off as 5, and the rest equal 6. the modifies clause and postcondition say that the method is allowed to modify both the fields of c and the elements of a. you can see that the method's implementation satisfies that specification.\n\nhow do you write a postcondition that refers to\n\na) the final (that is, post-state) value of the array element at the index given by the final value of c.x?\n\nb) the initial (that is, pre-state) value of the array element at the index given by the initial value of c.x?\n\nc) the final value of the array element at the index given by the initial value of c.x?\n\nd) (tricky!) the initial value of the array element at the index given by the final value of c.x?\n\nanswer. a) easy peasy:\n\nensures a[c.x] == 15\n\n\n1\n\n\nb) easy peasy:\n\nensures old(a[c.x]) == 6\n\n\n1\n\n\nc) by wrapping old around c.x, the dereference (that is, the dot) picks up the initial value of c.x. by making sure you don't wrap the array dereference (that is, the brackets) inside old, the expression a[...] will pick up the final value of teh array element.\n\nensures a[old(c.x)] == 16\n\n\n1\n\n\nd) if we could, we'd wrap old around the brackets, but not the .. but that doesn't work, because what goes between the parentheses of old must syntactically be an expression, not just some random characters. instead, we can use a let expression: let the bound variable k be the final value of c.x, and then use this bound variable inside old:\n\nensures var k := c.x; old(a[k]) == 5\n\n\n1\n\n\n\n# 3.2.âmodifies permission is checked immediately\n\nfor every heap assignment in a method, dafny checks that the method has license to modify the indicated heap location. that is, the heap location must either be allowed by the modifies clause or be newly allocated (that is, allocated since the start of the enclosing method). if the method does not have this license, then the heap assignment is illegal, even if the method later restores the previous value. for example, the following is illegal:\n\nmethod m(c: c) {\n  c.x := c.x + 1;  // error\n  c.x := c.x - 1;\n}\n\n\n1\n2\n3\n4\n\n\nin fact, this is also illegal:\n\nmethod m(c: c) {\n  c.x := c.x;  // error\n}\n\n\n1\n2\n3\n\n\nbut for a method with the following specification:\n\nmethod m(c: c)\n  modifies c\n  ensures unchanged(c)\n\n\n1\n2\n3\n\n\nboth of the method implementations above are legal.\n\n\n# 4.âadvanced features\n\n\n# 4.0.âmore precise frame expressions\n\nit is appropriate to think of dafny's frame expressions as operating at the object granularity. that is, modifies clauses (and also unchanged expressions, as well as the reads clauses of functions) take a set of objects and give permission to modify the fields of those objects (or, for unchanged, say that the fields of those objects are not changed, or, for reads, say that the function is allowed to depend on the fields of those objects).\n\nit can happen that you want to be more precise. for example, suppose you want to say that a method may modify the y field of a given parameter c, but not the x field. you can specify this behavior by\n\nmethod m(c: c)\n  modifies c\n  ensures old(c.x) == c.x\n\n\n1\n2\n3\n\n\nthis works well if you want to modify most of the fields of c, but want to call out that some fields stay the same. (if a field never changes after construction, it is best to declare it as immutable, which you do with const.) but if instead most fields remain the same and you only want to modify one or two, then the use of old will feel verbose.\n\ndafny provides a way to give some frame expressions at the object-field granularity. you do this by appending a back-tick and the expression that denotes the object. for example, to specify that only the y field of c may change, you can write\n\nmethod m(c: c)\n  modifies c`y\n\n\n1\n2\n\n\nthis says m is not allowed to modify all fields of c, but only the y field. note that this is quite different from saying modifies c.y, which gives m permission to modify all fields of the object denoted by c.y.\n\nthe object-field granularity can also be used in unchanged expressions (and reads clauses). for example, yet another way to specify the method m is\n\nmethod m(c: c)\n  modifies c\n  ensures unchanged(c`x)\n\n\n1\n2\n3\n\n\njust like you can abbreviate this.x by just x (if there is no ambiguity with other local names), you can also abbreviate thisxby just ``x.\n\nregrettably, dafny does allow this back-tick notation for array elements, for it would be mighty nice to be able to write specifications like\n\nmethod p(a: array<int>, i: int, m: int, n: int)\n  requires 0 <= i < a.length\n  requires 0 <= m <= n <= a.length\n  modifies a`[i], a`[m..n]  // error: this syntax is not supported\n\n\n1\n2\n3\n4\n\n\na future version of dafny may support this syntax.\n\n\n# 4.1.âstate labels\n\nold and unchanged are examples of two-state predicates. that means they talk not just about the current state, but also about a previous stateânamely, the pre-state of the enclosing method, in all the examples we've seen so far. (well, old only talks about the previous state, not the current state, but it's still a two-state predicate, because it doesn't just talk about the current state.)\n\nthe primary use of two-state expressions is in postconditions. however, you can also use them, for example, in assertions in a method body, like so:\n\nmethod l(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.x := c.x + 3;\n  c.x := c.x + 4;\n  assert c.x == old(c.x) + 9 && unchanged(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsometimes, you want to talk about a heap value in some intermediate state. one way to do that is to use ghost variables. for example:\n\nmethod l1(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  ghost var g := c.x;\n  c.x := c.x + 3;\n  ghost var h := c.x;\n  c.x := c.x + 4;\n  assert c.x == h + 4 == g + 7 == old(c.x) + 9;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nif you want to refer to many values in the heap from an previous intermediate state, then you can use labels. these are the same labels as you would use to do a control-flow break out of a loop or other statement. like in many other languages, the declaration of a label in dafny ends with a : (colon). unlike many other languages, dafny also requires the declaration to start with the keyword label, which is intended to make the placement more prominent.\n\nold and unchanged can be followed with @ and a label, which makes them two-state predicates that refer to the current state and the previous state. here is an example:\n\nmethod l2(c: c)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.y := new d;\n  label g:\n  c.x := c.x + 3;\n  label h:\n  c.x := c.x + 4;\n  assert c.x == old@h(c.x) + 4 == old@g(c.x) + 7 == old(c.x) + 9;\n  assert unchanged@g(c`y);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nhere's a more stimulating example:\n\nmethod inc(c: c, m: nat, n: nat)\n  modifies c\n  ensures c.x == old(c.x) + 3 * m + 2 * n\n{\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant c.x == old(c.x) + 3 * i\n  {\n    c.x, i := c.x + 3, i + 1;\n  }\n  label middle:\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c.x == old@middle(c.x) + 2 * i\n  {\n    c.x, i := c.x + 2, i + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Short-Circuit Operators",frontmatter:{title:"Short-Circuit Operators",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/369e25/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/45.Short-Circuit%20Operators.html",relativePath:"80.è¯­è¨/30.publication-lecture/45.Short-Circuit Operators.md",key:"v-62c9c110",path:"/pages/369e25/",headers:[{level:2,title:"0.âThe Well-Definedness Rule",slug:"_0-the-well-definedness-rule",normalizedTitle:"0.âthe well-definedness rule",charIndex:613},{level:2,title:"1.âShort-circuiting",slug:"_1-short-circuiting",normalizedTitle:"1.âshort-circuiting",charIndex:1490},{level:2,title:"2.âExample: commutativity of and",slug:"_2-example-commutativity-of-and",normalizedTitle:"2.âexample: commutativity of and",charIndex:2636},{level:2,title:"3.âExample: contrapositive",slug:"_3-example-contrapositive",normalizedTitle:"3.âexample: contrapositive",charIndex:3952},{level:2,title:"4.âSymmetric well-definedness",slug:"_4-symmetric-well-definedness",normalizedTitle:"4.âsymmetric well-definedness",charIndex:5215},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:5770}],headersStr:"0.âThe Well-Definedness Rule 1.âShort-circuiting 2.âExample: commutativity of and 3.âExample: contrapositive 4.âSymmetric well-definedness References",content:"Dafny Power User: Short-Circuit Operators\n\nK. Rustan M. Leino\n\nManuscript KRML 268, 31 May 2019\n\nAbstract. The boolean operators (âandâ, âorâ, â¦) in Dafny are short-circuiting. This means, for example, that you cannot reverse the operands of âandâ and expect your program to be unchanged. This is well known to programmers. But if you write specifications in the same programming language, should you not be nervous that âandâ no longer appears to be commutative?\n\nThis note points out that the difference lies not in the meaning of the operators, but rather in what expressions are legal in the first place.\n\n\n# 0.âThe Well-Definedness Rule\n\nIn Dafny, a.Length gives the length of the array referenced by a and 5/x gives the integer quotient of 5 and x. But what if a is null or if x is 0, what do these expressions mean then? The Dafny verifier checks that you are never in a situation where you have to rely on what these expressions evaluate to for such operand values. So, in a legal Dafny program, expressions are known to be defined. This allows the verifier to do meaningful reasoning and allows the compiler to assume the absence of run-time failures. I'll call this the Well-Definedness Rule.\n\nTo enforce the Well-Definedness Rule, the Dafny verifier checks that every expression you write down is well-defined in every context where that expression could possibly be used. For example, the well-definedness of a.Length is a != null and the well-definedness of 5/x is x != 0.\n\n\n# 1.âShort-circuiting\n\nThe boolean operators &&, ||, ==>, and <== are short-circuiting in Dafny. This notion is commonly described in terms of how an expression is evaluated at run time, namely: evaluation proceeds left-to-right (or right-to-left in the case of <==), but an operand is evaluated only if the operands evaluated so far do not already determine the value of the expression. In this way, if the first operand determines the value of the expression (as evaluating the first operand of && to false does), then the evaluation of the second operand is omitted.\n\nThe meaning of the boolean operators are the same in Dafny as in logic.\n\nHold it! How can that be? Conjunction (âandâ) in logic is symmetric (that is, A && B is the same as B && A) and short-circuiting is inherently asymmetric. How can a short-circuiting operator have the same meaning as in logic? Here's how: Short-circuiting affects the well-definedness of expressions, not their meaning when defined.\n\nSo, I should have said: Expressions with boolean operators are not always defined in Dafny. But when they are defined, their meaning is the same in Dafny as in logic.\n\n\n# 2.âExample: commutativity of and\n\nIn logic,\n\nx != 0 && 5/x == 1\n\n\n1\n\n\nis the very same thing as\n\n5/x == 1 && x != 0\n\n\n1\n\n\nThis is also true in Dafny, but only in situations where these are well-defined.\n\nx != 0 is always well-defined and 5/x == 1 is well-defined when x is non-0. That is, the well-definedness of x != 0 is true and the well-definedness of 5/x == 1 is x != 0.\n\nLet me use WDe to denote the well-definedness of an expression e. So, WDx != 0 is true and WD5/x == 1 is x != 0.\n\nFor conjunction, we have that WDe0 && e1 is\n\nWDe0 && (e0 ==> WDe1)\n\n\n1\n\n\nThat is, while the left argument has to be well-defined, the right argument only has to be well-defined when the left argument evaluates to true.\n\nSo, WDx != 0 && 5/x == 1 is\n\ntrue && (x != 0 ==> x != 0)\n\n\n1\n\n\nwhich simplifies to true. In contrast, WD5/x == 1 && x != 0 is\n\nx != 0 && (5/x == 1 ==> true)\n\n\n1\n\n\nwhich simplifies to x != 0.\n\nSummarizing the example, conjunction in logic is symmetric. This is also true in Dafny, provided that both ways of writing the expression are well-defined. As the example shows, the first conjunction is always well-defined, whereas the other is well-defined only when x != 0. So, if you're in a situation where you don't know if x != 0 holds or not, you're better off writing the first of these conjunctions.\n\n\n# 3.âExample: contrapositive\n\nThe contrapositive of the implication A ==> B is !B ==> !A, that is, the implication with the arguments reversed and negated. In logic, these two implications are equivalent. This is also true in Dafny, provided both expressions are defined.\n\nAs an example, consider the expression a != null ==> a.Length > 0. We have that WDa != null ==> a.Length > 0 is\n\ntrue && (a != null ==> a != null)\n\n\n1\n\n\nwhich simplifies to true. For the contrapositive of the implication, we have that WDa.Length <= 0 ==> a == null is\n\na != null && (a.Length <= 0 ==> true)\n\n\n1\n\n\nwhich simplifies to a != null.\n\nIn Dafny, we can only talk about the meaning of expressions if they are well-defined. As we just worked out, the first of these implications is always well-defined whereas the other is well-defined when a != null. So, in any context where a != null is known to hold, the two implications have the same meaning and you can use them interchangeably. But if there's a possibility that a != null might not hold, then the first implication is still defined (and thus you can start to talk about what value the expression will evaluate to), whereas the second implication is not well-defined (and thus is flagged as an error by the Dafny verifier).\n\n\n# 4.âSymmetric well-definedness\n\nAs a final remark, well-definedness of boolean operands in Dafny is defined to match the notion of short-circuiting. This is well understood by programmers. Indeed, no programmer in their right mind would even think of ever writing\n\np.x < 1000 && p != null\n\n\n1\n\n\nbut would write\n\np != null && p.x < 1000\n\n\n1\n\n\nAs we have seen, this gives rise to an asymmetric definition of well-definedness. But this is not the only way to define well-definedness. For more information, see an article by Darvas, Mehta, and Rudich [0].\n\n\n# References\n\n[0]ÃdÃ¡m Darvas, Farhad Mehta, and Arsenii Rudich. Efficient well-definedness checking. In Alessandro Armando, Peter Baumgartner, and Gilles Dowek, editors, Automated Reasoning, 4th International Joint Conference, IJCAR 2008, volume 5195 of Lecture Notes in Computer Science, pages 100â115. Springer, 2008. ð",normalizedContent:"dafny power user: short-circuit operators\n\nk. rustan m. leino\n\nmanuscript krml 268, 31 may 2019\n\nabstract. the boolean operators (âandâ, âorâ, â¦) in dafny are short-circuiting. this means, for example, that you cannot reverse the operands of âandâ and expect your program to be unchanged. this is well known to programmers. but if you write specifications in the same programming language, should you not be nervous that âandâ no longer appears to be commutative?\n\nthis note points out that the difference lies not in the meaning of the operators, but rather in what expressions are legal in the first place.\n\n\n# 0.âthe well-definedness rule\n\nin dafny, a.length gives the length of the array referenced by a and 5/x gives the integer quotient of 5 and x. but what if a is null or if x is 0, what do these expressions mean then? the dafny verifier checks that you are never in a situation where you have to rely on what these expressions evaluate to for such operand values. so, in a legal dafny program, expressions are known to be defined. this allows the verifier to do meaningful reasoning and allows the compiler to assume the absence of run-time failures. i'll call this the well-definedness rule.\n\nto enforce the well-definedness rule, the dafny verifier checks that every expression you write down is well-defined in every context where that expression could possibly be used. for example, the well-definedness of a.length is a != null and the well-definedness of 5/x is x != 0.\n\n\n# 1.âshort-circuiting\n\nthe boolean operators &&, ||, ==>, and <== are short-circuiting in dafny. this notion is commonly described in terms of how an expression is evaluated at run time, namely: evaluation proceeds left-to-right (or right-to-left in the case of <==), but an operand is evaluated only if the operands evaluated so far do not already determine the value of the expression. in this way, if the first operand determines the value of the expression (as evaluating the first operand of && to false does), then the evaluation of the second operand is omitted.\n\nthe meaning of the boolean operators are the same in dafny as in logic.\n\nhold it! how can that be? conjunction (âandâ) in logic is symmetric (that is, a && b is the same as b && a) and short-circuiting is inherently asymmetric. how can a short-circuiting operator have the same meaning as in logic? here's how: short-circuiting affects the well-definedness of expressions, not their meaning when defined.\n\nso, i should have said: expressions with boolean operators are not always defined in dafny. but when they are defined, their meaning is the same in dafny as in logic.\n\n\n# 2.âexample: commutativity of and\n\nin logic,\n\nx != 0 && 5/x == 1\n\n\n1\n\n\nis the very same thing as\n\n5/x == 1 && x != 0\n\n\n1\n\n\nthis is also true in dafny, but only in situations where these are well-defined.\n\nx != 0 is always well-defined and 5/x == 1 is well-defined when x is non-0. that is, the well-definedness of x != 0 is true and the well-definedness of 5/x == 1 is x != 0.\n\nlet me use wde to denote the well-definedness of an expression e. so, wdx != 0 is true and wd5/x == 1 is x != 0.\n\nfor conjunction, we have that wde0 && e1 is\n\nwde0 && (e0 ==> wde1)\n\n\n1\n\n\nthat is, while the left argument has to be well-defined, the right argument only has to be well-defined when the left argument evaluates to true.\n\nso, wdx != 0 && 5/x == 1 is\n\ntrue && (x != 0 ==> x != 0)\n\n\n1\n\n\nwhich simplifies to true. in contrast, wd5/x == 1 && x != 0 is\n\nx != 0 && (5/x == 1 ==> true)\n\n\n1\n\n\nwhich simplifies to x != 0.\n\nsummarizing the example, conjunction in logic is symmetric. this is also true in dafny, provided that both ways of writing the expression are well-defined. as the example shows, the first conjunction is always well-defined, whereas the other is well-defined only when x != 0. so, if you're in a situation where you don't know if x != 0 holds or not, you're better off writing the first of these conjunctions.\n\n\n# 3.âexample: contrapositive\n\nthe contrapositive of the implication a ==> b is !b ==> !a, that is, the implication with the arguments reversed and negated. in logic, these two implications are equivalent. this is also true in dafny, provided both expressions are defined.\n\nas an example, consider the expression a != null ==> a.length > 0. we have that wda != null ==> a.length > 0 is\n\ntrue && (a != null ==> a != null)\n\n\n1\n\n\nwhich simplifies to true. for the contrapositive of the implication, we have that wda.length <= 0 ==> a == null is\n\na != null && (a.length <= 0 ==> true)\n\n\n1\n\n\nwhich simplifies to a != null.\n\nin dafny, we can only talk about the meaning of expressions if they are well-defined. as we just worked out, the first of these implications is always well-defined whereas the other is well-defined when a != null. so, in any context where a != null is known to hold, the two implications have the same meaning and you can use them interchangeably. but if there's a possibility that a != null might not hold, then the first implication is still defined (and thus you can start to talk about what value the expression will evaluate to), whereas the second implication is not well-defined (and thus is flagged as an error by the dafny verifier).\n\n\n# 4.âsymmetric well-definedness\n\nas a final remark, well-definedness of boolean operands in dafny is defined to match the notion of short-circuiting. this is well understood by programmers. indeed, no programmer in their right mind would even think of ever writing\n\np.x < 1000 && p != null\n\n\n1\n\n\nbut would write\n\np != null && p.x < 1000\n\n\n1\n\n\nas we have seen, this gives rise to an asymmetric definition of well-definedness. but this is not the only way to define well-definedness. for more information, see an article by darvas, mehta, and rudich [0].\n\n\n# references\n\n[0]adam darvas, farhad mehta, and arsenii rudich. efficient well-definedness checking. in alessandro armando, peter baumgartner, and gilles dowek, editors, automated reasoning, 4th international joint conference, ijcar 2008, volume 5195 of lecture notes in computer science, pages 100â115. springer, 2008. ð",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Statement versus Expression Syntax",frontmatter:{title:"Statement versus Expression Syntax",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/f8c1c5/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/50.Statement%20versus%20Expression%20Syntax.html",relativePath:"80.è¯­è¨/30.publication-lecture/50.Statement versus Expression Syntax.md",key:"v-75eb6ec4",path:"/pages/f8c1c5/",headers:[{level:2,title:"0.âIf Statements and If-Then-Else Expressions",slug:"_0-if-statements-and-if-then-else-expressions",normalizedTitle:"0.âif statements and if-then-else expressions",charIndex:1145},{level:3,title:"0.0.âIf-case Statements",slug:"_0-0-if-case-statements",normalizedTitle:"0.0.âif-case statements",charIndex:3805},{level:3,title:"0.1.âIndiscriminate Choice",slug:"_0-1-indiscriminate-choice",normalizedTitle:"0.1.âindiscriminate choice",charIndex:6432},{level:3,title:"0.2.âBinding Guards",slug:"_0-2-binding-guards",normalizedTitle:"0.2.âbinding guards",charIndex:7062},{level:2,title:"1.âMatch Statements and Match Expressions",slug:"_1-match-statements-and-match-expressions",normalizedTitle:"1.âmatch statements and match expressions",charIndex:8768},{level:2,title:"2.âLocal Variables and Let Bindings",slug:"_2-local-variables-and-let-bindings",normalizedTitle:"2.âlocal variables and let bindings",charIndex:11138},{level:3,title:"2.0.âGhost Variables",slug:"_2-0-ghost-variables",normalizedTitle:"2.0.âghost variables",charIndex:14530},{level:3,title:"2.1.âPatterns",slug:"_2-1-patterns",normalizedTitle:"2.1.âpatterns",charIndex:16645},{level:3,title:"2.2.âAssign-Such-That Statements and Let-Such-That Expressions",slug:"_2-2-assign-such-that-statements-and-let-such-that-expressions",normalizedTitle:"2.2.âassign-such-that statements and let-such-that expressions",charIndex:18e3},{level:3,title:"2.3.âUpates",slug:"_2-3-upates",normalizedTitle:"2.3.âupates",charIndex:21354},{level:2,title:"3.âStatement Expressions",slug:"_3-statement-expressions",normalizedTitle:"3.âstatement expressions",charIndex:21761},{level:3,title:"3.0.âLemmas with out-parameters",slug:"_3-0-lemmas-with-out-parameters",normalizedTitle:"3.0.âlemmas with out-parameters",charIndex:23342},{level:2,title:"4.âPutting it all together",slug:"_4-putting-it-all-together",normalizedTitle:"4.âputting it all together",charIndex:24887},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:26042},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:26125}],headersStr:"0.âIf Statements and If-Then-Else Expressions 0.0.âIf-case Statements 0.1.âIndiscriminate Choice 0.2.âBinding Guards 1.âMatch Statements and Match Expressions 2.âLocal Variables and Let Bindings 2.0.âGhost Variables 2.1.âPatterns 2.2.âAssign-Such-That Statements and Let-Such-That Expressions 2.3.âUpates 3.âStatement Expressions 3.0.âLemmas with out-parameters 4.âPutting it all together Acknowledgments References",content:"Dafny Power User: Statement versus Expression Syntax\n\nK. Rustan M. Leino\n\nManuscript KRML 266, 17 May 2019\n\nAbstract. This note describes some constructs that exist in both a statement form and an expression form in Dafny. It points out the syntactic similarities and differences between the two forms, and discusses related constructs.\n\nDafny distinguishes between statements and expressions. For example, the body of a method is a statement whereas the body of a function is an expression. A statement can assign to local variables, allocate and mutate objects in the heap, use loops in control flow, and be nondeterministic. An expression cannot do any of those things. Instead, it can bind values to bound variables, read values in the heap, use recursion, and is always deterministic. Syntactically, most statements are terminated with a semi-colon and sometimes a sequence of statements is surrounded by curly braces. A few expressions contain semi-colons, but never at the end, and an expression can be surrounded by round parentheses.\n\nLet's take a look at some constructs that exist in both a statement form and an expression form.\n\n\n# 0.âIf Statements and If-Then-Else Expressions\n\nOf constructs that exist in both statement and expression form, the conditional (if) is probably the most common, and it is also the one with the most conspicuous difference between the two forms.\n\nThe conditional statement is the if statement, which has a âthenâ branch and an optional âelseâ branch. The âthenâ branch is always a block statement, which is necessarily surrounded by curly braces. The âelseâ branch, if present, is either a block statement or another if statement.\n\nFor example, the following statement declares local variables min and max that are assigned according to the relative sizes of x and y:\n\nvar min, max;\nif x < y {\n  min, max := x, y;\n} else {\n  min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nNotice that min and max are declared before the if statement (Dafny will infer the types of these two variables), which means they are still in scope after the whole if statement. If these variables were instead declared inside each branch, they would go out of scope at the curly brace that ends each respective block statement.\n\nThe conditional expression is the if-then-else expression. Unlike the if statement, the expression form uses the keyword then to separate the guard from the âthenâ branch, and always requires and explicit âelseâ branch. For example, an expression that returns the smaller of x and y is:\n\nif x < y then x else y\n\n\n1\n\n\nSuch expressions can be used as right-hand sides of assignments to local variables:\n\nvar min, max := if x < y then x else y, if x < y then y else x;\n\n\n1\n\n\nFor this example, we can also use a single if-then-else expression where each branch results in a pair. We can assign that pair to a variable, and then assign the pair's components to min and max:\n\nvar minmax := if x < y then (x,y) else (y,x);\nvar min, max := minmax.0, minmax.1;\n\n\n1\n2\n\n\nThe following shows an example of nested and cascaded if statements:\n\nvar middle;\nif x < y {\n  if y < z {\n    middle := y;\n  } else if z < x {\n    middle := x;\n  } else {\n    middle := z;\n  }\n} else {\n  if x < z {\n    middle := x;\n  } else if z < y {\n    middle := y;\n  } else {\n    middle := z;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nAnd here is the analogous program using conditional expressions:\n\nvar middle :=\n  if x < y then\n    if y < z then y else if z < x then x else z\n  else\n    if x < z then x else if z < y then y else z;\n\n\n1\n2\n3\n4\n5\n\n\nFor statements, there are some additional forms of conditionals. Because these forms allow nondeterminism, there statements do exist in an analogous expression form. The next few subsections describe these additional conditional statements.\n\n\n# 0.0.âIf-case Statements\n\nOne additional form of conditional statements is the if-case statement. Instead of two mutually exclusive branches, the if-case statement provides any number of branches (cases, alternatives), and their conditions need not be mutually exclusive. Syntactically, the if-case statement follows the keyword if with ones or more branches of the form\n\ncase Guard => Body\n\n\n1\n\n\nwhere Guard is an expression and Body is a list of statements.\n\nFor example, the computation of min/max can be written as follows:\n\nvar min, max;\nif\ncase x <= y =>\n  min, max := x, y;\ncase y <= x =>\n  min, max := y, x;\n\n\n1\n2\n3\n4\n5\n6\n\n\nNote that <= is the âat mostâ (or, some say âless than or equal toâ) operator, whereas => is the piece of syntax that separates the guard and body of each case.\n\nThe if-case statement picks any one of the cases whose guard evaluates to true. The ordering of the cases is not relevant. In the example above, if x and y are equal, then the choice of which case to execute is nondeterminstic. For this example, it so happens that both cases have the same effect if x and y are equal, but that need not be so. Not having to specify which branch to take when the choice is irrelevant frees the programmer's mind and, arguably, results in a cleaner, more symmetric, and more abstract program.\n\nEach case gives rise to a new block scope, despite the fact that the body is a list of statements, not a block statement. In other words, any local variables declared in one case go out of scope where the case ends.\n\nThe body of a case continues until the next case begins or until the enclosing block ends. If you want to end the last case sooner, you could surround the entire if-case statement with a pair of curly braces, but that doesn't look so nice. Therefore, Dafny optionally allows the set of cases to be enclosed in a pair of curly braces, like this:\n\nvar min, max;\nif {\n  case x <= y =>\n    min, max := x, y;\n  case y <= x =>\n    min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nAn if-case statement can have any number of branches. For example:\n\nvar middle;\nif {\n  case x <= y <= z =>  middle := y;\n  case z <= y <= x =>  middle := y;\n  case y <= x <= z =>  middle := x;\n  case z <= x <= y =>  middle := x;\n  case y <= z <= x =>  middle := z;\n  case x <= z <= y =>  middle := z;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nAs I mentioned, if more than one guard evaluates to true, Dafny may choose to execute any one of the the corresponding bodies (but only one!). What if none of the guards evaluates to true? That is not allowed, and the verifier will report an error if it cannot prove that at least one case applies.\n\n\n# 0.1.âIndiscriminate Choice\n\nWhen Dafny is used as a modeling language, one may want to write down several statements that can be chosen between indiscriminately. This can be done by writing * in place of the guard expression in the common if statement.\n\nFor example, the effect of the statement\n\nif * {\n  S;\n} else if * {\n  T;\n} else {\n  U;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nis to execute one of the statements S, T, or U, but you can never predict which one of those statements will be chosen.\n\nSuch an indiscriminate choice can also be written using an if-case statement:\n\nif\ncase true =>  S;\ncase true =>  T;\ncase true =>  U;\n\n\n1\n2\n3\n4\n\n\n\n# 0.2.âBinding Guards\n\nFinally, both the common if statement and the if-case statement allow guards to introduce a variable with some constraints. These are called binding guards.\n\nFor example, suppose you want to perform an operation to an arbitrary even number in a given set, unless the set contains no even number, in which case you want to do something else. One way to accomplish this is to write an if statement whose then branch uses an assign-such-that statement to pick such an element:\n\nif exists x :: x in S && x % 2 == 0 {\n  var x :| x in S && x % 2 == 0;\n  ProcessEven(x);\n} else {\n  ProcessEmpty();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nBut there is a lot of duplication between the existential quantifier in the guard and the assign-such-that statement in the then branch. With a binding guard, the same program can be written as follows:\n\nif x :| x in S && x % 2 == 0 {\n  ProcessEven(x);\n} else {\n  ProcessEmpty();\n}\n\n\n1\n2\n3\n4\n5\n\n\nThis statement introduces x and picks as its value any value satisfying the condition following the :|. If no such x exists, the else branch is executed. The bound variable x is in scope only in the then branch.\n\nSimilarly, suppose you want to pick an even number from a set and apply some operation to it, or pick an odd number from the set and apply some other operation to it, or do something else if the set contains neither an even nor an odd number. Then you can use an if-case statement with binding guards:\n\nif\ncase x :| x in S && x % 2 == 0 =>\n  ProcessEven(x);\ncase x :| x in S && x % 2 == 1 =>\n  ProcessOdd(x);\ncase S == {} =>\n  ProcessEmpty();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that if S contains both even and odd numbers, then Dafny may pick either of the first two cases.\n\n\n# 1.âMatch Statements and Match Expressions\n\nAnother branching construct is match, which also comes in a statement form and in an expression form. The syntax of these two are identical, except that each body of the former is a list of statements where each body of the latter is an expression. These have the forms\n\nmatch s\ncase A(x) =>\n  StmtList0;\ncase B(y) =>\n  StmtList1;\ncase C(z) =>\n  StmtList2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nand\n\nmatch s\ncase A(x) => Expr0\ncase B(y) => Expr1\ncase C(z) => Expr2\n\n\n1\n2\n3\n4\n\n\nrespectively.\n\nWhat follows the keyword case is a pattern, which looks like an expression built of datatype constructors and bound variables. For example, consider the standard datatype definition for a list, parameterized by an element type T:\n\ndatatype List<T> = Nil | Cons(T, List<T>)\n\n\n1\n\n\nThe following expression returns the minimum of 2 and the length of a list xs:\n\nmatch xs\ncase Nil => 0\ncase Cons(x, Nil) => 1\ncase Cons(x, Cons(y, ys)) => 2\n\n\n1\n2\n3\n4\n\n\nUnlike in several other programming languages, the cases of a match in Dafny are unordered. A bound variable that is not used can be replaced by an underscore, _. So, the match expression above can be written equivalently as\n\nmatch xs\ncase Cons(_, Nil) => 1\ncase Cons(_, Cons(_, _)) => 2\ncase Nil => 0\n\n\n1\n2\n3\n4\n\n\nAnalogously to the if-case statement, each case of a match statement is implicitly a lexical scope. In other words, any local variables declared in one case goes out of scope at the end of that branch.\n\nAlso as for the if-case statement, each case of a match goes as far as possible, but not past another case. To end a case early, the set of cases can be enclosed in a pair of curly braces. For example:\n\nmatch xs\ncase Cons(_, ys) =>\n  match ys {\n    case Cons(_, _) => 2\n    case Nil => 1\n  }\ncase Nil => 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNote that curly braces, not parentheses, are used in this way for both match statements and match expressions. One can, of course, also surround an entire match expression with parentheses, so the expression above can be written equivalently as:\n\nmatch xs\ncase Cons(_, ys) =>\n  (match ys\n   case Cons(_, _) => 2\n   case Nil => 1)\ncase Nil => 0\n\n\n1\n2\n3\n4\n5\n6\n\n\nIn some situations, it may also be possible to simply reorder the cases for the same effect:\n\nmatch xs\ncase Nil => 0\ncase Cons(_, ys) =>\n  match ys\n  case Nil => 1\n  case Cons(_, _) => 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.âLocal Variables and Let Bindings\n\nThe statement that introduces a local variable has the form:\n\nvar x: int := 17;\n\n\n1\n\n\nThe type decoration \": intâ is needed only if Dafny cannot infer the type, so it is typically omitted. The assignment of an initial value, here â:= 17\", can also be omitted, if the initial value of the variable is irrelevant. (If the variable is used before the program explicitly assigns to it, Dafny will initialize the variable to an arbitrary value of its type.) The variable introduced stays in scope until the current lexical scope ends (typically at the next close-curly-brace).\n\nA var statement can introduce several variables. If so, any type decoration acts only on the variable it follows. That is, you can think of : as having higher binding power than the , that separates the variable names. If an initial assignment is used, it must give a value to all variables being declared. For example,\n\nvar a, b: bool, c := 13, true, 8.29;\n\n\n1\n\n\ndeclares an integer variable a, a boolean variable b, and a real-valued variable c.\n\nThe following example introduces three local variables, z, x, and y, and arranges in a complicated way to set z to 0 (where k is some integer variable in the enclosing scope):\n\nvar z;\nvar x, y := k, k;\nz := x - y;\n\n\n1\n2\n3\n\n\nThere is a form of the var statement in expressions: the let expression. The variables introduced by let expressions are usually called bound variables or let-bound variables. The syntax of the let expression is like the var statement, but followed by an expression. For example, the expression\n\nvar w := 5; w + w\n\n\n1\n\n\nreturns 10. If you're used to functional programming, you may choose to read this statement as âletâ (var) w âbeâ (:=) 5 âinâ (;) w + w.\n\nThe syntax intentionally mimics that of the var statement, to deemphasize the distinction between statements and expressions. For example, the statement that assigns to z above can be written with a let expression:\n\nvar z :=\n  var x, y := k, k;\n  x - y;\n\n\n1\n2\n3\n\n\nexcept that, here, the variables x and y are only in scope in the body of the let expression (which ends at the semi-colon); in the statement above, x and y are introduced as local variables, which remain in scope until the end of the lexical block. Note that the first semi-colon is a separator in the let expression, whereas the second semi-colon terminates the var statement.\n\nLocal variables can be modified by assignment statements. In contrast, let-bound variables are immutable. In this light, we think of a let expression as binding a value to each of its let-bound variables. Whereas the right-hand side of the := in a var statement gives initial values to the local variable, the right-hand side of the := in a let expression provides defining values for the let-bound variables. A syntactic difference between the var statement and let expression is that a let expression must always include the := and the accompanying defining expressions.\n\nThe relation between var statements and let expressions is analogous to the relation between a case in a match statement and a case in a match expression. Recall, for the match constructs, each case takes the shape\n\ncase Pattern => StmtList;\n\n\n1\n\n\nor\n\ncase Pattern => Expr\n\n\n1\n\n\nrespectively. Analogously, var statements and let expressions take the respective shapes\n\nvar x := Expr; StmtList;\n\n\n1\n\n\nor\n\nvar x := Expr; Expr\n\n\n1\n\n\n\n# 2.0.âGhost Variables\n\nMany constructs in Dafny come in two manifestations: compiled or ghost. A ghost construct is used in specifications to reason about the correctness of the program, but is erased by the compiler and has no run-time cost. Local variables and let expressions come in both manifestations. The ones we saw above were all compiled manifestations. To declare local variables or let-bound variables as ghost, simply precede the var keyword with ghost.\n\nFor example,\n\nvar m := 20;\nghost var n := m + 3;\n\n\n1\n2\n\n\nintroduces a compiled variable m and a ghost variable n.\n\nDafny makes sure that ghost variables (and other ghost constructs) really can be erased by the compiler without changing the meaning of the program. One of the checks it performs is that the values of compiled variables never depend on ghost variables. For example, the following declaration of n as a compiled variable is not legal, because the use the value of a ghost variable in an assignment to a compiled variable:\n\nghost var m := 20;\nvar n := m + 3;  // error: illegal to assign a ghost to a compiled variable\n\n\n1\n2\n\n\nWhen a var statement or let expression omits the ghost keyword, all variables the statement introduces are declared as compiled. And when the ghost keyword is present, all variables the statement introduces are declared as ghost. There is one exception to this rule. The exception applies when a var statement that omits the ghost keyword gives a method call as the right-hand side. Then, any local variable that corresponds to a ghost out-parameter of the method called is implicitly declared as ghost, and if the method itself is ghost, then all of the local variables are implicitly declared as ghost.\n\nFor example, consider a method with two out-parameters, one compiled and one ghost:\n\nmethod M() returns (x: int, ghost y: int)\n\n\n1\n\n\nThe statement\n\nvar a, b := M();\n\n\n1\n\n\ndeclares a to be a compiled local variable and b to be a ghost local variable. If the statement explicitly uses the ghost keyword, as in\n\nghost var a, b := M();\n\n\n1\n\n\nthen both a and b are declared to be ghost local variables.\n\n\n# 2.1.âPatterns\n\nIn a var statement and let expression, the left-hand side of := need not be a list of variables, but can be a list of patterns, just like the patterns in the cases of a match construct. This has the effect of deconstructing the right-hand side of := (that is, the initializing or defining expressions) and then assigning the new variables.\n\nFor example, using the datatype definition List from above, the var statement\n\nvar Cons(a, Cons(b, Nil)) := E;\n\n\n1\n\n\nintroduces two variables, a and b, and sets these to the first two elements of the list E. The value denoted by the right-hand side must match the pattern in the left-hand side, and this is enforced by the verifier. In the example, E must denote a list whose length is exactly 2.\n\nJust like in match patterns, any variable that is not needed can be replaced by an underscore. For example,\n\nvar Cons(_, Cons(b, _)) := E;\n\n\n1\n\n\nintroduces b and initializes it to the second element of the list E, where E is allowed to have more than two elements.\n\nTo discard a result from the right-hand side, use an underscore as the corresponding actual out-parameter. For example, if P is a method with one out-parameter,\n\nvar _ := P();\n\n\n1\n\n\ncalls P() and then discards its result. This is also allowed if P is a function, but then there's not much point in making the function call at all.\n\n\n# 2.2.âAssign-Such-That Statements and Let-Such-That Expressions\n\nThe var statements and let expressions we've seen so far are precise about what value to assign or bind to the new variables. There's is a cousin to these constructs that instead prescribes a set of values, any one of which may be picked at run-time as the value assigned. It is the assign-such-that statement (in statement form) and the let-such-that expression (in expression form).\n\nFor example, the assign-such-that statement\n\nvar x :| x in S;\n\n\n1\n\n\nintroduces local variable x and says to set it to any value that satisfies the predicate x in S. In other words, this statement sets x to some value in S. (The verifier will complain for this example statement if it cannot prove S to be nonempty.)\n\nSyntactically, the difference between an ordinary assignment and an assign-such-that construct is that the former uses := whereas the latter uses :|. Also, in the ordinary assignment, the variables introduced are not in scope in the right-hand side, where the variables introduced are in scope in the right-hand side of the assign-such-that constructs. Like the var statement and let expression, the such-that forms can introduce multiple variables, but the left-hand side is always a list of variables, never patterns.\n\nHere is an example var statement with an assign-such-that statement that introduces three new variables, b, s, and t. It requires that either S is nonempty or N is strictly positive.\n\nvar b, s, t :| (b ==> s in S) && (!b ==> 0 <= t < N);\n\n\n1\n\n\nThe assign-such-that constructs give rise to a proof obligation that there exists some value for each of the new variables that satisfies the right-hand side. For the example above, the proof obligation thus amounts to that S is nonempty. A Dafny compiler may impose additional restrictions on the right-hand side, because it may not always be clever enough to generate executable code that is guaranteed to, in finite time, find values for the variables.\n\nThe assign-such-that statement and let-such-that expression are the same, but there is an additional restriction on compiled let-such-that expressions. The restriction stems from the fact that expressions in Dafny are always deterministic, that is, if you evaluate an expression twice in the same state, you will get the same value. This is important in order to let the verifier reason about âobviousâ properties like\n\nE == E\n\n\n1\n\n\nStatements, on the other hand, can be nondeterministic, so assign-such-that statements may return different values each time they are executed:\n\nvar x :| x in S;\nvar y :| y in S;\nassert x == y;  // this condition is NOT guaranteed, unless |S| == 1\n\n\n1\n2\n3\n\n\nDafny's guarantee that let-such-that expressions be deterministic (within each run of the program) is unproblematic for ghost expressions, but the same guarantee for compiled let-such-that expressions would incur too high of a run-time cost (see [0]). Instead, Dafny restricts compiled such-that-expressions to those that uniquely specify the values of its variables. For example, if S is a nonempty set of integers, the compiled expression\n\nvar x :| x in S && forall y :: y in S ==> x <= y;\nx\n\n\n1\n2\n\n\nis legal and evaluates to the smallest element in S. Unfortunately, this restriction on compiled let-such-that expressions is sometimes more harsh than one would like.\n\n\n# 2.3.âUpates\n\nLet-bound variables get their value at the time of declaration, but local variables can be subsequently updated with assignment statements or assign-such-that statements. These are like the assignments that provide the initial value of the local variables, except that patterns in the left-hand side are allowed only when the local variables are introduced, not in subsequent assignments.0\n\n\n# 3.âStatement Expressions\n\nGenerally, statements contain expressions, but not the other way around. With one exception: the statement expression. It has the form S; E, where S is one of several ghost statements and E is an expression. The expression S; E evaluates to E. That is, statement S does not affect the value of the expression. The role of S is to provide information that will help prove the well-formedness of E.\n\nFor example, suppose there is a function F and a lemma AboutF that tells us something about the value returned by F:\n\nfunction method F(x: int): int\nlemma AboutF(x: int)\n  requires 0 <= x\n  ensures 0 < F(x)\n\n\n1\n2\n3\n4\n\n\nIn the example, the lemma AboutF, which can be used if x is non-negative, says that F(x) returns a positive value. Now, consider the following statement:\n\nif 0 <= y && 10 / F(y) == 2 {  // error: possible division by zero\n  // ...\n}\n\n\n1\n2\n3\n\n\nWithout further information, Dafny is unable to prove the absence of division-by-zero in the guard of this if statement. To help the verifier along, we can use the lemma. To do that, we might try calling the lemma just before the if statement:\n\nAboutF(y);  // error: precondition violation\nif 0 <= y && 10 / F(y) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nBut that doesn't work, because in that context, it could be that y is negative. By using a statement expression, we can insert the lemma call just where we need it:\n\nif 0 <= y && 10 / (AboutF(y); F(y)) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n\n\nA statement expression accepts five kinds of statements: lemma calls and assert, assume, reveal, and calc statements.\n\n\n# 3.0.âLemmas with out-parameters\n\nThere's a restriction on the lemma calls in statement expressions: the lemma must not have any out-parameters.1 This may be frustrating when it occasionally pops up.\n\nAs an example, consider the following declarations:\n\n// Some property that integers may have\npredicate P(k: int)\n\n// A lemma that, for every x, shows---by returning a witness---the\n// existence of a k satisfying P(k) \nlemma MyLemma(x: int) returns (k: int)\n  ensures P(k)\n\n// Two functions that need the P property\nfunction method G(x: int, ghost k: int): int\n  requires P(k)\nfunction method H(x: int): int\n  requires exists k :: P(k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nIt would be nice to be able to write an expression\n\nvar k := MyLemma(x); G(x, k)\n\n\n1\n\n\nor to write an expression\n\nvar _ := MyLemma(x); H(x)\n\n\n1\n\n\nwhen the out-parameter does not need to be named. But the restriction forbids these.\n\nThere are workarounds. They are rather clumsy, but they show how various expressions discussed in this note can be combined to produce the desired result.\n\nFor the latter case, a workaround is the expression\n\nassert exists k :: P(k) by {\n  var _ := MyLemma(x);\n}\nH(x)\n\n\n1\n2\n3\n4\n\n\nThe former is similar, but also uses a let-such-that expression to obtain a name for the value whose existence is proved by the first assert:\n\nassert exists k :: P(k) by {\n  var _ := MyLemma(x);\n}\nghost var k :| P(k);\nG(x, k)\n\n\n1\n2\n3\n4\n5\n\n\nNote that this let-such-that expression is ghost, so the restriction that k must be determined uniquely does not apply.\n\n\n# 4.âPutting it all together\n\nDafny makes a distinction between statements and expressions, but the syntactic similarities I've discussed in this note make it less of a burden to remember what to write where. As a final example, consider the following (rather contrived) method and function for computing the same thing:\n\nmethod DoItByMethod(xs: List<int>) returns (r: nat)\n{\n  match xs\n  case Nil =>\n    return 0;\n  case Cons(x, _) =>\n    var square := x * x;\n    AboutF(square);\n    return F(square);\n}\n\nfunction method DoItByFunction(xs: List<int>): nat\n{\n  match xs\n  case Nil =>\n    0\n  case Cons(x, _) =>\n    var square := x * x;\n    AboutF(square);\n    F(square)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nTo be technical about it, the method uses a match statement, a var statement with a local variable, a lemma call, and the final function call that computes the result, whereas the function uses a match expression, a let expression with a let-bound variable, a statement expression featuring a lemma call, and the final function call.\n\nBut when you're in the midst of it, there's no need to dwell on those fine distinctions!\n\n# Acknowledgments\n\nI thank Matthias Schlaipfer for useful feedback on this note.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning â Short Presentations, volume 35 of EPiC Series in Computer Science, pages 106â118. EasyChair, December 2015. ð\n\n----------------------------------------\n\n0.This restriction may be removed in some future version of the language. â©\n\n1.This restriction may be removed in some future version of the language. â©",normalizedContent:"dafny power user: statement versus expression syntax\n\nk. rustan m. leino\n\nmanuscript krml 266, 17 may 2019\n\nabstract. this note describes some constructs that exist in both a statement form and an expression form in dafny. it points out the syntactic similarities and differences between the two forms, and discusses related constructs.\n\ndafny distinguishes between statements and expressions. for example, the body of a method is a statement whereas the body of a function is an expression. a statement can assign to local variables, allocate and mutate objects in the heap, use loops in control flow, and be nondeterministic. an expression cannot do any of those things. instead, it can bind values to bound variables, read values in the heap, use recursion, and is always deterministic. syntactically, most statements are terminated with a semi-colon and sometimes a sequence of statements is surrounded by curly braces. a few expressions contain semi-colons, but never at the end, and an expression can be surrounded by round parentheses.\n\nlet's take a look at some constructs that exist in both a statement form and an expression form.\n\n\n# 0.âif statements and if-then-else expressions\n\nof constructs that exist in both statement and expression form, the conditional (if) is probably the most common, and it is also the one with the most conspicuous difference between the two forms.\n\nthe conditional statement is the if statement, which has a âthenâ branch and an optional âelseâ branch. the âthenâ branch is always a block statement, which is necessarily surrounded by curly braces. the âelseâ branch, if present, is either a block statement or another if statement.\n\nfor example, the following statement declares local variables min and max that are assigned according to the relative sizes of x and y:\n\nvar min, max;\nif x < y {\n  min, max := x, y;\n} else {\n  min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nnotice that min and max are declared before the if statement (dafny will infer the types of these two variables), which means they are still in scope after the whole if statement. if these variables were instead declared inside each branch, they would go out of scope at the curly brace that ends each respective block statement.\n\nthe conditional expression is the if-then-else expression. unlike the if statement, the expression form uses the keyword then to separate the guard from the âthenâ branch, and always requires and explicit âelseâ branch. for example, an expression that returns the smaller of x and y is:\n\nif x < y then x else y\n\n\n1\n\n\nsuch expressions can be used as right-hand sides of assignments to local variables:\n\nvar min, max := if x < y then x else y, if x < y then y else x;\n\n\n1\n\n\nfor this example, we can also use a single if-then-else expression where each branch results in a pair. we can assign that pair to a variable, and then assign the pair's components to min and max:\n\nvar minmax := if x < y then (x,y) else (y,x);\nvar min, max := minmax.0, minmax.1;\n\n\n1\n2\n\n\nthe following shows an example of nested and cascaded if statements:\n\nvar middle;\nif x < y {\n  if y < z {\n    middle := y;\n  } else if z < x {\n    middle := x;\n  } else {\n    middle := z;\n  }\n} else {\n  if x < z {\n    middle := x;\n  } else if z < y {\n    middle := y;\n  } else {\n    middle := z;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nand here is the analogous program using conditional expressions:\n\nvar middle :=\n  if x < y then\n    if y < z then y else if z < x then x else z\n  else\n    if x < z then x else if z < y then y else z;\n\n\n1\n2\n3\n4\n5\n\n\nfor statements, there are some additional forms of conditionals. because these forms allow nondeterminism, there statements do exist in an analogous expression form. the next few subsections describe these additional conditional statements.\n\n\n# 0.0.âif-case statements\n\none additional form of conditional statements is the if-case statement. instead of two mutually exclusive branches, the if-case statement provides any number of branches (cases, alternatives), and their conditions need not be mutually exclusive. syntactically, the if-case statement follows the keyword if with ones or more branches of the form\n\ncase guard => body\n\n\n1\n\n\nwhere guard is an expression and body is a list of statements.\n\nfor example, the computation of min/max can be written as follows:\n\nvar min, max;\nif\ncase x <= y =>\n  min, max := x, y;\ncase y <= x =>\n  min, max := y, x;\n\n\n1\n2\n3\n4\n5\n6\n\n\nnote that <= is the âat mostâ (or, some say âless than or equal toâ) operator, whereas => is the piece of syntax that separates the guard and body of each case.\n\nthe if-case statement picks any one of the cases whose guard evaluates to true. the ordering of the cases is not relevant. in the example above, if x and y are equal, then the choice of which case to execute is nondeterminstic. for this example, it so happens that both cases have the same effect if x and y are equal, but that need not be so. not having to specify which branch to take when the choice is irrelevant frees the programmer's mind and, arguably, results in a cleaner, more symmetric, and more abstract program.\n\neach case gives rise to a new block scope, despite the fact that the body is a list of statements, not a block statement. in other words, any local variables declared in one case go out of scope where the case ends.\n\nthe body of a case continues until the next case begins or until the enclosing block ends. if you want to end the last case sooner, you could surround the entire if-case statement with a pair of curly braces, but that doesn't look so nice. therefore, dafny optionally allows the set of cases to be enclosed in a pair of curly braces, like this:\n\nvar min, max;\nif {\n  case x <= y =>\n    min, max := x, y;\n  case y <= x =>\n    min, max := y, x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nan if-case statement can have any number of branches. for example:\n\nvar middle;\nif {\n  case x <= y <= z =>  middle := y;\n  case z <= y <= x =>  middle := y;\n  case y <= x <= z =>  middle := x;\n  case z <= x <= y =>  middle := x;\n  case y <= z <= x =>  middle := z;\n  case x <= z <= y =>  middle := z;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nas i mentioned, if more than one guard evaluates to true, dafny may choose to execute any one of the the corresponding bodies (but only one!). what if none of the guards evaluates to true? that is not allowed, and the verifier will report an error if it cannot prove that at least one case applies.\n\n\n# 0.1.âindiscriminate choice\n\nwhen dafny is used as a modeling language, one may want to write down several statements that can be chosen between indiscriminately. this can be done by writing * in place of the guard expression in the common if statement.\n\nfor example, the effect of the statement\n\nif * {\n  s;\n} else if * {\n  t;\n} else {\n  u;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nis to execute one of the statements s, t, or u, but you can never predict which one of those statements will be chosen.\n\nsuch an indiscriminate choice can also be written using an if-case statement:\n\nif\ncase true =>  s;\ncase true =>  t;\ncase true =>  u;\n\n\n1\n2\n3\n4\n\n\n\n# 0.2.âbinding guards\n\nfinally, both the common if statement and the if-case statement allow guards to introduce a variable with some constraints. these are called binding guards.\n\nfor example, suppose you want to perform an operation to an arbitrary even number in a given set, unless the set contains no even number, in which case you want to do something else. one way to accomplish this is to write an if statement whose then branch uses an assign-such-that statement to pick such an element:\n\nif exists x :: x in s && x % 2 == 0 {\n  var x :| x in s && x % 2 == 0;\n  processeven(x);\n} else {\n  processempty();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nbut there is a lot of duplication between the existential quantifier in the guard and the assign-such-that statement in the then branch. with a binding guard, the same program can be written as follows:\n\nif x :| x in s && x % 2 == 0 {\n  processeven(x);\n} else {\n  processempty();\n}\n\n\n1\n2\n3\n4\n5\n\n\nthis statement introduces x and picks as its value any value satisfying the condition following the :|. if no such x exists, the else branch is executed. the bound variable x is in scope only in the then branch.\n\nsimilarly, suppose you want to pick an even number from a set and apply some operation to it, or pick an odd number from the set and apply some other operation to it, or do something else if the set contains neither an even nor an odd number. then you can use an if-case statement with binding guards:\n\nif\ncase x :| x in s && x % 2 == 0 =>\n  processeven(x);\ncase x :| x in s && x % 2 == 1 =>\n  processodd(x);\ncase s == {} =>\n  processempty();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that if s contains both even and odd numbers, then dafny may pick either of the first two cases.\n\n\n# 1.âmatch statements and match expressions\n\nanother branching construct is match, which also comes in a statement form and in an expression form. the syntax of these two are identical, except that each body of the former is a list of statements where each body of the latter is an expression. these have the forms\n\nmatch s\ncase a(x) =>\n  stmtlist0;\ncase b(y) =>\n  stmtlist1;\ncase c(z) =>\n  stmtlist2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nand\n\nmatch s\ncase a(x) => expr0\ncase b(y) => expr1\ncase c(z) => expr2\n\n\n1\n2\n3\n4\n\n\nrespectively.\n\nwhat follows the keyword case is a pattern, which looks like an expression built of datatype constructors and bound variables. for example, consider the standard datatype definition for a list, parameterized by an element type t:\n\ndatatype list<t> = nil | cons(t, list<t>)\n\n\n1\n\n\nthe following expression returns the minimum of 2 and the length of a list xs:\n\nmatch xs\ncase nil => 0\ncase cons(x, nil) => 1\ncase cons(x, cons(y, ys)) => 2\n\n\n1\n2\n3\n4\n\n\nunlike in several other programming languages, the cases of a match in dafny are unordered. a bound variable that is not used can be replaced by an underscore, _. so, the match expression above can be written equivalently as\n\nmatch xs\ncase cons(_, nil) => 1\ncase cons(_, cons(_, _)) => 2\ncase nil => 0\n\n\n1\n2\n3\n4\n\n\nanalogously to the if-case statement, each case of a match statement is implicitly a lexical scope. in other words, any local variables declared in one case goes out of scope at the end of that branch.\n\nalso as for the if-case statement, each case of a match goes as far as possible, but not past another case. to end a case early, the set of cases can be enclosed in a pair of curly braces. for example:\n\nmatch xs\ncase cons(_, ys) =>\n  match ys {\n    case cons(_, _) => 2\n    case nil => 1\n  }\ncase nil => 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote that curly braces, not parentheses, are used in this way for both match statements and match expressions. one can, of course, also surround an entire match expression with parentheses, so the expression above can be written equivalently as:\n\nmatch xs\ncase cons(_, ys) =>\n  (match ys\n   case cons(_, _) => 2\n   case nil => 1)\ncase nil => 0\n\n\n1\n2\n3\n4\n5\n6\n\n\nin some situations, it may also be possible to simply reorder the cases for the same effect:\n\nmatch xs\ncase nil => 0\ncase cons(_, ys) =>\n  match ys\n  case nil => 1\n  case cons(_, _) => 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.âlocal variables and let bindings\n\nthe statement that introduces a local variable has the form:\n\nvar x: int := 17;\n\n\n1\n\n\nthe type decoration \": intâ is needed only if dafny cannot infer the type, so it is typically omitted. the assignment of an initial value, here â:= 17\", can also be omitted, if the initial value of the variable is irrelevant. (if the variable is used before the program explicitly assigns to it, dafny will initialize the variable to an arbitrary value of its type.) the variable introduced stays in scope until the current lexical scope ends (typically at the next close-curly-brace).\n\na var statement can introduce several variables. if so, any type decoration acts only on the variable it follows. that is, you can think of : as having higher binding power than the , that separates the variable names. if an initial assignment is used, it must give a value to all variables being declared. for example,\n\nvar a, b: bool, c := 13, true, 8.29;\n\n\n1\n\n\ndeclares an integer variable a, a boolean variable b, and a real-valued variable c.\n\nthe following example introduces three local variables, z, x, and y, and arranges in a complicated way to set z to 0 (where k is some integer variable in the enclosing scope):\n\nvar z;\nvar x, y := k, k;\nz := x - y;\n\n\n1\n2\n3\n\n\nthere is a form of the var statement in expressions: the let expression. the variables introduced by let expressions are usually called bound variables or let-bound variables. the syntax of the let expression is like the var statement, but followed by an expression. for example, the expression\n\nvar w := 5; w + w\n\n\n1\n\n\nreturns 10. if you're used to functional programming, you may choose to read this statement as âletâ (var) w âbeâ (:=) 5 âinâ (;) w + w.\n\nthe syntax intentionally mimics that of the var statement, to deemphasize the distinction between statements and expressions. for example, the statement that assigns to z above can be written with a let expression:\n\nvar z :=\n  var x, y := k, k;\n  x - y;\n\n\n1\n2\n3\n\n\nexcept that, here, the variables x and y are only in scope in the body of the let expression (which ends at the semi-colon); in the statement above, x and y are introduced as local variables, which remain in scope until the end of the lexical block. note that the first semi-colon is a separator in the let expression, whereas the second semi-colon terminates the var statement.\n\nlocal variables can be modified by assignment statements. in contrast, let-bound variables are immutable. in this light, we think of a let expression as binding a value to each of its let-bound variables. whereas the right-hand side of the := in a var statement gives initial values to the local variable, the right-hand side of the := in a let expression provides defining values for the let-bound variables. a syntactic difference between the var statement and let expression is that a let expression must always include the := and the accompanying defining expressions.\n\nthe relation between var statements and let expressions is analogous to the relation between a case in a match statement and a case in a match expression. recall, for the match constructs, each case takes the shape\n\ncase pattern => stmtlist;\n\n\n1\n\n\nor\n\ncase pattern => expr\n\n\n1\n\n\nrespectively. analogously, var statements and let expressions take the respective shapes\n\nvar x := expr; stmtlist;\n\n\n1\n\n\nor\n\nvar x := expr; expr\n\n\n1\n\n\n\n# 2.0.âghost variables\n\nmany constructs in dafny come in two manifestations: compiled or ghost. a ghost construct is used in specifications to reason about the correctness of the program, but is erased by the compiler and has no run-time cost. local variables and let expressions come in both manifestations. the ones we saw above were all compiled manifestations. to declare local variables or let-bound variables as ghost, simply precede the var keyword with ghost.\n\nfor example,\n\nvar m := 20;\nghost var n := m + 3;\n\n\n1\n2\n\n\nintroduces a compiled variable m and a ghost variable n.\n\ndafny makes sure that ghost variables (and other ghost constructs) really can be erased by the compiler without changing the meaning of the program. one of the checks it performs is that the values of compiled variables never depend on ghost variables. for example, the following declaration of n as a compiled variable is not legal, because the use the value of a ghost variable in an assignment to a compiled variable:\n\nghost var m := 20;\nvar n := m + 3;  // error: illegal to assign a ghost to a compiled variable\n\n\n1\n2\n\n\nwhen a var statement or let expression omits the ghost keyword, all variables the statement introduces are declared as compiled. and when the ghost keyword is present, all variables the statement introduces are declared as ghost. there is one exception to this rule. the exception applies when a var statement that omits the ghost keyword gives a method call as the right-hand side. then, any local variable that corresponds to a ghost out-parameter of the method called is implicitly declared as ghost, and if the method itself is ghost, then all of the local variables are implicitly declared as ghost.\n\nfor example, consider a method with two out-parameters, one compiled and one ghost:\n\nmethod m() returns (x: int, ghost y: int)\n\n\n1\n\n\nthe statement\n\nvar a, b := m();\n\n\n1\n\n\ndeclares a to be a compiled local variable and b to be a ghost local variable. if the statement explicitly uses the ghost keyword, as in\n\nghost var a, b := m();\n\n\n1\n\n\nthen both a and b are declared to be ghost local variables.\n\n\n# 2.1.âpatterns\n\nin a var statement and let expression, the left-hand side of := need not be a list of variables, but can be a list of patterns, just like the patterns in the cases of a match construct. this has the effect of deconstructing the right-hand side of := (that is, the initializing or defining expressions) and then assigning the new variables.\n\nfor example, using the datatype definition list from above, the var statement\n\nvar cons(a, cons(b, nil)) := e;\n\n\n1\n\n\nintroduces two variables, a and b, and sets these to the first two elements of the list e. the value denoted by the right-hand side must match the pattern in the left-hand side, and this is enforced by the verifier. in the example, e must denote a list whose length is exactly 2.\n\njust like in match patterns, any variable that is not needed can be replaced by an underscore. for example,\n\nvar cons(_, cons(b, _)) := e;\n\n\n1\n\n\nintroduces b and initializes it to the second element of the list e, where e is allowed to have more than two elements.\n\nto discard a result from the right-hand side, use an underscore as the corresponding actual out-parameter. for example, if p is a method with one out-parameter,\n\nvar _ := p();\n\n\n1\n\n\ncalls p() and then discards its result. this is also allowed if p is a function, but then there's not much point in making the function call at all.\n\n\n# 2.2.âassign-such-that statements and let-such-that expressions\n\nthe var statements and let expressions we've seen so far are precise about what value to assign or bind to the new variables. there's is a cousin to these constructs that instead prescribes a set of values, any one of which may be picked at run-time as the value assigned. it is the assign-such-that statement (in statement form) and the let-such-that expression (in expression form).\n\nfor example, the assign-such-that statement\n\nvar x :| x in s;\n\n\n1\n\n\nintroduces local variable x and says to set it to any value that satisfies the predicate x in s. in other words, this statement sets x to some value in s. (the verifier will complain for this example statement if it cannot prove s to be nonempty.)\n\nsyntactically, the difference between an ordinary assignment and an assign-such-that construct is that the former uses := whereas the latter uses :|. also, in the ordinary assignment, the variables introduced are not in scope in the right-hand side, where the variables introduced are in scope in the right-hand side of the assign-such-that constructs. like the var statement and let expression, the such-that forms can introduce multiple variables, but the left-hand side is always a list of variables, never patterns.\n\nhere is an example var statement with an assign-such-that statement that introduces three new variables, b, s, and t. it requires that either s is nonempty or n is strictly positive.\n\nvar b, s, t :| (b ==> s in s) && (!b ==> 0 <= t < n);\n\n\n1\n\n\nthe assign-such-that constructs give rise to a proof obligation that there exists some value for each of the new variables that satisfies the right-hand side. for the example above, the proof obligation thus amounts to that s is nonempty. a dafny compiler may impose additional restrictions on the right-hand side, because it may not always be clever enough to generate executable code that is guaranteed to, in finite time, find values for the variables.\n\nthe assign-such-that statement and let-such-that expression are the same, but there is an additional restriction on compiled let-such-that expressions. the restriction stems from the fact that expressions in dafny are always deterministic, that is, if you evaluate an expression twice in the same state, you will get the same value. this is important in order to let the verifier reason about âobviousâ properties like\n\ne == e\n\n\n1\n\n\nstatements, on the other hand, can be nondeterministic, so assign-such-that statements may return different values each time they are executed:\n\nvar x :| x in s;\nvar y :| y in s;\nassert x == y;  // this condition is not guaranteed, unless |s| == 1\n\n\n1\n2\n3\n\n\ndafny's guarantee that let-such-that expressions be deterministic (within each run of the program) is unproblematic for ghost expressions, but the same guarantee for compiled let-such-that expressions would incur too high of a run-time cost (see [0]). instead, dafny restricts compiled such-that-expressions to those that uniquely specify the values of its variables. for example, if s is a nonempty set of integers, the compiled expression\n\nvar x :| x in s && forall y :: y in s ==> x <= y;\nx\n\n\n1\n2\n\n\nis legal and evaluates to the smallest element in s. unfortunately, this restriction on compiled let-such-that expressions is sometimes more harsh than one would like.\n\n\n# 2.3.âupates\n\nlet-bound variables get their value at the time of declaration, but local variables can be subsequently updated with assignment statements or assign-such-that statements. these are like the assignments that provide the initial value of the local variables, except that patterns in the left-hand side are allowed only when the local variables are introduced, not in subsequent assignments.0\n\n\n# 3.âstatement expressions\n\ngenerally, statements contain expressions, but not the other way around. with one exception: the statement expression. it has the form s; e, where s is one of several ghost statements and e is an expression. the expression s; e evaluates to e. that is, statement s does not affect the value of the expression. the role of s is to provide information that will help prove the well-formedness of e.\n\nfor example, suppose there is a function f and a lemma aboutf that tells us something about the value returned by f:\n\nfunction method f(x: int): int\nlemma aboutf(x: int)\n  requires 0 <= x\n  ensures 0 < f(x)\n\n\n1\n2\n3\n4\n\n\nin the example, the lemma aboutf, which can be used if x is non-negative, says that f(x) returns a positive value. now, consider the following statement:\n\nif 0 <= y && 10 / f(y) == 2 {  // error: possible division by zero\n  // ...\n}\n\n\n1\n2\n3\n\n\nwithout further information, dafny is unable to prove the absence of division-by-zero in the guard of this if statement. to help the verifier along, we can use the lemma. to do that, we might try calling the lemma just before the if statement:\n\naboutf(y);  // error: precondition violation\nif 0 <= y && 10 / f(y) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nbut that doesn't work, because in that context, it could be that y is negative. by using a statement expression, we can insert the lemma call just where we need it:\n\nif 0 <= y && 10 / (aboutf(y); f(y)) == 2 {\n  // ...\n}\n\n\n1\n2\n3\n\n\na statement expression accepts five kinds of statements: lemma calls and assert, assume, reveal, and calc statements.\n\n\n# 3.0.âlemmas with out-parameters\n\nthere's a restriction on the lemma calls in statement expressions: the lemma must not have any out-parameters.1 this may be frustrating when it occasionally pops up.\n\nas an example, consider the following declarations:\n\n// some property that integers may have\npredicate p(k: int)\n\n// a lemma that, for every x, shows---by returning a witness---the\n// existence of a k satisfying p(k) \nlemma mylemma(x: int) returns (k: int)\n  ensures p(k)\n\n// two functions that need the p property\nfunction method g(x: int, ghost k: int): int\n  requires p(k)\nfunction method h(x: int): int\n  requires exists k :: p(k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nit would be nice to be able to write an expression\n\nvar k := mylemma(x); g(x, k)\n\n\n1\n\n\nor to write an expression\n\nvar _ := mylemma(x); h(x)\n\n\n1\n\n\nwhen the out-parameter does not need to be named. but the restriction forbids these.\n\nthere are workarounds. they are rather clumsy, but they show how various expressions discussed in this note can be combined to produce the desired result.\n\nfor the latter case, a workaround is the expression\n\nassert exists k :: p(k) by {\n  var _ := mylemma(x);\n}\nh(x)\n\n\n1\n2\n3\n4\n\n\nthe former is similar, but also uses a let-such-that expression to obtain a name for the value whose existence is proved by the first assert:\n\nassert exists k :: p(k) by {\n  var _ := mylemma(x);\n}\nghost var k :| p(k);\ng(x, k)\n\n\n1\n2\n3\n4\n5\n\n\nnote that this let-such-that expression is ghost, so the restriction that k must be determined uniquely does not apply.\n\n\n# 4.âputting it all together\n\ndafny makes a distinction between statements and expressions, but the syntactic similarities i've discussed in this note make it less of a burden to remember what to write where. as a final example, consider the following (rather contrived) method and function for computing the same thing:\n\nmethod doitbymethod(xs: list<int>) returns (r: nat)\n{\n  match xs\n  case nil =>\n    return 0;\n  case cons(x, _) =>\n    var square := x * x;\n    aboutf(square);\n    return f(square);\n}\n\nfunction method doitbyfunction(xs: list<int>): nat\n{\n  match xs\n  case nil =>\n    0\n  case cons(x, _) =>\n    var square := x * x;\n    aboutf(square);\n    f(square)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nto be technical about it, the method uses a match statement, a var statement with a local variable, a lemma call, and the final function call that computes the result, whereas the function uses a match expression, a let expression with a let-bound variable, a statement expression featuring a lemma call, and the final function call.\n\nbut when you're in the midst of it, there's no need to dwell on those fine distinctions!\n\n# acknowledgments\n\ni thank matthias schlaipfer for useful feedback on this note.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning â short presentations, volume 35 of epic series in computer science, pages 106â118. easychair, december 2015. ð\n\n----------------------------------------\n\n0.this restriction may be removed in some future version of the language. â©\n\n1.this restriction may be removed in some future version of the language. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"The Parent Trick for proving termination and a function-by-method use case",frontmatter:{title:"The Parent Trick for proving termination and a function-by-method use case",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/5a4346/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/55.The%20Parent%20Trick%20for%20proving%20termination%20and%20a%20function-by-method%20use%20case.html",relativePath:"80.è¯­è¨/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md",key:"v-76a9f96e",path:"/pages/5a4346/",headers:[{level:2,title:"0.âMotivating example: sets of strings",slug:"_0-motivating-example-sets-of-strings",normalizedTitle:"0.âmotivating example: sets of strings",charIndex:427},{level:2,title:"1.âTwo mutually recursive functions",slug:"_1-two-mutually-recursive-functions",normalizedTitle:"1.âtwo mutually recursive functions",charIndex:1546},{level:2,title:"2.âWhy the Parent Trick works",slug:"_2-why-the-parent-trick-works",normalizedTitle:"2.âwhy the parent trick works",charIndex:5455},{level:2,title:"3.âTwo more remarks",slug:"_3-two-more-remarks",normalizedTitle:"3.âtwo more remarks",charIndex:6687},{level:2,title:"4.âSegue into an arduous journey",slug:"_4-segue-into-an-arduous-journey",normalizedTitle:"4.âsegue into an arduous journey",charIndex:7483},{level:2,title:"5.âMaking a unique choice",slug:"_5-making-a-unique-choice",normalizedTitle:"5.âmaking a unique choice",charIndex:8698},{level:2,title:"6.âRestructuring the recursion",slug:"_6-restructuring-the-recursion",normalizedTitle:"6.ârestructuring the recursion",charIndex:11804},{level:2,title:"7.âA more efficient choice",slug:"_7-a-more-efficient-choice",normalizedTitle:"7.âa more efficient choice",charIndex:13568},{level:2,title:"8.âFunction-by-method",slug:"_8-function-by-method",normalizedTitle:"8.âfunction-by-method",charIndex:14058},{level:2,title:"9.âMax as a function-by-method",slug:"_9-max-as-a-function-by-method",normalizedTitle:"9.âmax as a function-by-method",charIndex:15462},{level:2,title:"10.âA more common situation",slug:"_10-a-more-common-situation",normalizedTitle:"10.âa more common situation",charIndex:17568},{level:2,title:"11.âNaming the choice",slug:"_11-naming-the-choice",normalizedTitle:"11.ânaming the choice",charIndex:18535},{level:2,title:"12.âWhat you remove may differ from what you just added",slug:"_12-what-you-remove-may-differ-from-what-you-just-added",normalizedTitle:"12.âwhat you remove may differ from what you just added",charIndex:19243},{level:2,title:"13.âTermination",slug:"_13-termination",normalizedTitle:"13.âtermination",charIndex:21772},{level:2,title:"14.âSummary",slug:"_14-summary",normalizedTitle:"14.âsummary",charIndex:22678},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:23301},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:23777}],headersStr:"0.âMotivating example: sets of strings 1.âTwo mutually recursive functions 2.âWhy the Parent Trick works 3.âTwo more remarks 4.âSegue into an arduous journey 5.âMaking a unique choice 6.âRestructuring the recursion 7.âA more efficient choice 8.âFunction-by-method 9.âMax as a function-by-method 10.âA more common situation 11.âNaming the choice 12.âWhat you remove may differ from what you just added 13.âTermination 14.âSummary Acknowledgments References",content:"Dafny Power User: The Parent Trick for proving termination, and a function-by-method use case\n\nK. Rustan M. Leino\n\nManuscript KRML 283, 11 February 2022\n\nAbstract. This note proves termination for a common situation of mutually recursive functions. After that, it takes an arduous journey to turn an aggregating set operation into compiled code, which gives an opportunity to showcase Dafny's function-by-method construct.\n\n\n# 0.âMotivating example: sets of strings\n\nA nonempty prefix-closed set S of strings can be stored as a DAG where each edge is labeled with one character. The presence in S of a string L is represented by the presence of a path from the root of the DAG through edges whose labels, in order, spell out L. For example, a DAG that represents the set {\"\", \"a\", \"ab\", \"b\"} is\n\n            Node (root)\n            /  \\\n           a    b\n          /      \\\n        Node      |\n          \\       |\n           b      |\n            \\    /\n             Node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWe declare the data structure for storing such sets of strings as follows:\n\ndatatype StringSet = Node(children: map<char, StringSet>)\n\npredicate In(s: string, tree: StringSet) {\n   s == \"\" ||\n   var ch := s[0];\n      ch in tree.children.Keys &&\n      In(s[1..], tree.children[ch])\n}\n\nlemma Examples() {\n  var tree :=\n    var empty := Node(map[]);\n    var n := Node(map['b' := empty]);\n    Node(map['a' := n, 'b' := empty]);\n  assert In(\"\", tree);\n  assert In(\"ab\", tree);\n  assert !In(\"xyz\", tree);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1.âTwo mutually recursive functions\n\nLet's write a function that computes the length of the longest string in the set. We'll do it using two mutually recursive functions (and a helper function Maximum).\n\nfunction MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree.children.Values)\n}\n\nfunction MaxLenForest(trees: set<StringSet>): nat {\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(trees - {t});\n    Maximum(m, n)\n}\n\nfunction Maximum(x: int, y: int): int {\n  if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nBut herein lies a problem: proving termination. As it stands, the verifier complains that it cannot prove termination for the call from MaxLen to MaxLenForest or for the call from MaxLenForest to MaxLen. (But it is able to prove termination for the recursive call to MaxLenForest.)\n\nLet's remind ourselves of what the decreases clauses for the two functions are, since we didn't write them explicitly and thus get Dafny's defaults. If you hover over the functions in the IDE, you'll discover that the decreases clauses that Dafny used are the following:\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n\nfunction MaxLenForest(trees: set<StringSet>): nat\n  decreases trees\n\n\n1\n2\n3\n4\n5\n\n\nTermination for the recursive call of MaxLenForest verifies, because trees - {t} is smaller than tree. But for the other two calls, it's no wonder that termination cannot be proved, since Dafny's built-in well-founded order does not relate datatypes (here, StringSet) and sets.\n\nIf we could arrange for the decreases clauses to have the same type, or at least that the types of one is a prefix of the types of the other, we may be able to make progress. This can be done by thinking of MaxLenForest as operating in âthe context ofâ an enclosing tree, that is, the âparentâ tree of the forest. Adding such a parent parameter to MaxLenForest and, for the purpose of this presentation, showing the default decreases clauses explicitly, we get:\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction MaxLenForest(parent: StringSet, trees: set<StringSet>): nat\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nThis is a little better, because now the verifier can prove the termination of the call from MaxLen to MaxLenForest. The reason it can do that is that Dafny's lexicographic ordering considers the 2-tuple tree, tree.children.Values to be smaller than the 1-tuple tree.\n\nBut we still need to prove termination of the call from MaxLenForest back to MaxLen. We'd like to argue that this call terminates because t is âsmaller thanââthat is, structurally included inâthe enclosing parent. But this information is not spelled out in the program. To make the information available, we need to write a precondition for MaxLenForest that says that the forest in enclosed in parent. Dafny allows operator < to be used with datatypes, with the meaning of âstructurally included inâ.\n\nfunction MaxLen(tree: StringSet): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction MaxLenForest(parent: StringSet, trees: set<StringSet>): nat\n  requires forall t :: t in trees ==> t < parent\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nWith that precondition, the verifier completes the proof of the program.\n\n\n# 2.âWhy the Parent Trick works\n\nSo, although Dafny's well-founded order does not relate datatypes and sets, even for a set that is structurally included in a datatype value, the verifier does know that the elements of that set (assuming the type of the elements is a datatype) are structurally included in the parent. In symbols, the well-founded order does not let you prove\n\ntree.children < tree\n\n\n1\n\n\nbut it does let you prove\n\ntree.children[i] < tree\n\n\n1\n\n\nfor any i in range. This is why âthe parent trickâ is an idiom that lets you prove termination for these sorts of mutually recursive functions.\n\nIn summary, the need for the parent trick came about because we had two mutually recursive functions. This meant that we needed to ârememberâ the context in which the MaxLenForest function is called, which is done by passing the extra parameter. If MaxLenForest somehow were written as just one recursive function, then we would still use Dafny's knowledge that a datatype value d inside the set inside a datatype value D is structurally included in D (and thus d < D), but we wouldn't need to apply the parent trick to pass the context as a parameter. I will show such an example below (see function MaxLen in Section 6).\n\n\n# 3.âTwo more remarks\n\nFirst, in presenting the program above, I explicitly showed the decreases clauses. But if you list the parameters in the order that I did, then the explicit decreases clause will coincide with Dafny's defaults. So, you can omit the decreases clauses and the verifier will still be able to prove the program.\n\nSecond, as I wrote them, the functions are ghost, so they are erased by the compiler and not available at run time. If you want the functions to be available at run time, you might be bothered by having to pass the âparentâ parameter along everywhere. This is easily solved by then marking the âparentâ parameter as ghost. This is possible, because parent is not used by the function, other than for its proof, so it's fine if the compiler erases the parameter.\n\n\n# 4.âSegue into an arduous journey\n\nIf you try doing what I just said in the two remarks, the functions will be declared as follows:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children.Values)\n}\n\nfunction method MaxLenForest(ghost parent: StringSet, trees: set<StringSet>): nat\n  requires forall t :: t in trees ==> t < parent\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := MaxLen(t);\n    var n := MaxLenForest(parent, trees - {t});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nbut you'll notice an error:\n\nvar t :| t in trees;\n^ here\nError: to be compilable, the value of a let-such-that expression must be\nuniquely determined\n\n\n1\n2\n3\n4\n\n\nThis is a completely different problem than the termination problem we worked to solve above. The problem is that the choice of a t that satisfies t in trees is not unique, as is required for compiling the let-such-that expression. The reasons for this restriction are explained in a different paper [0]. If you don't care about compiling MaxLen, you can stop reading now. Otherwise, stretch your legs, get more coffee, and keep reading.\n\n\n# 5.âMaking a unique choice\n\nTo make the choice of t unique, we need to strengthen the constraint in the let-such-that expression. For example, we might want to pick the âsmallestâ of the values in trees. But what does âsmallestâ mean among a set of StringSet trees? An easier way out is to change the program to pass the whole map tree.children to MaxLenForest, rather than just the children trees themselves (tree.childre.Values). Then, we can pick the smallest among the labels, whichâsince our labels have type charâis easy to do. Here's what we get:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + MaxLenForest(tree, tree.children)\n}\n\nfunction method MaxLenForest(ghost parent: StringSet,\n                             children: map<char, StringSet>): nat\n  requires forall lbl :: lbl in children.Keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    var lbl :|\n      lbl in children.Keys &&\n      forall lbl' :: lbl' in children.Keys ==> lbl <= lbl';\n    var m := MaxLen(children[lbl]);\n    var n := MaxLenForest(parent, children - {lbl});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nNote that the expression children - {lbl} is a map-domain subtraction. That is, it denotes the map that is like children, except it doesn't have the key lbl.\n\nThe additional constraint makes the choice unique. However, now that we've strengthened it, the verifier is no longer convinced there is any choice for lbl. To fix this problem, we need to demonstrate that every nonempty set of characters has a smallest element. The easiest way to conduct such a demonstration is to compute it:\n\nfunction PickSmallest(s: set<char>): (ch: char)\n  requires s != {}\n  ensures ch in s && forall ch' :: ch' in s ==> ch <= ch'\n{\n  var ch :| ch in s;\n  if ch' :| ch' in s && ch' < ch then\n    var s' := s - {ch};\n    assert s == s' + {ch};\n    PickSmallest(s')\n  else\n    ch\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nâBut wait!â, you say. \"How come this function gets away with the weak let-such-that constraint that was a problem in MaxLenForest?\" It's because PickSmallest is a ghost function, so its let-such-that expression does not have the uniqueness requirement (see [0]). Alright, then, so our final step is to use function PickSmallest just before the let-such-that expression in MaxLenForest:\n\nfunction method MaxLenForest(ghost parent: StringSet,\n                             children: map<char, StringSet>): nat\n  requires forall lbl :: lbl in children.Keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    ghost var smallest := PickSmallest(children.Keys);\n    var lbl :|\n      lbl in children.Keys &&\n      forall lbl' :: lbl' in children.Keys ==> lbl <= lbl';\n    var m := MaxLen(children[lbl]);\n    var n := MaxLenForest(parent, children - {lbl});\n    Maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nAfter putting the result of PickSmallest into a ghost variable, the verifier has all the evidence it needs for the existence of a value of lbl. So, this concludes our program.\n\n\n# 6.âRestructuring the recursion\n\nThe running example has already showed several techniques and features in Dafny. But in our final program above, we still have a rather big and unsatisfying let-such-that constraint. The mandate that we have to pick a unique element from the set seems unnecessarily harsh, since all we're trying to do is compute the maximum of a set, and the maximum will be the same regardless of which order we consider the elements in. So, what we'd like to do is use nondeterminism inside MaxLenForest, as long as we can prove that the nondeterminism does not affect the result. And Dafny has just the feature for this: function-by-method declarations.\n\nTo make a reusable function, let's define a general function Max as follows:\n\nfunction method Max(s: set<int>): int\n  requires s != {}\n  ensures Max(s) in s\n  ensures forall z :: z in s ==> z <= Max(s)\n\n\n1\n2\n3\n4\n\n\nBy constructing the set of elements we want to take the maximum of, we can use Max in MaxLen:\n\nfunction method MaxLen(tree: StringSet): nat {\n  if tree.children == map[] then\n    0\n  else\n    var s := set t | t in tree.children.Values :: MaxLen(t);\n    assert s != {} by {\n      assert forall lbl ::\n        lbl in tree.children.Keys ==> MaxLen(tree.children[lbl]) in s;\n    }\n    1 + Max(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAs you see here, the verifier needed help in proving that s is nonempty. This proof obligation is addressed by asserting that, for every label in (the known to be nonempty) tree.children, s contains the MaxLen of the corresponding value. (Since MaxLen is now recursive and doesn't go through a mutually recursive function like MaxLenForest, we don't need the parent trick. That is, there's no longer a need to pass any additional context parameter.)\n\n\n# 7.âA more efficient choice\n\nFrom now on, we'll focus just on Max. It would be nice to write its body as\n\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := Max(s');\n    Maximum(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nAlas, this is not allowed, because the compiled let-such-that does not uniquely determine the value for x. This is the exactly the problem that we started with and want to steer around!\n\nFunction-by-method to the rescue.\n\n\n# 8.âFunction-by-method\n\nSay what?! A function-by-method is a combination of a function and method. The body of the function part of a function-by-method is a ghost expression, but this expression acts just as the specification for what value is to be returned. The body of the method part of the function-by-method then gives a compilable method body for computing the value.\n\nUsing a bit of program text, the basic idea is to declare a function-by-method like\n\nfunction F(x: X): (y: Y)\n  requires Pre(x)\n  ensures Post(x, y)\n{\n  Expr;\n} by method {\n  MBody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nwhere Expr is a ghost expression (the âfunction partâ) and MBody is a compilable statement list (the âmethod partâ).\n\nTo explain the meaning of this function-by-method, it's helpful to look at it as two declarations:\n\nfunction F(x: X): (y: Y)\n  requires Pre(x)\n  ensures Post(x, y)\n{\n  Expr;\n}\n\nmethod _F(x: X) returns (y: Y)\n  requires Pre(x)\n  ensures y == F(x)\n{\n  MBody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nNow, Dafny arranges that every use of the original function-by-method in a ghost context calls ghost function F, and that every use of the function-by-method is a non-ghost context calls the compiled method _F.\n\nNote that any ensures clause on the original function-by-method is a proof obligation of the function part. The postcondition of the method part is y == F(x). (I'll come back to this point later.)\n\n\n# 9.âMax as a function-by-method\n\nUsing a function-by-method declaration, we write Max as follows:\n\nfunction Max(s: set<int>): (m: int)\n  requires s != {}\n  ensures m in s && forall z :: z in s ==> z <= m\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := Max(s');\n    Maximum(x, y)\n} by method {\n   m :| m in s;\n   var r := s - {m};\n   while r != {}\n     invariant r < s\n     invariant m in s && forall z :: z in s - r ==> z <= m\n   {\n     var x :| x in r;\n     assert forall z :: z in s - (r - {x}) ==> z in s - r || z == x;\n     r := r - {x};\n     if m < x {\n       m := x;\n     }\n   }\n   assert s - {} == s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nThis function-by-method verifies as given. However, the reason it verifies is subtle and may not be what you expect (especially if this is the first time you see a function-by-method). Let me explain the reason and then show a more typical proof of a function-by-method.\n\nThe point of the method part of a function-by-method is to provide a method implementation that returns exactly the same value as the given function body. For this reason, the postcondition that the method body has to satisfy is m == Max(s). This is a very precise postcondition. The ensures clause declared in the function-by-method applies to the function part. It is usually much less precise; in fact, for most functions, this ensures clause is omitted, since the body of the function transparently says what the result value is.\n\nIn general, just because the method part of a function-by-method happens to satisfy the ensures clause of the function-by-method does not mean the method part is correct. But in our Max example, the two coincide, because the ensures clause I gave for the function-by-method uniquely determines m. Thus, any method body that satisfies this ensures clause also satisfies m == Max(s). (You can confirm this by deleting m in s from the ensures clause. This will cause the method part to fail to verify, while the function part still verifies.)\n\n\n# 10.âA more common situation\n\nA more generally applicable pattern for proving the method part of a recursive makes use of the function in the loop invariant. To illustrate this, I will remove the ensures clause of Max. Consequently, the iterative method body needs to establish that it computes exactly what the recursion function body does.\n\nThe idea is to use a body like this:\n\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == Max(r)\n  {\n    var x :| x in s - r;\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis loops maintains the invariant m == Max(r) while enlarging r until it becomes s. Doing this proof is tricky, because of two issues. Both of these issues have standard solutions, which are really good to know. The two issues and solutions are explained for a simpler example in another Dafny Power User note [1], but it seems worthwhile to show them here as well.\n\n\n# 11.âNaming the choice\n\nThe first issue is that the let-such-that expression is like a function, but by Dafny semantics it may be a different function for each textual occurrence of :| (see [0]). It is easy to become confused and frustrated if, without realizing it, you're using more than one :| function. Therefore, let's make sure there is only one textual occurrence of this operator. We do that by putting it inside a named function:\n\nfunction Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nWith this function, we write the function part of the function-by-method Max as\n\n  var x := Pick(s);\n  if s == {x} then\n    x\n  else\n    Maximum(Max(s - {x}), x)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 12.âWhat you remove may differ from what you just added\n\nThe second issue is that we will need to help the verifier along in the proof of invariance for the loop. The reason is that the next element that the loop adds to the growing set r may not be the same element that the Pick function would choose when going in the opposite direction. Specifically, if the loop adds x to r as it's computing Max(r + {x}), there's no reason to believe that the definition of Max(r + {x}) picks x and recurses on Max(r). (Again, for a simpler example and better motivation, see [1].)\n\nThis lemma is tricky to prove, even if you've written similar proofs several times. An additional complication for our function Max is that Max requires its argument to be nonempty. Here is the lemma and a proof:\n\nlemma MaxOfOneMore(t: set<int>, x: int)\n  requires t != {} && x !in t\n  ensures Max(t + {x}) == Maximum(Max(t), x)\n  decreases |t|\n{\n  var u := t + {x};\n  var z := Pick(u);\n  var u'x, u'z := u - {x}, u - {z};\n  assert Max(u) == Maximum(Max(u'z), z);\n\n  if z == x {\n    // Straight from the definition of Max\n  } else if t == {z} {\n    assert u'z == {x} && u'x == {z};\n    // This is known about Max on singletons:\n    assert Max(u'z) == x;\n    assert Max(u'x) == z;\n    // So, regardless of which of x and z gets picked first, the result is the same\n    assert Max(u) == Maximum(x, z) == Maximum(z, x);\n  } else {\n    var u'z'x := u'z - {x};\n    calc {\n      Maximum(Max(u'z), z);\n    ==  { assert u'z == (u'z'x) + {x}; }\n      Maximum(Max((u'z'x) + {x}), z);\n    ==  { MaxOfOneMore(u'z'x, x); }\n      Maximum(Maximum(Max(u'z'x), x), z);\n    ==  // Maximum is commutative and associative\n      Maximum(Maximum(Max(u'z'x), z), x);\n    ==  { MaxOfOneMore(u'z'x, z); }\n      Maximum(Max(u'z'x + {z}), x);\n    ==  { assert u'z'x + {z} == u'x == t; }\n      Maximum(Max(t), x);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nThat's a mouthful. But once you have the lemma, using it once in the loop body finishes the proof of our function-by-method:\n\nfunction Max(s: set<int>): (m: int)\n  requires s != {}\n{\n  var x := Pick(s);\n  if s == {x} then\n    x\n  else\n    Maximum(Max(s - {x}), x)\n} by method {\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == Max(r)\n  {\n    var x :| x in s - r;\n    MaxOfOneMore(r, x);\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 13.âTermination\n\nA final remark. It looks as if Max uses the lemma MaxOfOneMore, and the lemma uses Max. Doesn't this mutual recursion mean we have to prove termination? No, because there's isn't actually any mutual recursion in this example. To understand why, remember that the two parts of a function-by-method are treated as if they were one function and one method (see Section 8). This function and method are different points in the call graph, where calls to Max from ghost contexts go to the function part and calls to Max from compiled contexts go to the method part. Therefore, we have that the following call-graph edges:\n\nMax (function) --\x3e Max (function)\nMaxOfOneMore   --\x3e MaxOfOneMore, Max (function)\nMax (method)   --\x3e MaxOfOneMore, Max (function)\n\n\n1\n2\n3\n\n\nAs you can see from these, the function part of Max is recursive and the lemma is recursive, but there is no mutual recursion.\n\n\n# 14.âSummary\n\nI started this note with the innocent problem of how to prove the termination of two mutually recursive functions. As the solution, I showed the Parent Trick. I then changed the code to make it compilable, which introduced proof obligations to show certain choices to be deterministic. This can be better solved using a function-by-method, so I gave a brief introduction to Dafny's function-by-method declaration and used it to present two solutions. The more straightforward solution worked for the example at hand, whereas the second solution shows a more typical pattern for such method implementations.\n\n# Acknowledgments\n\nI'm grateful to MikaÃ«l Mayer for asking a question about these mutually recursive functions, which propelled me to write this note, and for his helpful comments on the write-up. The function-by-method construct was designed as a direct outgrowth of some collaborative work with Daniel Matichuk, Olivier Savary Belanger, and Mike Dodds, where as a step toward verified compilation we were considering how to implement immutable things with mutable things.\n\n\n# References\n\n[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning â Short Presentations, volume 35 of EPiC Series in Computing, pages 106â118. EasyChair, 2015. https://easychair.org/publications/paper/dM. ð\n\n[1]K. Rustan M. Leino. Dafny power user: Functions over set elements. Manuscript KRML 274, February 2020. http://leino.science/papers/krml274.html. ð",normalizedContent:"dafny power user: the parent trick for proving termination, and a function-by-method use case\n\nk. rustan m. leino\n\nmanuscript krml 283, 11 february 2022\n\nabstract. this note proves termination for a common situation of mutually recursive functions. after that, it takes an arduous journey to turn an aggregating set operation into compiled code, which gives an opportunity to showcase dafny's function-by-method construct.\n\n\n# 0.âmotivating example: sets of strings\n\na nonempty prefix-closed set s of strings can be stored as a dag where each edge is labeled with one character. the presence in s of a string l is represented by the presence of a path from the root of the dag through edges whose labels, in order, spell out l. for example, a dag that represents the set {\"\", \"a\", \"ab\", \"b\"} is\n\n            node (root)\n            /  \\\n           a    b\n          /      \\\n        node      |\n          \\       |\n           b      |\n            \\    /\n             node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nwe declare the data structure for storing such sets of strings as follows:\n\ndatatype stringset = node(children: map<char, stringset>)\n\npredicate in(s: string, tree: stringset) {\n   s == \"\" ||\n   var ch := s[0];\n      ch in tree.children.keys &&\n      in(s[1..], tree.children[ch])\n}\n\nlemma examples() {\n  var tree :=\n    var empty := node(map[]);\n    var n := node(map['b' := empty]);\n    node(map['a' := n, 'b' := empty]);\n  assert in(\"\", tree);\n  assert in(\"ab\", tree);\n  assert !in(\"xyz\", tree);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 1.âtwo mutually recursive functions\n\nlet's write a function that computes the length of the longest string in the set. we'll do it using two mutually recursive functions (and a helper function maximum).\n\nfunction maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree.children.values)\n}\n\nfunction maxlenforest(trees: set<stringset>): nat {\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(trees - {t});\n    maximum(m, n)\n}\n\nfunction maximum(x: int, y: int): int {\n  if x < y then y else x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nbut herein lies a problem: proving termination. as it stands, the verifier complains that it cannot prove termination for the call from maxlen to maxlenforest or for the call from maxlenforest to maxlen. (but it is able to prove termination for the recursive call to maxlenforest.)\n\nlet's remind ourselves of what the decreases clauses for the two functions are, since we didn't write them explicitly and thus get dafny's defaults. if you hover over the functions in the ide, you'll discover that the decreases clauses that dafny used are the following:\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n\nfunction maxlenforest(trees: set<stringset>): nat\n  decreases trees\n\n\n1\n2\n3\n4\n5\n\n\ntermination for the recursive call of maxlenforest verifies, because trees - {t} is smaller than tree. but for the other two calls, it's no wonder that termination cannot be proved, since dafny's built-in well-founded order does not relate datatypes (here, stringset) and sets.\n\nif we could arrange for the decreases clauses to have the same type, or at least that the types of one is a prefix of the types of the other, we may be able to make progress. this can be done by thinking of maxlenforest as operating in âthe context ofâ an enclosing tree, that is, the âparentâ tree of the forest. adding such a parent parameter to maxlenforest and, for the purpose of this presentation, showing the default decreases clauses explicitly, we get:\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction maxlenforest(parent: stringset, trees: set<stringset>): nat\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nthis is a little better, because now the verifier can prove the termination of the call from maxlen to maxlenforest. the reason it can do that is that dafny's lexicographic ordering considers the 2-tuple tree, tree.children.values to be smaller than the 1-tuple tree.\n\nbut we still need to prove termination of the call from maxlenforest back to maxlen. we'd like to argue that this call terminates because t is âsmaller thanââthat is, structurally included inâthe enclosing parent. but this information is not spelled out in the program. to make the information available, we need to write a precondition for maxlenforest that says that the forest in enclosed in parent. dafny allows operator < to be used with datatypes, with the meaning of âstructurally included inâ.\n\nfunction maxlen(tree: stringset): nat\n  decreases tree\n{\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction maxlenforest(parent: stringset, trees: set<stringset>): nat\n  requires forall t :: t in trees ==> t < parent\n  decreases parent, trees\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nwith that precondition, the verifier completes the proof of the program.\n\n\n# 2.âwhy the parent trick works\n\nso, although dafny's well-founded order does not relate datatypes and sets, even for a set that is structurally included in a datatype value, the verifier does know that the elements of that set (assuming the type of the elements is a datatype) are structurally included in the parent. in symbols, the well-founded order does not let you prove\n\ntree.children < tree\n\n\n1\n\n\nbut it does let you prove\n\ntree.children[i] < tree\n\n\n1\n\n\nfor any i in range. this is why âthe parent trickâ is an idiom that lets you prove termination for these sorts of mutually recursive functions.\n\nin summary, the need for the parent trick came about because we had two mutually recursive functions. this meant that we needed to ârememberâ the context in which the maxlenforest function is called, which is done by passing the extra parameter. if maxlenforest somehow were written as just one recursive function, then we would still use dafny's knowledge that a datatype value d inside the set inside a datatype value d is structurally included in d (and thus d < d), but we wouldn't need to apply the parent trick to pass the context as a parameter. i will show such an example below (see function maxlen in section 6).\n\n\n# 3.âtwo more remarks\n\nfirst, in presenting the program above, i explicitly showed the decreases clauses. but if you list the parameters in the order that i did, then the explicit decreases clause will coincide with dafny's defaults. so, you can omit the decreases clauses and the verifier will still be able to prove the program.\n\nsecond, as i wrote them, the functions are ghost, so they are erased by the compiler and not available at run time. if you want the functions to be available at run time, you might be bothered by having to pass the âparentâ parameter along everywhere. this is easily solved by then marking the âparentâ parameter as ghost. this is possible, because parent is not used by the function, other than for its proof, so it's fine if the compiler erases the parameter.\n\n\n# 4.âsegue into an arduous journey\n\nif you try doing what i just said in the two remarks, the functions will be declared as follows:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children.values)\n}\n\nfunction method maxlenforest(ghost parent: stringset, trees: set<stringset>): nat\n  requires forall t :: t in trees ==> t < parent\n{\n  if trees == {} then\n    0\n  else\n    var t :| t in trees;\n    var m := maxlen(t);\n    var n := maxlenforest(parent, trees - {t});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nbut you'll notice an error:\n\nvar t :| t in trees;\n^ here\nerror: to be compilable, the value of a let-such-that expression must be\nuniquely determined\n\n\n1\n2\n3\n4\n\n\nthis is a completely different problem than the termination problem we worked to solve above. the problem is that the choice of a t that satisfies t in trees is not unique, as is required for compiling the let-such-that expression. the reasons for this restriction are explained in a different paper [0]. if you don't care about compiling maxlen, you can stop reading now. otherwise, stretch your legs, get more coffee, and keep reading.\n\n\n# 5.âmaking a unique choice\n\nto make the choice of t unique, we need to strengthen the constraint in the let-such-that expression. for example, we might want to pick the âsmallestâ of the values in trees. but what does âsmallestâ mean among a set of stringset trees? an easier way out is to change the program to pass the whole map tree.children to maxlenforest, rather than just the children trees themselves (tree.childre.values). then, we can pick the smallest among the labels, whichâsince our labels have type charâis easy to do. here's what we get:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    1 + maxlenforest(tree, tree.children)\n}\n\nfunction method maxlenforest(ghost parent: stringset,\n                             children: map<char, stringset>): nat\n  requires forall lbl :: lbl in children.keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    var lbl :|\n      lbl in children.keys &&\n      forall lbl' :: lbl' in children.keys ==> lbl <= lbl';\n    var m := maxlen(children[lbl]);\n    var n := maxlenforest(parent, children - {lbl});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nnote that the expression children - {lbl} is a map-domain subtraction. that is, it denotes the map that is like children, except it doesn't have the key lbl.\n\nthe additional constraint makes the choice unique. however, now that we've strengthened it, the verifier is no longer convinced there is any choice for lbl. to fix this problem, we need to demonstrate that every nonempty set of characters has a smallest element. the easiest way to conduct such a demonstration is to compute it:\n\nfunction picksmallest(s: set<char>): (ch: char)\n  requires s != {}\n  ensures ch in s && forall ch' :: ch' in s ==> ch <= ch'\n{\n  var ch :| ch in s;\n  if ch' :| ch' in s && ch' < ch then\n    var s' := s - {ch};\n    assert s == s' + {ch};\n    picksmallest(s')\n  else\n    ch\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nâbut wait!â, you say. \"how come this function gets away with the weak let-such-that constraint that was a problem in maxlenforest?\" it's because picksmallest is a ghost function, so its let-such-that expression does not have the uniqueness requirement (see [0]). alright, then, so our final step is to use function picksmallest just before the let-such-that expression in maxlenforest:\n\nfunction method maxlenforest(ghost parent: stringset,\n                             children: map<char, stringset>): nat\n  requires forall lbl :: lbl in children.keys ==> children[lbl] < parent\n{\n  if children == map[] then\n    0\n  else\n    ghost var smallest := picksmallest(children.keys);\n    var lbl :|\n      lbl in children.keys &&\n      forall lbl' :: lbl' in children.keys ==> lbl <= lbl';\n    var m := maxlen(children[lbl]);\n    var n := maxlenforest(parent, children - {lbl});\n    maximum(m, n)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nafter putting the result of picksmallest into a ghost variable, the verifier has all the evidence it needs for the existence of a value of lbl. so, this concludes our program.\n\n\n# 6.ârestructuring the recursion\n\nthe running example has already showed several techniques and features in dafny. but in our final program above, we still have a rather big and unsatisfying let-such-that constraint. the mandate that we have to pick a unique element from the set seems unnecessarily harsh, since all we're trying to do is compute the maximum of a set, and the maximum will be the same regardless of which order we consider the elements in. so, what we'd like to do is use nondeterminism inside maxlenforest, as long as we can prove that the nondeterminism does not affect the result. and dafny has just the feature for this: function-by-method declarations.\n\nto make a reusable function, let's define a general function max as follows:\n\nfunction method max(s: set<int>): int\n  requires s != {}\n  ensures max(s) in s\n  ensures forall z :: z in s ==> z <= max(s)\n\n\n1\n2\n3\n4\n\n\nby constructing the set of elements we want to take the maximum of, we can use max in maxlen:\n\nfunction method maxlen(tree: stringset): nat {\n  if tree.children == map[] then\n    0\n  else\n    var s := set t | t in tree.children.values :: maxlen(t);\n    assert s != {} by {\n      assert forall lbl ::\n        lbl in tree.children.keys ==> maxlen(tree.children[lbl]) in s;\n    }\n    1 + max(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nas you see here, the verifier needed help in proving that s is nonempty. this proof obligation is addressed by asserting that, for every label in (the known to be nonempty) tree.children, s contains the maxlen of the corresponding value. (since maxlen is now recursive and doesn't go through a mutually recursive function like maxlenforest, we don't need the parent trick. that is, there's no longer a need to pass any additional context parameter.)\n\n\n# 7.âa more efficient choice\n\nfrom now on, we'll focus just on max. it would be nice to write its body as\n\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := max(s');\n    maximum(x, y)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nalas, this is not allowed, because the compiled let-such-that does not uniquely determine the value for x. this is the exactly the problem that we started with and want to steer around!\n\nfunction-by-method to the rescue.\n\n\n# 8.âfunction-by-method\n\nsay what?! a function-by-method is a combination of a function and method. the body of the function part of a function-by-method is a ghost expression, but this expression acts just as the specification for what value is to be returned. the body of the method part of the function-by-method then gives a compilable method body for computing the value.\n\nusing a bit of program text, the basic idea is to declare a function-by-method like\n\nfunction f(x: x): (y: y)\n  requires pre(x)\n  ensures post(x, y)\n{\n  expr;\n} by method {\n  mbody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nwhere expr is a ghost expression (the âfunction partâ) and mbody is a compilable statement list (the âmethod partâ).\n\nto explain the meaning of this function-by-method, it's helpful to look at it as two declarations:\n\nfunction f(x: x): (y: y)\n  requires pre(x)\n  ensures post(x, y)\n{\n  expr;\n}\n\nmethod _f(x: x) returns (y: y)\n  requires pre(x)\n  ensures y == f(x)\n{\n  mbody;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nnow, dafny arranges that every use of the original function-by-method in a ghost context calls ghost function f, and that every use of the function-by-method is a non-ghost context calls the compiled method _f.\n\nnote that any ensures clause on the original function-by-method is a proof obligation of the function part. the postcondition of the method part is y == f(x). (i'll come back to this point later.)\n\n\n# 9.âmax as a function-by-method\n\nusing a function-by-method declaration, we write max as follows:\n\nfunction max(s: set<int>): (m: int)\n  requires s != {}\n  ensures m in s && forall z :: z in s ==> z <= m\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := max(s');\n    maximum(x, y)\n} by method {\n   m :| m in s;\n   var r := s - {m};\n   while r != {}\n     invariant r < s\n     invariant m in s && forall z :: z in s - r ==> z <= m\n   {\n     var x :| x in r;\n     assert forall z :: z in s - (r - {x}) ==> z in s - r || z == x;\n     r := r - {x};\n     if m < x {\n       m := x;\n     }\n   }\n   assert s - {} == s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nthis function-by-method verifies as given. however, the reason it verifies is subtle and may not be what you expect (especially if this is the first time you see a function-by-method). let me explain the reason and then show a more typical proof of a function-by-method.\n\nthe point of the method part of a function-by-method is to provide a method implementation that returns exactly the same value as the given function body. for this reason, the postcondition that the method body has to satisfy is m == max(s). this is a very precise postcondition. the ensures clause declared in the function-by-method applies to the function part. it is usually much less precise; in fact, for most functions, this ensures clause is omitted, since the body of the function transparently says what the result value is.\n\nin general, just because the method part of a function-by-method happens to satisfy the ensures clause of the function-by-method does not mean the method part is correct. but in our max example, the two coincide, because the ensures clause i gave for the function-by-method uniquely determines m. thus, any method body that satisfies this ensures clause also satisfies m == max(s). (you can confirm this by deleting m in s from the ensures clause. this will cause the method part to fail to verify, while the function part still verifies.)\n\n\n# 10.âa more common situation\n\na more generally applicable pattern for proving the method part of a recursive makes use of the function in the loop invariant. to illustrate this, i will remove the ensures clause of max. consequently, the iterative method body needs to establish that it computes exactly what the recursion function body does.\n\nthe idea is to use a body like this:\n\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == max(r)\n  {\n    var x :| x in s - r;\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nthis loops maintains the invariant m == max(r) while enlarging r until it becomes s. doing this proof is tricky, because of two issues. both of these issues have standard solutions, which are really good to know. the two issues and solutions are explained for a simpler example in another dafny power user note [1], but it seems worthwhile to show them here as well.\n\n\n# 11.ânaming the choice\n\nthe first issue is that the let-such-that expression is like a function, but by dafny semantics it may be a different function for each textual occurrence of :| (see [0]). it is easy to become confused and frustrated if, without realizing it, you're using more than one :| function. therefore, let's make sure there is only one textual occurrence of this operator. we do that by putting it inside a named function:\n\nfunction pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\n\n\n1\n2\n3\n4\n5\n\n\nwith this function, we write the function part of the function-by-method max as\n\n  var x := pick(s);\n  if s == {x} then\n    x\n  else\n    maximum(max(s - {x}), x)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 12.âwhat you remove may differ from what you just added\n\nthe second issue is that we will need to help the verifier along in the proof of invariance for the loop. the reason is that the next element that the loop adds to the growing set r may not be the same element that the pick function would choose when going in the opposite direction. specifically, if the loop adds x to r as it's computing max(r + {x}), there's no reason to believe that the definition of max(r + {x}) picks x and recurses on max(r). (again, for a simpler example and better motivation, see [1].)\n\nthis lemma is tricky to prove, even if you've written similar proofs several times. an additional complication for our function max is that max requires its argument to be nonempty. here is the lemma and a proof:\n\nlemma maxofonemore(t: set<int>, x: int)\n  requires t != {} && x !in t\n  ensures max(t + {x}) == maximum(max(t), x)\n  decreases |t|\n{\n  var u := t + {x};\n  var z := pick(u);\n  var u'x, u'z := u - {x}, u - {z};\n  assert max(u) == maximum(max(u'z), z);\n\n  if z == x {\n    // straight from the definition of max\n  } else if t == {z} {\n    assert u'z == {x} && u'x == {z};\n    // this is known about max on singletons:\n    assert max(u'z) == x;\n    assert max(u'x) == z;\n    // so, regardless of which of x and z gets picked first, the result is the same\n    assert max(u) == maximum(x, z) == maximum(z, x);\n  } else {\n    var u'z'x := u'z - {x};\n    calc {\n      maximum(max(u'z), z);\n    ==  { assert u'z == (u'z'x) + {x}; }\n      maximum(max((u'z'x) + {x}), z);\n    ==  { maxofonemore(u'z'x, x); }\n      maximum(maximum(max(u'z'x), x), z);\n    ==  // maximum is commutative and associative\n      maximum(maximum(max(u'z'x), z), x);\n    ==  { maxofonemore(u'z'x, z); }\n      maximum(max(u'z'x + {z}), x);\n    ==  { assert u'z'x + {z} == u'x == t; }\n      maximum(max(t), x);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nthat's a mouthful. but once you have the lemma, using it once in the loop body finishes the proof of our function-by-method:\n\nfunction max(s: set<int>): (m: int)\n  requires s != {}\n{\n  var x := pick(s);\n  if s == {x} then\n    x\n  else\n    maximum(max(s - {x}), x)\n} by method {\n  m :| m in s;\n  var r := {m};\n  while r != s\n    invariant {} != r <= s\n    invariant m == max(r)\n  {\n    var x :| x in s - r;\n    maxofonemore(r, x);\n    r := r + {x};\n    if m < x {\n      m := x;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 13.âtermination\n\na final remark. it looks as if max uses the lemma maxofonemore, and the lemma uses max. doesn't this mutual recursion mean we have to prove termination? no, because there's isn't actually any mutual recursion in this example. to understand why, remember that the two parts of a function-by-method are treated as if they were one function and one method (see section 8). this function and method are different points in the call graph, where calls to max from ghost contexts go to the function part and calls to max from compiled contexts go to the method part. therefore, we have that the following call-graph edges:\n\nmax (function) --\x3e max (function)\nmaxofonemore   --\x3e maxofonemore, max (function)\nmax (method)   --\x3e maxofonemore, max (function)\n\n\n1\n2\n3\n\n\nas you can see from these, the function part of max is recursive and the lemma is recursive, but there is no mutual recursion.\n\n\n# 14.âsummary\n\ni started this note with the innocent problem of how to prove the termination of two mutually recursive functions. as the solution, i showed the parent trick. i then changed the code to make it compilable, which introduced proof obligations to show certain choices to be deterministic. this can be better solved using a function-by-method, so i gave a brief introduction to dafny's function-by-method declaration and used it to present two solutions. the more straightforward solution worked for the example at hand, whereas the second solution shows a more typical pattern for such method implementations.\n\n# acknowledgments\n\ni'm grateful to mikael mayer for asking a question about these mutually recursive functions, which propelled me to write this note, and for his helpful comments on the write-up. the function-by-method construct was designed as a direct outgrowth of some collaborative work with daniel matichuk, olivier savary belanger, and mike dodds, where as a step toward verified compilation we were considering how to implement immutable things with mutable things.\n\n\n# references\n\n[0]k. rustan m. leino. compiling hilbert's epsilon operator. in ansgar fehnker, annabelle mciver, geoff sutcliffe, and andrei voronkov, editors, lpar-20. 20th international conferences on logic for programming, artificial intelligence and reasoning â short presentations, volume 35 of epic series in computing, pages 106â118. easychair, 2015. https://easychair.org/publications/paper/dm. ð\n\n[1]k. rustan m. leino. dafny power user: functions over set elements. manuscript krml 274, february 2020. http://leino.science/papers/krml274.html. ð",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Type-Parameter Completion",frontmatter:{title:"Type-Parameter Completion",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c45b5a/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/60.Type-Parameter%20Completion.html",relativePath:"80.è¯­è¨/30.publication-lecture/60.Type-Parameter Completion.md",key:"v-b98a2e5c",path:"/pages/c45b5a/",headers:[{level:2,title:"[#](http://leino.science/papers/krml270.html#sec-type-parameters)0.âType Parameters",slug:"_0-type-parameters",normalizedTitle:'<a href="http://leino.science/papers/krml270.html#sec-type-parameters" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>0.âtype parameters',charIndex:null},{level:2,title:"1.âExamples",slug:"_1-examples",normalizedTitle:"1.âexamples",charIndex:1887},{level:2,title:"2.âFilling in Missing Type Arguments",slug:"_2-filling-in-missing-type-arguments",normalizedTitle:"2.âfilling in missing type arguments",charIndex:3101},{level:3,title:"2.0.âExample: One type parameter",slug:"_2-0-example-one-type-parameter",normalizedTitle:"2.0.âexample: one type parameter",charIndex:3524},{level:3,title:"2.1.âExample: Two type parameters",slug:"_2-1-example-two-type-parameters",normalizedTitle:"2.1.âexample: two type parameters",charIndex:4223},{level:3,title:"2.2.âExample: Nested type parameters",slug:"_2-2-example-nested-type-parameters",normalizedTitle:"2.2.âexample: nested type parameters",charIndex:6671},{level:3,title:"2.3.âExample: Datatype",slug:"_2-3-example-datatype",normalizedTitle:"2.3.âexample: datatype",charIndex:7229},{level:2,title:"3.âAuto-Declaring Type Parameters",slug:"_3-auto-declaring-type-parameters",normalizedTitle:"3.âauto-declaring type parameters",charIndex:7431},{level:3,title:"3.0.âExamples",slug:"_3-0-examples",normalizedTitle:"3.0.âexamples",charIndex:7956},{level:3,title:"3.1.âSometimes you need formal type parameters",slug:"_3-1-sometimes-you-need-formal-type-parameters",normalizedTitle:"3.1.âsometimes you need formal type parameters",charIndex:9018},{level:2,title:"4.âFinal Notes",slug:"_4-final-notes",normalizedTitle:"4.âfinal notes",charIndex:9820}],headersStr:"[#](http://leino.science/papers/krml270.html#sec-type-parameters)0.âType Parameters 1.âExamples 2.âFilling in Missing Type Arguments 2.0.âExample: One type parameter 2.1.âExample: Two type parameters 2.2.âExample: Nested type parameters 2.3.âExample: Datatype 3.âAuto-Declaring Type Parameters 3.0.âExamples 3.1.âSometimes you need formal type parameters 4.âFinal Notes",content:"Dafny Power User: Type-Parameter Completion\n\nK. Rustan M. Leino\n\nManuscript KRML 270, 22 June 2019\n\nAbstract. When type parameters don't need to be named, Dafny has a scheme for filling them in automatically. Omitting the type parameters reduces clutter in function signatures. This note describes how the type parameters get filled in.\n\n\n# #0.âType Parameters\n\nAs in many languages, types in Dafny can be parameterized by other types. For example, the type set<int> denotes finite sets of integers and is parameterized by int. As another example, if List is a type defined as\n\ndatatype List<A> = Nil | Cons(A, List<A>)\n\n\n1\n\n\nand Expr is a type denoting expressions, then List<Expr> is a type that is parameterized by Expr. In the declaration of List, A is a formal type parameter, and in the type List<Expr>, Expr is the actual type parameter (or, actual type argument).\n\nSince set and List each requires a type parameter, they are not themselves types. That is, it doesn't make sense for a variable to have type set. We say that set and List are type constructors. More precisely, they are unary type constructors, since they take one type parameter. Each type constructor has an arity, which says how many type parameters it needs. So, a unary type constructor has arity 1. (There are no type constructors with arity 0; such a thing is simply a type.)\n\nIn Dafny, type constructors are not first class. This means that every mention of a type constructor must always be fully instantiated. However, the instantiation need not be explicit in the program text.\n\nIn the signature declarations of datatypes, functions, and methods, Dafny allows type constructors to be used without explicit type parameters. In this note, I describe Dafny's scheme for filling in those missing type parameters.0\n\nLet's start by looking at two examples that show the advantages of having such a scheme.\n\n\n# 1.âExamples\n\nHere are functions for computing the length of a list and for computing the set of elements in a list.\n\nfunction method Length(list: List): nat {\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction method Elements(list: List): set {\n  match list\n  case Nil => {}\n  case Cons(x, tail) => {x} + Elements(tail)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAt first glance, they look to be exactly what you expect. But if you think some more, you will notice that List and set have no given type parameters. This is delightful! Both Length and Elements have more to do with the structure of the list than with the types of the elements stored in the list, and therefore it's nice that the definitions of these functions don't need to be cluttered up with the declaration and uses of the type parameters.\n\nIf you wrote the type parameters explicitly, the signatures of the functions above would look like this:\n\nfunction method Length<A>(list: List<A>): nat\nfunction method Elements<A>(list: List<A>): set<A>\n\n\n1\n2\n\n\nYou'll agree this is rather heavy on the <A>'s.1\n\nSo that you can use these abridged signatures effectively, let's now look at how omitted type parameters are filled in.\n\n\n# 2.âFilling in Missing Type Arguments\n\nIn the type signatures of functions and methods and in the right-hand side of (the \"=\" in) datatype definitions, type parameters can be omitted. The rule is that if the type signature or right-hand side mentions a type constructor without any type arguments, then Dafny will fill these in from a prefix of the formal type parameters of the enclosing function, method, or datatype.\n\n\n# 2.0.âExample: One type parameter\n\nSuppose the program text includes the following function signature:\n\nfunction method ReverseAux<A>(list: List<A>, acc: List): List<A>\n\n<A>\n\n\n1\n2\n3\n\n\nNote that List in the type of acc does not have an explicit type argument. Dafny now fills in the type parameter of List using the type parameter of function ReverseAux, completing the type of acc List<A>, as illustrated by the arrow above.2\n\nThe type arguments to the other occurrences of List in the function's type signature can be filled in in the same manner. So, the same function ReverseAux can be declared simply as:\n\nfunction method ReverseAux<A>(list: List, acc: List): List\n\n\n<A>``<A>``<A>\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.âExample: Two type parameters\n\nConsider a datatype Path with two type parameters:\n\ndatatype Path<L,R> = Stop | Left(L, Path<L,R>) | Right(R, Path<L,R>)\n\n\n1\n\n\nA value of type Path<L,R> represents a finite path of left- and right-turns. Each left-step is accompanied by a value (call it a âbreadcrumbâ, if you wish) of type L and every right-step is accompanied by a breadcrumb of type R.\n\nHere are two functions on paths. Hansel picks up all the breadcrumbs encountered on left turns and Gretel picks up all the breadcrumbs encountered on right turns.\n\nfunction Hansel<L,R>(p: Path<L,R>): List<L> {\n  match p\n  case Stop => Nil\n  case Left(l, rest) => Cons(l, Hansel(rest))\n  case Right(_, rest) => Hansel(rest)\n}\n\nfunction Gretel<L,R>(p: Path<L,R>): List<R> {\n  match p\n  case Stop => Nil\n  case Left(_, rest) => Gretel(rest)\n  case Right(r, rest) => Cons(r, Gretel(rest))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nUsing Dafny's type-parameter completion, we can write these as:\n\ndatatype Path<L,R> = Stop | Left(L, Path) | Right(R, Path)\n\n\n\n\nfunction Hansel<L,R>(p: Path): List\n\n\n\nfunction Gretel<L,R>(p: Path): List<R>\n\n<L,R>``<L,R>\n<L,R>``<L>\n<L,R>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nNote that both occurrences of Path in the right-hand side of the declaration of type Path get both type arguments filled in with the type's type parameters <L,R> given in the left-hand side of the declaration. In both of the functions, Path also gets the arguments <L,R> as declared in the functions. Moreover, for Hansel, type List automatically gets the argument <L>, because List needs one argument and therefore it only picks up a prefix of the function's type parameters <L,R>. Function Gretel has result type List<R>. Here, it is not possible to elide the type argument list <R>, since <R> is not a prefix of <L,R>.\n\nThe example illustrates how type-parameter completion picks a prefix of the enclosing function's type parameters. This allows you to write just List instead of List<L>. However, since L and R otherwise play symmetric roles in this example, you can of course also choose to write out List<L> explicitly. You may argue that doing so more clearly highlights the difference between functions Hansel and Gretel. You would then write the following signatures:\n\ndatatype Path<L,R> = Stop | Left(L, Path) | Right(R, Path)\nfunction Hansel<L,R>(p: Path): List<L>\nfunction Gretel<L,R>(p: Path): List<R>\n\n\n1\n2\n3\n\n\nwhich still looks pretty clean.\n\n\n# 2.2.âExample: Nested type parameters\n\nType-parameter completion applies not just to the outermost types. For example,\n\ndatatype Tree<A> = Node(children: List<Tree<A>>)\n\n\n1\n\n\ncan also be written as\n\ndatatype Tree<A> = Node(children: List<Tree>)\n  \n<A>\n\n\n1\n2\n3\n\n\nNote that if you supply any type parameters at all, then Dafny will not change or complete the list you have given. The completion rule supplies the parameters to a type constructor only if the type constructor is mentioned with no type arguments at all (that is, without any angle brackets).\n\n\n# 2.3.âExample: Datatype\n\nType-parameter completion also applies in the right-hand side of datatypes. So, if you want to, you can declare List as follows:\n\ndatatype List<A> = Nil | Cons(A, List)\n\n\n1\n\n\n\n# 3.âAuto-Declaring Type Parameters\n\nWhat I described so far pertains to the actual type arguments of type constructors in signatures. There's one more part to Dafny's type-parameter completion. For functions and methods, but not for datatypes, if the function or method is declared without explicit formal type parameters, then Dafny provides these as well. This list of formal type parameters in this completion will be made long enough to cover the length of any missing type-argument list described in Section 2 above.\n\n\n# 3.0.âExamples\n\nAs we saw in Section 2.0 above, function ReverseAux can omit the uses of its type parameter A. Consequently, there is no need for the signature to mention A by name. Dafny's type-parameter auto-declaration rule allows us to omit A altogether. By doing so, we can declare ReverseAux simply as\n\nfunction method ReverseAux(list: List, acc: List): List\n\n\n1\n\n\n<A>``<A>``<A>\n\n\n1\n\n\nThis declaration says that ReverseAux takes two lists and returns a list. There's no need to explicitly mention the type of list elements, and it is tacitly understood that the three lists mentioned have the same type of elements.\n\nWe already saw two other examples in the motivational Section 3.0: Length and Elements. Function Elements relies on type-parameter completion in three ways: both the user-defined type constructor List and the built-in type constructor set are completed with the same type parameter and this (un-named) type parameter is added to the formal type parameters of the function.\n\nfunction method Elements(list: List): set\n\n\n1\n\n\n<A>``<A>\n\n\n1\n\n\n\n# 3.1.âSometimes you need formal type parameters\n\nNote that you cannot take advantage of the auto-declaration part of type-parameter completion if you have a need to mention the type parameter. For example, you can shorten the signature of Snoc to:\n\nfunction method Snoc<A>(list: List, a: A): List {\n  match list\n  case Nil => Cons(a, Nil)\n  case Cons(x, tail) => Cons(x, Snoc(tail, a))\n}\n\n\n1\n2\n3\n4\n5\n\n\nBut since a's type needs to be mentioned as A, you must declare A explicitly. That is, you cannot abbreviate Snoc's type signature more than this.\n\nActual type parameters are completed in the right-hand side of datatype declarations, but auto-declaration of formal type parameters does not apply to datatypes. For example, you cannot omit the <A> in the left-hand side of the declaration of List.\n\n\n# 4.âFinal Notes\n\nRecall that if you supply any type parameters at all, then Dafny will not extend the list you have given. The completion rule will supply type parameters to a function or method only if the function or method is declared with no type parameters at all (that is, without any angle brackets).\n\nFinally, remember that Dafny's type-parameter completion is a feature, not a requirement. If you don't want to make use of this completion, then by all means, feel free to write out all formal type parameters and actual type arguments explicitly in your own programs.\n\n----------------------------------------\n\n0.Dafny's scheme for filling in type parameters in signature declarations is one of two mechanisms that the language employs to reduce type clutter in the program text. The other mechanism is type inference, which tries to figure out types of variables and expressions based on how these are used. In this Power note, I will not talk about type inference. â©\n\n1.The compiled function Elements makes use of one other thing that Dafny fills in automatically, namely the fact that the argument to set needs to be a type that supports equality in compiled contexts. If you wrote this explicitly, the function signature would be\n\nfunction method Elements<A(==)>(list: List<A>): set<A>\n\n\n1\n\n\nIn this note, I won't say more about equality-supporting types or how Dafny tries to infer these. â©\n\n2.The Dafny IDE in Visual Studio displays type information in tool tips. If you hover the mouse over acc in this IDE, the tool tip that pops up will tell you the full type of acc, namely List<A>. In the future, the other Dafny IDEs may also show such type tool-tips. â©",normalizedContent:"dafny power user: type-parameter completion\n\nk. rustan m. leino\n\nmanuscript krml 270, 22 june 2019\n\nabstract. when type parameters don't need to be named, dafny has a scheme for filling them in automatically. omitting the type parameters reduces clutter in function signatures. this note describes how the type parameters get filled in.\n\n\n# #0.âtype parameters\n\nas in many languages, types in dafny can be parameterized by other types. for example, the type set<int> denotes finite sets of integers and is parameterized by int. as another example, if list is a type defined as\n\ndatatype list<a> = nil | cons(a, list<a>)\n\n\n1\n\n\nand expr is a type denoting expressions, then list<expr> is a type that is parameterized by expr. in the declaration of list, a is a formal type parameter, and in the type list<expr>, expr is the actual type parameter (or, actual type argument).\n\nsince set and list each requires a type parameter, they are not themselves types. that is, it doesn't make sense for a variable to have type set. we say that set and list are type constructors. more precisely, they are unary type constructors, since they take one type parameter. each type constructor has an arity, which says how many type parameters it needs. so, a unary type constructor has arity 1. (there are no type constructors with arity 0; such a thing is simply a type.)\n\nin dafny, type constructors are not first class. this means that every mention of a type constructor must always be fully instantiated. however, the instantiation need not be explicit in the program text.\n\nin the signature declarations of datatypes, functions, and methods, dafny allows type constructors to be used without explicit type parameters. in this note, i describe dafny's scheme for filling in those missing type parameters.0\n\nlet's start by looking at two examples that show the advantages of having such a scheme.\n\n\n# 1.âexamples\n\nhere are functions for computing the length of a list and for computing the set of elements in a list.\n\nfunction method length(list: list): nat {\n  match list\n  case nil => 0\n  case cons(_, tail) => 1 + length(tail)\n}\n\nfunction method elements(list: list): set {\n  match list\n  case nil => {}\n  case cons(x, tail) => {x} + elements(tail)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nat first glance, they look to be exactly what you expect. but if you think some more, you will notice that list and set have no given type parameters. this is delightful! both length and elements have more to do with the structure of the list than with the types of the elements stored in the list, and therefore it's nice that the definitions of these functions don't need to be cluttered up with the declaration and uses of the type parameters.\n\nif you wrote the type parameters explicitly, the signatures of the functions above would look like this:\n\nfunction method length<a>(list: list<a>): nat\nfunction method elements<a>(list: list<a>): set<a>\n\n\n1\n2\n\n\nyou'll agree this is rather heavy on the <a>'s.1\n\nso that you can use these abridged signatures effectively, let's now look at how omitted type parameters are filled in.\n\n\n# 2.âfilling in missing type arguments\n\nin the type signatures of functions and methods and in the right-hand side of (the \"=\" in) datatype definitions, type parameters can be omitted. the rule is that if the type signature or right-hand side mentions a type constructor without any type arguments, then dafny will fill these in from a prefix of the formal type parameters of the enclosing function, method, or datatype.\n\n\n# 2.0.âexample: one type parameter\n\nsuppose the program text includes the following function signature:\n\nfunction method reverseaux<a>(list: list<a>, acc: list): list<a>\n\n<a>\n\n\n1\n2\n3\n\n\nnote that list in the type of acc does not have an explicit type argument. dafny now fills in the type parameter of list using the type parameter of function reverseaux, completing the type of acc list<a>, as illustrated by the arrow above.2\n\nthe type arguments to the other occurrences of list in the function's type signature can be filled in in the same manner. so, the same function reverseaux can be declared simply as:\n\nfunction method reverseaux<a>(list: list, acc: list): list\n\n\n<a>``<a>``<a>\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.âexample: two type parameters\n\nconsider a datatype path with two type parameters:\n\ndatatype path<l,r> = stop | left(l, path<l,r>) | right(r, path<l,r>)\n\n\n1\n\n\na value of type path<l,r> represents a finite path of left- and right-turns. each left-step is accompanied by a value (call it a âbreadcrumbâ, if you wish) of type l and every right-step is accompanied by a breadcrumb of type r.\n\nhere are two functions on paths. hansel picks up all the breadcrumbs encountered on left turns and gretel picks up all the breadcrumbs encountered on right turns.\n\nfunction hansel<l,r>(p: path<l,r>): list<l> {\n  match p\n  case stop => nil\n  case left(l, rest) => cons(l, hansel(rest))\n  case right(_, rest) => hansel(rest)\n}\n\nfunction gretel<l,r>(p: path<l,r>): list<r> {\n  match p\n  case stop => nil\n  case left(_, rest) => gretel(rest)\n  case right(r, rest) => cons(r, gretel(rest))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nusing dafny's type-parameter completion, we can write these as:\n\ndatatype path<l,r> = stop | left(l, path) | right(r, path)\n\n\n\n\nfunction hansel<l,r>(p: path): list\n\n\n\nfunction gretel<l,r>(p: path): list<r>\n\n<l,r>``<l,r>\n<l,r>``<l>\n<l,r>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nnote that both occurrences of path in the right-hand side of the declaration of type path get both type arguments filled in with the type's type parameters <l,r> given in the left-hand side of the declaration. in both of the functions, path also gets the arguments <l,r> as declared in the functions. moreover, for hansel, type list automatically gets the argument <l>, because list needs one argument and therefore it only picks up a prefix of the function's type parameters <l,r>. function gretel has result type list<r>. here, it is not possible to elide the type argument list <r>, since <r> is not a prefix of <l,r>.\n\nthe example illustrates how type-parameter completion picks a prefix of the enclosing function's type parameters. this allows you to write just list instead of list<l>. however, since l and r otherwise play symmetric roles in this example, you can of course also choose to write out list<l> explicitly. you may argue that doing so more clearly highlights the difference between functions hansel and gretel. you would then write the following signatures:\n\ndatatype path<l,r> = stop | left(l, path) | right(r, path)\nfunction hansel<l,r>(p: path): list<l>\nfunction gretel<l,r>(p: path): list<r>\n\n\n1\n2\n3\n\n\nwhich still looks pretty clean.\n\n\n# 2.2.âexample: nested type parameters\n\ntype-parameter completion applies not just to the outermost types. for example,\n\ndatatype tree<a> = node(children: list<tree<a>>)\n\n\n1\n\n\ncan also be written as\n\ndatatype tree<a> = node(children: list<tree>)\n  \n<a>\n\n\n1\n2\n3\n\n\nnote that if you supply any type parameters at all, then dafny will not change or complete the list you have given. the completion rule supplies the parameters to a type constructor only if the type constructor is mentioned with no type arguments at all (that is, without any angle brackets).\n\n\n# 2.3.âexample: datatype\n\ntype-parameter completion also applies in the right-hand side of datatypes. so, if you want to, you can declare list as follows:\n\ndatatype list<a> = nil | cons(a, list)\n\n\n1\n\n\n\n# 3.âauto-declaring type parameters\n\nwhat i described so far pertains to the actual type arguments of type constructors in signatures. there's one more part to dafny's type-parameter completion. for functions and methods, but not for datatypes, if the function or method is declared without explicit formal type parameters, then dafny provides these as well. this list of formal type parameters in this completion will be made long enough to cover the length of any missing type-argument list described in section 2 above.\n\n\n# 3.0.âexamples\n\nas we saw in section 2.0 above, function reverseaux can omit the uses of its type parameter a. consequently, there is no need for the signature to mention a by name. dafny's type-parameter auto-declaration rule allows us to omit a altogether. by doing so, we can declare reverseaux simply as\n\nfunction method reverseaux(list: list, acc: list): list\n\n\n1\n\n\n<a>``<a>``<a>\n\n\n1\n\n\nthis declaration says that reverseaux takes two lists and returns a list. there's no need to explicitly mention the type of list elements, and it is tacitly understood that the three lists mentioned have the same type of elements.\n\nwe already saw two other examples in the motivational section 3.0: length and elements. function elements relies on type-parameter completion in three ways: both the user-defined type constructor list and the built-in type constructor set are completed with the same type parameter and this (un-named) type parameter is added to the formal type parameters of the function.\n\nfunction method elements(list: list): set\n\n\n1\n\n\n<a>``<a>\n\n\n1\n\n\n\n# 3.1.âsometimes you need formal type parameters\n\nnote that you cannot take advantage of the auto-declaration part of type-parameter completion if you have a need to mention the type parameter. for example, you can shorten the signature of snoc to:\n\nfunction method snoc<a>(list: list, a: a): list {\n  match list\n  case nil => cons(a, nil)\n  case cons(x, tail) => cons(x, snoc(tail, a))\n}\n\n\n1\n2\n3\n4\n5\n\n\nbut since a's type needs to be mentioned as a, you must declare a explicitly. that is, you cannot abbreviate snoc's type signature more than this.\n\nactual type parameters are completed in the right-hand side of datatype declarations, but auto-declaration of formal type parameters does not apply to datatypes. for example, you cannot omit the <a> in the left-hand side of the declaration of list.\n\n\n# 4.âfinal notes\n\nrecall that if you supply any type parameters at all, then dafny will not extend the list you have given. the completion rule will supply type parameters to a function or method only if the function or method is declared with no type parameters at all (that is, without any angle brackets).\n\nfinally, remember that dafny's type-parameter completion is a feature, not a requirement. if you don't want to make use of this completion, then by all means, feel free to write out all formal type parameters and actual type arguments explicitly in your own programs.\n\n----------------------------------------\n\n0.dafny's scheme for filling in type parameters in signature declarations is one of two mechanisms that the language employs to reduce type clutter in the program text. the other mechanism is type inference, which tries to figure out types of variables and expressions based on how these are used. in this power note, i will not talk about type inference. â©\n\n1.the compiled function elements makes use of one other thing that dafny fills in automatically, namely the fact that the argument to set needs to be a type that supports equality in compiled contexts. if you wrote this explicitly, the function signature would be\n\nfunction method elements<a(==)>(list: list<a>): set<a>\n\n\n1\n\n\nin this note, i won't say more about equality-supporting types or how dafny tries to infer these. â©\n\n2.the dafny ide in visual studio displays type information in tool tips. if you hover the mouse over acc in this ide, the tool tip that pops up will tell you the full type of acc, namely list<a>. in the future, the other dafny ides may also show such type tool-tips. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"Type-parameter modes variance and cardinality preservation",frontmatter:{title:"Type-parameter modes variance and cardinality preservation",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/3c9a0b/",categories:["è¯­è¨","publication-lecture"],tags:[null],readingShow:"top"},regularPath:"/80.%E8%AF%AD%E8%A8%80/30.publication-lecture/65.Type-parameter%20modes%20variance%20and%20cardinality%20preservation.html",relativePath:"80.è¯­è¨/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md",key:"v-1cf80342",path:"/pages/3c9a0b/",headers:[{level:2,title:"0.âSubtypes",slug:"_0-subtypes",normalizedTitle:"0.âsubtypes",charIndex:1472},{level:2,title:"1.âType parameters",slug:"_1-type-parameters",normalizedTitle:"1.âtype parameters",charIndex:2816},{level:2,title:"2.âVariance",slug:"_2-variance",normalizedTitle:"2.âvariance",charIndex:3929},{level:3,title:"2.0.âCo-variance",slug:"_2-0-co-variance",normalizedTitle:"2.0.âco-variance",charIndex:4213},{level:3,title:"2.1.âContra-variance",slug:"_2-1-contra-variance",normalizedTitle:"2.1.âcontra-variance",charIndex:5067},{level:3,title:"2.2.âNon-variance",slug:"_2-2-non-variance",normalizedTitle:"2.2.ânon-variance",charIndex:6145},{level:2,title:"3.âDeclaring variance",slug:"_3-declaring-variance",normalizedTitle:"3.âdeclaring variance",charIndex:6895},{level:2,title:"4.âPositive and negative positions",slug:"_4-positive-and-negative-positions",normalizedTitle:"4.âpositive and negative positions",charIndex:10320},{level:2,title:"5.âFive type-parameter modes",slug:"_5-five-type-parameter-modes",normalizedTitle:"5.âfive type-parameter modes",charIndex:13772},{level:2,title:"6.âInjectivity",slug:"_6-injectivity",normalizedTitle:"6.âinjectivity",charIndex:14475},{level:2,title:"7.âA logical contradiction",slug:"_7-a-logical-contradiction",normalizedTitle:"7.âa logical contradiction",charIndex:16173},{level:2,title:"8.âCardinality requirement",slug:"_8-cardinality-requirement",normalizedTitle:"8.âcardinality requirement",charIndex:18912},{level:2,title:"9.âType parameters and cardinality",slug:"_9-type-parameters-and-cardinality",normalizedTitle:"9.âtype parameters and cardinality",charIndex:22927},{level:2,title:"10.âCombining variance and cardinality preservation",slug:"_10-combining-variance-and-cardinality-preservation",normalizedTitle:"10.âcombining variance and cardinality preservation",charIndex:25467},{level:2,title:"11.âBuilt-in type constructors",slug:"_11-built-in-type-constructors",normalizedTitle:"11.âbuilt-in type constructors",charIndex:26311},{level:3,title:"11.0.âiset and ->",slug:"_11-0-iset-and",normalizedTitle:"11.0.âiset and -&gt;",charIndex:null},{level:3,title:"11.1.âTwo subtle consequences",slug:"_11-1-two-subtle-consequences",normalizedTitle:"11.1.âtwo subtle consequences",charIndex:29634},{level:3,title:"11.2.âset and iset",slug:"_11-2-set-and-iset",normalizedTitle:"11.2.âset and iset",charIndex:33103},{level:3,title:"11.3.âmap and imap",slug:"_11-3-map-and-imap",normalizedTitle:"11.3.âmap and imap",charIndex:34183},{level:2,title:"12.âOther sources",slug:"_12-other-sources",normalizedTitle:"12.âother sources",charIndex:35104},{level:2,title:"13.âSummary",slug:"_13-summary",normalizedTitle:"13.âsummary",charIndex:36961},{level:4,title:"Acknowledgments",slug:"acknowledgments",normalizedTitle:"acknowledgments",charIndex:37583},{level:2,title:"References",slug:"references",normalizedTitle:"references",charIndex:38469},{level:2,title:"A.âFinite powerset preserves cardinality",slug:"a-finite-powerset-preserves-cardinality",normalizedTitle:"a.âfinite powerset preserves cardinality",charIndex:40182}],headersStr:"0.âSubtypes 1.âType parameters 2.âVariance 2.0.âCo-variance 2.1.âContra-variance 2.2.âNon-variance 3.âDeclaring variance 4.âPositive and negative positions 5.âFive type-parameter modes 6.âInjectivity 7.âA logical contradiction 8.âCardinality requirement 9.âType parameters and cardinality 10.âCombining variance and cardinality preservation 11.âBuilt-in type constructors 11.0.âiset and -> 11.1.âTwo subtle consequences 11.2.âset and iset 11.3.âmap and imap 12.âOther sources 13.âSummary Acknowledgments References A.âFinite powerset preserves cardinality",content:"Dafny Power User: Type-parameter modes: variance and cardinality preservation\n\nK. Rustan M. Leino\n\nManuscript KRML 280, 9 August 2021\n\nAbstract. Dafny supports 5 type-parameter variance and cardinality-preservation modes. Variance is common in languages with types, and cardinality preservation is a concern that arises in the context of verification. This note explains these modes and motivates the need for cardinality preservation. Along the way, it explains some phrases like âstrict positivityâ.\n\nThis note is long, so here's a little reading guide:\n\n * If you're a beginner and want to learn about type-parameter variance, read the first 4 sections.\n * If you're using type-parameter modes and are wondering about the syntax of each mode, see the table in Section 10.\n * If you want to see which type-parameter modes are used with Dafny's built-in types, see Section 11.\n * If you wonder what trouble you'd be in without cardinality-preservation rules (or, as some would say it, without âstrict positivityâ), then Section 7 will give you the idea (and the first code snippet in Section 9 adds type parameters to that example).\n * If you're a language designer, you may find the rest of Section 11 to be food for thought.\n * There's a little proof about finite powersets and cardinalities in Appendix A.\n * Finally, I have come to think that âstrict positivityâ is not a good term to use. I think âcardinality preservationâ is more to the point, see Section 12.\n\n\n# 0.âSubtypes\n\nDafny defines a subtype relation on types. If A is a subtype of B, then every value of A is also a value of type B. For example, the subset type nat is a subtype of int. As another example, given\n\ntrait Tr {\n  // ...\n}\nclass Cl extends Tr {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype Cl is a subtype of Tr.\n\nNote. The definition of subtype above mentions âIfâ. This is not an âIf and only ifâ, because it doesn't go the other way around. For example, the type\n\ntype Unreal = r: real | r == r + 1.0\n  witness *\n\n\n1\n2\n\n\ndefines a type Unreal that has no values. Thus, every value of Unreal is also a value of int. Still, Dafny does not consider Unreal to be a subtype of int.\n\nThe subtype relation is reflexiveâthat is, every type is (trivially) a subtype of itselfâand transitive. Other than that, there are three sources of subtyping in Dafny. One is that a subset type (like the built-in nat and the type Unreal above) is a subtype of its base type (int for nat and real for Unreal). Another is that a class or trait is a subtype of each trait it extends. For example, as we saw above, Cl is a subtype of Tr, and every reference type is a subtype of the built-in trait object (which, e.g., every class implicitly extends). The third source of subtyping stems from variance of type parameters, as I will explain in the next few sections.\n\n\n# 1.âType parameters\n\nA type can be parameterized by other types. For example,\n\nclass Cell<Data> {\n  var data: Data\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nintroduces a class Cell parameterized by a type Data, and\n\ndatatype PS<X, Y> = PSCtor(x: X, ys: seq<Y>)\n\n\n1\n\n\nintroduces a datatype PS parameterized by two types, where the values are essentially pairs consisting of one value (x) of the first type and a sequence (ys) of values of the other type.\n\nSince Cell and PS have (1 and 2, respectively) type parameters, they sometimes known as (unary and binary) type constructors. This just means they are not types by themselves, but they need their parameters to be filled in to be types. For example, PS<int, real> and PS<bool, bool> are types, whereas PS<int> and PS are not.\n\nAside. In some cases, Dafny will fill in or infer the type arguments automatically. In those cases, you may be able to write just PS in your program. For example,\n\nvar p: PS := PSCtor(5, [3.14, 2.7]);\n\n\n1\n\n\nis a legal statement. This is just a syntactic shorthand, and the type arguments of PS are still there, even if the program text omits them.\n\n\n# 2.âVariance\n\nWhether or not a parameterized type is a subtype of another may depend on the parameters. For example, it turns out that seq<nat> is a subtype of seq<int>, but seq<bool> is not a subtype of seq<real>. The reason behind this is that seq is co-variant in its argument.\n\n\n# 2.0.âCo-variance\n\nWhen a (here, unary) type constructor M is co-variant in its argument, then\n\n> for any types A and B such that A is a subtype of B, M<A> is a subtype of M<B>.\n\nLet me write the subtype relation as <:. Then, what I just said about M can be written as\n\n> A, B :: A <: B ==> M<A> <: M<B>\n\nThis is really just saying that M is monotonic (with respect to the subtyping ordering) in its argument. For example, in math, a function f over the reals is monotonic (with respect to the less-or-equal ordering) when\n\n> x, y :: x y ==> f(x) f(y)\n\nA type constructor with many arguments may be co-variant in some of its type arguments and not others. For example, if Trois is a type constructor with three arguments and is co-variant in the first and third argument, then\n\n> A, B, H, X, Y :: A <: B && X <: Y ==> Trois<A, H, X> <: Trois<B, H, Y>\n\n\n# 2.1.âContra-variance\n\nSome type constructors are contra-variant in some of their type arguments. This means that the subtype of the argument has an opposite effect on the subtyping of the constructed type. More precisely, when a (here, unary) type constructor M is contra-variant in its argument, then\n\n> A, B :: A <: B ==> M<B> <: M<A>\n\nThis corresponds to the math notion of a function being anti-monotonic.\n\nFor illustration, consider the declarations\n\ndatatype Color = Blue | Green\ntype Coloring<X> = X -> Color\n\n\n1\n2\n\n\nwhich, for any type X, defines Coloring<X> to be the type whose values are functions that give each X value a Color. As it turns out, type constructor Coloring is contra-variant in its argument. Consequently, every value of Coloring<int> is a value of Coloring<nat>. This makes senseâeach value of Coloring<int> is a function that gives every integer a color, and each value of Coloring<nat> is a function that gives every non-negative integer a color, and every function that gives all integers a color also gives the non-negative integers a color.\n\n\n# 2.2.âNon-variance\n\nFor some type constructors, if you provide different type arguments, the resulting types have no relation to each other. For example, using class Cell from above, there is no subtype relation between Cell<nat> and Cell<int>. In this case, we say that the type constructor is non-variant in its argument.\n\nNote. Perversely, non-variance is sometimes called invariance. That's a terrible mistake. âInvariantâ refers to something that does not change, which is very much the opposite of the effect of non-variant type parameters. When you change the argument given to a non-variant type parameter, the resulting type can be something completely differentânot the same thing. So, pleaseâ¦ don't refer to non-variant as âinvariantâ!\n\n\n# 3.âDeclaring variance\n\nDafny defines the type-parameter variance of the built-in type constructors. For example, seq is co-variant in its type argument. (I'll mention the other collection types in Section 11.) As another example, for any n, the n-ary arrow type constructor is contra-variant in each of its n input types and co-variant in its output type. Reference types (user-defined classes, built-in arrays, etc.) are required to be non-variant in each of their type parameters.\n\nFor datatype and codatatype declarations, subset types, opaque types, and type synonyms, there's some freedom in choosing the variance for each type parameter. To declare a type constructor to be co-variant in a type parameter, mark the type parameter with a prefix +. For contra-variance, mark the type parameter with a prefix -. The absence of any such mark declares the type constructor to be non-variant in that type parameter.\n\nFor example, the declaration\n\ntype Example<+A, -B, C, +D>\n\n\n1\n\n\nintroduces an opaque-type type constructor Example with four type arguments. The type constructor is co-variant in its first and fourth arguments, contra-variant in its second argument, and non-variant in its third argument.\n\nAs another example, the built-in tuple type constructors (which are datatypes) are co-variant in each of their arguments.\n\nNote. In Section 2.1, I said that Coloring<X> is contra-variant. That's not quite true. The right-hand side of the definition of Coloring<X> is contra-variant in X. If you want Coloring to have this property, you must explicitly mark the parameter as such. That is, Coloring<X> declared in 2.1 is non-variant in X, whereas declaring it as\n\ntype Coloring<-X> = X -> Color\n\n\n1\n\n\nmakes it contra-variant.\n\nThere are no restrictions on the type-parameter variance of opaque types. But for the other type declarations, the right-hand side definition of the type must be consistent with each type-parameter variance given on the left-hand side.\n\nFor example, consider the following attempt at defining a datatype:\n\ndatatype Record<-X> = Record(x: X)  // error: X is not used contra-variantly\n\n\n1\n\n\nThis declaration introduces X as a contra-variant type parameter of Record, but the right-hand side definition of Record does not use X according to that variance. If X is instead introduced as a co-variant or non-variant type parameter, the definition is legal.\n\nNote. Even if the right-hand side is consistent with declaring a type parameter as co-variant or as contra-variant, the declaration of a type constructor does not need to advertise that to its users. In other words, it's fine to declare\n\ndatatype Record<X> = Record(x: X)\n\n\n1\n\n\neven though\n\ndatatype Record<+X> = Record(x: X)\n\n\n1\n\n\nis also legal and would allow more uses of Record. As another example, the Section 2.1 declaration of Coloring makes it non-variant, whereas its right-hand side would be consistent with making Coloring contra-variant. This is the same kind of choice of abstraction that is available throughout a programming language. For example, a function can have an int result type even it returns only non-negative integers. This establishes a contract between the implementation of a function and its callers. In particular, it says that the caller must be prepared to receive any integer result, and it gives the implementation the freedom to in the future return negative integers without breaking any callers.\n\n\n# 4.âPositive and negative positions\n\nWhen looking at the right-hand side of a type declaration to see if the type parameters are used in accordance with their variance, it is useful to think of positive and negative positions. The basic idea is that an occurrence of a type X in a type expression T is in a positive position if the occurrence is to the left of an even number of arrows in T, and it is in a negative position if it occurs to the left of an odd number of arrows.\n\nTo illustrate, consider the following type expression:\n\n(A, (B -> bool) -> C, seq<D -> (E -> F)>)\n\n\n1\n\n\nIn this type expression, A, B, C, and F are in positive positions and D and E are in negative positions.\n\nTo explain the origin of the names âpositiveâ and ânegativeâ, let me write T(X) to denote a type expression where I have singled out a particular occurrence of X. If the X in T(X) occurs in a positive position, then any subtype/supertype change in X will cause a change in the same direction in T(X). That is, it is as if T(X) âmultipliesâ X by a positive number. Conversely, if X is in a negative position, then any subtype/supertype change in X will cause a change in the opposite direction in T(X). That is, it is as if T(X) âmultipliesâ X by a negative number.\n\nIn more symbols, if X occurs in a positive position in T(X), then\n\n> X, Y :: X <: Y ==> T(X) <: T(Y)\n\nand if X occurs in a negative position in T(X), then\n\n> X, Y :: X <: Y ==> T(Y) <: T(X)\n\nIt's no accident that these formulas look like the ones that define co-variance and contra-variance in Section 2, because those concepts are tightly related to the concepts of positive and negative positions.\n\nConsider a type-constructor declaration with a type parameter X and a right-hand side RHS. If X is marked as co-variant, then it is used correctly if all its occurrences in RHS are in positive positions. If X is marked as contra-variant, then it is used correctly if all its occurrences in RHS are in negative positions.\n\nLet me tidy up a detail. In my above definitions of positive and negative positions, I only mentioned arrow type constructors. If for a moment we ignore syntax and write an arrow type like A -> B as Arrow<A, B>, then we can view the (built-in) definition of Arrow as\n\ntype Arrow<-X, +Y>\n\n\n1\n\n\nNow, the definition of positive/negative positions goes as follows. For any type T,\n\n * If T has the form X where X is a type parameter, then this occurrence of X is in a positive position.\n\n * \n\nIf\n\nT\n\n\n1\n\n\nhas the form\n\nTC<..., U, ...>\n\n\n1\n\n\nwhere type expression\n\nU\n\n\n1\n\n\nis passed in as the type parameter\n\nA\n\n\n1\n\n\nin type constructor\n\nTC\n\n\n1\n\n\n, then\n\n * if A is declared as co-variant, then all the positive positions in U are positive positions in T and all negative positions in U are negative positions in T\n * if A is declared as contra-variant, then all the positive positions in U are negative positions in T and all negative positions in U are positive positions in T\n * if A is declared as non-variant, then U contributes neither positive nor negative positions to T\n\nFor example, in the type\n\nseq<(A, Cell<B -> bool>, C -> D)> -> Example<int, E, F, G>\n\n\n1\n\n\nwhere Cell and Example are as defined above (and, recall, the built-in seq and the built-in tuple types are co-variant in their arguments, and the type constructor -> is like Arrow above), the type variables in positive positions are C and G, and the type variables in negative positions are A, D, and E.\n\n\n# 5.âFive type-parameter modes\n\nIn most programming languages that support type-parameter variance, you will encounter only the 3 modes of variance I've discussed so far. If that's all you want to know, you can stop reading now. (Dafny's defaults are such that you rarely need to know about more than these 3 modes.)\n\nDafny, it turns out, has 5 type-parameter modes. The additional modes come about because Dafny is concerned with formal verification. To motivate and explain the additional modes, I will review a property about datatypes, show a subtle way that mere type declarations can cause a logical contradiction, introduce the concept of cardinality preservation, and then come back to Dafny.\n\n\n# 6.âInjectivity\n\nThe constructors of a datatype or codatatype are injective in their arguments. This means that there is only one way to construct a particular datatype value.\n\nIn more detail, let's review four properties of datatypes. For illustration, let's consider a standard List definition (of integersâjust to keep things simple).\n\ndatatype List = Nil | Cons(head: int, tail: List)\n\n\n1\n\n\nFirst, this definition says that there are two variants of lists: those that are constructed using Nil and those that are constructed using Cons. So, for any value xs of type List, the disjunction\n\nxs.Nil? || xs.Cons?\n\n\n1\n\n\nalways holds. Second, the two variants give rise to different values. So,\n\n!(xs.Nil? && xs.Cons?)\n\n\n1\n\n\nalways holds. Third, each constructor is a function, in the sense that its arguments (and nothing else!) determine the value they produce. So,\n\nx == y && xs == ys  ==>  Cons(x, xs) == Cons(y, ys)\n\n\n1\n\n\nalways holds. Fourth, two values of the same variant are equal only if the corresponding arguments are equal. So,\n\nCons(x, xs) == Cons(y, ys)  ==>  x == y && xs == ys\n\n\n1\n\n\nIt's this fourth property that is called injectivity. More precisely, a datatype constructor is injective in each argument. (An alternate name for âinjectiveâ is âone-to-oneâ.) When a function is injective (in an argument), there exists an inverse function (for that argument). For a datatype, those inverse functions are called destructors, and they can be given names by introducing names for the parameters of the constructors. In the List declaration above, the inverse functions for Cons were introduced as .head and .tail. So, we have\n\nCons(x, xs).head == x  &&  Cons(x, xs).tail == xs\n\n\n1\n\n\n\n# 7.âA logical contradiction\n\nConsider the following type declarations:\n\ntype F = D -> bool\ndatatype D = Ctor(f: F)\n\n\n1\n2\n\n\nI'm now going to argue that there is an infinite number of values of type D. Regardless of how many D values there are, we can define a function f``0 of type F that always returns false. If we pass in f``0 to Ctor, we get a D value, call it d``0. (We just proved that the set of D values is nonempty!) From our definition of f``0, we have that f``0``(d``0``) == false. Next, let's define a function f``1 that is like f``0, except that it returns true for d``0. Define d``1 to be the value Ctor(f``1``). Because f``0 is different from f``1, the injectivity of Ctor tells us that d``0 is different from d``1. (We have now shown that there are at least 2 D values!) Next, define a function f``2 that is like f``1, except that it returns true for d``1. By passing f``2 to Ctor, we get yet another D value. We can continue this process forever, which shows that there is no finite bound on the number of D values. Hence, the set of D values is infinite.\n\nHow many F values are there? If D were finite, you would immediately answer 2``|D|, where |D| is the size of Dâalso known as the cardinality of Dâbecause for each D value, F may return one of 2 values. This is called the powerset of D. But as we just concluded above, D is infinite. Well, it turns out that the answer is still the same: the cardinality of F is 2``|D|, where we're using cardinal numbers instead of natural numbers. This sounds mathematical, but all you need to know is that the inequality n < 2``n holds for cardinal numbers just like it holds for natural numbers (see, e.g., Theorem 22.10 of [3]). In other words, the number of F values is strictly larger than the number of D values.\n\nThis is trouble.\n\nFor every F value, we can construct a D value, and thus |F| <= |D|. But we concluded above that |D| < 2``|D| and 2``|D|`` == |F|. Putting these facts together by transitivity, we get |F| < |F|, which is just false.\n\nUsing a construction akin to Cantor's diagonalization argument [6] or Russell's paradox [5], we can exploit this contradiction in cardinalities and prove false:\n\nlemma False()\n  ensures false\n{\n  var g := (d: D) => !d.f(d);\n  var dd := Ctor(g);\n  calc {\n    g(dd);\n  ==  // def. g\n    !dd.f(dd);\n  ==  { assert dd.f == g; }\n    !g(dd);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nWell, it's more accurate to say that this could be trouble, because it would let us prove false. Luckily, the type definitions for F and D are not accepted by Dafny. That is, to avoid this logical contradiction, Dafny does not allow a datatype (here, D) to be defined in terms of right-hand sides that would have larger cardinalities than D itself.\n\n\n# 8.âCardinality requirement\n\nTo avoid the contradiction in cardinalities when defining a type D as some type expression T(D), we must make sure the cardinalities of D and T(D) can be the same. That is, we need to be able to make D large enough that its cardinality equals that of T(D). The previous section showed an example where this is not possible, because no matter how big you make D, T(D) will be exponentially larger. I'll refer to this condition as the cardinality requirement.\n\nA contradiction in cardinalities can occur only if a type is defined in terms of itself. That is, suppose a type D is defined to be RHS. If RHS does not depend on D, then D will, without risk of any contradiction, have the same cardinality as RHS. A problem can occur only if RHS depends on D. For all cases of non-trivial dependencies, one can use an argument like in Section 7 to show that D has an infinite number of elements. Therefore, when designing a restriction to enforce the cardinality requirement, we only need to think about types of infinite cardinality.\n\nIn type theory, we can think of a fixed repertoire of type compositions. Types are either type names or sum-type, product-type, or arrow-type compositions. Type names include built-in types like bool and int, and also include user-defined types, like D from above. Sum types correspond to the variants of a datatype. Product types correspond to the list of arguments in each such variant. Finally, arrow types are the types of functions.\n\nUsing standard type-theory notation for these types and for the cardinality of the type named , the cardinality of types, denoted , is defined as follows:\n\nFrom this definition, we see that the cardinality is a polynomial of the cardinalities of the type names involved, except in the case of arrow types. For any polynomial and infinite cardinal number , equals . So, the only way to violate the cardinality requirement is if D occurs in the left-hand argument of an arrow type.\n\nNote. Just because D occurs in the left-hand argument to an arrow does not mean there is a problem with cardinalities. In particular, arrow types are harmless if the right-hand type has cardinality 0 or 1, and so are product types where an argument has cardinality 0. For example, Empty is an empty type (that is, a type with cardinality 0) and Singleton is a unit type (that is, a type with cardinality 1), then there is no cardinality concern with the type\n\ndatatype D = Done | More(D -> Empty, D -> Singleton, (D, Empty) -> int)\n\n\n1\n\n\nNevertheless, Dafny's rules forbid this type, too, because the rules do not look for the special cases with cardinality-0 or cardinality-1 types. That's alright. By forbidding these trivial types, the rules both eliminate actual cardinality problems and stay simple.\n\nThe crucial point is this: Except for cardinality-0 types that are used as arguments to product types or as left-hand arguments to arrow types,\n\n> a type expression T(D) that mentions D is always at least as big as D.\n\nThis leads us to a proposed way to enforce the cardinality requirement:\n\n> For any type D defined to be T(D), do not allow D to be mentioned in the left-hand argument of any arrow type in T(D).\n\nThe proposed rule talks about left-hand arguments of arrow types, which reminds us of the positive/negative positions we discussed in Section 4 as a way to enforce variance restrictions. Some people think of the cardinality requirement as taking a step beyond saying D must be in positive positions. That is, whereas a doubly negative position (like X in (X -> bool) -> bool) is a positive position, the cardinality requirement seems to call for a strictly positive positions, where a doubly negative position is still a negative position. For this reason, you sometimes hear that the cardinality requirement is enforced by strict positivity. (I'll have more to say about this in Section 12.)\n\nBut wait! Weren't we discussing type parameters? What does the cardinality requirement have to do with type parameters?\n\n\n# 9.âType parameters and cardinality\n\nA variation of the example logical contradiction we saw in Section 7 can be written using type parameters:\n\ntype G<X> = X -> bool\ndatatype E = Ctor(g: G<E>)\n\n\n1\n2\n\n\nOnce the type synonym G is expanded, we get the same example, and indeed the same contradiction.\n\nIn a modular setting, it is not realistic to rely on being able to expand all types before checking for cardinality problems. For example, suppose type G is declared in a different module that exports G as an opaque type. A client module might then see just\n\ntype G<X>\ndatatype E = Ctor(g: G<E>)\n\n\n1\n2\n\n\nfrom which it is not evident whether or not there may be problems with cardinality.\n\nTo solve this problem, Dafny lets every type constructor declare which of its type parameters are used in ways that preserve cardinality. The mark ! in the following example illustrates:\n\ntype Example<X, !Y>\n\n\n1\n\n\nThis declaration says that Example uses type parameter X in a way that adheres to the cardinality requirement, whereas it does not promise the same for Y. This means that\n\ndatatype Good = None | Some(Example<Good, int>)\n\n\n1\n\n\nis legal, whereas\n\ndatatype Bad = None | Some(Example<int, Bad>) // error: violates cardinality requirement\n\n\n1\n\n\nis not, because it may violate the cardinality requirement.\n\nWe can now state the enforcement of the cardinality requirement precisely. Ignoring syntax, like I did in Section 4, we can view all types as type constructors that take a list of type parameters, each of which is identified as cardinality preserving or possibly not cardinality preserving. For any type T,\n\n * If T has the form X where X is a type parameter, then this occurrence of X is a cardinality-preserving position iff X is marked as cardinality preserving.\n\n * \n\nIf\n\nT\n\n\n1\n\n\nhas the form\n\nTC<..., U, ...>\n\n\n1\n\n\nwhere type expression\n\nU\n\n\n1\n\n\nis passed in as the type parameter\n\nA\n\n\n1\n\n\nin type constructor\n\nTC\n\n\n1\n\n\n, then\n\n * if A is declared as cardinality preserving, then all the cardinality-preserving positions in U are cardinality-preserving positions in T\n * if A is not declared as cardinality preserving, then U does not contribute any cardinality-preserving positions to T\n\nThe cardinality requirement is now enforced by the following cardinality-preservation rule: for any type D<..., X, ...> defined as RHS,\n\n * In RHS, D is allowed to be used only in cardinality-preserving positions.\n * If X is marked as cardinality preserving, then, in RHS, X is allowed to be used only in cardinality-preserving positions.\n\n\n# 10.âCombining variance and cardinality preservation\n\nWith 3 kinds of variance, each with cardinality preservation or not, you'd think we'd have 6 modes altogether. But there is no way to be contra-variant and cardinality preservingâin terms of arrow types, contra-variance says the type parameter is to the left of some arrow, and that makes it not preserve cardinality. Therefore, Dafny supports 5 modes. The default mode is non-variant, cardinality preserving. The other four modes can be indicated with the prefix marks +, *, -, and !, as shown by this table:\n\n                 CARDINALITY PRESERVING   \nvariance         yes                      not necessarily\n                                          \nco-variant       +                        *\ncontra-variant   N/A                      -\nnon-variant      (default)                !\n\n\n# 11.âBuilt-in type constructors\n\nDafny has several built-in type constructors. Here are their type-parameter modes:\n\nset<+A>          // finite sets\niset<*A>         // possibly infinite sets\nseq<+A>          // sequences\nmultiset<+A>     // multisets\nmap<+A, +B>      // finite maps\nimap<*A, +B>     // possibly infinite maps\n(+A, +B, +C)     // tuple types\n-A -> +B         // arrow type for total functions\n-A --\x3e +B        // arrow type for partial functions\n-A ~> +B         // arrow type for general functions\narray<A>         // arrays\narray2<A>        // multi-dimensional arrays\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nMost of these are probably what you'd expect. For example, as we have seen above in examples, sequences are co-variant in their type argument, and they are also cardinality preserving. Tuple types (a 3-tuple is shown above) are built-in datatypes and they are co-variant and cardinality-preserving in all their arguments. Array types of any dimension are reference types, which are restricted to be non-variant in their type parameters, and they are also cardinality preserving. Arrow types are co-variant and cardinality preserving in their last type parameter and, as we have discussed, contra-variant and not cardinality preserving in the other type parameters.\n\nSome of type modes among the built-in types are more subtle. If you're tired of considering subtleties and are happy to accept the type-parameter modes of the built-in types, you can skip the rest of this section. If you want understand the rationale behind these type-parameter modes, keep reading.\n\n\n# 11.0.âiset and ->\n\nAn iset<X> is a possibly infinite set of X's. We can think of such a set as a function that for each X returns true or false, depending on whether or not the value is in the set. So, iset<X> is like the type X -> bool, which is not cardinality preserving in X.0 But why is iset<X> co-variant in X while X -> bool is contra-variant in X?\n\nWhat I'm about to say applies to any types Y and X where Y is a subtype of X, but I find it helpful to think of specific, familiar types, so I will instead use the types nat and int.\n\nSince nat is a subtype of int, co-variance would say that every iset<nat> value is also an iset<int> value. Indeed, a set containing only non-negative integers is also an iset<int>, so it makes sense that iset is co-variant in its type argument.\n\nIf -> were co-variant, then any nat -> bool function would have to be a int -> bool function, which isn't so. For example, consider the nat -> bool function\n\n(n: nat) => 1000 / (n+1) < 20\n\n\n1\n\n\nThis function evaluates to false for 3 and evaluates to true for 999. If we ignore the \": nat\" type of the function's argument and try to think of the function as having type int -> bool, we expect to get a bool value if we apply the function to any integer. But the function's body is undefined for -1, so clearly it's not like an int -> bool function. We conclude that -> is not co-variant in its first argument.\n\nInstead, it is contra-variant in its first argument. That is, every int -> bool function is also a nat -> bool function. Being the latter says you get a bool result whenever you apply it to a non-negative integer. Since that's also true for any int -> bool function, it makes sense to say -> is contra-variant in its first argument.\n\n\n# 11.1.âTwo subtle consequences\n\nThere are two subtle consequences of the decision to make iset co-variant and _ -> bool contra-variant. They have to do with expressing membership/domain. To talk about them, let me first be explicit about the following principle in the Dafny language design:\n\n * The Static Types Don't Alter Values principle.\n   \n   A static type says something about the value, but does not alter the value. If Y is a subtype of X, then you're allowed to assign a value of type Y to a variable of type X. In Dafny, such an assignment does not alter the value assigned. For example, given variables\n   \n   x: X    y: Y    originalY: Y\n   \n   \n   1\n   \n   \n   the following assignments are allowed and result in the assertion being verified:\n   \n   originalY := y; // save the value of y\n   x := y; // assign y to a variable of a different type (a supertype)\n   y := x; // assign x back to y\n   assert x == y == originalY;\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   The assignment from y to x is allowed, since Y is a subtype of X. The assignment from x to y is allowed by the type system, but generates a proof obligation that the value of x at the time of the assignment is indeed a value of type Y. Since neither assignment alters the value, the final assertion succeeds.\n\nNow, if s has type iset<int>, then the expression -7 in s evaluates to a boolean that tells us whether or not -7 is an element of set s. Suppose t has type iset<nat>. Is the expression -7 in t legal? Yes, because we could assign t to s (which, according to the language-design principle above, does not alter the value) and then ask -7 in s. Since there is a way to ask about -7's membership in t, it seems fine to allow the expression -7 in t directly, and that's what Dafny does.\n\nNote. One could try to imagine a different language design, where an iset<int> value would be allowed to masquerade as an iset<nat> value. In such a language, consider the following program snippet, where variables s and t have types iset<int> and iset<nat>, respectively:\n\nt := s;\nassert s == t;\nassert -7 in s <==> -7 in t;\n\n\n1\n2\n3\n\n\nBy the Static Types Don't Alter Values principle, the first assertion should hold. And if s and t are indeed equal, then the next assertion should also hold. But that's nonsense, since every element of an iset<nat> is non-negative. Perhaps the language could outlaw the expression -7 in t, since -7 is not a value in the element type (nat) of the static type of tâbut this doesn't help, since (as we considered above) we can ask about -7's membership in t without writing -7 in t directly. The conclusion is that such an imagined language design goes against the Static Types Don't Alter Values principle.\n\nNext, if f is an int -> bool function, we can (by contra-variance) assign it to a variable g of type nat -> bool. Since f is defined on every integer, the expression f.requires(-7) is true. So what about g.requires(-7)? It would be strange for it to return true, since -7 is not a value of the first type parameter of g's type. But we also can't let it return false, because then g is not equal to f, which violates the Static Types Don't Alter Values principle. The only way out is to try to outlaw g.requires(-7).\n\nFor an expression e of static type A -> B, Dafny defines e.requires to have type A -> bool. So, f.requires has type int -> bool, which means one can pass -7 to it. But g.requires has type nat -> bool, so it is not legal to pass it -7.\n\n\n# 11.2.âset and iset\n\nHaving looked at iset<X> in detail, our first thought might be that set<X> would be the same. After all, we can view both iset<X> and set<X> as having values of the form X -> bool. While co-variance applies to iset and set alike, the cardinality concern we had with X -> bool and iset<X> does not apply to set<X> (explained next). Therefore, set's type parameter is declared with +.\n\nFor any type X, the values of iset<X> are in one-to-one correspondence with the powerset of Xâthat is, all functions from X to bool, or, equivalently, all possible subsets of Xâwhose cardinality is 2``|X|. The values of set<X> correspond to the finite powerset of Xâthat is, the functions from X to bool that return true only for a finite number of elements, or, equivalently, all finite subsets of X. The cardinality of the finite powerset is far smaller. Specifically, if X has infinite cardinality (which is the case we are interested in, see Section 8), then the cardinality of the finite powerset of X equals the cardinality of X itself (see Appendix A for a proof).\n\n\n# 11.3.âmap and imap\n\nThe last point to explain about the type-parameter modes of the built-in type constructors regards finite maps (map<X, Y>) and possibly infinite maps (imap<X, Y>).\n\nYou can view map<X, Y> and imap<X, Y> as (finite and possibly infinite) sets of pairs (x, y), with x a value of X and y a value of Y. Thus, as you consider subtypes (or supertypes) of either X or Y, the possible pairs shrink (or grow, respectively). This justifies the map types as being co-variant in both arguments.\n\nValues of type imap<X, Y> are in one-to-one correspondence with the values of type X -> Y, so our concerns about cardinality preservation apply (hence, imap declares its first argument with the mark *). But the cardinality of map<X, Y>, which allows only a finite number of mappings from X to Y, is far smaller. So, analogously to set<X>, when X is infinite, map<X, Y> has no more elements than both |X| and |Y|.\n\n\n# 12.âOther sources\n\nIt seems that every textbook or course on types would cover the topic of cardinality preservation (or âstrict positivityâ as it's often called), but I have had difficulty finding such coverage. When I was first learning about this, the most useful reference I found was a seminal paper by Elsa Gunter [1]. But even that paper left me puzzled as to what types a verification language can allow without the risk of a logical contradiction.\n\nI now think that what had muddled my mind was the phrase âstrict positivityâ. I don't know who invented or popularized that phrase, but given the syntactic enforcement of cardinality preservation, I understand that it's tempting to think of the restriction as a stricter version of the positive-position restriction for type-parameter variance (Section 4). But if you think of the requirement as barring a type name from occurring âto the left of any arrowâ, then the motivation is not clear. âPositivityâ has well established connotations with monotonicity, whereas âstrict positivityâ has nothing to do with monotonicity. Once you realize the salient point is how the cardinality of a type parameter affects the cardinality of the type generated by a type constructor, the light in your head comes on. If youâlike I didâfeel betrayed by the phrase âstrict positivityâ, youâlike I doâwill feel compelled to instead use the name cardinality preservation.\n\nMany other verification languages incorporate restrictions to avoid logic contradictions. Of these, I want to mention the F* language [4], which does not forbid types like those in Section 7; instead, to avoid logical contradictions, F* omits the injectivity property of constructors (see Section 6) for such types. In other words, the constructors of a datatype in F* are injective only if the type satisfies the cardinality requirement.\n\n\n# 13.âSummary\n\nConsider a (here, unary) type constructor T. Variance is a set of type-parameter modes that tell you what you can conclude about the subtyping relationship between T(X) and T(Y) by knowing something about the subtyping relationship between X and Y. Cardinality preservation is a set of type-parameter modes that tell you what you can conclude about the relative cardinalities of T(X) and T(Y) by knowing something about the relative cardinalities of X and Y. Dafny supports 5 type-parameter modes that a type constructor can use to express the desired combination of variance and cardinality preservation.\n\n# Acknowledgments\n\nI first learnedâyears agoâabout the logical contradiction in Section 7 from Jean-Christophe FilliÃ¢tre and Christine Paulin-Mohring.\n\nAndreas Lochbihler demonstrated to me that the contradiction is detectable in Dafny, even though Dafny has no concepts or types that deal with cardinal numbers directly.\n\nDiscussions with Nik Swamy caused me to introduce the 5, not 3, type-parameter modes in Dafny, but I realize now that I was then still confused by the phrase âstrict positivityâ.\n\nRecently, I had some illuminating discussions with Andrei Paskevich and Jatin Arora on this topic.\n\nRemy Willems asked me questions about the type-parameter mark ! in Dafny, which prompted me to write this note to explore the topic in more detail. Little did I know I would spend this many words!\n\nI'm grateful to all of these colleagues.\n\nDafny error message movie reference [0].\n\n\n# References\n\n[0]âContinuum Transfunctionerâ. In Philip Stark, writer, and Danny Leiner, director, Dude, Where's My Car?, Twentieth Century Fox, Alcon Entertainment, 2000. ð\n\n[1]Elsa L. Gunter. Why we can't have SML-style datatype declarations in HOL. In Luc J. M. Claesen and Michael J. C. Gordon, editors, Higher Order Logic Theorem Proving and its Applications, Proceedings of the IFIP TC10/WG10.2 Workshop HOL'92., volume A-20 of IFIP Transactions, pages 561â568. North-Holland/Elsevier, September 1992. Preprint available at http://egunter.cs.illinois.edu/papers/HOL1992.pdf. ð\n\n[2]Arturo Magidin. The cardinality of the set of all finite subsets of an infinite set. Math StackExchange, March 2011. https://math.stackexchange.com/questions/27096/the-cardinality-of-the-set-of-all-finite-subsets-of-an-infinite-set/27098#27098. ð\n\n[3]J. Donald Monk. Introduction to Set Theory. McGraw-Hill, 1969. Electronic version available from http://euclid.colorado.edu/~monkd/monk11.pdf. ð\n\n[4]Nilhil Swamy, et al. F*: A higher-order effectful language designed for program verification. https://fstar-lang.org/. ð\n\n[5]Bertrand Russell. The Principles of Mathematics. W. W. Norton & Company, New York, 2d. ed. reprint edition, 1996. First published in 1903. ð\n\n[6]Keith Simmons. Universality and the Liar: An Essay on Truth and the Diagonal Argument. Cambridge University Press, 1993. ISBN 978-0-521-43069-2, https://www.google.com/books/edition/Universality_and_the_Liar/wEj3Spept0AC. ð\n\n[7]chelivery. Cardinality of the set of all finite subset of . Math StackExchange, December 2016. https://math.stackexchange.com/questions/2057826/cardinality-of-the-set-of-all-finite-subset-of-mathbbr/2057908#2057908. ð\n\n\n# A.âFinite powerset preserves cardinality\n\nWhile I haven't found the result in a textbook or journal article, math.stackexchange.com contains at least two proofs that finite powersets preserve cardinality [2, 7]. Here's a version of [7], but for any infinite set (not just ).\n\nTheorem. Let be an infinite set and be the set of all finite subsets of . Then, .\n\nProof. To prove and to have the same cardinality, we need to show a bijection between the two. By the SchrÃ¶der-Bernstein Theorem, it suffices to show an injective function from to and a (possibly different) surjective function from to . The function from each element in to the singleton set in is injective. So, it remains to show a surjective function from to .\n\nFor any natural number , let denote the -element subsets of . We then have that\n\nSince, for each , is a subset of , there exists a surjective function . We define a function by . Function is surjective, because for any value in , , so by the surjectivity of there is an such that , and thus .\n\nAlright, so we have a surjective function, , from to , but we need to show a surjective function from to . We have (see Section 8), and and (since is infinite), so by cardinal arithmetic, . Hence, there is a surjective function, call it , from to . We conclude that is a surjective function from to , which completes our proof.\n\n----------------------------------------\n\n0.This had been defined incorrectly in Dafny. The issue was reported by Travis Hance and fixed by Jatin Arora. â©",normalizedContent:"dafny power user: type-parameter modes: variance and cardinality preservation\n\nk. rustan m. leino\n\nmanuscript krml 280, 9 august 2021\n\nabstract. dafny supports 5 type-parameter variance and cardinality-preservation modes. variance is common in languages with types, and cardinality preservation is a concern that arises in the context of verification. this note explains these modes and motivates the need for cardinality preservation. along the way, it explains some phrases like âstrict positivityâ.\n\nthis note is long, so here's a little reading guide:\n\n * if you're a beginner and want to learn about type-parameter variance, read the first 4 sections.\n * if you're using type-parameter modes and are wondering about the syntax of each mode, see the table in section 10.\n * if you want to see which type-parameter modes are used with dafny's built-in types, see section 11.\n * if you wonder what trouble you'd be in without cardinality-preservation rules (or, as some would say it, without âstrict positivityâ), then section 7 will give you the idea (and the first code snippet in section 9 adds type parameters to that example).\n * if you're a language designer, you may find the rest of section 11 to be food for thought.\n * there's a little proof about finite powersets and cardinalities in appendix a.\n * finally, i have come to think that âstrict positivityâ is not a good term to use. i think âcardinality preservationâ is more to the point, see section 12.\n\n\n# 0.âsubtypes\n\ndafny defines a subtype relation on types. if a is a subtype of b, then every value of a is also a value of type b. for example, the subset type nat is a subtype of int. as another example, given\n\ntrait tr {\n  // ...\n}\nclass cl extends tr {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ntype cl is a subtype of tr.\n\nnote. the definition of subtype above mentions âifâ. this is not an âif and only ifâ, because it doesn't go the other way around. for example, the type\n\ntype unreal = r: real | r == r + 1.0\n  witness *\n\n\n1\n2\n\n\ndefines a type unreal that has no values. thus, every value of unreal is also a value of int. still, dafny does not consider unreal to be a subtype of int.\n\nthe subtype relation is reflexiveâthat is, every type is (trivially) a subtype of itselfâand transitive. other than that, there are three sources of subtyping in dafny. one is that a subset type (like the built-in nat and the type unreal above) is a subtype of its base type (int for nat and real for unreal). another is that a class or trait is a subtype of each trait it extends. for example, as we saw above, cl is a subtype of tr, and every reference type is a subtype of the built-in trait object (which, e.g., every class implicitly extends). the third source of subtyping stems from variance of type parameters, as i will explain in the next few sections.\n\n\n# 1.âtype parameters\n\na type can be parameterized by other types. for example,\n\nclass cell<data> {\n  var data: data\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\nintroduces a class cell parameterized by a type data, and\n\ndatatype ps<x, y> = psctor(x: x, ys: seq<y>)\n\n\n1\n\n\nintroduces a datatype ps parameterized by two types, where the values are essentially pairs consisting of one value (x) of the first type and a sequence (ys) of values of the other type.\n\nsince cell and ps have (1 and 2, respectively) type parameters, they sometimes known as (unary and binary) type constructors. this just means they are not types by themselves, but they need their parameters to be filled in to be types. for example, ps<int, real> and ps<bool, bool> are types, whereas ps<int> and ps are not.\n\naside. in some cases, dafny will fill in or infer the type arguments automatically. in those cases, you may be able to write just ps in your program. for example,\n\nvar p: ps := psctor(5, [3.14, 2.7]);\n\n\n1\n\n\nis a legal statement. this is just a syntactic shorthand, and the type arguments of ps are still there, even if the program text omits them.\n\n\n# 2.âvariance\n\nwhether or not a parameterized type is a subtype of another may depend on the parameters. for example, it turns out that seq<nat> is a subtype of seq<int>, but seq<bool> is not a subtype of seq<real>. the reason behind this is that seq is co-variant in its argument.\n\n\n# 2.0.âco-variance\n\nwhen a (here, unary) type constructor m is co-variant in its argument, then\n\n> for any types a and b such that a is a subtype of b, m<a> is a subtype of m<b>.\n\nlet me write the subtype relation as <:. then, what i just said about m can be written as\n\n> a, b :: a <: b ==> m<a> <: m<b>\n\nthis is really just saying that m is monotonic (with respect to the subtyping ordering) in its argument. for example, in math, a function f over the reals is monotonic (with respect to the less-or-equal ordering) when\n\n> x, y :: x y ==> f(x) f(y)\n\na type constructor with many arguments may be co-variant in some of its type arguments and not others. for example, if trois is a type constructor with three arguments and is co-variant in the first and third argument, then\n\n> a, b, h, x, y :: a <: b && x <: y ==> trois<a, h, x> <: trois<b, h, y>\n\n\n# 2.1.âcontra-variance\n\nsome type constructors are contra-variant in some of their type arguments. this means that the subtype of the argument has an opposite effect on the subtyping of the constructed type. more precisely, when a (here, unary) type constructor m is contra-variant in its argument, then\n\n> a, b :: a <: b ==> m<b> <: m<a>\n\nthis corresponds to the math notion of a function being anti-monotonic.\n\nfor illustration, consider the declarations\n\ndatatype color = blue | green\ntype coloring<x> = x -> color\n\n\n1\n2\n\n\nwhich, for any type x, defines coloring<x> to be the type whose values are functions that give each x value a color. as it turns out, type constructor coloring is contra-variant in its argument. consequently, every value of coloring<int> is a value of coloring<nat>. this makes senseâeach value of coloring<int> is a function that gives every integer a color, and each value of coloring<nat> is a function that gives every non-negative integer a color, and every function that gives all integers a color also gives the non-negative integers a color.\n\n\n# 2.2.ânon-variance\n\nfor some type constructors, if you provide different type arguments, the resulting types have no relation to each other. for example, using class cell from above, there is no subtype relation between cell<nat> and cell<int>. in this case, we say that the type constructor is non-variant in its argument.\n\nnote. perversely, non-variance is sometimes called invariance. that's a terrible mistake. âinvariantâ refers to something that does not change, which is very much the opposite of the effect of non-variant type parameters. when you change the argument given to a non-variant type parameter, the resulting type can be something completely differentânot the same thing. so, pleaseâ¦ don't refer to non-variant as âinvariantâ!\n\n\n# 3.âdeclaring variance\n\ndafny defines the type-parameter variance of the built-in type constructors. for example, seq is co-variant in its type argument. (i'll mention the other collection types in section 11.) as another example, for any n, the n-ary arrow type constructor is contra-variant in each of its n input types and co-variant in its output type. reference types (user-defined classes, built-in arrays, etc.) are required to be non-variant in each of their type parameters.\n\nfor datatype and codatatype declarations, subset types, opaque types, and type synonyms, there's some freedom in choosing the variance for each type parameter. to declare a type constructor to be co-variant in a type parameter, mark the type parameter with a prefix +. for contra-variance, mark the type parameter with a prefix -. the absence of any such mark declares the type constructor to be non-variant in that type parameter.\n\nfor example, the declaration\n\ntype example<+a, -b, c, +d>\n\n\n1\n\n\nintroduces an opaque-type type constructor example with four type arguments. the type constructor is co-variant in its first and fourth arguments, contra-variant in its second argument, and non-variant in its third argument.\n\nas another example, the built-in tuple type constructors (which are datatypes) are co-variant in each of their arguments.\n\nnote. in section 2.1, i said that coloring<x> is contra-variant. that's not quite true. the right-hand side of the definition of coloring<x> is contra-variant in x. if you want coloring to have this property, you must explicitly mark the parameter as such. that is, coloring<x> declared in 2.1 is non-variant in x, whereas declaring it as\n\ntype coloring<-x> = x -> color\n\n\n1\n\n\nmakes it contra-variant.\n\nthere are no restrictions on the type-parameter variance of opaque types. but for the other type declarations, the right-hand side definition of the type must be consistent with each type-parameter variance given on the left-hand side.\n\nfor example, consider the following attempt at defining a datatype:\n\ndatatype record<-x> = record(x: x)  // error: x is not used contra-variantly\n\n\n1\n\n\nthis declaration introduces x as a contra-variant type parameter of record, but the right-hand side definition of record does not use x according to that variance. if x is instead introduced as a co-variant or non-variant type parameter, the definition is legal.\n\nnote. even if the right-hand side is consistent with declaring a type parameter as co-variant or as contra-variant, the declaration of a type constructor does not need to advertise that to its users. in other words, it's fine to declare\n\ndatatype record<x> = record(x: x)\n\n\n1\n\n\neven though\n\ndatatype record<+x> = record(x: x)\n\n\n1\n\n\nis also legal and would allow more uses of record. as another example, the section 2.1 declaration of coloring makes it non-variant, whereas its right-hand side would be consistent with making coloring contra-variant. this is the same kind of choice of abstraction that is available throughout a programming language. for example, a function can have an int result type even it returns only non-negative integers. this establishes a contract between the implementation of a function and its callers. in particular, it says that the caller must be prepared to receive any integer result, and it gives the implementation the freedom to in the future return negative integers without breaking any callers.\n\n\n# 4.âpositive and negative positions\n\nwhen looking at the right-hand side of a type declaration to see if the type parameters are used in accordance with their variance, it is useful to think of positive and negative positions. the basic idea is that an occurrence of a type x in a type expression t is in a positive position if the occurrence is to the left of an even number of arrows in t, and it is in a negative position if it occurs to the left of an odd number of arrows.\n\nto illustrate, consider the following type expression:\n\n(a, (b -> bool) -> c, seq<d -> (e -> f)>)\n\n\n1\n\n\nin this type expression, a, b, c, and f are in positive positions and d and e are in negative positions.\n\nto explain the origin of the names âpositiveâ and ânegativeâ, let me write t(x) to denote a type expression where i have singled out a particular occurrence of x. if the x in t(x) occurs in a positive position, then any subtype/supertype change in x will cause a change in the same direction in t(x). that is, it is as if t(x) âmultipliesâ x by a positive number. conversely, if x is in a negative position, then any subtype/supertype change in x will cause a change in the opposite direction in t(x). that is, it is as if t(x) âmultipliesâ x by a negative number.\n\nin more symbols, if x occurs in a positive position in t(x), then\n\n> x, y :: x <: y ==> t(x) <: t(y)\n\nand if x occurs in a negative position in t(x), then\n\n> x, y :: x <: y ==> t(y) <: t(x)\n\nit's no accident that these formulas look like the ones that define co-variance and contra-variance in section 2, because those concepts are tightly related to the concepts of positive and negative positions.\n\nconsider a type-constructor declaration with a type parameter x and a right-hand side rhs. if x is marked as co-variant, then it is used correctly if all its occurrences in rhs are in positive positions. if x is marked as contra-variant, then it is used correctly if all its occurrences in rhs are in negative positions.\n\nlet me tidy up a detail. in my above definitions of positive and negative positions, i only mentioned arrow type constructors. if for a moment we ignore syntax and write an arrow type like a -> b as arrow<a, b>, then we can view the (built-in) definition of arrow as\n\ntype arrow<-x, +y>\n\n\n1\n\n\nnow, the definition of positive/negative positions goes as follows. for any type t,\n\n * if t has the form x where x is a type parameter, then this occurrence of x is in a positive position.\n\n * \n\nif\n\nt\n\n\n1\n\n\nhas the form\n\ntc<..., u, ...>\n\n\n1\n\n\nwhere type expression\n\nu\n\n\n1\n\n\nis passed in as the type parameter\n\na\n\n\n1\n\n\nin type constructor\n\ntc\n\n\n1\n\n\n, then\n\n * if a is declared as co-variant, then all the positive positions in u are positive positions in t and all negative positions in u are negative positions in t\n * if a is declared as contra-variant, then all the positive positions in u are negative positions in t and all negative positions in u are positive positions in t\n * if a is declared as non-variant, then u contributes neither positive nor negative positions to t\n\nfor example, in the type\n\nseq<(a, cell<b -> bool>, c -> d)> -> example<int, e, f, g>\n\n\n1\n\n\nwhere cell and example are as defined above (and, recall, the built-in seq and the built-in tuple types are co-variant in their arguments, and the type constructor -> is like arrow above), the type variables in positive positions are c and g, and the type variables in negative positions are a, d, and e.\n\n\n# 5.âfive type-parameter modes\n\nin most programming languages that support type-parameter variance, you will encounter only the 3 modes of variance i've discussed so far. if that's all you want to know, you can stop reading now. (dafny's defaults are such that you rarely need to know about more than these 3 modes.)\n\ndafny, it turns out, has 5 type-parameter modes. the additional modes come about because dafny is concerned with formal verification. to motivate and explain the additional modes, i will review a property about datatypes, show a subtle way that mere type declarations can cause a logical contradiction, introduce the concept of cardinality preservation, and then come back to dafny.\n\n\n# 6.âinjectivity\n\nthe constructors of a datatype or codatatype are injective in their arguments. this means that there is only one way to construct a particular datatype value.\n\nin more detail, let's review four properties of datatypes. for illustration, let's consider a standard list definition (of integersâjust to keep things simple).\n\ndatatype list = nil | cons(head: int, tail: list)\n\n\n1\n\n\nfirst, this definition says that there are two variants of lists: those that are constructed using nil and those that are constructed using cons. so, for any value xs of type list, the disjunction\n\nxs.nil? || xs.cons?\n\n\n1\n\n\nalways holds. second, the two variants give rise to different values. so,\n\n!(xs.nil? && xs.cons?)\n\n\n1\n\n\nalways holds. third, each constructor is a function, in the sense that its arguments (and nothing else!) determine the value they produce. so,\n\nx == y && xs == ys  ==>  cons(x, xs) == cons(y, ys)\n\n\n1\n\n\nalways holds. fourth, two values of the same variant are equal only if the corresponding arguments are equal. so,\n\ncons(x, xs) == cons(y, ys)  ==>  x == y && xs == ys\n\n\n1\n\n\nit's this fourth property that is called injectivity. more precisely, a datatype constructor is injective in each argument. (an alternate name for âinjectiveâ is âone-to-oneâ.) when a function is injective (in an argument), there exists an inverse function (for that argument). for a datatype, those inverse functions are called destructors, and they can be given names by introducing names for the parameters of the constructors. in the list declaration above, the inverse functions for cons were introduced as .head and .tail. so, we have\n\ncons(x, xs).head == x  &&  cons(x, xs).tail == xs\n\n\n1\n\n\n\n# 7.âa logical contradiction\n\nconsider the following type declarations:\n\ntype f = d -> bool\ndatatype d = ctor(f: f)\n\n\n1\n2\n\n\ni'm now going to argue that there is an infinite number of values of type d. regardless of how many d values there are, we can define a function f``0 of type f that always returns false. if we pass in f``0 to ctor, we get a d value, call it d``0. (we just proved that the set of d values is nonempty!) from our definition of f``0, we have that f``0``(d``0``) == false. next, let's define a function f``1 that is like f``0, except that it returns true for d``0. define d``1 to be the value ctor(f``1``). because f``0 is different from f``1, the injectivity of ctor tells us that d``0 is different from d``1. (we have now shown that there are at least 2 d values!) next, define a function f``2 that is like f``1, except that it returns true for d``1. by passing f``2 to ctor, we get yet another d value. we can continue this process forever, which shows that there is no finite bound on the number of d values. hence, the set of d values is infinite.\n\nhow many f values are there? if d were finite, you would immediately answer 2``|d|, where |d| is the size of dâalso known as the cardinality of dâbecause for each d value, f may return one of 2 values. this is called the powerset of d. but as we just concluded above, d is infinite. well, it turns out that the answer is still the same: the cardinality of f is 2``|d|, where we're using cardinal numbers instead of natural numbers. this sounds mathematical, but all you need to know is that the inequality n < 2``n holds for cardinal numbers just like it holds for natural numbers (see, e.g., theorem 22.10 of [3]). in other words, the number of f values is strictly larger than the number of d values.\n\nthis is trouble.\n\nfor every f value, we can construct a d value, and thus |f| <= |d|. but we concluded above that |d| < 2``|d| and 2``|d|`` == |f|. putting these facts together by transitivity, we get |f| < |f|, which is just false.\n\nusing a construction akin to cantor's diagonalization argument [6] or russell's paradox [5], we can exploit this contradiction in cardinalities and prove false:\n\nlemma false()\n  ensures false\n{\n  var g := (d: d) => !d.f(d);\n  var dd := ctor(g);\n  calc {\n    g(dd);\n  ==  // def. g\n    !dd.f(dd);\n  ==  { assert dd.f == g; }\n    !g(dd);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwell, it's more accurate to say that this could be trouble, because it would let us prove false. luckily, the type definitions for f and d are not accepted by dafny. that is, to avoid this logical contradiction, dafny does not allow a datatype (here, d) to be defined in terms of right-hand sides that would have larger cardinalities than d itself.\n\n\n# 8.âcardinality requirement\n\nto avoid the contradiction in cardinalities when defining a type d as some type expression t(d), we must make sure the cardinalities of d and t(d) can be the same. that is, we need to be able to make d large enough that its cardinality equals that of t(d). the previous section showed an example where this is not possible, because no matter how big you make d, t(d) will be exponentially larger. i'll refer to this condition as the cardinality requirement.\n\na contradiction in cardinalities can occur only if a type is defined in terms of itself. that is, suppose a type d is defined to be rhs. if rhs does not depend on d, then d will, without risk of any contradiction, have the same cardinality as rhs. a problem can occur only if rhs depends on d. for all cases of non-trivial dependencies, one can use an argument like in section 7 to show that d has an infinite number of elements. therefore, when designing a restriction to enforce the cardinality requirement, we only need to think about types of infinite cardinality.\n\nin type theory, we can think of a fixed repertoire of type compositions. types are either type names or sum-type, product-type, or arrow-type compositions. type names include built-in types like bool and int, and also include user-defined types, like d from above. sum types correspond to the variants of a datatype. product types correspond to the list of arguments in each such variant. finally, arrow types are the types of functions.\n\nusing standard type-theory notation for these types and for the cardinality of the type named , the cardinality of types, denoted , is defined as follows:\n\nfrom this definition, we see that the cardinality is a polynomial of the cardinalities of the type names involved, except in the case of arrow types. for any polynomial and infinite cardinal number , equals . so, the only way to violate the cardinality requirement is if d occurs in the left-hand argument of an arrow type.\n\nnote. just because d occurs in the left-hand argument to an arrow does not mean there is a problem with cardinalities. in particular, arrow types are harmless if the right-hand type has cardinality 0 or 1, and so are product types where an argument has cardinality 0. for example, empty is an empty type (that is, a type with cardinality 0) and singleton is a unit type (that is, a type with cardinality 1), then there is no cardinality concern with the type\n\ndatatype d = done | more(d -> empty, d -> singleton, (d, empty) -> int)\n\n\n1\n\n\nnevertheless, dafny's rules forbid this type, too, because the rules do not look for the special cases with cardinality-0 or cardinality-1 types. that's alright. by forbidding these trivial types, the rules both eliminate actual cardinality problems and stay simple.\n\nthe crucial point is this: except for cardinality-0 types that are used as arguments to product types or as left-hand arguments to arrow types,\n\n> a type expression t(d) that mentions d is always at least as big as d.\n\nthis leads us to a proposed way to enforce the cardinality requirement:\n\n> for any type d defined to be t(d), do not allow d to be mentioned in the left-hand argument of any arrow type in t(d).\n\nthe proposed rule talks about left-hand arguments of arrow types, which reminds us of the positive/negative positions we discussed in section 4 as a way to enforce variance restrictions. some people think of the cardinality requirement as taking a step beyond saying d must be in positive positions. that is, whereas a doubly negative position (like x in (x -> bool) -> bool) is a positive position, the cardinality requirement seems to call for a strictly positive positions, where a doubly negative position is still a negative position. for this reason, you sometimes hear that the cardinality requirement is enforced by strict positivity. (i'll have more to say about this in section 12.)\n\nbut wait! weren't we discussing type parameters? what does the cardinality requirement have to do with type parameters?\n\n\n# 9.âtype parameters and cardinality\n\na variation of the example logical contradiction we saw in section 7 can be written using type parameters:\n\ntype g<x> = x -> bool\ndatatype e = ctor(g: g<e>)\n\n\n1\n2\n\n\nonce the type synonym g is expanded, we get the same example, and indeed the same contradiction.\n\nin a modular setting, it is not realistic to rely on being able to expand all types before checking for cardinality problems. for example, suppose type g is declared in a different module that exports g as an opaque type. a client module might then see just\n\ntype g<x>\ndatatype e = ctor(g: g<e>)\n\n\n1\n2\n\n\nfrom which it is not evident whether or not there may be problems with cardinality.\n\nto solve this problem, dafny lets every type constructor declare which of its type parameters are used in ways that preserve cardinality. the mark ! in the following example illustrates:\n\ntype example<x, !y>\n\n\n1\n\n\nthis declaration says that example uses type parameter x in a way that adheres to the cardinality requirement, whereas it does not promise the same for y. this means that\n\ndatatype good = none | some(example<good, int>)\n\n\n1\n\n\nis legal, whereas\n\ndatatype bad = none | some(example<int, bad>) // error: violates cardinality requirement\n\n\n1\n\n\nis not, because it may violate the cardinality requirement.\n\nwe can now state the enforcement of the cardinality requirement precisely. ignoring syntax, like i did in section 4, we can view all types as type constructors that take a list of type parameters, each of which is identified as cardinality preserving or possibly not cardinality preserving. for any type t,\n\n * if t has the form x where x is a type parameter, then this occurrence of x is a cardinality-preserving position iff x is marked as cardinality preserving.\n\n * \n\nif\n\nt\n\n\n1\n\n\nhas the form\n\ntc<..., u, ...>\n\n\n1\n\n\nwhere type expression\n\nu\n\n\n1\n\n\nis passed in as the type parameter\n\na\n\n\n1\n\n\nin type constructor\n\ntc\n\n\n1\n\n\n, then\n\n * if a is declared as cardinality preserving, then all the cardinality-preserving positions in u are cardinality-preserving positions in t\n * if a is not declared as cardinality preserving, then u does not contribute any cardinality-preserving positions to t\n\nthe cardinality requirement is now enforced by the following cardinality-preservation rule: for any type d<..., x, ...> defined as rhs,\n\n * in rhs, d is allowed to be used only in cardinality-preserving positions.\n * if x is marked as cardinality preserving, then, in rhs, x is allowed to be used only in cardinality-preserving positions.\n\n\n# 10.âcombining variance and cardinality preservation\n\nwith 3 kinds of variance, each with cardinality preservation or not, you'd think we'd have 6 modes altogether. but there is no way to be contra-variant and cardinality preservingâin terms of arrow types, contra-variance says the type parameter is to the left of some arrow, and that makes it not preserve cardinality. therefore, dafny supports 5 modes. the default mode is non-variant, cardinality preserving. the other four modes can be indicated with the prefix marks +, *, -, and !, as shown by this table:\n\n                 cardinality preserving   \nvariance         yes                      not necessarily\n                                          \nco-variant       +                        *\ncontra-variant   n/a                      -\nnon-variant      (default)                !\n\n\n# 11.âbuilt-in type constructors\n\ndafny has several built-in type constructors. here are their type-parameter modes:\n\nset<+a>          // finite sets\niset<*a>         // possibly infinite sets\nseq<+a>          // sequences\nmultiset<+a>     // multisets\nmap<+a, +b>      // finite maps\nimap<*a, +b>     // possibly infinite maps\n(+a, +b, +c)     // tuple types\n-a -> +b         // arrow type for total functions\n-a --\x3e +b        // arrow type for partial functions\n-a ~> +b         // arrow type for general functions\narray<a>         // arrays\narray2<a>        // multi-dimensional arrays\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nmost of these are probably what you'd expect. for example, as we have seen above in examples, sequences are co-variant in their type argument, and they are also cardinality preserving. tuple types (a 3-tuple is shown above) are built-in datatypes and they are co-variant and cardinality-preserving in all their arguments. array types of any dimension are reference types, which are restricted to be non-variant in their type parameters, and they are also cardinality preserving. arrow types are co-variant and cardinality preserving in their last type parameter and, as we have discussed, contra-variant and not cardinality preserving in the other type parameters.\n\nsome of type modes among the built-in types are more subtle. if you're tired of considering subtleties and are happy to accept the type-parameter modes of the built-in types, you can skip the rest of this section. if you want understand the rationale behind these type-parameter modes, keep reading.\n\n\n# 11.0.âiset and ->\n\nan iset<x> is a possibly infinite set of x's. we can think of such a set as a function that for each x returns true or false, depending on whether or not the value is in the set. so, iset<x> is like the type x -> bool, which is not cardinality preserving in x.0 but why is iset<x> co-variant in x while x -> bool is contra-variant in x?\n\nwhat i'm about to say applies to any types y and x where y is a subtype of x, but i find it helpful to think of specific, familiar types, so i will instead use the types nat and int.\n\nsince nat is a subtype of int, co-variance would say that every iset<nat> value is also an iset<int> value. indeed, a set containing only non-negative integers is also an iset<int>, so it makes sense that iset is co-variant in its type argument.\n\nif -> were co-variant, then any nat -> bool function would have to be a int -> bool function, which isn't so. for example, consider the nat -> bool function\n\n(n: nat) => 1000 / (n+1) < 20\n\n\n1\n\n\nthis function evaluates to false for 3 and evaluates to true for 999. if we ignore the \": nat\" type of the function's argument and try to think of the function as having type int -> bool, we expect to get a bool value if we apply the function to any integer. but the function's body is undefined for -1, so clearly it's not like an int -> bool function. we conclude that -> is not co-variant in its first argument.\n\ninstead, it is contra-variant in its first argument. that is, every int -> bool function is also a nat -> bool function. being the latter says you get a bool result whenever you apply it to a non-negative integer. since that's also true for any int -> bool function, it makes sense to say -> is contra-variant in its first argument.\n\n\n# 11.1.âtwo subtle consequences\n\nthere are two subtle consequences of the decision to make iset co-variant and _ -> bool contra-variant. they have to do with expressing membership/domain. to talk about them, let me first be explicit about the following principle in the dafny language design:\n\n * the static types don't alter values principle.\n   \n   a static type says something about the value, but does not alter the value. if y is a subtype of x, then you're allowed to assign a value of type y to a variable of type x. in dafny, such an assignment does not alter the value assigned. for example, given variables\n   \n   x: x    y: y    originaly: y\n   \n   \n   1\n   \n   \n   the following assignments are allowed and result in the assertion being verified:\n   \n   originaly := y; // save the value of y\n   x := y; // assign y to a variable of a different type (a supertype)\n   y := x; // assign x back to y\n   assert x == y == originaly;\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   the assignment from y to x is allowed, since y is a subtype of x. the assignment from x to y is allowed by the type system, but generates a proof obligation that the value of x at the time of the assignment is indeed a value of type y. since neither assignment alters the value, the final assertion succeeds.\n\nnow, if s has type iset<int>, then the expression -7 in s evaluates to a boolean that tells us whether or not -7 is an element of set s. suppose t has type iset<nat>. is the expression -7 in t legal? yes, because we could assign t to s (which, according to the language-design principle above, does not alter the value) and then ask -7 in s. since there is a way to ask about -7's membership in t, it seems fine to allow the expression -7 in t directly, and that's what dafny does.\n\nnote. one could try to imagine a different language design, where an iset<int> value would be allowed to masquerade as an iset<nat> value. in such a language, consider the following program snippet, where variables s and t have types iset<int> and iset<nat>, respectively:\n\nt := s;\nassert s == t;\nassert -7 in s <==> -7 in t;\n\n\n1\n2\n3\n\n\nby the static types don't alter values principle, the first assertion should hold. and if s and t are indeed equal, then the next assertion should also hold. but that's nonsense, since every element of an iset<nat> is non-negative. perhaps the language could outlaw the expression -7 in t, since -7 is not a value in the element type (nat) of the static type of tâbut this doesn't help, since (as we considered above) we can ask about -7's membership in t without writing -7 in t directly. the conclusion is that such an imagined language design goes against the static types don't alter values principle.\n\nnext, if f is an int -> bool function, we can (by contra-variance) assign it to a variable g of type nat -> bool. since f is defined on every integer, the expression f.requires(-7) is true. so what about g.requires(-7)? it would be strange for it to return true, since -7 is not a value of the first type parameter of g's type. but we also can't let it return false, because then g is not equal to f, which violates the static types don't alter values principle. the only way out is to try to outlaw g.requires(-7).\n\nfor an expression e of static type a -> b, dafny defines e.requires to have type a -> bool. so, f.requires has type int -> bool, which means one can pass -7 to it. but g.requires has type nat -> bool, so it is not legal to pass it -7.\n\n\n# 11.2.âset and iset\n\nhaving looked at iset<x> in detail, our first thought might be that set<x> would be the same. after all, we can view both iset<x> and set<x> as having values of the form x -> bool. while co-variance applies to iset and set alike, the cardinality concern we had with x -> bool and iset<x> does not apply to set<x> (explained next). therefore, set's type parameter is declared with +.\n\nfor any type x, the values of iset<x> are in one-to-one correspondence with the powerset of xâthat is, all functions from x to bool, or, equivalently, all possible subsets of xâwhose cardinality is 2``|x|. the values of set<x> correspond to the finite powerset of xâthat is, the functions from x to bool that return true only for a finite number of elements, or, equivalently, all finite subsets of x. the cardinality of the finite powerset is far smaller. specifically, if x has infinite cardinality (which is the case we are interested in, see section 8), then the cardinality of the finite powerset of x equals the cardinality of x itself (see appendix a for a proof).\n\n\n# 11.3.âmap and imap\n\nthe last point to explain about the type-parameter modes of the built-in type constructors regards finite maps (map<x, y>) and possibly infinite maps (imap<x, y>).\n\nyou can view map<x, y> and imap<x, y> as (finite and possibly infinite) sets of pairs (x, y), with x a value of x and y a value of y. thus, as you consider subtypes (or supertypes) of either x or y, the possible pairs shrink (or grow, respectively). this justifies the map types as being co-variant in both arguments.\n\nvalues of type imap<x, y> are in one-to-one correspondence with the values of type x -> y, so our concerns about cardinality preservation apply (hence, imap declares its first argument with the mark *). but the cardinality of map<x, y>, which allows only a finite number of mappings from x to y, is far smaller. so, analogously to set<x>, when x is infinite, map<x, y> has no more elements than both |x| and |y|.\n\n\n# 12.âother sources\n\nit seems that every textbook or course on types would cover the topic of cardinality preservation (or âstrict positivityâ as it's often called), but i have had difficulty finding such coverage. when i was first learning about this, the most useful reference i found was a seminal paper by elsa gunter [1]. but even that paper left me puzzled as to what types a verification language can allow without the risk of a logical contradiction.\n\ni now think that what had muddled my mind was the phrase âstrict positivityâ. i don't know who invented or popularized that phrase, but given the syntactic enforcement of cardinality preservation, i understand that it's tempting to think of the restriction as a stricter version of the positive-position restriction for type-parameter variance (section 4). but if you think of the requirement as barring a type name from occurring âto the left of any arrowâ, then the motivation is not clear. âpositivityâ has well established connotations with monotonicity, whereas âstrict positivityâ has nothing to do with monotonicity. once you realize the salient point is how the cardinality of a type parameter affects the cardinality of the type generated by a type constructor, the light in your head comes on. if youâlike i didâfeel betrayed by the phrase âstrict positivityâ, youâlike i doâwill feel compelled to instead use the name cardinality preservation.\n\nmany other verification languages incorporate restrictions to avoid logic contradictions. of these, i want to mention the f* language [4], which does not forbid types like those in section 7; instead, to avoid logical contradictions, f* omits the injectivity property of constructors (see section 6) for such types. in other words, the constructors of a datatype in f* are injective only if the type satisfies the cardinality requirement.\n\n\n# 13.âsummary\n\nconsider a (here, unary) type constructor t. variance is a set of type-parameter modes that tell you what you can conclude about the subtyping relationship between t(x) and t(y) by knowing something about the subtyping relationship between x and y. cardinality preservation is a set of type-parameter modes that tell you what you can conclude about the relative cardinalities of t(x) and t(y) by knowing something about the relative cardinalities of x and y. dafny supports 5 type-parameter modes that a type constructor can use to express the desired combination of variance and cardinality preservation.\n\n# acknowledgments\n\ni first learnedâyears agoâabout the logical contradiction in section 7 from jean-christophe filliatre and christine paulin-mohring.\n\nandreas lochbihler demonstrated to me that the contradiction is detectable in dafny, even though dafny has no concepts or types that deal with cardinal numbers directly.\n\ndiscussions with nik swamy caused me to introduce the 5, not 3, type-parameter modes in dafny, but i realize now that i was then still confused by the phrase âstrict positivityâ.\n\nrecently, i had some illuminating discussions with andrei paskevich and jatin arora on this topic.\n\nremy willems asked me questions about the type-parameter mark ! in dafny, which prompted me to write this note to explore the topic in more detail. little did i know i would spend this many words!\n\ni'm grateful to all of these colleagues.\n\ndafny error message movie reference [0].\n\n\n# references\n\n[0]âcontinuum transfunctionerâ. in philip stark, writer, and danny leiner, director, dude, where's my car?, twentieth century fox, alcon entertainment, 2000. ð\n\n[1]elsa l. gunter. why we can't have sml-style datatype declarations in hol. in luc j. m. claesen and michael j. c. gordon, editors, higher order logic theorem proving and its applications, proceedings of the ifip tc10/wg10.2 workshop hol'92., volume a-20 of ifip transactions, pages 561â568. north-holland/elsevier, september 1992. preprint available at http://egunter.cs.illinois.edu/papers/hol1992.pdf. ð\n\n[2]arturo magidin. the cardinality of the set of all finite subsets of an infinite set. math stackexchange, march 2011. https://math.stackexchange.com/questions/27096/the-cardinality-of-the-set-of-all-finite-subsets-of-an-infinite-set/27098#27098. ð\n\n[3]j. donald monk. introduction to set theory. mcgraw-hill, 1969. electronic version available from http://euclid.colorado.edu/~monkd/monk11.pdf. ð\n\n[4]nilhil swamy, et al. f*: a higher-order effectful language designed for program verification. https://fstar-lang.org/. ð\n\n[5]bertrand russell. the principles of mathematics. w. w. norton & company, new york, 2d. ed. reprint edition, 1996. first published in 1903. ð\n\n[6]keith simmons. universality and the liar: an essay on truth and the diagonal argument. cambridge university press, 1993. isbn 978-0-521-43069-2, https://www.google.com/books/edition/universality_and_the_liar/wej3spept0ac. ð\n\n[7]chelivery. cardinality of the set of all finite subset of . math stackexchange, december 2016. https://math.stackexchange.com/questions/2057826/cardinality-of-the-set-of-all-finite-subset-of-mathbbr/2057908#2057908. ð\n\n\n# a.âfinite powerset preserves cardinality\n\nwhile i haven't found the result in a textbook or journal article, math.stackexchange.com contains at least two proofs that finite powersets preserve cardinality [2, 7]. here's a version of [7], but for any infinite set (not just ).\n\ntheorem. let be an infinite set and be the set of all finite subsets of . then, .\n\nproof. to prove and to have the same cardinality, we need to show a bijection between the two. by the schroder-bernstein theorem, it suffices to show an injective function from to and a (possibly different) surjective function from to . the function from each element in to the singleton set in is injective. so, it remains to show a surjective function from to .\n\nfor any natural number , let denote the -element subsets of . we then have that\n\nsince, for each , is a subset of , there exists a surjective function . we define a function by . function is surjective, because for any value in , , so by the surjectivity of there is an such that , and thus .\n\nalright, so we have a surjective function, , from to , but we need to show a surjective function from to . we have (see section 8), and and (since is infinite), so by cardinal arithmetic, . hence, there is a surjective function, call it , from to . we conclude that is a surjective function from to , which completes our proof.\n\n----------------------------------------\n\n0.this had been defined incorrectly in dafny. the issue was reported by travis hance and fixed by jatin arora. â©",charsets:{cjk:!0},lastUpdated:"2022/03/26, 14:38:56",lastUpdatedTimestamp:1648276736e3},{title:"å½æ¡£",frontmatter:{archivesPage:!0,title:"å½æ¡£",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-75b9d625",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"åç±»",frontmatter:{categoriesPage:!0,title:"åç±»",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-27678185",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"æ ç­¾",frontmatter:{tagsPage:!0,title:"æ ç­¾",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-6ae3dba5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2020/05/02, 18:04:18",lastUpdatedTimestamp:1588413858e3},{title:"tips",frontmatter:{title:"tips",date:"2022-04-01T15:09:44.000Z",permalink:"/pages/12f287/",sidebar:"auto",categories:["Tips"],tags:[null],readingShow:"top"},regularPath:"/_posts/tips/tips.html",relativePath:"_posts/tips/tips.md",key:"v-3e5a3109",path:"/pages/12f287/",headersStr:null,content:"# this is a tip",normalizedContent:"# this is a tip",charsets:{},lastUpdated:"2022/04/01, 15:25:10",lastUpdatedTimestamp:164879791e4},{title:"Home",frontmatter:{home:!0,heroText:"Dafny",tagline:"welcome",pageClass:"dafny-index-class",features:[{title:"å¥é¨",details:"Dafnyå¥é¨èµæï¼å¿«éä¸æï¼ð§¸",link:"/peizhi/",imgUrl:"/img/rumen.png"},{title:"è¿é¶",details:"è¿ä¸æ­¥æä¸ºDafnyé«é¶ç©å®¶å§~ð",link:"/zhinan/",imgUrl:"/img/jinjie.png"},{title:"èµæº",details:"ä¸­ææå¡ç¤¾åºï¼éä¸­å­¦ä¹ èµæºð",link:"/ziyuan/",imgUrl:"/img/ziyuan.png"}],readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-87a57784",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/06, 20:36:17",lastUpdatedTimestamp:1649248577e3}],themeConfig:{bodyBgImg:"https://s1.ax1x.com/2022/04/01/q4APj1.png",bodyBgImgOpacity:1,sidebar:{"/00.ç®å½é¡µ/":[["01.åç«¯.md","Dafnyå¥é¨","/peizhi"],["02.æå.md","Dafnyè¿é¶","/zhinan"],["03.æç¨.md","Dafnyæç¨","/jiaocheng"],["04.èµæº.md","æ´å¤","/ziyuan"],["05.æ¶è.md","æ¶è","/shoucang"],["07.tips.md","Dafny tips","/tips"],["08.è¯­è¨.md","languages","/en-US"],["09.æ´å¤.md","Dafny more","/more"]],catalogue:{"åç«¯":"/peizhi","æå":"/zhinan","æç¨":"/jiaocheng","èµæº":"/ziyuan","æ¶è":"/shoucang",tips:"/tips","è¯­è¨":"/en-US","æ´å¤":"/more"},"/10.éç½®/":[{title:"å¥é¨ä»ç»",collapsable:!0,children:[["00.å¥é¨ä»ç»/00.ä»ä¹æ¯Dafny.md","è¯­è¨ä»ç»","/pages/56e571/"]]},{title:"ç¨èµ·æ¥å§",collapsable:!0,children:[["10.ç¨èµ·æ¥å§/00.å®è£.md","å®è£Dafny","/pages/4fa796/"],["10.ç¨èµ·æ¥å§/05.å¿«éå¥é¨.md","å¿«éå¥é¨","/pages/085606/"],["10.ç¨èµ·æ¥å§/10.ç®åä¸æ.md","ç®åä¸æ","/pages/39fb20/"]]}],"/20.æå/":[{title:"Dafnyå¿«éå¥é¨",collapsable:!0,children:[["00.Dafnyå¿«éå¥é¨/00.åºç¡ Basic.md","åºç¡ Basic","/pages/6e15a6/"],["00.Dafnyå¿«éå¥é¨/05.æ¹æ³ Method.md","æ¹æ³ Method","/pages/eba166/"],["00.Dafnyå¿«éå¥é¨/10.å³é®å­ Keyword.md","å³é®å­ Keyword","/pages/83cdf9/"],["00.Dafnyå¿«éå¥é¨/15.å½æ° Function.md","å½æ° Function","/pages/01d76e/"],["00.Dafnyå¿«éå¥é¨/20.ç±» Class.md","ç±» Class","/pages/0fadc1/"],["00.Dafnyå¿«éå¥é¨/30.æ³å Generics.md","æ³å Generics","/pages/a010ab/"],["00.Dafnyå¿«éå¥é¨/35.å£°æ Statement.md","å£°æ Statement","/pages/c4fda3/"],["00.Dafnyå¿«éå¥é¨/40.è¡¨è¾¾å¼ Expression.md","è¡¨è¾¾å¼ Expression","/pages/e8438e/"]]},{title:"ç®åä¾å­",collapsable:!0,children:[["10.ç®åä¾å­/00.å¯»æ¾æå¤§åæå°æ°.md","å¯»æ¾æå¤§åæå°æ°","/pages/0978ce/"],["10.ç®åä¾å­/05.ææ³¢é£å¥æ°å.md","ææ³¢é£å¥æ°å","/pages/e3e481/"],["10.ç®åä¾å­/10.çº¿æ§æ¥è¯¢.md","çº¿æ§æ¥è¯¢","/pages/02fdef/"],["10.ç®åä¾å­/15. å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°.md","å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°","/pages/9b332b/"],["10.ç®åä¾å­/20.éå.md","éå","/pages/3d1110/"],["10.ç®åä¾å­/25.ç»æ­¢.md","ç»æ­¢","/pages/2146d4/"]]}],"/30.æç¨/":[{title:"Dafnyæç¨",collapsable:!0,children:[["00.Dafnyæç¨/00.ä»ç».md","ä»ç»","/pages/877eb3/"],["00.Dafnyæç¨/05.æ¹æ³.md","æ¹æ³","/pages/bf40c0/"],["00.Dafnyæç¨/10.åç½®ååç½®æ¡ä»¶.md","åç½®ååç½®æ¡ä»¶","/pages/2e0c73/"],["00.Dafnyæç¨/15.æ­è¨.md","æ­è¨","/pages/36c1b4/"],["00.Dafnyæç¨/20.å½æ°.md","å½æ°","/pages/a1d5a4/"],["00.Dafnyæç¨/25.å¾ªç¯ä¸åå¼.md","å¾ªç¯ä¸åå¼","/pages/d89435/"],["00.Dafnyæç¨/30.ç»æ­¢.md","ç»æ­¢","/pages/af29e4/"],["00.Dafnyæç¨/35.æ°ç».md","æ°ç»","/pages/828a83/"],["00.Dafnyæç¨/40.éè¯.md","éè¯","/pages/17e8d1/"],["00.Dafnyæç¨/45.è°è¯.md","è°è¯","/pages/cc01af/"],["00.Dafnyæç¨/50.æ¡æ¶.md","æ¡æ¶","/pages/13bbcd/"],["00.Dafnyæç¨/55.äºåæ¥æ¾.md","äºåæ¥æ¾","/pages/1319be/"],["00.Dafnyæç¨/60.ç»è®º.md","ç»è®º","/pages/30a8c2/"]]},{title:"Dafnyè¿é¶è¯­æ³",collapsable:!0,children:[["10.Dafnyè¿é¶è¯­æ³/00.å¼çåå½çº³.md","å¼çåå½çº³","/pages/273cac/"],["10.Dafnyè¿é¶è¯­æ³/05.æ¨¡å.md","æ¨¡å","/pages/9d19b8/"],["10.Dafnyè¿é¶è¯­æ³/10.éå.md","éå","/pages/b9300a/"],["10.Dafnyè¿é¶è¯­æ³/15.åºå.md","åºå","/pages/cb3d21/"],["10.Dafnyè¿é¶è¯­æ³/20.ç»æ­¢.md","ç»æ­¢","/pages/fc6196/"],["10.Dafnyè¿é¶è¯­æ³/25.å¼ç±»å.md","å¼ç±»å","/pages/a2a107/"]]}],"/40.èµæº/":[{title:"å®è·µæ¢ç´¢",collapsable:!0,children:[["00.å®è·µæ¢ç´¢/1.èªå¨å½çº³.md","èªå¨å½çº³","/pages/718207/"],["00.å®è·µæ¢ç´¢/2.èªå¨è°ç¨å¼ç.md","èªå¨è°ç¨å¼ç","/pages/1f579f/"],["00.å®è·µæ¢ç´¢/3.å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD.md","å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD","/pages/f6638c/"],["00.å®è·µæ¢ç´¢/4.åç§æ¨å¯¼å¼.md","åç§æ¨å¯¼å¼","/pages/1d2420/"],["00.å®è·µæ¢ç´¢/5.ä¸åç±»åçè¯æ.md","ä¸åç±»åçè¯æ","/pages/20c275/"],["00.å®è·µæ¢ç´¢/6.éååç´ ä¸çå½æ°.md","éååç´ ä¸çå½æ°","/pages/67167e/"],["00.å®è·µæ¢ç´¢/7.å¨éåä¸è¿­ä»£.md","å¨éåä¸è¿­ä»£","/pages/be298d/"]]},{title:"å¸¸ç¨å·¥å·",collapsable:!0,children:[["10.å¸¸ç¨å·¥å·/00.Dafny type system.md","Dafny type system","/pages/8065fd/"],["10.å¸¸ç¨å·¥å·/05.Style Guide for Dafny programs.md","Style Guide for Dafny programs","/pages/0f17ab/"],["10.å¸¸ç¨å·¥å·/10.Cheet Sheet.md","Cheet Sheet","/pages/a65c3f/"]]}],"/50.æ¶è/":[["01.æ¶èç«.md","æ¶èç«","/pages/1b94a4/"]],"/60.æ¯æ/":[["01.å¯¼èªç«.md","æ¬ç« - å¯¼èªç«æ¨¡å","/pages/30bf81/"]],"/80.è¯­è¨/":[{title:"dafny-quick-start",collapsable:!0,children:[["00.dafny-quick-start/00.Dafny Quick Reference.md","Dafny Quick Reference","/pages/8fb957/"],["00.dafny-quick-start/10.Getting Started with Dafny A Guide.md","Getting Started with Dafny A Guide","/pages/8766fd/"],["00.dafny-quick-start/20.cheet.md","cheet","/pages/fe5721/"]]},{title:"dafny-tutorials",collapsable:!0,children:[["10.dafny-tutorials/00.Getting Started with Dafny A Guide.md","Getting Started with Dafny A Guide","/pages/c80a4c/"]]},{title:"detailed-document",collapsable:!0,children:[["20.detailed-document/00.Dafny type system.md","Dafny type system","/pages/a9c4a5/"],["20.detailed-document/10.Style Guide for Dafny programers.md","Style Guide for Dafny programs","/pages/c0c2c7/"]]},{title:"publication-lecture",collapsable:!0,children:[["30.publication-lecture/00.Automatic Induction.md","Automatic Induction","/pages/a9363c/"],["30.publication-lecture/05.Calling Lemmas Automatically.md","Calling Lemmas Automatically","/pages/30441e/"],["30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md","Case study of definitions, proofs, algorithm correctness GCD","/pages/746026/"],["30.publication-lecture/15.Comprehensions.md","Comprehensions","/pages/da6921/"],["30.publication-lecture/20.Different Styles of Proofs.md","Different Styles of Proofs","/pages/8d8607/"],["30.publication-lecture/30.Functions over Set Elements.md","Functions over Set Elements","/pages/097ba0/"],["30.publication-lecture/35.Iterating over a Collection.md","Iterating over a Collection","/pages/c4484e/"],["30.publication-lecture/40.old and unchanged.md","old and unchanged","/pages/7fe522/"],["30.publication-lecture/45.Short-Circuit Operators.md","Short-Circuit Operators","/pages/369e25/"],["30.publication-lecture/50.Statement versus Expression Syntax.md","Statement versus Expression Syntax","/pages/f8c1c5/"],["30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md","The Parent Trick for proving termination and a function-by-method use case","/pages/5a4346/"],["30.publication-lecture/60.Type-Parameter Completion.md","Type-Parameter Completion","/pages/c45b5a/"],["30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md","Type-parameter modes variance and cardinality preservation","/pages/3c9a0b/"]]}]},sidebarDepth:2,logo:"/img/logo-2.png",repo:"aaron-clou/dafnycommunity",searchMaxSuggestions:10,lastUpdated:"ä¸æ¬¡æ´æ°",docsDir:"docs",editLinks:!0,editLinkText:"ç¼è¾",author:{name:"lijiahai",link:"https://github.com/Aaron-clou"},blogger:{avatar:"https://s1.ax1x.com/2022/04/01/qh3tDe.png",name:"Dafny",slogan:"æ°ä¸ä»£éªè¯è¯­è¨"},social:{iconfontCssFile:"//at.alicdn.com/t/font_3282046_m07s574tfh.css",icons:[{iconClass:"icon-github-fill",title:"Github",link:"https://github.com/Aaron-clou/dafnycommunity"},{iconClass:"icon-gitee2",title:"Gitee",link:"https://gitee.com/leo214/dafnycommunity"},{iconClass:"icon-email-fill",title:"Email",link:"1374921025@qq.com"}]},footer:{createYear:2022,copyrightInfo:"Li Jiahai | Dafny Community | 2022"},nav:[{text:"é¦é¡µ",link:"/"},{text:"éç½®",link:"/peizhi/",items:[{text:"å¥é¨ä»ç»",link:"",items:[{text:"ä»ä¹æ¯dafny?",link:"/pages/56e571/"}]},{text:"ç¨èµ·æ¥å§ï¼",link:"",items:[{text:"å®è£",link:"/pages/4fa796/"},{text:"å¿«éä¸æ",link:"/pages/085606/"},{text:"å¯è½éå°çé®é¢?",link:"/pages/39fb20/"}]}]},{text:"æå",link:"/zhinan/",items:[{text:"Dafnyå¿«éå¥é¨",items:[{text:"åºç¡å­¦ä¹  Basic",link:"/pages/6e15a6/"},{text:"æ¹æ³ Method",link:"/pages/eba166/"},{text:"å³é®å­ Keyword",link:"/pages/83cdf9/"},{text:"å½æ° Function",link:"/pages/01d76e/"},{text:"ç±» Class ",link:"/pages/0fadc1/"},{text:"æ³å Generics",link:"/pages/a010ab/"},{text:"å£°æ Statement",link:"/pages/c4fda3/"},{text:"è¡¨è¾¾å¼ Expression",link:"/pages/e8438e/"}]},{text:"Dafnyç®åä¾å­",link:"",items:[{text:"å¯»æ¾æå¤§æå°æ°å",link:"/pages/0978ce/"},{text:"ææ³¢é£å¥æ°å",link:"/pages/e3e481/"},{text:"çº¿æ§æ¥è¯¢",link:"/pages/02fdef/"},{text:"å¼ç-è®¡ç®åºåéè´åç´ ä¸ªæ°",link:"/pages/9b332b/"},{text:"éå",link:"/pages/3d1110/"},{text:"ç»æ­¢",link:"/pages/2146d4/"}]}]},{text:"æç¨",link:"/jiaocheng/",items:[{text:"Dafnyæå¯¼",items:[{text:"ä»ç»",link:"/pages/877eb3/"},{text:"æ¹æ³ Methods",link:"/pages/bf40c0/"},{text:"åç½®/åç½®æ¡ä»¶ Pre/Postconditions",link:"/pages/2e0c73/"},{text:"æ­è¨ Assertions",link:"/pages/36c1b4/"},{text:"å½æ° Functions",link:"/pages/a1d5a4/"},{text:"å¾ªç¯ä¸åä½ Loop Invariants",link:"/pages/d89435/"},{text:"æ°ç» Arrays",link:"/pages/828a83/"},{text:"éè¯(å½æ°) Quantifiers",link:"/pages/17e8d1/"},{text:"è°è¯(å½æ°) Predicates",link:"/pages/cc01af/"},{text:"æ¡æ¶ Framing",link:"/pages/13bbcd/"},{text:"äºåæç´¢ Binary Search",link:"/pages/1319be/"},{text:"æ»ç»",link:"/pages/30a8c2/"}]},{text:"Dafnyè¿é¶è¯­æ³",items:[{text:"å¼çåå½çº³ Lemmas and Induction",link:"/pages/273cac/"},{text:"æ¨¡å Modules",link:"/pages/9d19b8/"},{text:"éå sets",link:"/pages/b9300a/"},{text:"åºå sequence",link:"/pages/cb3d21/"},{text:"ç»æ­¢ Terminal",link:"/pages/fc6196/"},{text:"å¼ç±»å Values Types",link:"/pages/a2a107/"}]}]},{text:"èµæº",link:"/ziyuan/",items:[{text:"å®è·µæ¢ç´¢",items:[{text:"èªå¨å½çº³",link:"/pages/718207/"},{text:"èªå¨è°ç¨å¼ç",link:"/pages/1f579f/"},{text:"å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§",link:"/pages/f6638c/"},{text:"åç§æ¨å¯¼å¼",link:"/pages/1d2420/"},{text:"ä¸åç±»åçè¯æ",link:"/pages/20c275/"},{text:"éååç´ ä¸çå½æ°",link:"/pages/67167e/"},{text:"å¨éåä¸çè¿­ä»£",link:"/pages/be298d/"}]},{text:"å¸¸ç¨å·¥å·",items:[{text:"Type System",link:"/pages/8065fd/"},{text:"Style Guide",link:"/pages/0f17ab/"},{text:"Cheet Sheet",link:"/pages/fe5721/"}]}]},{text:"â¨æ¶è",link:"/pages/1b94a4/"},{text:"ð·ï¸è¯­è¨",link:"",items:[{text:"ç®ä½ä¸­æ",link:"/"},{text:"English",link:"/en-US/"}]},{text:"ð¬ç¤¾åºçè¨æ¿",link:"/pages/caf1f9/"}],blogInfo:{blogCreate:"2022-2-1",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"åç«¯",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/01.åç«¯.md",wordsCount:40,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"10.éç½®",imgUrl:"/img/rumen.png",description:"è¯­è¨å¥é¨èµæ"}},title:"Dafnyå¥é¨",date:"2020-03-11T21:50:53.000Z",permalink:"/peizhi",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"æå",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/02.æå.md",wordsCount:39,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"20.æå",imgUrl:"/img/jinjie.png",description:"Dafnyè¿é¶æç¨"}},title:"Dafnyè¿é¶",date:"2020-03-11T21:50:54.000Z",permalink:"/zhinan",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"æç¨",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/03.æç¨.md",wordsCount:39,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"30.æç¨",imgUrl:"/img/jinjie.png",description:"Dafnyæç¨éé¦"}},title:"Dafnyæç¨",date:"2020-03-11T21:50:55.000Z",permalink:"/jiaocheng",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"èµæº",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/04.èµæº.md",wordsCount:49,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"40.èµæº",imgUrl:"/img/ziyuan.png",description:"å­¦ä¹ ãé¢è¯ãå¨çº¿å·¥å·ç­æ´å¤æç« åé¡µé¢"}},title:"æ´å¤",date:"2020-03-11T21:50:56.000Z",permalink:"/ziyuan",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"æ¶è",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/05.æ¶è.md",wordsCount:42,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"50.æ¶è",imgUrl:"/img/ziyuan.png",description:"æ´å¤éªè¯è¯­è¨å¨è¿é"}},title:"æ¶è",date:"2020-03-11T21:50:53.000Z",permalink:"/shoucang",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"tips",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/07.tips.md",wordsCount:33,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"70.tips",imgUrl:"/img/ziyuan.png",description:"tips"}},title:"Dafny tips",date:"2020-03-11T21:50:53.000Z",permalink:"/tips",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"è¯­è¨",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/08.è¯­è¨.md",wordsCount:34,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"80.è¯­è¨",imgUrl:"/img/ziyuan.png",description:"language"}},title:"languages",date:"2020-03-11T21:50:53.000Z",permalink:"/en-US",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"æ´å¤",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/00.ç®å½é¡µ/09.æ´å¤.md",wordsCount:35,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"80.æ´å¤",imgUrl:"/img/ziyuan.png",description:"æ´å¤"}},title:"Dafny more",date:"2020-03-11T21:50:53.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"ä»ä¹æ¯Dafny",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.éç½®/00.å¥é¨ä»ç»/00.ä»ä¹æ¯Dafny.md",wordsCount:455,readingTime:"1.6m",title:"è¯­è¨ä»ç»",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/56e571/",categories:["éç½®"],tags:[null]},{name:"å®è£",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.éç½®/10.ç¨èµ·æ¥å§/00.å®è£.md",wordsCount:539,readingTime:"2.6m",title:"å®è£Dafny",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/4fa796/",comment:!0,categories:["éç½®"],tags:[null]},{name:"å¿«éå¥é¨",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.éç½®/10.ç¨èµ·æ¥å§/05.å¿«éå¥é¨.md",wordsCount:"3.7k",readingTime:"14.5m",title:"å¿«éå¥é¨",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/085606/",categories:["éç½®"],tags:[null]},{name:"ç®åä¸æ",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/10.éç½®/10.ç¨èµ·æ¥å§/10.ç®åä¸æ.md",wordsCount:67,readingTime:"1",title:"ç®åä¸æ",date:"2022-03-22T21:51:40.000Z",permalink:"/pages/39fb20/",categories:["éç½®"],tags:[null]},{name:"çè¨æ¿",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/100.ç¤¾åºçè¨æ¿/çè¨æ¿.md",wordsCount:355,readingTime:"2m",title:"çè¨æ¿",date:"2022-03-24T12:22:23.000Z",permalink:"/pages/caf1f9/",categories:["ç¤¾åºçè¨æ¿"],tags:null,article:!1,sidebar:!1,editLink:!1},{name:"åºç¡ Basic",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/00.åºç¡ Basic.md",wordsCount:405,readingTime:"1.5m",title:"åºç¡ Basic",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/6e15a6/",categories:["æå"],tags:[null]},{name:"æ¹æ³ Method",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/05.æ¹æ³ Method.md",wordsCount:411,readingTime:"1.6m",title:"æ¹æ³ Method",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/eba166/",categories:["æå"],tags:[null]},{name:"å³é®å­ Keyword",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/10.å³é®å­ Keyword.md",wordsCount:410,readingTime:"1.6m",title:"å³é®å­ Keyword",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/83cdf9/",categories:["æå"],tags:[null]},{name:"å½æ° Function",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/15.å½æ° Function.md",wordsCount:463,readingTime:"1.8m",title:"å½æ° Function",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/01d76e/",categories:["æå"],tags:[null]},{name:"ç±» Class",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/20.ç±» Class.md",wordsCount:57,readingTime:"1",title:"ç±» Class",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/0fadc1/",categories:["æå"],tags:[null]},{name:"æ³å Generics",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/30.æ³å Generics.md",wordsCount:108,readingTime:"1",title:"æ³å Generics",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/a010ab/",categories:["æå"],tags:[null]},{name:"å£°æ Statement",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/35.å£°æ Statement.md",wordsCount:680,readingTime:"2.6m",title:"å£°æ Statement",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/c4fda3/",categories:["æå"],tags:[null]},{name:"è¡¨è¾¾å¼ Expression",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/00.Dafnyå¿«éå¥é¨/40.è¡¨è¾¾å¼ Expression.md",wordsCount:995,readingTime:"3.8m",title:"è¡¨è¾¾å¼ Expression",date:"2022-03-26T14:12:25.000Z",permalink:"/pages/e8438e/",categories:["æå"],tags:[null]},{name:"å¯»æ¾æå¤§åæå°æ°",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/00.å¯»æ¾æå¤§åæå°æ°.md",wordsCount:258,readingTime:"1m",title:"å¯»æ¾æå¤§åæå°æ°",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/0978ce/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:"ææ³¢é£å¥æ°å",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/05.ææ³¢é£å¥æ°å.md",wordsCount:266,readingTime:"1m",title:"ææ³¢é£å¥æ°å",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/e3e481/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:"çº¿æ§æ¥è¯¢",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/10.çº¿æ§æ¥è¯¢.md",wordsCount:412,readingTime:"1.6m",title:"çº¿æ§æ¥è¯¢",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/02fdef/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:" å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/15. å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°.md",wordsCount:634,readingTime:"2.5m",title:"å¼ç-è®¡ç®åºåä¸­éè´åç´ çä¸ªæ°",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/9b332b/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:"éå",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/20.éå.md",wordsCount:239,readingTime:"1m",title:"éå",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/3d1110/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:"ç»æ­¢",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/20.æå/10.ç®åä¾å­/25.ç»æ­¢.md",wordsCount:199,readingTime:"1",title:"ç»æ­¢",date:"2022-04-06T19:48:23.000Z",permalink:"/pages/2146d4/",categories:["æå","ç®åä¾å­"],tags:["æå­¦ä¾å­"]},{name:"ä»ç»",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/00.ä»ç».md",wordsCount:433,readingTime:"1.5m",title:"ä»ç»",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/877eb3/",categories:["æç¨"],tags:[null]},{name:"æ¹æ³",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/05.æ¹æ³.md",wordsCount:741,readingTime:"2.8m",title:"æ¹æ³",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/bf40c0/",categories:["æç¨"],tags:[null]},{name:"åç½®ååç½®æ¡ä»¶",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/10.åç½®ååç½®æ¡ä»¶.md",wordsCount:"1.7k",readingTime:"6.2m",title:"åç½®ååç½®æ¡ä»¶",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/2e0c73/",categories:["æç¨"],tags:[null]},{name:"æ­è¨",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/15.æ­è¨.md",wordsCount:"2.4k",readingTime:"9.7m",title:"æ­è¨",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/36c1b4/",categories:["æç¨"],tags:[null]},{name:"å½æ°",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/20.å½æ°.md",wordsCount:"1.3k",readingTime:"5.3m",title:"å½æ°",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/a1d5a4/",categories:["æç¨"],tags:[null]},{name:"å¾ªç¯ä¸åå¼",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/25.å¾ªç¯ä¸åå¼.md",wordsCount:"2.6k",readingTime:"10.6m",title:"å¾ªç¯ä¸åå¼",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/d89435/",categories:["æç¨"],tags:[null]},{name:"ç»æ­¢",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/30.ç»æ­¢.md",wordsCount:913,readingTime:"3.5m",title:"ç»æ­¢",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/af29e4/",categories:["æç¨"],tags:[null]},{name:"æ°ç»",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/35.æ°ç».md",wordsCount:732,readingTime:"2.7m",title:"æ°ç»",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/828a83/",categories:["æç¨"],tags:[null]},{name:"éè¯",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/40.éè¯.md",wordsCount:"1.6k",readingTime:"6.4m",title:"éè¯",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/17e8d1/",categories:["æç¨"],tags:[null]},{name:"è°è¯",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/45.è°è¯.md",wordsCount:422,readingTime:"1.5m",title:"è°è¯",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/cc01af/",categories:["æç¨"],tags:[null]},{name:"æ¡æ¶",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/50.æ¡æ¶.md",wordsCount:960,readingTime:"3.5m",title:"æ¡æ¶",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/13bbcd/",categories:["æç¨"],tags:[null]},{name:"äºåæ¥æ¾",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/55.äºåæ¥æ¾.md",wordsCount:"1k",readingTime:"4.6m",title:"äºåæ¥æ¾",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/1319be/",categories:["æç¨"],tags:[null]},{name:"ç»è®º",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/00.Dafnyæç¨/60.ç»è®º.md",wordsCount:429,readingTime:"1.4m",title:"ç»è®º",date:"2022-03-25T21:54:53.000Z",permalink:"/pages/30a8c2/",categories:["æç¨"],tags:[null]},{name:"å¼çåå½çº³",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/00.å¼çåå½çº³.md",wordsCount:"7.4k",readingTime:"32.8m",title:"å¼çåå½çº³",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/273cac/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"æ¨¡å",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/05.æ¨¡å.md",wordsCount:"4.1k",readingTime:"16.7m",title:"æ¨¡å",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/9d19b8/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"éå",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/10.éå.md",wordsCount:"1.5k",readingTime:"6.5m",title:"éå",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/b9300a/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"åºå",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/15.åºå.md",wordsCount:"1.6k",readingTime:"7m",title:"åºå",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/cb3d21/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"ç»æ­¢",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/20.ç»æ­¢.md",wordsCount:"1.8k",readingTime:"6.8m",title:"ç»æ­¢",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/fc6196/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"å¼ç±»å",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/30.æç¨/10.Dafnyè¿é¶è¯­æ³/25.å¼ç±»å.md",wordsCount:"5.1k",readingTime:"20.6m",title:"å¼ç±»å",date:"2022-03-26T16:32:54.000Z",permalink:"/pages/a2a107/",categories:["æç¨","Dafnyè¿é¶è¯­æ³"],tags:[null]},{name:"èªå¨å½çº³",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/1.èªå¨å½çº³.md",wordsCount:"5.2k",readingTime:"20.1m",title:"èªå¨å½çº³",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/718207/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"èªå¨è°ç¨å¼ç",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/2.èªå¨è°ç¨å¼ç.md",wordsCount:"1.7k",readingTime:"6.5m",title:"èªå¨è°ç¨å¼ç",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1f579f/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/3.å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD.md",wordsCount:"5.2k",readingTime:"21.1m",title:"å®ä¹ãè¯æãç®æ³æ­£ç¡®æ§çæ¡ä¾ç ç©¶GCD",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/f6638c/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"åç§æ¨å¯¼å¼",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/4.åç§æ¨å¯¼å¼.md",wordsCount:"7k",readingTime:"28.5m",title:"åç§æ¨å¯¼å¼",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/1d2420/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"ä¸åç±»åçè¯æ",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/5.ä¸åç±»åçè¯æ.md",wordsCount:"4.9k",readingTime:"19.5m",title:"ä¸åç±»åçè¯æ",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/20c275/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"éååç´ ä¸çå½æ°",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/6.éååç´ ä¸çå½æ°.md",wordsCount:"2.6k",readingTime:"10.2m",title:"éååç´ ä¸çå½æ°",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/67167e/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"å¨éåä¸è¿­ä»£",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/00.å®è·µæ¢ç´¢/7.å¨éåä¸è¿­ä»£.md",wordsCount:"3.5k",readingTime:"14.3m",title:"å¨éåä¸è¿­ä»£",date:"2022-03-25T21:11:09.000Z",permalink:"/pages/be298d/",categories:["èµæº","Dafnyå®è·µæ¢ç´¢"],tags:[null]},{name:"Dafny type system",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/10.å¸¸ç¨å·¥å·/00.Dafny type system.md",wordsCount:"14.7k",readingTime:"57.9m",title:"Dafny type system",date:"2022-03-26T16:59:26.000Z",permalink:"/pages/8065fd/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:[null]},{name:"Style Guide for Dafny programs",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/10.å¸¸ç¨å·¥å·/05.Style Guide for Dafny programs.md",wordsCount:"1.6k",readingTime:"7m",title:"Style Guide for Dafny programs",date:"2022-03-26T17:01:15.000Z",permalink:"/pages/0f17ab/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:"111 -"},{name:"Cheet Sheet",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/40.èµæº/10.å¸¸ç¨å·¥å·/10.Cheet Sheet.md",wordsCount:449,readingTime:"2.7m",title:"Cheet Sheet",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/a65c3f/",categories:["èµæº","å¸¸ç¨å·¥å·"],tags:[null]},{name:"æ¶èç«",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/50.æ¶è/01.æ¶èç«.md",wordsCount:489,readingTime:"2.5m",title:"æ¶èç«",date:"2022-03-25T11:48:45.000Z",permalink:"/pages/1b94a4/",categories:["æ¶è"],tags:[null]},{name:"å¯¼èªç«",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/60.æ¯æ/01.å¯¼èªç«.md",wordsCount:382,readingTime:"1.9m",title:"æ¬ç« - å¯¼èªç«æ¨¡å",date:"2022-01-11T14:03:46.000Z",categories:[null],tags:[null],permalink:"/pages/30bf81/"},{name:"Dafny Quick Reference",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/00.dafny-quick-start/00.Dafny Quick Reference.md",wordsCount:"3.8k",readingTime:"14.6m",title:"Dafny Quick Reference",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8fb957/",categories:["è¯­è¨","dafny-quick-start"],tags:[null]},{name:"Getting Started with Dafny A Guide",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/00.dafny-quick-start/10.Getting Started with Dafny A Guide.md",wordsCount:"11k",readingTime:"1h8m",title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:02:27.000Z",permalink:"/pages/8766fd/",categories:["è¯­è¨","dafny-quick-start"],tags:[null]},{name:"cheet",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/00.dafny-quick-start/20.cheet.md",wordsCount:448,readingTime:"2.7m",title:"cheet",date:"2022-03-26T11:02:27.000Z",categories:["è¯­è¨","dafny-quick-start"],tags:[null],permalink:"/pages/fe5721/"},{name:"Getting Started with Dafny A Guide",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/10.dafny-tutorials/00.Getting Started with Dafny A Guide.md",wordsCount:"11k",readingTime:"1h8m",title:"Getting Started with Dafny A Guide",date:"2022-03-26T11:03:41.000Z",permalink:"/pages/c80a4c/",categories:["è¯­è¨","dafny-tutorials"],tags:[null]},{name:"Dafny type system",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/20.detailed-document/00.Dafny type system.md",wordsCount:"10.8k",readingTime:"1h7m",title:"Dafny type system",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/a9c4a5/",categories:["è¯­è¨","detailed-document"],tags:[null]},{name:"Style Guide for Dafny programers",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/20.detailed-document/10.Style Guide for Dafny programers.md",wordsCount:"1.2k",readingTime:"7.5m",title:"Style Guide for Dafny programs",date:"2022-03-26T11:03:01.000Z",permalink:"/pages/c0c2c7/",categories:["è¯­è¨","detailed-document"],tags:[null]},{name:"Automatic Induction",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/00.Automatic Induction.md",wordsCount:"3.9k",readingTime:"24.1m",title:"Automatic Induction",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/a9363c/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Calling Lemmas Automatically",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/05.Calling Lemmas Automatically.md",wordsCount:"1.2k",readingTime:"7.5m",title:"Calling Lemmas Automatically",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/30441e/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Case study of definitions, proofs, algorithm correctness GCD",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md",wordsCount:"3.9k",readingTime:"24.6m",title:"Case study of definitions, proofs, algorithm correctness GCD",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/746026/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Comprehensions",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/15.Comprehensions.md",wordsCount:"5.3k",readingTime:"32.8m",title:"Comprehensions",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/da6921/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Different Styles of Proofs",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/20.Different Styles of Proofs.md",wordsCount:"3.6k",readingTime:"22.6m",title:"Different Styles of Proofs",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/8d8607/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Functions over Set Elements",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/30.Functions over Set Elements.md",wordsCount:"1.9k",readingTime:"12m",title:"Functions over Set Elements",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/097ba0/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Iterating over a Collection",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/35.Iterating over a Collection.md",wordsCount:"2.6k",readingTime:"16.5m",title:"Iterating over a Collection",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c4484e/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"old and unchanged",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/40.old and unchanged.md",wordsCount:"2.9k",readingTime:"18m",title:"old and unchanged",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/7fe522/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Short-Circuit Operators",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/45.Short-Circuit Operators.md",wordsCount:"1.1k",readingTime:"6.9m",title:"Short-Circuit Operators",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/369e25/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Statement versus Expression Syntax",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/50.Statement versus Expression Syntax.md",wordsCount:"4.7k",readingTime:"29.1m",title:"Statement versus Expression Syntax",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/f8c1c5/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"The Parent Trick for proving termination and a function-by-method use case",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md",wordsCount:"4.1k",readingTime:"25.4m",title:"The Parent Trick for proving termination and a function-by-method use case",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/5a4346/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Type-Parameter Completion",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/60.Type-Parameter Completion.md",wordsCount:"2.1k",readingTime:"13.1m",title:"Type-Parameter Completion",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/c45b5a/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"Type-parameter modes variance and cardinality preservation",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/80.è¯­è¨/30.publication-lecture/65.Type-parameter modes variance and cardinality preservation.md",wordsCount:"7.9k",readingTime:"49.1m",title:"Type-parameter modes variance and cardinality preservation",date:"2022-03-26T11:04:26.000Z",permalink:"/pages/3c9a0b/",categories:["è¯­è¨","publication-lecture"],tags:[null]},{name:"tips",filePath:"/home/runner/work/dafnycommunity/dafnycommunity/docs/_posts/tips/tips.md",wordsCount:21,readingTime:"1",title:"tips",date:"2022-04-01T15:09:44.000Z",permalink:"/pages/12f287/",sidebar:"auto",categories:["Tips"],tags:[null]}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500},indexImg:{navColor:2,switchNavColor:!0,bgTimeColor:!0,bgTimeColorArray:["rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)","rgba(0, 0, 0, .3)"],descFade:!0,desc:["Dafny -- New Verification Language","Welcome to our Dafny community","Hello,explorer!"],descFontSize:"1.5rem",descFadeInTime:200,descFadeOutTime:!1,descNextTime:8e3,bubble:!0,bubblePosition:0,bubbleNum:10}},locales:{"/":{lang:"zh-CN",title:"Dafny",description:"Dafnyä¸­æç¤¾åº",path:"/"}}};function Kr(n){var e=document.querySelector(n);e&&e.parentNode.removeChild(e)}function Jr(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".articleInfo-wrap > .articleInfo > .info",t=0,a=setInterval((function(){t++;var i=document.querySelector(e);i?Qr(n,i)||(i.appendChild(n),clearInterval(a)):t>10&&clearInterval(a)}),1e3)}function Qr(n,e){return n.parentNode==e}t(133),t(149),t(134);var nl=t(212),el=t(213),tl=(t(231),t(233),t(42));var al={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,a=e.article,i=e.home;return!(t||!1===a||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(tl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(tl.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(tl.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},a=function(a,i){var s=n[a].frontmatter,o=s.categories,r=s.tags;"array"===Object(tl.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[a]))})),"array"===Object(tl.n)(r)&&r.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[a]))}))},i=0,s=n.length;i<s;i++)a(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var a in n.categories)e.push({key:a,length:n.categories[a].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Li.component(nl.default),Li.component(el.default);function il(n){return n.toString().padStart(2,"0")}t(375);Li.component("BlockToggle",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,492))})),Li.component("Card",(function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,493))})),Li.component("IndexBigImg",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,494))})),Li.component("Twikoo",(function(){return Promise.all([t.e(0),t.e(7)]).then(t.bind(null,495))})),Li.component("WebInfo",(function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,488))})),Li.component("Badge",(function(){return Promise.all([t.e(0),t.e(8)]).then(t.bind(null,576))})),Li.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,212))})),Li.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,213))}));t(376),t(220);var sl={name:"ReadingProgress",data:function(){return{readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}},watch:{$readingShow:function(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted:function(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy:function(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base:function(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase:function(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:function(){return Math.max(document.body.scrollHeight,document.body.offsetHeight,0)},getScreenHeight:function(){return Math.max(window.innerHeight,document.documentElement.clientHeight,0)},getReadingTop:function(){return Math.max(window.pageYOffset,document.documentElement.scrollTop,0)},getTransform:function(){var n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find((function(e){return e in n.style}))||void 0},getProgressStyle:function(){var n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?"".concat(this.transform,": scaleX(").concat(n,")"):"width: ".concat(100*n,"%");case"left":case"right":return this.transform?"".concat(this.transform,": scaleY(").concat(n,")"):"height: ".concat(100*n,"%");default:return null}}}},ol=(t(377),Object(Hr.a)(sl,(function(){var n=this.$createElement,e=this._self._c||n;return e("ClientOnly",[this.$readingShow?e("div",{staticClass:"reading-progress",class:this.$readingShow},[e("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),rl=[function(n){n.Vue,n.options;var e=n.router,a=n.siteData;n.isServer||e.beforeEach((function(n,e,i){i(),"/"!==n.path&&n.path!==e.path&&a.themeConfig.blogInfo&&(Kr(".page-view-js"),Kr(".page-view"),Kr(".book-words"),Kr(".reading-time"),a.pages.forEach((function(e){if(e.path==n.path&&(null==e.frontmatter.article||e.frontmatter.article)){var i=a.themeConfig.blogInfo,s=i.eachFileWords,o=i.pageView,r=i.pageIteration,l=i.readingTime;return s&&s.forEach((function(n){var t,a;n.permalink==e.frontmatter.permalink&&(!function(n){if(n){var e=document.createElement("div");e.title="æç« å­æ°",e.className="book-words iconfont icon-book",e.style.float="left",e.style.marginLeft="20px",e.style.fontSize="0.8rem",e.innerHTML='<a href="javascript:;" style="margin-left: 3px; color: #888">'.concat(n,"</a>"),Jr(e)}}(n.wordsCount),(l||null==l)&&(t=n.readingTime,(a=document.createElement("div")).title="é¢éè¯»æ¶é¿",a.className="reading-time iconfont icon-shijian",a.style.float="left",a.style.marginLeft="20px",a.style.fontSize="0.8rem",a.innerHTML='<a href="javascript:;" style="margin-left: 3px; color: #888">'.concat(t,"</a>"),Jr(a)))})),void((o||null==o)&&(!function(){var n=document.createElement("div");n.title="æµè§é",n.className="page-view iconfont icon-view",n.style.float="left",n.style.marginLeft="20px",n.style.fontSize="0.8rem",n.innerHTML='<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="æ­£å¨è·å..." class="loading iconfont icon-loading"></i></a>',Jr(n);var e=document.createElement("style");e.innerHTML="@keyframes turn {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  .loading {\n    display: inline-block;\n    animation: turn 1s linear infinite;\n    -webkit-animation: turn 1s linear infinite;\n  }",document.head.appendChild(e)}(),setTimeout((function(){!function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3e3;Yr?Yr.fetch():Yr=t(230);var e=0,a="9999";setTimeout((function(){var t=setInterval((function(){var i=document.querySelector(".view-data");i?((e+=n)>10*n&&(i.innerText=a,clearInterval(t)),""==i.innerText?Yr.fetch():clearInterval(t)):clearInterval(t)}),n)}),n)}(r)}),1500)))}})))}))},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,a=e.date,i=e.author;"string"==typeof a&&"Z"===a.charAt(a.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(il(n.getUTCMonth()+1),"-").concat(il(n.getUTCDate())," ").concat(il(n.getUTCHours()),":").concat(il(n.getUTCMinutes()),":").concat(il(n.getUTCSeconds()))}(a)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(al)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){var e=n.Vue;e.component(ol.name,ol),e.mixin({computed:{$readingShow:function(){return this.$page.frontmatter.readingShow}}})}],ll=["ReadingProgress","Twikoo","BlockToggle"];t(131);t(205);function hl(n,e){return(hl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(206),t(207);function cl(n){return(cl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function dl(n,e){if(e&&("object"===Ao(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function ul(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,a=cl(n);if(e){var i=cl(this).constructor;t=Reflect.construct(a,arguments,i)}else t=a.apply(this,arguments);return dl(this,t)}}var fl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&hl(n,e)}(t,n);var e=ul(t);function t(){return hr(this,t),e.apply(this,arguments)}return dr(t)}(function(){function n(){hr(this,n),this.store=new Li({data:{state:{}}})}return dr(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Li.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(fl.prototype,{getPageAsyncComponent:Wo,getLayoutAsyncComponent:Uo,getAsyncComponent:Go,getVueComponent:$o});var ml={install:function(n){var e=new fl;n.$vuepress=e,n.prototype.$vuepress=e}};function pl(n){n.beforeEach((function(e,t,a){if(yl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";yl(n,i)?a(i):a()}else a();else{var s=e.path+"/",o=e.path+".html";yl(n,o)?a(o):yl(n,s)?a(s):a()}}))}function yl(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var gl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Xo("pageKey",e),Li.component(e)||Li.component(e,Wo(e)),Li.component(e)?n(e):n("")}},bl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,a=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},a()[t.slotKey])}},vl={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},xl=(t(379),t(380),Object(Hr.a)(vl,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function wl(){return(wl=Object(a.a)(regeneratorRuntime.mark((function n(e){var t,a,i,s;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Vr.routerBase||Vr.base,pl(a=new qo({base:t,mode:"history",fallback:!1,routes:Zr,scrollBehavior:function(n,e,t){return t||(n.hash?!Li.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(rl.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Li,options:i,router:a,siteData:Vr,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return s=new Li(Object.assign(i,{router:a,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ll.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:s,router:a});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Li.config.productionTip=!1,Li.use(qo),Li.use(ml),Li.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Li;So(e),t.$vuepress.$set("siteData",e);var a=n(t.$vuepress.$get("siteData")),i=new a,s=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(s).reduce((function(n,e){return e.startsWith("$")&&(n[e]=s[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){hr(this,e)}return dr(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,a=void 0===t?{}:t;for(var i in a)"/"===i?e=a[i]:0===this.$page.path.indexOf(i)&&(n=a[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Vr)),Li.component("Content",gl),Li.component("ContentSlotsDistributor",bl),Li.component("OutboundLink",xl),Li.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,a=e.children;if(t._isMounted)return a;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Li.component("Layout",Uo("Layout")),Li.component("NotFound",Uo("NotFound")),Li.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"26f9de9"},function(n){return wl.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);