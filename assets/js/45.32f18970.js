(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{531:function(n,e,s){"use strict";s.r(e);var a=s(18),t=Object(a.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"量词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#量词"}},[n._v("#")]),n._v(" 量词")]),n._v(" "),s("p",[s("code",[n._v("Dafny")]),n._v("中的量词通常采用"),s("code",[n._v("forall")]),n._v("表达式的形式，也称为通用量词。顾名思义，如果某个属性对某个集合的所有元素都成立，则该表达式为真。现在，我们将考虑整数的集合。全称量词的例子，包装在一个断言中，如下所示:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("量词为它所考虑的集合中的每个元素引入一个临时名称。这叫做绑定变量，在这里是k。绑定变量有一个类型，它几乎总是推断出来的，而不是显式给出的，而且通常是"),s("code",[n._v("int")]),n._v("。(一般来说，一个人可以有任意数量的绑定变量，这个主题我们将在后面返回。)一对冒号("),s("code",[n._v("::")]),n._v(")将绑定变量及其可选类型与量化属性分隔开(量化属性的类型必须为"),s("code",[n._v("bool")]),n._v(")。在本例中，属性是对任何整数加1都是一个严格的更大的整数。"),s("code",[n._v("Dafny")]),n._v("能够自动证明这个简单的性质。一般来说，对无限集进行量化不是很有用，比如所有的整数。量词通常用于量化数组或数据结构中的所有元素。对于数组，我们可以使用隐含运算符，使得量化属性对于非索引的值很平凡地为真:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("这说明数组的每个元素都有一个属性。它的含义是，在计算表达式的第二部分之前，确保"),s("code",[n._v("k")]),n._v("实际上是数组中的有效下标。"),s("code",[n._v("Dafny")]),n._v("不仅可以使用这个事实来证明数组是安全访问的，而且还可以将必须考虑的整数集减少到只考虑数组中的下标。\n对于量词，说明键不在数组中是很简单的:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("   forall k :: 0 <= k < a.Length ==> a[k] != key\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br")])]),s("p",[n._v("因此，我们的方法后置条件变成(加上"),s("code",[n._v("a")]),n._v("上的非零条件):\n"),s("code",[n._v("method Find(a: array<int>, key: int) returns (index: int)")])]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("p",[n._v("我们可以用多种方式填充这个方法的主体，但也许最简单的是线性搜索，实现如下:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br")])]),s("p",[n._v("正如您所看到的，我们在"),s("code",[n._v("while")]),n._v("循环中省略了循环不变量，因此Dafny在其中一个后置条件上给出了一个验证错误。我们得到错误的原因是"),s("code",[n._v("Dafny")]),n._v("不知道循环实际上覆盖了所有的元素。为了让"),s("code",[n._v("Dafny")]),n._v("相信这一点，我们必须编写一个不变式，说明当前索引之前的所有内容都已经被查看过了(并且不是键)。就像后置条件一样，我们可以使用一个量词来表达这个属性:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[n._v("这说明，除了之前的一切，当前的指数并不是关键。请注意，在进入循环时，"),s("code",[n._v("i")]),n._v("为零，因此隐含的第一部分总是假的，因此量化属性总是真的。这种常见的情况被称为空洞真理”:量词之所以成立，是因为它量化了一组空的对象。这意味着它在进入循环时为真。我们在扩展数组的非键部分之前测试数组的值，因此"),s("code",[n._v("Dafny")]),n._v("可以证明这个不变量是保留的。当我们试图添加这个不变量时，出现了一个问题:"),s("code",[n._v("Dafny")]),n._v("抱怨索引超出了不变量中数组访问的范围。\n这段代码没有验证，因为在"),s("code",[n._v("index")]),n._v("上没有不变式，所以它可能大于数组的长度。那么绑定变量"),s("code",[n._v("k")]),n._v("可能会超过数组的长度。为了解决这个问题，我们将标准边界放在"),s("code",[n._v("index")]),n._v("上，"),s("code",[n._v("0 <= index <= a.Length")]),n._v("。注意，因为我们使用了"),s("code",[n._v("k < index")]),n._v("，所以即使在"),s("code",[n._v("index == a.Length")]),n._v("时，数组访问也不会出现错误。在处理数组时，使用超出增长范围末尾一处的变量是一种常见模式，在数组中，通常使用它每次构建一个元素的属性。完整的方法如下:")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[s("strong",[n._v("练习12.")])]),n._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[n._v("点击查看题目及代码")]),n._v(" "),s("p",[n._v("编写一个接受整数数组的方法，该方法要求数组至少有一个元素，并返回数组中最大元素的索引。用表示方法意图的前置和后置条件来注释方法，并用循环不变式来注释其主体以验证方法。")]),n._v(" "),s("div",{staticClass:"language-dafny line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("method FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])])]),n._v(" "),s("p",[n._v("线性搜索不是很有效，特别是当许多查询由相同的数据组成时。如果数组是有序的，那么我们可以使用非常有效的二进制搜索过程来找到键。但是为了能够证明我们的实现是正确的，我们需要一些方法来要求输入的数组实际上是有序的。我们可以在方法的require子句中直接使用量词来实现这一点，但更模块化的表达方式是通过一个"),s("code",[n._v("predicate")]),n._v("。")])])}),[],!1,null,null,null);e.default=t.exports}}]);