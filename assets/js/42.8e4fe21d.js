(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{528:function(n,s,a){"use strict";a.r(s);var i=a(18),e=Object(i.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"循环不变式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环不变式"}},[n._v("#")]),n._v(" 循环不变式")]),n._v(" "),a("p",[n._v("“while”循环给Dafny带来了一个问题。Dafny无法提前知道代码将循环多少次。但是Dafny需要考虑程序中的所有路径，这可能包括循环任意次数。为了使Dafny能够使用循环，您需要提供循环不变式，这是另一种注释。\n循环不变式是在进入循环时以及每次循环体执行后保存的表达式。它捕获了一些不变的东西，也就是说，在循环的每一步中都是不变的。现在，很明显，我们需要在每次循环的时候改变变量，等等，否则我们就不需要循环了。像前置条件和后置条件一样，不变量是一个属性，它在每次循环执行时都被保留，使用我们已经看到的布尔表达式表示。例如，我们在上面的循环中看到，如果' i '一开始是正的，那么它就一直是正的。因此，我们可以使用它自己的关键字将不变量添加到循环中:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br")])]),a("p",[n._v("当您指定一个不变量时，Dafny证明了两件事:不变量在进入循环时保持不变，并且被循环保存。通过保留，我们的意思是假设在循环开始时不变式保持不变，我们必须证明执行循环体一次使不变式再次保持不变。Dafny只能在分析循环体时知道不变量说了什么，除了循环保护(循环条件)。就像Dafny自己不会发现方法的属性一样，除非通过一个不变量告诉它，否则它只会知道循环的最基本属性被保留。\n在我们的例子中，循环的重点是每次建立一个(好吧，两个)斐波那契数，直到我们达到想要的数。退出循环后，我们将得到' i == n '，因为当i达到' n '时，' i '将停止递增。我们可以使用断言技巧来检查Dafny是否也看到了这个事实:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br")])]),a("p",[n._v("我们发现这个断言失败了。据Dafny所知，在循环过程中的某个点上，“i”可能以某种方式变得比“n”大得多。在循环退出后(即在循环结束后的代码中)，它所知道的是循环保护失败，不变量保持不变。在本例中，这相当于' n <= i '和' 0 <= i '。但这并不足以保证' i == n '，只保证' n <= i '。我们需要消除i超过n的可能性。解决这个问题的第一个猜想可能是:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br")])]),a("p",[n._v("这并不验证，因为Dafny会报错循环没有保存(也称为没有维护)不变式。我们希望能够说，在循环结束后，所有不变式都保留下来。我们的不变式适用于循环的每一次执行，除了最后一次。因为循环体只有在循环保护生效时才执行，所以在最后一次迭代中，‘i’从‘n - 1’到‘n’，但在循环退出时不会进一步增加。因此，我们只从我们的不变量中省略了一种情况，修复它相对容易:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("现在，我们可以说，‘n <= i’来自循环保护，‘0 <= i <= n’来自不变量，这允许Dafny证明‘i == n’断言。选择循环不变量的挑战在于找到一个被循环保留的不变量，而且它还能让您证明在循环执行后需要什么。")]),n._v(" "),a("p",[a("strong",[n._v("练习7.")]),n._v(" "),a("em",[n._v("将循环不变量改为' 0 <= i <= n+2 '。循环是否仍然验证?断言' i == n '在循环之后仍然验证吗?")])]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br")])]),a("p",[a("strong",[n._v("练习8.")]),n._v(" "),a("em",[n._v("使用原来的循环不变式，将循环守卫从' i < n '更改为' i != n '。循环和循环后的断言仍然进行验证吗?为什么或为什么不?")])]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br")])]),a("p",[n._v("除了计数器之外，我们的算法还需要一对表示序列中相邻斐波那契数列的数字。不出所料，我们将有另外一两个不变式来将这些数字和计数器联系起来。为了找到这些不变量，我们使用了一种常见的Dafny技巧:从后置条件向后计算。\n斐波那契方法的后置条件是返回值' b '等于' fib(n) '。但是在循环之后，我们有了' i == n '，所以在循环的最后我们需要' b == fib(i) '。这可能是一个很好的不变量，因为它与循环计数器相关。这种现象在Dafny的程序中非常普遍。通常，一个方法只是一个循环，当它结束时，通过使计数器达到另一个数字，通常是一个参数或数组或序列的长度，使后置条件为真。变量b，也就是我们的输出参数，将会是当前的斐波那契数列:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("   invariant b == fib(i)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("我们还注意到，在我们的算法中，我们可以通过跟踪一对数字来计算任何斐波那契数，并将它们相加得到下一个数字。我们想要一种方法来追踪之前的斐波那契数，我们称之为' a '另一个不变式将表示该数字与循环计数器的关系。不变量有:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("   invariant a == fib(i - 1)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("在循环的每一步，对这两个值求和以得到下一个前导数，而后面的数字是旧的前导数。使用并行赋值，我们可以编写一个循环来执行以下操作:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br")])]),a("p",[n._v("这里' a '是结尾数，' b '是前导数。并行赋值意味着在对变量赋值之前计算整个右手边。因此，“a”将得到“b”的旧值，而“b”将得到两个旧值的和，这正是我们想要的行为。\n我们还对循环计数器' i '进行了更改。因为我们还想跟踪后面的数字，所以我们不能从0开始计数器，否则我们将不得不计算一个负的斐波那契数。这样做的问题是，当我们进入循环时，循环计数器不变式可能不成立。唯一的问题是当n为0时。这可以作为一种特殊情况消除，方法是在循环开始时测试该条件。完成的斐波那契方法变成:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br")])]),a("p",[n._v("Dafny不再报错循环不变式不成立，因为如果' n '为零，它将在到达循环之前返回。Dafny还能够使用循环不变量来证明，在循环之后，' i == n '和' b == fib(i) '，它们一起隐含了后置条件' b == fib(n) '。")]),n._v(" "),a("p",[a("strong",[n._v("练习9.")]),n._v(" "),a("em",[n._v("上面的' ComputeFib '方法比必要的要复杂得多。写一个简单的程序，不引入' a '作为' b '前面的斐波那契数，而是引入一个变量' c '在' b '后面。根据斐波那契数列的数学定义来验证你的程序是正确的。")])]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br")])]),a("p",[a("strong",[n._v("练习10.")]),n._v(" "),a("em",[n._v("从上面完成的' ComputeFib '方法开始，删除' if '语句，并将' i '初始化为' 0 '，' a '初始化为' 1 '，' b '初始化为' 0 '。通过调整循环不变量来匹配新的行为来验证这个新程序。")])]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br")])]),a("p",[n._v("使用不变量的一个问题是，很容易忘记让循环“取得进展”，即在每一步做工作。例如，我们可以在前面的程序中省略整个循环体。这些不变量是正确的，因为它们在进入循环时仍然为真，而且由于循环没有改变任何东西，它们将被循环保存下来。我们知道，如果退出循环，那么我们可以假设守卫和不变量为负值，但这并没有说明如果我们永远不退出循环会发生什么。因此，我们希望确保循环在某个点结束，这给了我们一个更强的正确性保证(技术术语是完全正确性)。")])])}),[],!1,null,null,null);s.default=e.exports}}]);