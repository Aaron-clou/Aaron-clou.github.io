(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{540:function(n,s,a){"use strict";a.r(s);var e=a(18),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#终止"}},[n._v("#")]),n._v(" 终止")]),n._v(" "),a("p",[n._v("Dafny证明所有程序终止。有两个潜在的非终止(发散)行为来源:循环，递归函数和方法。Dafny使用一种技术来处理这两种情况，减少注释。")]),n._v(" "),a("p",[n._v("递减注释指定一个称为终止度量的值，该值在每次遍历循环或每次调用递归函数或方法时严格变小。这个值也是有界的，因此它不会永远减小。这样，如果值从任意有限值开始，循环或递归必须停止。为了证明这一点，Dafny证明了终止度量在每次迭代中变得更小。如果Dafny无法证明这一点，它表示没有减少终止措施。因为每一种终止措施都有一个内置的下界，这就是Dafny需要做的，以证明终止。")]),n._v(" "),a("p",[n._v("Dafny可以在递减注释中使用几种类型的值，但最常见的是整数。整数有一个自然的下界，0，而且通常很容易证明它们是递减的。由于许多循环遍历索引，这类终止证明非常常见。例如，我们可能有以下循环:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      // do something interesting\n      i := i + 1;\n   }\n}\n\nwhile i < n\n   invariant 0 <= i <= n\n{\n   // do something interesting\n   i := i + 1;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br")])]),a("p",[n._v("如果我们把这个交给Dafny，就能立即证实。但是它是怎么知道它会终止的呢?因为这是如此常见的循环形式，Dafny有一个猜测终止度量的特殊规则。Dafny看到没有显式的递减注释，所以它尝试猜测一个。它看到循环条件是"),a("code",[n._v("A < B")]),n._v("形式的比较，对于某些A和B，所以它做出猜测:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  decreases B - A\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("如果这样的话")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  decreases n - i\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("如果我们将这个注释添加到循环中，它将继续进行验证。Dafny实际上没有那么严格要求终止测度为0。它真正需要的是，当终止度量为负时，循环不会再次执行。所以我们可以这样写:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method m()\n{\n   var i, n := 0, 11;\n   while i < n\n      decreases n - i\n   {\n      // do something interesting\n      i := i + 5;\n   }\n}\n\nvar i, n := 0, 11;\nwhile i < n\n   decreases n - i\n{\n   // do something interesting\n   i := i + 5;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br")])]),a("p",[n._v("这里，在最后一次迭代中，i变成了15，所以终止测度是-4。但在这里，循环保护为假，所以循环不会再次执行。注意，我们必须删除循环不变式，因为i现在可以超过n。")]),n._v(" "),a("p",[n._v("Dafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。Dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的:\nDafny证明了整个程序的终止，而不仅仅是循环。为此，它对递归函数和方法使用了相同的技术。Dafny分析哪些函数/方法彼此调用，以找出可能的递归。对于每个可能递归的函数/方法，它需要显式或隐式减少函数或方法上的注释。大多数递归函数/方法都是自递归的:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function fac(n: nat): nat\n{\n   if n == 0 then 1 else n * fac(n-1)\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("Dafny接受了这个计划。对于大多数递归函数来说，它们只是用更小的参数值来调用自己，所以参数减少是默认的猜测。可以通过添加以下内容:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("decreases n\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("到函数声明来明确"),a("code",[n._v("decreases")]),n._v("注释")]),n._v(" "),a("p",[n._v("有时，具有可能不会终止的循环或终止证明未知的循环是有益的。例如，考虑以下方法:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("method hail(N: nat)\n   decreases *\n{\n   var n := N;\n   while 1 < n\n      decreases *\n   {\n      n := if n % 2 == 0 then n / 2 else n * 3 + 1;\n   }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br")])]),a("p",[n._v("这个程序终止当且仅当Collatz猜想为真时，这是一个数学上的开放问题，所以你不能期望Dafny能够证明终止。您还可以编写流处理器之类的代码，以便永远运行。因此，Dafny提供了一个“"),a("code",[n._v("out")]),n._v("”，一个特殊的注释，指示Dafny不要试图证明终止，这在前面的"),a("code",[n._v("hail")]),n._v("方法中已经给出。这可以用于所有非鬼循环。注意，如果一个方法包含一个标记为"),a("code",[n._v("decreases *")]),n._v("的循环，那么它本身也必须被标记为decreases *。")]),n._v(" "),a("p",[n._v("Dafny可以使用整数以外的值作为终止度量。当指定序列时，Dafny自动使用长度作为终止度量。如果一个集合是另一个集合的严格子集，则认为这个集合更小，因此每个集合必须包含在前面的集合中。对于集合，空集合是尽可能小的，序列有自然数长度，所以这两个都有下界。虽然不是非常有用，但也可以在递减子句中使用"),a("code",[n._v("bool")]),n._v("和"),a("code",[n._v("references")]),n._v("。(如果你想了解细节，请参阅参考资料。)最后的终止度量是其他类型度量的元组。例如，下面的"),a("code",[n._v("Ackermann")]),n._v("函数的实现使用一对整数来证明终止")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function Ack(m: nat, n: nat): nat\n   decreases m, n\n{\n   if m == 0 then n + 1\n   else if n == 0 then Ack(m - 1, 1)\n   else Ack(m - 1, Ack(m, n - 1))\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("在这里，递减子句被明确地写了出来，尽管Dafny会猜出完全相同的事情。元组使用组件值的大小比较来确定度量值是否缩水。在这种情况下，它使用两个整数，但一般来说，不同的部分可以属于不同的类别。这种比较是按词典编纂的。如果第一个元素，在这里是m，比其他的值小没关系。它们可以增加，减少，或保持不变。只有当第一个元素不变时，才考虑第二个元素。然后，第二个值需要减小。如果没有，则第三个元素必须减少，以此类推。最终，必有一种元素会减少。过了这个点，其他元素就可以自由增加或做它们想做的事。\n在Ack函数中，有三个递归调用。在第一种情况下，m变小1，但n增大。这很好，因为在元组中n在m后面。在第二个调用中，m也减少了，因此第二个参数允许是任何值(这很好，因为Dafny实际上并没有证明关于第三个递归调用的结果的任何东西)。Dafny确实需要证明第三通电话符合终止措施。对于这个调用，m保持不变，但n减小，因此总体度量也减小了。\n终止不仅适用于单个函数/方法，还适用于多个相互递归的函数/方法。例如，考虑这对递归定义的奇偶校验谓词:")]),n._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("predicate even(n: nat)\n   ensures even(n) <==> n % 2 == 0\n{\n   if n == 0 then true else odd(n-1)\n}\npredicate odd(n: nat)\n   ensures odd(n) <==> n % 2 != 0\n{\n   if n == 0 then false else even(n-1)\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br")])]),a("p",[n._v("Dafny通过考虑两个函数中所有可能的路径证明了它们的终止。")])])}),[],!1,null,null,null);s.default=t.exports}}]);