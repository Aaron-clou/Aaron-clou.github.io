(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{555:function(e,n,s){"use strict";s.r(n);var a=s(18),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("a",{attrs:{href:"https://dafny-lang.github.io/dafny",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dafny Documentation"),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),s("h2",{attrs:{id:"getting-started-with-dafny-a-guide"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getting-started-with-dafny-a-guide"}},[e._v("#")]),e._v(" Getting Started with Dafny: A Guide")]),e._v(" "),s("p",[e._v("Be sure to follow along with the code examples by clicking the “load in editor” link in the corner. See what the tool says, try to fix programs on your own, and experiment!")]),e._v(" "),s("h3",{attrs:{id:"introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),s("p",[e._v("Dafny is a language that is designed to make it easy to write correct code. This means correct in the sense of not having any runtime errors, but also correct in actually doing what the programmer intended it to do. To accomplish this, Dafny relies on high-level annotations to reason about and prove correctness of code. The effect of a piece of code can be given abstractly, using a natural, high-level expression of the desired behavior, which is easier and less error prone to write. Dafny then generates a proof that the code matches the annotations (assuming they are correct, of course!). Dafny lifts the burden of writing bug-free "),s("em",[e._v("code")]),e._v(" into that of writing bug-free "),s("em",[e._v("annotations")]),e._v(". This is often easier than writing the code, because annotations are shorter and more direct. For example, the following fragment of annotation in Dafny says that every element of the array is strictly positive:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("forall k: int :: 0 <= k < a.Length ==> 0 < a[k]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("This says that for all integers "),s("code",[e._v("k")]),e._v(" that are indices into the array, the value at that index is greater than zero. By writing these annotations, one is confident that the code is correct. Further, the very act of writing the annotations can help one understand what the code is doing at a deeper level.")]),e._v(" "),s("p",[e._v("In addition to proving a correspondence to user supplied annotations, Dafny proves that there are no run time errors, such as index out of bounds, null dereferences, division by zero, etc. This guarantee is a powerful one, and is a strong case in and of itself for the use of Dafny and tools like it. Dafny also proves the termination of code, except in specially designated loops.")]),e._v(" "),s("p",[e._v("Let’s get started writing some Dafny programs.")]),e._v(" "),s("h3",{attrs:{id:"methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[e._v("#")]),e._v(" Methods")]),e._v(" "),s("p",[e._v("Dafny resembles a typical imperative programming language in many ways. There are methods, variables, types, loops, if statements, arrays, integers, and more. One of the basic units of any Dafny program is the "),s("em",[e._v("method")]),e._v(". A method is a piece of imperative, executable code. In other languages, they might be called procedures, or functions, but in Dafny the term “function” is reserved for a different concept that we will cover later. A method is declared in the following way:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("This declares a method called “"),s("code",[e._v("Abs")]),e._v("” which takes a single integer parameter, called “"),s("code",[e._v("x")]),e._v("”, and returns a single integer, called “"),s("code",[e._v("y")]),e._v("”. Note that the types are required for each parameter and return value, and follow each name after a colon ("),s("code",[e._v(":")]),e._v("). Also, the return values are named, and there can be multiple return values, as in below:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("The method body is the code contained within the braces, which until now has been cleverly represented as “"),s("code",[e._v("...")]),e._v("” (which is "),s("em",[e._v("not")]),e._v(" Dafny syntax). The body consists of a series of "),s("em",[e._v("statements")]),e._v(", such as the familiar imperative assignments, "),s("code",[e._v("if")]),e._v(" statements, loops, other method calls, "),s("code",[e._v("return")]),e._v(" statements, etc. For example, the "),s("code",[e._v("MultipleReturns")]),e._v(" method may be implemented as:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n   /* unless you want to keep your sanity. */\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n{\n   more := x + y;\n   less := x - y;\n   // comments: are not strictly necessary.\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("Assignments do not use “"),s("code",[e._v("=")]),e._v("”, but rather “"),s("code",[e._v(":=")]),e._v("”. (In fact, as Dafny uses “"),s("code",[e._v("==")]),e._v("” for equality, there is no use of a single equals sign in Dafny expressions.) Simple statements must be followed by a semicolon, and whitespace and comments ("),s("code",[e._v("//")]),e._v(" and "),s("code",[e._v("/**/")]),e._v(") are ignored. To return a value from a method, the value is assigned to one of the named return values sometime before a "),s("code",[e._v("return")]),e._v(" statement. In fact, the return values act very much like local variables, and can be assigned to more than once. The input parameters, however, are read only. "),s("code",[e._v("return")]),e._v(" statements are used when one wants to return before reaching the end of the body block of the method. Return statements can be just the "),s("code",[e._v("return")]),e._v(" keyword (where the current value of the out parameters are used), or they can take a list of values to return. There are also compound statements, such as "),s("code",[e._v("if")]),e._v(" statements. "),s("code",[e._v("if")]),e._v(" statements do not require parentheses around the boolean condition, and act as one would expect:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("One caveat is that they always need braces around the branches, even if the branch only contains a single statement (compound or otherwise). Here the "),s("code",[e._v("if")]),e._v(" statement checks whether "),s("code",[e._v("x")]),e._v(" is less than zero, using the familiar comparison operator syntax, and returns the absolute value as appropriate. (Other comparison operators are "),s("code",[e._v("<=")]),e._v(", "),s("code",[e._v(">")]),e._v(", "),s("code",[e._v(">=")]),e._v(", "),s("code",[e._v("!=")]),e._v(" and "),s("code",[e._v("==")]),e._v(", with the expected meaning. See the reference for more on operators.)")]),e._v(" "),s("h3",{attrs:{id:"pre-and-postconditions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-and-postconditions"}},[e._v("#")]),e._v(" Pre- and Postconditions")]),e._v(" "),s("p",[e._v("None of what we have seen so far has any specifications: the code could be written in virtually any imperative language (with appropriate considerations for multiple return values). The real power of Dafny comes from the ability to annotate these methods to specify their behavior. For example, one property that we observe with the "),s("code",[e._v("Abs")]),e._v(" method is that the result is always greater than or equal to zero, regardless of the input. We could put this observation in a comment, but then we would have no way to know whether the method actually had this property. Further, if someone came along and changed the method, we wouldn’t be guaranteed that the comment was changed to match. With annotations, we can have Dafny prove that the property we claim of the method is true. There are several ways to give annotations, but some of the most common, and most basic, are method "),s("em",[e._v("pre-")]),e._v(" and "),s("em",[e._v("postconditions")]),e._v(".")]),e._v(" "),s("p",[e._v("This property of the "),s("code",[e._v("Abs")]),e._v(" method, that the result is always non-negative, is an example of a postcondition: it is something that is true after the method returns. Postconditions, declared with the "),s("code",[e._v("ensures")]),e._v(" keyword, are given as part of the method’s declaration, after the return values (if present) and before the method body. The keyword is followed by the boolean expression. Like an "),s("code",[e._v("if")]),e._v(" or "),s("code",[e._v("while")]),e._v(" condition and most specifications, a postcondition is always a boolean expression: something that can be "),s("em",[e._v("true")]),e._v(" or "),s("em",[e._v("false")]),e._v(". In the case of the "),s("code",[e._v("Abs")]),e._v(" method, a reasonable postcondition is the following:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("You can see here why return values are given names. This makes them easy to refer to in the postcondition of a method. When the expression is true, we say that the postcondition "),s("em",[e._v("holds")]),e._v(". The postcondition must hold for every invocation of the function, and for every possible return point (including the implicit one at the end of the function body). In this case, the only property we are expressing is that the return value is always at least zero.")]),e._v(" "),s("p",[e._v("Sometimes there are multiple properties that we would like to establish about our code. In this case, we have two options. We can either join the two conditions together with the boolean “and” operator ("),s("code",[e._v("&&")]),e._v("), or we can write multiple "),s("code",[e._v("ensures")]),e._v(" specifications. The latter is basically the same as the former, but it seperates distinct properties. For example, the return value names from the "),s("code",[e._v("MultipleReturns")]),e._v(" method might lead one to guess the following postconditions:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("The postcondition can also be written:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("or even:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("because of the chaining comparison operator syntax in Dafny. (In general, most of the comparison operators can be chained, but only “in one direction”, i.e. not mixing “greater than” and “less than”. See the reference for details.)")]),e._v(" "),s("p",[e._v("The first way of expressing the postconditions separates the “less” part from the “more” part, which may be desirable. Another thing to note is that we have included one of the input parameters in the postcondition. This is useful because it allows us to relate the input and output of the method to one another (this works because input parameters are read only, and so are the same at the end as they were at the beginning).")]),e._v(" "),s("p",[e._v("Dafny actually rejects this program, claiming that the first postcondition does not hold (i.e. is not true). This means that Dafny wasn’t able to prove that this annotation holds every time the method returns. In general, there are two main causes for Dafny verification errors: specifications that are inconsistent with the code, and situations where it is not “clever” enough to prove the required properties. Differentiating between these two possibilities can be a difficult task, but fortunately, Dafny and the Boogie/Z3 system on which it is based are pretty smart, and will prove matching code and specifications with a minimum of fuss.")]),e._v(" "),s("p",[e._v("In this situation, Dafny is correct in saying there is an error with the code. The key to the problem is that "),s("code",[e._v("y")]),e._v(" is an integer, so it can be negative. If "),s("code",[e._v("y")]),e._v(" is negative (or zero), then "),s("code",[e._v("more")]),e._v(" can actually be smaller than or equal to "),s("code",[e._v("x")]),e._v(". Our method will not work as intended unless "),s("code",[e._v("y")]),e._v(" is strictly larger than zero. This is precisely the idea of a "),s("em",[e._v("precondition")]),e._v(". A precondition is similar to a postcondition, except that it is something that must be true "),s("em",[e._v("before")]),e._v(" a method is called. When you call a method, it is your job to establish (make true) the preconditions, something Dafny will enforce using a proof. Likewise, when you write a method, you get to assume the preconditions, but you must establish the postconditions. The caller of the method then gets to assume that the postconditions hold after the method returns.")]),e._v(" "),s("p",[e._v("preconditions have their own keyword, "),s("code",[e._v("requires")]),e._v(". We can give the necessary precondition to "),s("code",[e._v("MultipleReturns")]),e._v(" as below:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("Like postconditions, multiple preconditions can be written either with the boolean “and” operator ("),s("code",[e._v("&&")]),e._v("), or by multiple "),s("code",[e._v("requires")]),e._v(" keywords. Traditionally, "),s("code",[e._v("requires")]),e._v(" precede "),s("code",[e._v("ensures")]),e._v(" in the source code, though this is not strictly necessary (although the order of the "),s("code",[e._v("requires")]),e._v(" and "),s("code",[e._v("ensures")]),e._v(" annotations with respect to others of the same type can sometimes matter, as we will see later). With the addition of this condition, Dafny now verifies the code as correct, because this assumption is all that is needed to guarantee the code in the method body is correct.")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 0.")]),e._v(" "),s("em",[e._v("Write a method "),s("code",[e._v("Max")]),e._v(" that takes two integer parameters and returns their maximum. Add appropriate annotations and make sure your code verifies.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("Not all methods necessarily have preconditions. For example, the "),s("code",[e._v("Abs")]),e._v(" method we have already seen is defined for all integers, and so has no preconditions (other than the trivial requirement that its argument is an integer, which is enforced by the type system). Even though it has no need of preconditions, the "),s("code",[e._v("Abs")]),e._v(" function as it stands now is not very useful. To investigate why, we need to make use of another kind of annotation, the "),s("em",[e._v("assertion")]),e._v(".")]),e._v(" "),s("h3",{attrs:{id:"assertions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assertions"}},[e._v("#")]),e._v(" Assertions")]),e._v(" "),s("p",[e._v("Unlike pre- and postconditions, an assertion is placed somewhere in the middle of a method. Like the previous two annotations, an assertion has a keyword, "),s("code",[e._v("assert")]),e._v(", followed by the boolean expression and the semicolon that terminates simple statements. An assertion says that a particular expression always holds when control reaches that part of the code. For example, the following is a trivial use of an assertion inside a dummy method:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('method Testing()\n{\n   assert 2 < 3;\n   // Try "asserting" something that is not true.\n   // What does Dafny output?\n}\nmethod Testing()\n{\n   assert 2 < 3;\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("Dafny proves this method correct, as "),s("code",[e._v("2")]),e._v(" is always less than "),s("code",[e._v("3")]),e._v(". Asserts have several uses, but chief among them is checking whether your expectations of what is true at various points is actually true. You can use this to check basic arithmetical facts, as above, but they can also be used in more complex situations. Assertions are a powerful tool for debugging annotations, by checking what Dafny is able to prove about your code. For example, we can use it to investigate what Dafny knows about the "),s("code",[e._v("Abs")]),e._v(" function.")]),e._v(" "),s("p",[e._v("To do this, we need one more concept: local variables. Local variables behave exactly as you would expect, except maybe for a few issues with shadowing. (See the reference for details.) Local variables are declared with the "),s("code",[e._v("var")]),e._v(" keyword, and can optionally have type declarations. Unlike method parameters, where types are required, Dafny can infer the types of local variables in almost all situations. This is an example of an initialized, explicitly typed variable declaration:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   var x: int := 5;\n}\n   var x: int := 5;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("The type annotation can be dropped in this case:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   var x := 5;\n}\n   var x := 5;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("Multiple variables can be declared at once:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   var x, y, z: bool := 1, 2, true;\n}\n   var x, y, z: bool := 1, 2, true;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("Explicit type declarations only apply to the immediately preceding variable, so here the "),s("code",[e._v("bool")]),e._v(" declaration only applies to "),s("code",[e._v("z")]),e._v(", and not "),s("code",[e._v("x")]),e._v(" or "),s("code",[e._v("y")]),e._v(", which are both inferred to be "),s("code",[e._v("int")]),e._v("s. We needed variables because we want to talk about the return value of the "),s("code",[e._v("Abs")]),e._v(" method. We cannot put "),s("code",[e._v("Abs")]),e._v(" inside a specification directly, as the method could change memory state, among other problems. So we capture the return value of a call to "),s("code",[e._v("Abs")]),e._v(" as follows:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n// use definition of Abs() from before.\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[e._v("This is an example of a situation where we can ask Dafny what it knows about the values in the code, in this case "),s("code",[e._v("v")]),e._v(". We do this by adding assertions, like the one above. Every time Dafny encounters an assertion, it tries to prove that the condition holds for all executions of the code. In this example, there is only one control path through the method, and Dafny is able to prove the annotation easily because it is exactly the postcondition of the "),s("code",[e._v("Abs")]),e._v(" method. "),s("code",[e._v("Abs")]),e._v(" guarantees that the return value is non-negative, so it trivially follows that "),s("code",[e._v("v")]),e._v(", which is this value, is non-negative after the call to "),s("code",[e._v("Abs")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 1.")]),e._v(" "),s("em",[e._v("Write a test method that calls your "),s("code",[e._v("Max")]),e._v(" method from Exercise 0 and then asserts something about the result.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Max(a: int, b:int) returns (c: int)\n  // Use your code from Exercise 0\nmethod Testing() {\n  // Assert some things about Max. Does it operate as you expect?\n  // If it does not, can you think of a way to fix it?\n}\nmethod Testing() { ... }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("But we know something stronger about the "),s("code",[e._v("Abs")]),e._v(" method. In particular, for non-negative "),s("code",[e._v("x")]),e._v(", "),s("code",[e._v("Abs(x) == x")]),e._v(". Specifically, in the above program, the value of "),s("code",[e._v("v")]),e._v(" is 3. If we try adding an assertion (or changing the existing one) to say:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   assert v == 3;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br")])]),s("p",[e._v("we find that Dafny cannot prove our assertion, and gives an error. The reason this happens is that Dafny “forgets” about the body of every method except the one it is currently working on. This simplifies Dafny’s job tremendously, and is one of the reasons it is able to operate at reasonable speeds. It also helps us reason about our programs by breaking them apart and so we can analyze each method in isolation (given the annotations for the other methods). We don’t care at all what happens inside each method when we call it, as long as it satisfies its annotations. This works because Dafny will prove that all the methods satisfy their annotations, and refuse to compile our code until they do.")]),e._v(" "),s("p",[e._v("For the "),s("code",[e._v("Abs")]),e._v(" method, this means that the only thing Dafny knows in the Testing method about the value returned from "),s("code",[e._v("Abs")]),e._v(" is what the postconditions say about it, "),s("em",[e._v("and nothing more")]),e._v(". This means that Dafny won’t know the nice property about "),s("code",[e._v("Abs")]),e._v(" and non-negative integers unless we tell it by putting this in the postcondition of the "),s("code",[e._v("Abs")]),e._v(" method. Another way to look at it is to consider the method annotations (along with the type of the parameters and return values) as fixing the behavior of the method. Everywhere the method is used, we assume that it is any one of the conceivable method(s) that satisfies the pre- and postconditions. In the "),s("code",[e._v("Abs")]),e._v(" case, we might have written:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   // this stil does not verify, but now it is actually not true:\n   assert v == 3;\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("This method satisfies the postconditions, but clearly the program fragment:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   y := 0;\n}\nmethod Testing()\n{\n   var v := Abs(3);\n   assert 0 <= v;\n   assert v == 3;\n}\n   var v := Abs(3);\n   assert v == 3;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("would not be true in this case. Dafny is considering, in an abstract way, all methods with those annotations. The mathematical absolute value certainly is such a method, but so are all methods that return a positive constant, for example. We need stronger postconditions to eliminate these other possibilities, and “fix” the method down to exactly the one we want. We can partially do this with the following:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n{\n   // body as before\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br")])]),s("p",[e._v("This expresses exactly the property we discussed before, that the absolute value is the same for non-negative integers. The second ensures is expressed via the implication operator, which basically says that the left hand side implies the right in the mathematical sense (it binds more weakly than boolean “and” and comparisons, so the above says "),s("code",[e._v("0 <= x")]),e._v(" implies "),s("code",[e._v("y == x")]),e._v("). The left and right sides must both be boolean expressions.")]),e._v(" "),s("p",[e._v("The postcondition says that after "),s("code",[e._v("Abs")]),e._v(" is called, if the value of "),s("code",[e._v("x")]),e._v(" was non-negative, then "),s("code",[e._v("y")]),e._v(" is equal to "),s("code",[e._v("x")]),e._v(". One caveat of the implication is that it is still true if the left part (the antecedent) is false. So the second postcondition is trivially true when "),s("code",[e._v("x")]),e._v(" is negative. In fact, the only thing that the annotations say when "),s("code",[e._v("x")]),e._v(" is negative is that the result, "),s("code",[e._v("y")]),e._v(", is positive. But this is still not enough to fix the method, so we must add another postcondition, to make the following complete annotation covering all cases:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // body as before\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("These annotations are enough to require that our method actually computes the absolute value of "),s("code",[e._v("x")]),e._v(". These postconditions are not the only way to express this property. For example, this is a different, and somewhat shorter, way of saying the same thing:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y && (y == x || y == -x)\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\n   ensures 0 <= y && (y == x || y == -x)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("In general, there can be many ways to write down a given property. Most of the time it doesn’t matter which one you pick, but a good choice can make it easier to understand the stated property and verify that it is correct.")]),e._v(" "),s("p",[e._v("But we still have an issue: there seems to be a lot of duplication. The body of the method is reflected very closely in the annotations. While this is correct code, we want to eliminate this redundancy. As you might guess, Dafny provides a means of doing this: functions.")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 2.")]),e._v(" "),s("em",[e._v("Using a precondition, change "),s("code",[e._v("Abs")]),e._v(" to say it can only be called on negative values. Simplify the body of "),s("code",[e._v("Abs")]),e._v(" into just one return statement and make sure the method still verifies.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   // Add a precondition here.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n   // Simplify the body to just one return statement\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int) { ... }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 3.")]),e._v(" "),s("em",[e._v("Keeping the postconditions of "),s("code",[e._v("Abs")]),e._v(" the same as above, change the body of "),s("code",[e._v("Abs")]),e._v(" to just "),s("code",[e._v("y := x + 2")]),e._v(". What precondition do you need to annotate the method with in order for the verification to go through? What precondition do you need if the body is "),s("code",[e._v("y := x + 1")]),e._v("? What does that precondition say about when you can call the method?")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Abs(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n   // Add a precondition here so that the method verifies.\n   // Don't change the postconditions.\n   ensures 0 <= y\n   ensures 0 <= x ==> y == x\n   ensures x < 0 ==> y == -x\n{\n  y:= x + 1;\n}\nmethod Abs(x: int) returns (y: int) { ... }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br")])]),s("h3",{attrs:{id:"functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function abs(x: int): int\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("This declares a function called "),s("code",[e._v("abs")]),e._v(" which takes a single integer, and returns an integer (the second "),s("code",[e._v("int")]),e._v("). Unlike a method, which can have all sorts of statements in its body, a function body must consist of exactly one expression, with the correct type. Here our body must be an integer expression. In order to implement the absolute value function, we need to use an "),s("em",[s("code",[e._v("if")]),e._v(" expression")]),e._v(". An "),s("code",[e._v("if")]),e._v(" expression is like the ternary operator in other languages.")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function abs(x: int): int\n{\n   if x < 0 then -x else x\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("Obviously, the condition must be a boolean expression, and the two branches must have the same type. You might wonder why anyone would bother with functions, if they are so limited compared to methods. The power of functions comes from the fact that they can be "),s("em",[e._v("used directly in specifications")]),e._v(". So we can write:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod m()\n{\n   assert abs(3) == 3;\n}\n   assert abs(3) == 3;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("In fact, not only can we write this statement directly without capturing to a local variable, we didn’t even need to write all the postconditions that we did with the method (though functions can and do have pre- and postconditions in general). The limitations of functions are precisely what let Dafny do this. Unlike methods, Dafny does not forget the body of a function when considering other functions. So it can expand the definition of "),s("code",[e._v("abs")]),e._v(" in the above assertion and determine that the result is actually "),s("code",[e._v("3")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 4.")]),e._v(" "),s("em",[e._v("Write a "),s("strong",[e._v("function")]),e._v(" "),s("code",[e._v("max")]),e._v(" that returns the larger of two given integer parameters. Write a test method using an "),s("code",[e._v("assert")]),e._v(" that checks that your function is correct.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function max(a: int, b: int): int\n{\n   // Fill in an expression here.\n}\nmethod Testing() {\n  // Add assertions to check max here.\n}\nfunction max(a: int, b: int): int { ... }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("One caveat of functions is that not only can they appear in annotations, they can only appear in annotations. One cannot write:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   var v := abs(3);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("as this is not an annotation. Functions are never part of the final compiled program, they are just tools to help us verify our code. Sometimes it is convenient to use a function in real code, so one can define a "),s("code",[e._v("function method")]),e._v(", which can be called from real code. Note that there are restrictions on what functions can be function methods (See the reference for details).")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 5.")]),e._v(" "),s("em",[e._v("Change your test method from Exercise 4 to capture the value of "),s("code",[e._v("max")]),e._v(" to a variable, and then do the checks from Exercise 4 using the variable. Dafny will reject this program because you are calling "),s("code",[e._v("max")]),e._v(" from real code. Fix this problem using a "),s("code",[e._v("function method")]),e._v(".")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function max(a: int, b: int): int\n{\n   // Use your code from Exercise 4\n}\nmethod Testing() {\n  // Add assertions to check max here. Be sure to capture it to a local variable\n}\nfunction max(a: int, b: int): int { ... }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 6.")]),e._v(" "),s("em",[e._v("Now that we have an "),s("code",[e._v("abs")]),e._v(" function, change the postcondition of method "),s("code",[e._v("Abs")]),e._v(" to make use of "),s("code",[e._v("abs")]),e._v(". After confirming the method still verifies, change the body of "),s("code",[e._v("Abs")]),e._v(" to also use "),s("code",[e._v("abs")]),e._v(". (After doing this, you will realize there is not much point in having a method that does exactly the same thing as a function method.)")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function abs(x: int): int\n{\n   if x < 0 then -x else x\n}\nmethod Abs(x: int) returns (y: int)\n  // Use abs here, then confirm the method still verifies.\n{\n   // Then change this body to also use abs.\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nfunction abs(x: int): int\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("Unlike methods, functions can appear in expressions. Thus we can do something like implement the mathematical Fibonacci function:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("Here we use "),s("code",[e._v("nat")]),e._v("s, the type of natural numbers (non-negative integers), which is often more convenient than annotating everything to be non-negative. It turns out that we could make this function a function method if we wanted to. But this would be extremely slow, as this version of calculating the Fibonacci numbers has exponential complexity. There are much better ways to calculate the Fibonacci function. But this function is still useful, as we can have Dafny prove that a fast version really matches the mathematical definition. We can get the best of both worlds: the guarantee of correctness and the performance we want.")]),e._v(" "),s("p",[e._v("We can start by defining a method like the following:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   // ...\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("We haven’t written the body yet, so Dafny will complain that our postcondition doesn’t hold. We need an algorithm to calculate the "),s("code",[e._v("n")]),e._v("th Fibonacci number. The basic idea is to keep a counter, and repeatedly calculate adjacent pairs of Fibonacci numbers until the desired number is reached. To do this, we need a loop. In Dafny, this is done via a "),s("em",[s("code",[e._v("while")]),e._v(" loop")]),e._v(". A while loop looks like the following:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n   {\n      i := i + 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("This is a trivial loop that just increments "),s("code",[e._v("i")]),e._v(" until it reaches "),s("code",[e._v("n")]),e._v(". This will form the core of our loop to calculate Fibonacci numbers.")]),e._v(" "),s("h3",{attrs:{id:"loop-invariants"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loop-invariants"}},[e._v("#")]),e._v(" Loop Invariants")]),e._v(" "),s("p",[s("code",[e._v("while")]),e._v(" loops present a problem for Dafny. There is no way for Dafny to know in advance how many times the code will go around the loop. But Dafny needs to consider all paths through a program, which could include going around the loop any number of times. To make it possible for Dafny to work with loops, you need to provide "),s("em",[e._v("loop invariants")]),e._v(", another kind of annotation.")]),e._v(" "),s("p",[e._v("A loop invariant is an expression that holds upon entering a loop, and after every execution of the loop body. It captures something that is invariant, i.e. does not change, about every step of the loop. Now, obviously we are going to want to change variables, etc. each time around the loop, or we wouldn’t need the loop. Like pre- and postconditions, an invariant is a "),s("em",[e._v("property")]),e._v(" that is preserved for each execution of the loop, expressed using the same boolean expressions we have seen. For example, we see in the above loop that if "),s("code",[e._v("i")]),e._v(" starts off positive, then it stays positive. So we can add the invariant, using its own keyword, to the loop:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("When you specify an invariant, Dafny proves two things: the invariant holds upon entering the loop, and it is preserved by the loop. By preserved, we mean that assuming that the invariant holds at the beginning of the loop, we must show that executing the loop body once makes the invariant hold again. Dafny can only know upon analyzing the loop body what the invariants say, in addition to the loop guard (the loop condition). Just as Dafny will not discover properties of a method on its own, it will not know any but the most basic properties of a loop are preserved unless it is told via an invariant.")]),e._v(" "),s("p",[e._v("In our example, the point of the loop is to build up the Fibonacci numbers one (well, two) at a time until we reach the desired number. After we exit the loop, we will have that "),s("code",[e._v("i == n")]),e._v(", because "),s("code",[e._v("i")]),e._v(" will stop being incremented when it reaches "),s("code",[e._v("n")]),e._v(". We can use our assertion trick to check to see if Dafny sees this fact as well:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i\n   {\n      i := i + 1;\n   }\n   assert i == n;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("We find that this assertion fails. As far as Dafny knows, it is possible that "),s("code",[e._v("i")]),e._v(" somehow became much larger than "),s("code",[e._v("n")]),e._v(" at some point during the loop. All it knows after the loop exits (i.e. in the code after the loop) is that the loop guard failed, and the invariants hold. In this case, this amounts to "),s("code",[e._v("n <= i")]),e._v(" and "),s("code",[e._v("0 <= i")]),e._v(". But this is not enough to guarantee that "),s("code",[e._v("i == n")]),e._v(", just that "),s("code",[e._v("n <= i")]),e._v(". Somehow we need to eliminate the possibility of "),s("code",[e._v("i")]),e._v(" exceeding "),s("code",[e._v("n")]),e._v(". One first guess for solving this problem might be the following:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n}\n   var i := 0;\n   while i < n\n      invariant 0 <= i < n\n   {\n      i := i + 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("This does not verify, as Dafny complains that the invariant is not preserved (also known as not maintained) by the loop. We want to be able to say that after the loop exits, then all the invariants hold. Our invariant holds for every execution of the loop "),s("em",[e._v("except")]),e._v(" for the very last one. Because the loop body is executed only when the loop guard holds, in the last iteration "),s("code",[e._v("i")]),e._v(" goes from "),s("code",[e._v("n - 1")]),e._v(" to "),s("code",[e._v("n")]),e._v(", but does not increase further, as the loop exits. Thus, we have only omitted exactly one case from our invariant, and repairing it is relatively easy:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n}\n...\n   invariant 0 <= i <= n\n...\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("Now we can say both that "),s("code",[e._v("n <= i")]),e._v(" from the loop guard and "),s("code",[e._v("0 <= i <= n")]),e._v(" from the invariant, which allows Dafny to prove the assertion "),s("code",[e._v("i == n")]),e._v(". The challenge in picking loop invariants is finding one that is preserved by the loop, but also that lets you prove what you need after the loop has executed.")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 7.")]),e._v(" "),s("em",[e._v("Change the loop invariant to "),s("code",[e._v("0 <= i <= n+2")]),e._v(". Does the loop still verify? Does the assertion "),s("code",[e._v("i == n")]),e._v(" after the loop still verify?")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  // Change this. What happens?\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   invariant 0 <= i <= n+2\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 8.")]),e._v(" "),s("em",[e._v("With the original loop invariant, change the loop guard from "),s("code",[e._v("i < n")]),e._v(" to "),s("code",[e._v("i != n")]),e._v(". Do the loop and the assertion after the loop still verify? Why or why not?")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m(n: nat)\n{\n   var i: int := 0;\n   while i < n  // Change this. What happens?\n      invariant 0 <= i <= n\n   {\n      i := i + 1;\n   }\n   assert i == n;\n}\n   while i != n ...\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("In addition to the counter, our algorithm called for a pair of numbers which represent adjacent Fibonacci numbers in the sequence. Unsurprisingly, we will have another invariant or two to relate these numbers to each other and the counter. To find these invariants, we employ a common Dafny trick: working backwards from the postconditions.")]),e._v(" "),s("p",[e._v("Our postcondition for the Fibonacci method is that the return value "),s("code",[e._v("b")]),e._v(" is equal to "),s("code",[e._v("fib(n)")]),e._v(". But after the loop, we have that "),s("code",[e._v("i == n")]),e._v(", so we need "),s("code",[e._v("b == fib(i)")]),e._v(" at the end of the loop. This might make a good invariant, as it relates something to the loop counter. This observation is surprisingly common throughout Dafny programs. Often a method is just a loop that, when it ends, makes the postcondition true by having a counter reach another number, often an argument or the length of an array or sequence. So we have that the variable "),s("code",[e._v("b")]),e._v(", which is conveniently our out parameter, will be the current Fibonacci number:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   invariant b == fib(i)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("We also note that in our algorithm, we can compute any Fibonacci number by keeping track of a pair of numbers, and summing them to get the next number. So we want a way of tracking the previous Fibonacci number, which we will call "),s("code",[e._v("a")]),e._v(". Another invariant will express that number’s relation to the loop counter. The invariants are:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   invariant a == fib(i - 1)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("At each step of the loop, the two values are summed to get the next leading number, while the trailing number is the old leading number. Using a parallel assignment, we can write a loop that performs this operation:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n   var i := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br")])]),s("p",[e._v("Here "),s("code",[e._v("a")]),e._v(" is the trailing number, and "),s("code",[e._v("b")]),e._v(" is the leading number. The parallel assignment means that the entire right hand side is calculated before the assignments to the variables are made. Thus "),s("code",[e._v("a")]),e._v(" will get the old value of "),s("code",[e._v("b")]),e._v(", and "),s("code",[e._v("b")]),e._v(" will get the sum of the two old values, which is precisely the behavior we want.")]),e._v(" "),s("p",[e._v("We also have made a change to the loop counter "),s("code",[e._v("i")]),e._v(". Because we also want to track the trailing number, we can’t start the counter at zero, as otherwise we would have to calculate a negative Fibonacci number. The problem with doing this is that the loop counter invariant may not hold when we enter the loop. The only problem is when "),s("code",[e._v("n")]),e._v(" is zero. This can be eliminated as a special case, by testing for this condition at the beginning of the loop. The completed Fibonacci method becomes:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br")])]),s("p",[e._v("Dafny no longer complains about the loop invariant not holding, because if "),s("code",[e._v("n")]),e._v(" were zero, it would return before reaching the loop. Dafny is also able to use the loop invariants to prove that after the loop, "),s("code",[e._v("i == n")]),e._v(" and "),s("code",[e._v("b == fib(i)")]),e._v(", which together imply the postcondition, "),s("code",[e._v("b == fib(n)")]),e._v(".")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 9.")]),e._v(" "),s("em",[e._v("The "),s("code",[e._v("ComputeFib")]),e._v(" method above is more complicated than necessary. Write a simpler program by not introducing "),s("code",[e._v("a")]),e._v(" as the Fibonacci number that precedes "),s("code",[e._v("b")]),e._v(", but instead introducing a variable "),s("code",[e._v("c")]),e._v(" that succeeds "),s("code",[e._v("b")]),e._v(". Verify your program is correct according to the mathematical definition of Fibonacci.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition\n{\n   // Change the method body to instead use c as described.\n   // You will need to change both the initialization and the loop.\n   if n == 0 { return 0; }\n   var i: int := 1;\n   var a := 0;\n       b := 1;\n   while i < n\n      invariant 0 < i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 10.")]),e._v(" "),s("em",[e._v("Starting with the completed "),s("code",[e._v("ComputeFib")]),e._v(" method above, delete the "),s("code",[e._v("if")]),e._v(" statement and initialize "),s("code",[e._v("i")]),e._v(" to "),s("code",[e._v("0")]),e._v(", "),s("code",[e._v("a")]),e._v(" to "),s("code",[e._v("1")]),e._v(", and "),s("code",[e._v("b")]),e._v(" to "),s("code",[e._v("0")]),e._v(". Verify this new program by adjusting the loop invariants to match the new behavior.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)\n{\n   var i: int := 0;\n   var a := 1;\n       b := 0;\n   while i < n\n      // Fill in the invariants here.\n   {\n      a, b := b, a + b;\n      i := i + 1;\n   }\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[e._v("One of the problems with using invariants is that it is easy to forget to have the loop "),s("em",[e._v("make progress")]),e._v(", i.e. do work at each step. For example, we could have omitted the entire body of the loop in the previous program. The invariants would be correct, because they are still true upon entering the loop, and since the loop doesn’t change anything, they would be preserved by the loop. We know that "),s("em",[e._v("if")]),e._v(" we exit the loop, then we can assume the negation of the guard and the invariants, but this says nothing about what happens if we never exit the loop. Thus we would like to make sure the loop ends at some point, which gives us a stronger correctness guarantee (the technical term is "),s("em",[e._v("total correctness")]),e._v(").")]),e._v(" "),s("h3",{attrs:{id:"termination"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#termination"}},[e._v("#")]),e._v(" Termination")]),e._v(" "),s("p",[e._v("Dafny proves that code terminates, i.e. does not loop forever, by using "),s("code",[e._v("decreases")]),e._v(" annotations. For many things, Dafny is able to guess the right annotations, but sometimes it needs to be made explicit. In fact, for all of the code we have seen so far, Dafny has been able to do this proof on its own, which is why we haven’t seen the "),s("code",[e._v("decreases")]),e._v(" annotation explicitly yet. There are two places Dafny proves termination: loops and recursion. Both of these situations require either an explicit annotation or a correct guess by Dafny.")]),e._v(" "),s("p",[e._v("A "),s("code",[e._v("decreases")]),e._v(" annotation, as its name suggests, gives Dafny an expression that decreases with every loop iteration or recursive call. There are two conditions that Dafny needs to verify when using a "),s("code",[e._v("decreases")]),e._v(" expression: that the expression actually gets smaller, and that it is bounded. Many times, an integral value (natural or plain integer) is the quantity that decreases, but other things that can be used as well. (See the reference for details.) In the case of integers, the bound is assumed to be zero. For example, the following is a proper use of "),s("code",[e._v("decreases")]),e._v(" on a loop (with its own keyword, of course):")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m ()\n{\n   var i := 20;\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n}\n   while 0 < i\n      invariant 0 <= i\n      decreases i\n   {\n      i := i - 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br")])]),s("p",[e._v("Here Dafny has all the ingredients it needs to prove termination. The variable "),s("code",[e._v("i")]),e._v(" gets smaller each loop iteration, and is bounded below by zero. This is fine, except the loop is backwards from most loops, which tend to count up instead of down. In this case, what decreases is not the counter itself, but rather the distance between the counter and the upper bound. A simple trick for dealing with this situation is given below:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   var i, n := 0, 20;\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i < n\n      invariant 0 <= i <= n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br")])]),s("p",[e._v("This is actually Dafny’s guess for this situation, as it sees "),s("code",[e._v("i < n")]),e._v(" and assumes that "),s("code",[e._v("n - i")]),e._v(" is the quantity that decreases. The upper bound of the loop invariant implies that "),s("code",[e._v("0 <= n – i")]),e._v(", and gives Dafny a lower bound on the quantity. This also works when the bound "),s("code",[e._v("n")]),e._v(" is not constant, such as in the binary search algorithm, where two quantities approach each other, and neither is fixed.")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 11.")]),e._v(" "),s("em",[e._v("In the loop above, the invariant "),s("code",[e._v("i <= n")]),e._v(" and the negation of the loop guard allow us to conclude "),s("code",[e._v("i == n")]),e._v(" after the loop (as we checked previously with an "),s("code",[e._v("assert")]),e._v(". Note that if the loop guard were instead written as "),s("code",[e._v("i != n")]),e._v(" (as in Exercise 8), then the negation of the guard immediately gives "),s("code",[e._v("i == n")]),e._v(" after the loop, regardless of the loop invariant. Change the loop guard to "),s("code",[e._v("i != n")]),e._v(" and delete the invariant annotation. Does the program verify? What happened?")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   var i, n := 0, 20;\n   while i != n\n      decreases n - i\n   {\n      i := i + 1;\n   }\n}\n   while i != n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("The other situation that requires a termination proof is when methods or functions are recursive. Similarly to looping forever, these methods could potentially call themselves forever, never returning to their original caller. When Dafny is not able to guess the termination condition, an explicit decreases clause can be given along with pre- and postconditions, as in the unnecessary annotation for the fib function:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function fib(n: nat): nat\n   decreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nfunction fib(n: nat): nat\n   decreases n\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("As before, Dafny can guess this condition on its own, but sometimes the decreasing condition is hidden within a field of an object or somewhere else where Dafny cannot find it on its own, and it requires an explicit annotation.")]),e._v(" "),s("h3",{attrs:{id:"arrays"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arrays"}},[e._v("#")]),e._v(" Arrays")]),e._v(" "),s("p",[e._v("All that we have considered is fine for toy functions and little mathematical exercises, but it really isn’t helpful for real programs. So far we have only considered a handful of values at a time in local variables. Now we turn our attention to arrays of data. Arrays are a built-in part of the language, with their own type, "),s("code",[e._v("array<T>")]),e._v(", where "),s("code",[e._v("T")]),e._v(" is another type. For now we only consider arrays of integers, "),s("code",[e._v("array<int>")]),e._v(". Arrays can be "),s("code",[e._v("null")]),e._v(", and have a built-in length field, "),s("code",[e._v("a.Length")]),e._v(". Element access uses the standard bracket syntax and are indexed from zero, so "),s("code",[e._v("a[3]")]),e._v(" is preceded by the 3 elements "),s("code",[e._v("a[0]")]),e._v(", "),s("code",[e._v("a[1]")]),e._v(", and "),s("code",[e._v("a[2]")]),e._v(", in that order. All array accesses must be proven to be within bounds, which is part of Dafny’s no-runtime-errors safety guarantee. Because bounds checks are proven at verification time, no runtime checks need to be made. To create a new array, it must be allocated with the "),s("code",[e._v("new")]),e._v(" keyword, but for now we will only work with methods that take a previously allocated array as an argument. (See the tutorial on memory for more on allocation.)")]),e._v(" "),s("p",[e._v("One of the most basic things we might want to do with an array is search through it for a particular key, and return the index of a place where we can find the key if it exists. We have two outcomes for a search, with a different correctness condition for each. If the algorithm returns an index (i.e. non-negative integer), then the key should be present at that index. This might be expressed as follows:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Can you write code that satisfies the postcondition?\n   // Hint: you can do it with one statement.\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n   // Open in editor for a challenge...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("The array index here is safe because the implication operator is "),s("em",[e._v("short circuiting")]),e._v(". Short circuiting means if the left part is false, then the implication is already true regardless of the truth value of the second part, and thus it does not need to be evaluated. Using the short circuiting property of the implication operator, along with the boolean “and” ("),s("code",[e._v("&&")]),e._v("), which is also short circuiting, is a common Dafny practice. The condition "),s("code",[e._v("index < a.Length")]),e._v(" is necessary because otherwise the method could return a large integer which is not an index into the array. Together, the short circuiting behavior means that by the time control reaches the array access, "),s("code",[e._v("index")]),e._v(" must be a valid index.")]),e._v(" "),s("p",[e._v("If the key is not in the array, then we would like the method to return a negative number. In this case, we want to say that the method did not miss an occurrence of the key; in other words, that the key is not in the array. To express this property, we turn to another common Dafny tool: quantifiers.")]),e._v(" "),s("h3",{attrs:{id:"quantifiers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#quantifiers"}},[e._v("#")]),e._v(" Quantifiers")]),e._v(" "),s("p",[e._v("A quantifier in Dafny most often takes the form of a forall expression, also called a universal quantifier. As its name suggests, this expression is true if some property holds for all elements of some set. For now, we will consider the set of integers. An example universal quantifier, wrapped in an assertion, is given below:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method m()\n{\n   assert forall k :: k < k + 1;\n}\n   assert forall k :: k < k + 1;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("A quantifier introduces a temporary name for each element of the set it is considering. This is called the bound variable, in this case "),s("code",[e._v("k")]),e._v(". The bound variable has a type, which is almost always inferred rather than given explicitly and is usually "),s("code",[e._v("int")]),e._v(" anyway. (In general, one can have any number of bound variables, a topic we will return to later.) A pair of colons ("),s("code",[e._v("::")]),e._v(") separates the bound variable and its optional type from the quantified property (which must be of type "),s("code",[e._v("bool")]),e._v("). In this case, the property is that adding one to any integer makes a strictly larger integer. Dafny is able to prove this simple property automatically. Generally it is not very useful to quantify over infinite sets, such as all the integers. Instead, quantifiers are typically used to quantify over all elements in an array or data structure. We do this for arrays by using the implication operator to make the quantified property trivially true for values which are not indices:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   assert forall k :: 0 <= k < a.Length ==> ...a[k]...;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("This says that some property holds for each element of the array. The implication makes sure that "),s("code",[e._v("k")]),e._v(" is actually a valid index into the array before evaluating the second part of the expression. Dafny can use this fact not only to prove that the array is accessed safely, but also reduce the set of integers it must consider to only those that are indices into the array.")]),e._v(" "),s("p",[e._v("With a quantifier, saying the key is not in the array is straightforward:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   forall k :: 0 <= k < a.Length ==> a[k] != key\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("Thus our method postconditions become (with the addition of the non-nullity precondition on "),s("code",[e._v("a")]),e._v("):")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   // There are many ways to fill this in. Can you write one?\n}\nmethod Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br")])]),s("p",[e._v("We can fill in the body of this method in a number of ways, but perhaps the easiest is a linear search, implemented below:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   index := 0;\n   while index < a.Length\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br")])]),s("p",[e._v("As you can see, we have omitted the loop invariants on the "),s("code",[e._v("while")]),e._v(" loop, so Dafny gives us a verification error on one of the postconditions. The reason we get an error is that Dafny does not know that the loop actually covers all the elements. In order to convince Dafny of this, we have to write an invariant that says that everything before the current index has already been looked at (and are not the key). Just like the postcondition, we can use a quantifier to express this property:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n   invariant forall k :: 0 <= k < index ==> a[k] != key\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("This says that everything before, but excluding, the current index is not the key. Notice that upon entering the loop, "),s("code",[e._v("i")]),e._v(" is zero, so the first part of the implication is always false, and thus the quantified property is always true. This common situation is known as "),s("em",[e._v("vacuous truth")]),e._v(": the quantifier holds because it is quantifying over an empty set of objects. This means that it is true when entering the loop. We test the value of the array before we extend the non-key part of the array, so Dafny can prove that this invariant is preserved. One problem arises when we try to add this invariant: Dafny complains about the index being out of range for the array access within the invariant.")]),e._v(" "),s("p",[e._v("This code does not verify because there is no invariant on "),s("code",[e._v("index")]),e._v(", so it could be greater than the length of the array. Then the bound variable, "),s("code",[e._v("k")]),e._v(", could exceed the length of the array. To fix this, we put the standard bounds on "),s("code",[e._v("index")]),e._v(", "),s("code",[e._v("0 <= index <= a.Length")]),e._v(". Note that because we say "),s("code",[e._v("k < index")]),e._v(", the array access is still protected from error even when "),s("code",[e._v("index == a.Length")]),e._v(". The use of a variable that is one past the end of a growing range is a common pattern when working with arrays, where it is often used to build a property up one element at a time. The complete method is given below:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 12.")]),e._v(" "),s("em",[e._v("Write a method that takes an integer array, which it requires to have at least one element, and returns an index to the maximum of the array’s elements. Annotate the method with pre- and postconditions that state the intent of the method, and annotate its body with loop invariant to verify it.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("method FindMax(a: array<int>) returns (i: int)\n   // Annotate this method with pre- and postconditions\n   // that ensure it behaves as described.\n{\n   // Fill in the body that calculates the INDEX of the maximum.\n}\nmethod FindMax(a: array<int>) returns (i: int)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("A linear search is not very efficient, especially when many queries are made of the same data. If the array is sorted, then we can use the very efficient binary search procedure to find the key. But in order for us to be able to prove our implementation correct, we need some way to require that the input array actually is sorted. We could do this directly with a quantifier inside a requires clause of our method, but a more modular way to express this is through a "),s("em",[e._v("predicate")]),e._v(".")]),e._v(" "),s("h3",{attrs:{id:"predicates"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#predicates"}},[e._v("#")]),e._v(" Predicates")]),e._v(" "),s("p",[e._v("A predicate is a function which returns a boolean. It is a simple but powerful idea that occurs throughout Dafny programs. For example, we define the "),s("em",[s("code",[e._v("sorted")]),e._v(" predicate")]),e._v(" over arrays of integers as a function that takes an array as an argument, and returns "),s("code",[e._v("true")]),e._v(" if and only if that array is sorted in increasing order. The use of predicates makes our code shorter, as we do not need to write out a long property over and over. It can also make our code easier to read by giving a common property a name.")]),e._v(" "),s("p",[e._v("There are a number of ways we could write the "),s("code",[e._v("sorted")]),e._v(" predicate, but the easiest is to use a quantifier over the indices of the array. We can write a quantifier that expresses the property, “if "),s("code",[e._v("x")]),e._v(" is before "),s("code",[e._v("y")]),e._v(" in the array, then "),s("code",[e._v("x <= y")]),e._v(",” as a quantifier over two bound variables:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("Here we have two bound variables, "),s("code",[e._v("j")]),e._v(" and "),s("code",[e._v("k")]),e._v(", which are both integers. The comparisons between the two guarantee that they are both valid indices into the array, and that "),s("code",[e._v("j")]),e._v(" is before "),s("code",[e._v("k")]),e._v(". Then the second part says that they are ordered properly with respect to one another. Quantifiers are just a type of boolean valued expression in Dafny, so we can write the sorted predicate as:")]),e._v(" "),s("div",{staticClass:"language-{.edit} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("Note that there is no return type, because predicates always return a boolean.")]),e._v(" "),s("p",[e._v("Dafny rejects this code as given, claiming that the predicate cannot read "),s("code",[e._v("a")]),e._v(". Fixing this issue requires another annotation, the "),s("em",[e._v("reads annotation")]),e._v(".")]),e._v(" "),s("h3",{attrs:{id:"framing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#framing"}},[e._v("#")]),e._v(" Framing")]),e._v(" "),s("p",[e._v("The sorted predicate is not able to access the array because the array was not included in the function’s "),s("em",[e._v("reading frame")]),e._v(". The reading frame of a function (or predicate) is all the memory locations that the function is allowed to read. The reason we might limit what a function can read is so that when we write to memory, we can be sure that functions that did not read that part of memory have the same value they did before. For example, we might have two arrays, one of which we know is sorted. If we did not put a reads annotation on the sorted predicate, then when we modify the unsorted array, we cannot determine whether the other array stopped being sorted. While we might be able to give invariants to preserve it in this case, it gets even more complex when manipulating data structures. In this case, framing is essential to making the verification process feasible.")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n   ...\n   reads a\n   ...\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("A "),s("code",[e._v("reads")]),e._v(" annotation is not a boolean expression, like the other annotations we have seen, and can appear anywhere along with the pre- and postconditions. Instead of a property that should be true, it specifies a set of memory locations that the function is allowed to access. The name of an array, like "),s("code",[e._v("a")]),e._v(" in the above example, stands for all the elements of that array. One can also specify object fields and sets of objects, but we will not concern ourselves with those topics here. Dafny will check that you do not read any memory location that is not stated in the reading frame. This means that function calls within a function must have reading frames that are a subset of the calling function’s reading frame. One thing to note is that parameters to the function that are not memory locations do not need to be declared.")]),e._v(" "),s("p",[e._v("Frames also affect methods. As you might have guessed, they are not required to list the things they read, as we have written a method which accesses an array with no "),s("code",[e._v("reads")]),e._v(" annotation. Methods are allowed to read whatever memory they like, but they are required to list which parts of memory they modify, with a "),s("em",[e._v("modifies annotation")]),e._v(". They are almost identical to their "),s("code",[e._v("reads")]),e._v(" cousins, except they say what can be changed, rather than what the value of the function depends on. In combination with reads, modification restrictions allow Dafny to prove properties of code that would otherwise be very difficult or impossible. "),s("code",[e._v("reads")]),e._v(" and "),s("code",[e._v("modifies")]),e._v(" are one of the tools that allow Dafny to work on one method at a time, because they restrict what would otherwise be arbitrary modifications of memory to something that Dafny can reason about.")]),e._v(" "),s("p",[e._v("Note that framing only applies to the "),s("em",[e._v("heap")]),e._v(", or memory accessed through references. Local variables are not stored on the heap, so they cannot be mentioned in "),s("code",[e._v("reads")]),e._v(" annotations. Note also that types like sets, sequences, and multisets are value types, and are treated like integers or local variables. Arrays and objects are reference types, and they are stored on the heap (though as always there is a subtle distinction between the reference itself and the value it points to.)")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 13.")]),e._v(" "),s("em",[e._v("Modify the definition of the "),s("code",[e._v("sorted")]),e._v(" predicate so that it returns true exactly when the array is sorted and all its elements are distinct.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   // Fill in a new body here.\n}\npredicate sorted(a: array<int>)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[s("strong",[e._v("Exercise 14.")]),e._v(" "),s("em",[e._v("What happens if you remove the precondition "),s("code",[e._v("a != null")]),e._v("? Change the definition of "),s("code",[e._v("sorted")]),e._v(" so that it allows its argument to be null but returns false if it is.")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('predicate sorted(a: array<int>)\n   reads a\n{\n   // Change this definition to treat null arrays as "not sorted".\n   // (i.e. return false for null arrays)\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted(a: array<int>)\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("h3",{attrs:{id:"binary-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#binary-search"}},[e._v("#")]),e._v(" Binary Search")]),e._v(" "),s("p",[e._v("Predicates are usually used to make other annotations clearer:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   // This one is a little harder. What should go here?\n}\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n   requires a != null && sorted(a)\n   ensures ...\n{\n   ...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br")])]),s("p",[e._v("We have the same postconditions that we did for the linear search, as the goal is the same. The difference is that now we know the array is sorted. Because Dafny can unwrap functions, inside the body of the method it knows this too. We can then use that property to prove the correctness of the search. The method body is given below:")]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br")])]),s("p",[e._v("This is a fairly standard binary search implementation. First we declare our range to search over. This can be thought of as the remaining space where the key could possibly be. The range is inclusive-exclusive, meaning it encompasses indices ["),s("code",[e._v("low")]),e._v(", "),s("code",[e._v("high")]),e._v("). The first invariant expresses the fact that this range is within the array. The second says that the key is not anywhere outside of this range. In the first two branches of the "),s("code",[e._v("if")]),e._v(" chain, we find the element in the middle of our range is not the key, and so we move the range to exclude that element and all the other elements on the appropriate side of it. We need the addition of one when moving the lower end of the range because it is inclusive on the low side. If we do not add one, then the loop may continue forever when "),s("code",[e._v("mid == low")]),e._v(", which happens when "),s("code",[e._v("low + 1 == high")]),e._v(". We could change this to say that the loop exits when "),s("code",[e._v("low")]),e._v(" and "),s("code",[e._v("high")]),e._v(" are one apart, but this would mean we would need an extra check after the loop to determine if the key was found at the one remaining index. In the above formulation, this is unnecessary because when "),s("code",[e._v("low == high")]),e._v(", the loop exits. But this means that no elements are left in the search range, so the key was not found. This can be deduced from the loop invariant:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("   invariant forall i ::\n               0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("When "),s("code",[e._v("low == high")]),e._v(", the negated condition in the first part of the implication is always true (because no "),s("code",[e._v("i")]),e._v(" can be both at least and strictly smaller than the same value). Thus the invariant says that all elements in the array are not the key, and the second postcondition holds. As you can see, it is easy to introduce subtle off by one errors in this code. With the invariants, not only can Dafny prove the code correct, but we can understand the operation of the code more easily ourselves.")]),e._v(" "),s("p",[s("strong",[e._v("Exercise 15.")]),e._v(" "),s("em",[e._v("Change the assignments in the body of "),s("code",[e._v("BinarySearch")]),e._v(" to set "),s("code",[e._v("low")]),e._v(" to "),s("code",[e._v("mid")]),e._v(" or to set "),s("code",[e._v("high")]),e._v(" to "),s("code",[e._v("mid - 1")]),e._v(". In each case, what goes wrong?")])]),e._v(" "),s("div",{staticClass:"language-{.editonly} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br")])]),s("h3",{attrs:{id:"conclusion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),s("p",[e._v("We’ve seen a whirlwind tour of the major features of Dafny, and used it for some interesting, if a little on the small side, examples of what Dafny can do. But to really take advantage of the power Dafny offers, one needs to plow ahead into the advanced topics: objects, sequences and sets, data structures, lemmas, etc. Now that you are familiar with the basics of Dafny, you can peruse the tutorials on each of these topics at your leisure. Each tutorial is designed to be a relatively self-contained guide to its topic, though some benefit from reading others beforehand. The examples are also a good place to look for model Dafny programs. Finally, the reference contains the gritty details of Dafny syntax and semantics, for when you just need to know what the disjoint set operator is (it’s "),s("code",[e._v("!!")]),e._v(", for those interested).")]),e._v(" "),s("p",[e._v("Even if you do not use Dafny regularly, the idea of writing down exactly what it is that the code does in a precise way, and using this to prove code correct is a useful skill. Invariants, pre- and postconditions, and annotations are useful in debugging code, and also as documentation for future developers. When modifying or adding to a codebase, they confirm that the guarantees of existing code are not broken. They also ensure that APIs are used correctly, by formalizing behavior and requirements and enforcing correct usage. Reasoning from invariants, considering pre- and postconditions, and writing assertions to check assumptions are all general computer science skills that will benefit you no matter what language you work in.")])])}),[],!1,null,null,null);n.default=t.exports}}]);