(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{565:function(e,s,a){"use strict";a.r(s);var t=a(18),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Dafny Power User:\nold and unchanged")]),e._v(" "),a("p",[e._v("K. Rustan M. Leino")]),e._v(" "),a("p",[e._v("Manuscript KRML 273, 15 February 2020")]),e._v(" "),a("p",[a("strong",[e._v("Abstract.")]),e._v(" This note addresses the question \"What's the difference between "),a("code",[e._v("old")]),e._v(" and "),a("code",[e._v("unchanged")]),e._v('?".')]),e._v(" "),a("h2",{attrs:{id:"_0-the-essence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-the-essence"}},[e._v("#")]),e._v(" 0. The essence")]),e._v(" "),a("p",[e._v("In a nutshell, the expression "),a("code",[e._v("old(E)")]),e._v(" denotes the value of expression "),a("code",[e._v("E")]),e._v(" evaluated in the pre-state of the enclosing method. The expression "),a("code",[e._v("unchanged(R)")]),e._v(" says that the values of the fields of the object denoted by expression "),a("code",[e._v("R")]),e._v(" are the same as in the pre-state.")]),e._v(" "),a("p",[e._v("For instance, consider the following classes, which I will use throughout this note:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class C {\n  var x: int\n  var y: D\n  // ...\n}\nclass D {\n  var z: int\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("If "),a("code",[e._v("c")]),e._v(" is a parameter of type "),a("code",[e._v("C")]),e._v(", then the expression "),a("code",[e._v("unchanged(c)")]),e._v("means")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("old(c.x) == c.x && old(c.y) == c.y\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("But there's more, if you want to know it.")]),e._v(" "),a("h2",{attrs:{id:"_1-modifies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-modifies"}},[e._v("#")]),e._v(" 1. modifies")]),e._v(" "),a("p",[e._v("Let's review "),a("code",[e._v("modifies")]),e._v(" clauses on methods.")]),e._v(" "),a("p",[e._v("A method must declare the set of (previously allocated) objects whose fields it might modify. So, if a method "),a("code",[e._v("method M(c: C)")]),e._v(" wants to do an assignment like")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c.x := 10;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("or")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c.x := c.x + 2;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("then its specification must include the object reference "),a("code",[e._v("c")]),e._v(" in its "),a("code",[e._v("modifies")]),e._v(" clause, like so:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("This specification gives "),a("code",[e._v("M")]),e._v(" permission to modify the "),a("em",[e._v("fields")]),e._v(" of "),a("code",[e._v("c")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Exercise 0.")]),e._v("\nWhat does the following specification mean?")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C, d: D)\n  modifies c.y\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("strong",[e._v("Answer.")]),e._v("\nIt gives "),a("code",[e._v("M")]),e._v(" permission to modify the fields of "),a("code",[e._v("c.y")]),e._v(". For example, the body of "),a("code",[e._v("M")]),e._v(" can do the following assignment:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c.y.z := 15;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("It does "),a("em",[e._v("not")]),e._v(" give "),a("code",[e._v("M")]),e._v(" the permission to modify the "),a("code",[e._v("y")]),e._v(" field of object "),a("code",[e._v("c")]),e._v(". For example, the following is not allowed:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c.y := d;  // error: not allowed by modifies clause \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("A modifies clause is not transitive. That is, "),a("code",[e._v("modifies c")]),e._v(" gives permission to modify the fields of "),a("code",[e._v("c")]),e._v(", but not "),a("em",[e._v("their")]),e._v(" fields. In particular, the assignment")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c.y.z := 20;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is not allowed by the specification "),a("code",[e._v("modifies c")]),e._v(".")]),e._v(" "),a("p",[e._v("Methods are always allowed to allocate new objects and modify their fields, even without any mention in the "),a("code",[e._v("modifies")]),e._v(" clause. So, here's a way to ensure that "),a("code",[e._v("c.y.z")]),e._v(" has a post-value of "),a("code",[e._v("20")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures c.y.z == 20\n{\n  c.y := new D;  // allowed because c is in the modifies clause\n  c.y.z := 20;   // allowed because c.y is newly allocated\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("Note that this program swap out "),a("code",[e._v("c.y")]),e._v(" for a new object. The object previously referenced by "),a("code",[e._v("c.y")]),e._v(" is not changed by method "),a("code",[e._v("M")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"_2-frame-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-frame-expressions"}},[e._v("#")]),e._v(" 2. Frame expressions")]),e._v(" "),a("p",[e._v("What follows the "),a("code",[e._v("modifies")]),e._v(" keyword is a list of "),a("em",[e._v("frame expressions")]),e._v(". A frame expression denotes a set of objects (or arrays).")]),e._v(" "),a("p",[e._v("For convenience, a frame expression can be given as a set of object or as a single object. The latter is shorthand for the singleton set containing that object. The modifies clause denotes the set union of the objects denoted by each frame expression in the list. For example,")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method P(c: C, d: D, S: set<object>)\n  modifies c, d, S\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("is the same as")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method P(c: C, d: D, S: set<object>)\n  modifies {c} + {d} + S\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("h3",{attrs:{id:"_2-0-old"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-old"}},[e._v("#")]),e._v(" 2.0. old")]),e._v(" "),a("p",[e._v("If you want to say that "),a("code",[e._v("M")]),e._v(" has the effect of increasing the value of "),a("code",[e._v("c.x")]),e._v(", then you write a two-state postcondition that mentions the value of "),a("code",[e._v("c.x")]),e._v(" in both the method's pre-state and the method's post-state. The former is notated by "),a("code",[e._v("old(c.x)")]),e._v(", and the latter simply by "),a("code",[e._v("c.x")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures old(c.x) < c.x\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("This specification says nothing about the post-value of "),a("code",[e._v("c.y")]),e._v(". More precisely, the "),a("code",[e._v("modifies")]),e._v(" clause gives "),a("code",[e._v("M")]),e._v(" permission to update all of the fields of "),a("code",[e._v("c")]),e._v(" and the "),a("code",[e._v("ensures")]),e._v(" clause does not constrain the final value of "),a("code",[e._v("c.y")]),e._v(".")]),e._v(" "),a("p",[e._v("If you want to specify that the value of "),a("code",[e._v("c.y")]),e._v(" is not changed, then you can add another postcondition:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures old(c.x) < c.x && old(c.y) == c.y\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("This postcondition constrains the post-value of "),a("code",[e._v("c.y")]),e._v(" to be the same as its pre-value.")]),e._v(" "),a("h3",{attrs:{id:"_2-1-unchanged"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-unchanged"}},[e._v("#")]),e._v(" 2.1. unchanged")]),e._v(" "),a("p",[e._v("If you want to say that all fields of an object are unchanged, you can use an "),a("code",[e._v("unchanged")]),e._v(" expression. For example,")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C, k: int)\n  modifies c\n  ensures k < 0 ==> unchanged(c)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("This specification gives "),a("code",[e._v("M")]),e._v(" license to modify the fields of "),a("code",[e._v("c")]),e._v(". However, the postcondition constrains the fields to have the initial values if "),a("code",[e._v("k")]),e._v(" is negative.")]),e._v(" "),a("p",[e._v("An "),a("code",[e._v("unchanged")]),e._v(" expression accepts a variable number of arguments, each a frame expression. In other words, what you put inside the parentheses that follow the "),a("code",[e._v("unchanged")]),e._v(" keyword has the same syntax as "),a("code",[e._v("modifies")]),e._v(" clauses. For example,")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method P(c: C, d: D, S: set<object>, k: int)\n  modifies c, d, S\n  ensures k < 0 ==> unchanged(c, S)\n{\n  if d !in S {\n    d.z := 5;\n  }\n  if 0 <= k {\n    c.x := c.x + 4;\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("is a method that verifies. Note that if "),a("code",[e._v("d")]),e._v(" is in the set "),a("code",[e._v("S")]),e._v(" and "),a("code",[e._v("k")]),e._v(" is negative, then the postcondition says the fields of "),a("code",[e._v("d")]),e._v(" must have their initial values, because "),a("code",[e._v("unchanged(S)")]),e._v(" says that all fields of all objects in "),a("code",[e._v("S")]),e._v(" must not have changed.")]),e._v(" "),a("h2",{attrs:{id:"_3-the-fine-print"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-the-fine-print"}},[e._v("#")]),e._v(" 3. The fine print")]),e._v(" "),a("h3",{attrs:{id:"_3-0-modifies-determined-in-pre-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-modifies-determined-in-pre-state"}},[e._v("#")]),e._v(" 3.0. modifies determined in pre-state")]),e._v(" "),a("p",[e._v("A "),a("code",[e._v("modifies")]),e._v(" clause is evaluated in the method's pre-state.")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('method R(c: C, d: D)\n  modifies c, c.y\n{\n  var prevCY := c.y;\n  c.y := d;  // allowed by "modifies c"\n  prevCY.z := 9;  // allowed by "modifies c.y"\n  c.y.z := 9;  // not allowed\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("For the last assignment to be legal, the object denoted by "),a("code",[e._v("c.y")]),e._v(" at the time of the assignment (namely, "),a("code",[e._v("d")]),e._v(") would have to be in the original "),a("code",[e._v("modifies")]),e._v(" clause.")]),e._v(" "),a("p",[a("strong",[e._v("Exercise 1.")]),e._v("\nWrite a precondition for "),a("code",[e._v("R")]),e._v(" that makes all assignments legal.")]),e._v(" "),a("p",[a("strong",[e._v("Answer.")])]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("requires c.y == d\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The frame expressions given in an "),a("code",[e._v("unchanged")]),e._v(" expression are evaluated where the the "),a("code",[e._v("unchanged")]),e._v(" is given. For example, the following method satisfies its specification, because the postcondition talks about the fields of the post-state value of "),a("code",[e._v("c.y")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method S(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(c.y)\n{\n  c.y.z := 12;\n  c.y := d;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("If you change "),a("code",[e._v("unchanged(c.y)")]),e._v(" to "),a("code",[e._v("unchanged(old(c.y))")]),e._v(", then the postcondition says that the fields of the object denoted by the pre-state value of "),a("code",[e._v("c.y")]),e._v(" must not have changed:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method S'(c: C, d: D)\n  requires c.y != d\n  modifies c, c.y, d\n  ensures unchanged(old(c.y))\n{\n  c.y := d;\n  d.z := d.z + 1;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("So, the body of "),a("code",[e._v("S'")]),e._v(" verifies. If the swap the implementations of methods "),a("code",[e._v("S")]),e._v(" and "),a("code",[e._v("S'")]),e._v(", then neither of them verifies.")]),e._v(" "),a("h3",{attrs:{id:"_3-1-old-only-affects-the-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-old-only-affects-the-heap"}},[e._v("#")]),e._v(" 3.1. old only affects the heap")]),e._v(" "),a("p",[a("code",[e._v("old")]),e._v(" applies only to heap dereferences. If you want to think of it syntactically, then this means the "),a("code",[e._v(".")]),e._v(" (dot) in field dereferences (including the "),a("code",[e._v(".")]),e._v(" in "),a("code",[e._v("this.x")]),e._v(" when you write just "),a("code",[e._v("x")]),e._v(" and leave "),a("code",[e._v("this")]),e._v(" implicit) and the "),a("code",[e._v("[")]),e._v(" "),a("code",[e._v("]")]),e._v(" (brackets) in array dereferences. In particular, in- and out-parameters, and local and bound variables are unaffected by "),a("code",[e._v("old")]),e._v(".")]),e._v(" "),a("p",[e._v("For example, consider")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method W0(c: C, d: D) returns (k: int)\n  modifies c\n  ensures old(k == c.y.z)  // k refers to the final value of k\n{\n  k := c.y.z;\n  c.y := d;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("The postcondition of "),a("code",[e._v("W0")]),e._v(" holds, because "),a("code",[e._v("k")]),e._v(" refers to the output value for "),a("code",[e._v("k")]),e._v(" (not the arbitrary value that "),a("code",[e._v("k")]),e._v(" starts off with inside the body, which would be meaningless to a caller, anyhow). Also, "),a("code",[e._v("c")]),e._v(" inside the "),a("code",[e._v("old")]),e._v(" expression refers to (constant) value of in-parameter "),a("code",[e._v("c")]),e._v(".")]),e._v(" "),a("p",[e._v("Here is another example method that verifies:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method W1(c: C, a: array<int>)\n  requires 0 <= c.x < a.Length\n  modifies c, a\n{\n  var m := a[c.x];\n  a[c.x] := m + 5;\n  c.x := c.x + 1;\n  m := m + 2;\n  assert old(m == a[c.x] + 2);\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("p",[e._v("The assertion in the body could equally well have been written")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("assert m == old(a[c.x]) + 2;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[a("strong",[e._v("Exercise 2.")]),e._v("\nWhat error message does Dafny produce for the following method?")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method W2() {\n  var d := new D;\n  d.z := 7;\n  assert old(d.z) == 7;  // error\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[a("strong",[e._v("Answer.")]),e._v("\nThe error is")]),e._v(" "),a("blockquote",[a("p",[e._v("receiver must be allocated in the state in which its fields are accessed")])]),e._v(" "),a("p",[e._v("The expression "),a("code",[e._v("old(d.z)")]),e._v(" tries to get pre-state value of the "),a("code",[e._v("z")]),e._v(" field of (the current value of) "),a("code",[e._v("d")]),e._v(". But the object referenced by "),a("code",[e._v("d")]),e._v(" was not allocated in the pre-state of the method, so it makes no sense to ask for the value of "),a("code",[e._v("d.z")]),e._v(" in the method's pre-state. Dafny detects this and produces an error.")]),e._v(" "),a("p",[a("strong",[e._v("Exercise 3.")]),e._v("\nConsider the following method:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method W3(c: C, a: array<int>)\n  requires 100 <= c.x < a.Length\n  requires forall i :: 0 <= i < c.x ==> a[i] == 5\n  requires forall i :: c.x <= i < a.Length ==> a[i] == 6\n  modifies c, a\n  ensures 0 <= c.x < a.Length\n{\n  a[c.x] := 16;\n  c.x := c.x - 1;\n  a[c.x] := 15;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("This method takes an array with more than "),a("code",[e._v("100")]),e._v(" elements. The first "),a("code",[e._v("c.x")]),e._v(" of elements start off as "),a("code",[e._v("5")]),e._v(", and the rest equal "),a("code",[e._v("6")]),e._v(". The "),a("code",[e._v("modifies")]),e._v(" clause and postcondition say that the method is allowed to modify both the fields of "),a("code",[e._v("c")]),e._v(" and the elements of "),a("code",[e._v("a")]),e._v(". You can see that the method's implementation satisfies that specification.")]),e._v(" "),a("p",[e._v("How do you write a postcondition that refers to")]),e._v(" "),a("p",[e._v("a) the final (that is, post-state) value of the array element at the index given by the final value of "),a("code",[e._v("c.x")]),e._v("?")]),e._v(" "),a("p",[e._v("b) the initial (that is, pre-state) value of the array element at the index given by the initial value of "),a("code",[e._v("c.x")]),e._v("?")]),e._v(" "),a("p",[e._v("c) the final value of the array element at the index given by the initial value of "),a("code",[e._v("c.x")]),e._v("?")]),e._v(" "),a("p",[e._v("d) (tricky!) the initial value of the array element at the index given by the final value of "),a("code",[e._v("c.x")]),e._v("?")]),e._v(" "),a("p",[a("strong",[e._v("Answer.")]),e._v("\na) Easy peasy:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ensures a[c.x] == 15\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("b) Easy peasy:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ensures old(a[c.x]) == 6\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("c) By wrapping "),a("code",[e._v("old")]),e._v(" around "),a("code",[e._v("c.x")]),e._v(", the dereference (that is, the dot) picks up the initial value of "),a("code",[e._v("c.x")]),e._v(". By making sure you don't wrap the array dereference (that is, the brackets) inside "),a("code",[e._v("old")]),e._v(", the expression "),a("code",[e._v("a[...]")]),e._v(" will pick up the final value of teh array element.")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ensures a[old(c.x)] == 16\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("d) If we could, we'd wrap "),a("code",[e._v("old")]),e._v(" around the brackets, but not the "),a("code",[e._v(".")]),e._v(". But that doesn't work, because what goes between the parentheses of "),a("code",[e._v("old")]),e._v(" must syntactically be an expression, not just some random characters. Instead, we can use a let expression: let the bound variable "),a("code",[e._v("k")]),e._v(" be the final value of "),a("code",[e._v("c.x")]),e._v(", and then use this bound variable inside "),a("code",[e._v("old")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ensures var k := c.x; old(a[k]) == 5\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_3-2-modifies-permission-is-checked-immediately"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-modifies-permission-is-checked-immediately"}},[e._v("#")]),e._v(" 3.2. modifies permission is checked immediately")]),e._v(" "),a("p",[e._v("For every heap assignment in a method, Dafny checks that the method has license to modify the indicated heap location. That is, the heap location must either be allowed by the "),a("code",[e._v("modifies")]),e._v(" clause or be newly allocated (that is, allocated since the start of the enclosing method). If the method does not have this license, then the heap assignment is illegal, even if the method later restores the previous value. For example, the following is illegal:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C) {\n  c.x := c.x + 1;  // error\n  c.x := c.x - 1;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("In fact, this is also illegal:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C) {\n  c.x := c.x;  // error\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("But for a method with the following specification:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures unchanged(c)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("both of the method implementations above are legal.")]),e._v(" "),a("h2",{attrs:{id:"_4-advanced-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-advanced-features"}},[e._v("#")]),e._v(" 4. Advanced features")]),e._v(" "),a("h3",{attrs:{id:"_4-0-more-precise-frame-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-more-precise-frame-expressions"}},[e._v("#")]),e._v(" 4.0. More precise frame expressions")]),e._v(" "),a("p",[e._v("It is appropriate to think of Dafny's frame expressions as operating at the "),a("em",[e._v("object granularity")]),e._v(". That is, "),a("code",[e._v("modifies")]),e._v(" clauses (and also "),a("code",[e._v("unchanged")]),e._v(" expressions, as well as the "),a("code",[e._v("reads")]),e._v(" clauses of functions) take a set of "),a("em",[e._v("objects")]),e._v(" and give permission to modify the fields of those objects (or, for "),a("code",[e._v("unchanged")]),e._v(", say that the fields of those objects are not changed, or, for "),a("code",[e._v("reads")]),e._v(", say that the function is allowed to depend on the fields of those objects).")]),e._v(" "),a("p",[e._v("It can happen that you want to be more precise. For example, suppose you want to say that a method may modify the "),a("code",[e._v("y")]),e._v(" field of a given parameter "),a("code",[e._v("c")]),e._v(", but not the "),a("code",[e._v("x")]),e._v(" field. You can specify this behavior by")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures old(c.x) == c.x\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("This works well if you want to modify most of the fields of "),a("code",[e._v("c")]),e._v(", but want to call out that some fields stay the same. (If a field "),a("em",[e._v("never")]),e._v(" changes after construction, it is best to declare it as immutable, which you do with "),a("code",[e._v("const")]),e._v(".) But if instead most fields remain the same and you only want to modify one or two, then the use of "),a("code",[e._v("old")]),e._v(" will feel verbose.")]),e._v(" "),a("p",[e._v("Dafny provides a way to give some frame expressions at the "),a("em",[e._v("object-field granularity")]),e._v(". You do this by appending a back-tick and the expression that denotes the object. For example, to specify that only the "),a("code",[e._v("y")]),e._v(" field of "),a("code",[e._v("c")]),e._v(" may change, you can write")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c`y\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("This says "),a("code",[e._v("M")]),e._v(" is not allowed to modify all fields of "),a("code",[e._v("c")]),e._v(", but only the "),a("code",[e._v("y")]),e._v(" field. Note that this is quite different from saying "),a("code",[e._v("modifies c.y")]),e._v(", which gives "),a("code",[e._v("M")]),e._v(" permission to modify all fields of the object denoted by "),a("code",[e._v("c.y")]),e._v(".")]),e._v(" "),a("p",[e._v("The object-field granularity can also be used in "),a("code",[e._v("unchanged")]),e._v(" expressions (and "),a("code",[e._v("reads")]),e._v(" clauses). For example, yet another way to specify the method "),a("code",[e._v("M")]),e._v(" is")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method M(c: C)\n  modifies c\n  ensures unchanged(c`x)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("Just like you can abbreviate "),a("code",[e._v("this.x")]),e._v(" by just "),a("code",[e._v("x")]),e._v(" (if there is no ambiguity with other local names), you can also abbreviate "),a("code",[e._v("this")]),e._v("x"),a("code",[e._v("by just ``x")]),e._v(".")]),e._v(" "),a("p",[e._v("Regrettably, Dafny does allow this back-tick notation for array elements, for it would be mighty nice to be able to write specifications like")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method P(a: array<int>, i: int, m: int, n: int)\n  requires 0 <= i < a.Length\n  requires 0 <= m <= n <= a.Length\n  modifies a`[i], a`[m..n]  // error: this syntax is not supported\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("A future version of Dafny may support this syntax.")]),e._v(" "),a("h3",{attrs:{id:"_4-1-state-labels"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-state-labels"}},[e._v("#")]),e._v(" 4.1. State labels")]),e._v(" "),a("p",[a("code",[e._v("old")]),e._v(" and "),a("code",[e._v("unchanged")]),e._v(" are examples of two-state predicates. That means they talk not just about the current state, but also about a previous state—namely, the pre-state of the enclosing method, in all the examples we've seen so far. (Well, "),a("code",[e._v("old")]),e._v(" only talks about the previous state, not the current state, but it's still a two-state predicate, because it doesn't just talk about the current state.)")]),e._v(" "),a("p",[e._v("The primary use of two-state expressions is in postconditions. However, you can also use them, for example, in assertions in a method body, like so:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method L(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.x := c.x + 3;\n  c.x := c.x + 4;\n  assert c.x == old(c.x) + 9 && unchanged(c`y);\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("Sometimes, you want to talk about a heap value in some intermediate state. One way to do that is to use ghost variables. For example:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method L1(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  ghost var g := c.x;\n  c.x := c.x + 3;\n  ghost var h := c.x;\n  c.x := c.x + 4;\n  assert c.x == h + 4 == g + 7 == old(c.x) + 9;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("p",[e._v("If you want to refer to many values in the heap from an previous intermediate state, then you can use "),a("em",[e._v("labels")]),e._v(". These are the same labels as you would use to do a control-flow break out of a loop or other statement. Like in many other languages, the declaration of a label in Dafny ends with a "),a("code",[e._v(":")]),e._v(" (colon). Unlike many other languages, Dafny also requires the declaration to start with the keyword "),a("code",[e._v("label")]),e._v(", which is intended to make the placement more prominent.")]),e._v(" "),a("p",[a("code",[e._v("old")]),e._v(" and "),a("code",[e._v("unchanged")]),e._v(" can be followed with "),a("code",[e._v("@")]),e._v(" and a label, which makes them two-state predicates that refer to the current state and the previous state. Here is an example:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method L2(c: C)\n  modifies c\n{\n  c.x := c.x + 2;\n  c.y := new D;\n  label G:\n  c.x := c.x + 3;\n  label H:\n  c.x := c.x + 4;\n  assert c.x == old@H(c.x) + 4 == old@G(c.x) + 7 == old(c.x) + 9;\n  assert unchanged@G(c`y);\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("Here's a more stimulating example:")]),e._v(" "),a("div",{staticClass:"language-dafnyx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method Inc(c: C, m: nat, n: nat)\n  modifies c\n  ensures c.x == old(c.x) + 3 * m + 2 * n\n{\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant c.x == old(c.x) + 3 * i\n  {\n    c.x, i := c.x + 3, i + 1;\n  }\n  label Middle:\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c.x == old@Middle(c.x) + 2 * i\n  {\n    c.x, i := c.x + 2, i + 1;\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);