(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{525:function(s,e,n){"use strict";n.r(e);var a=n(18),t=Object(a.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"前置和后置条件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前置和后置条件"}},[s._v("#")]),s._v(" 前置和后置条件")]),s._v(" "),n("p",[s._v("到目前为止，我们所看到的所有代码都没有任何规范:代码几乎可以用任何命令式语言编写(适当考虑多个返回值)。"),n("code",[s._v("Dafny")]),s._v("的真正强大之处在于能够注释这些方法来指定它们的行为。例如，我们使用"),n("code",[s._v("Abs")]),s._v("方法观察到的一个属性是，不管输入是什么，结果总是大于或等于零。我们可以把这个观察结果放在注释中，但是我们没有办法知道这个方法是否真的有这个属性。而且，如果有人改变了方法，我们不能保证注释也会相应改变。通过注释，我们可以让"),n("code",[s._v("Dafny")]),s._v("证明我们声明的方法的属性是真的。有几种方法可以给出注解，但最常见和最基本的是方法的前置条件和后置条件。\nAbs方法的这个属性，即结果总是非负的，是后置条件的一个例子:它是在方法返回后为真。用"),n("code",[s._v("ensures")]),s._v("关键字声明的后置条件，作为方法声明的一部分，在返回值之后(如果存在)和方法体之前给出。关键字后面跟着布尔表达式。像"),n("code",[s._v("if")]),s._v("或 "),n("code",[s._v("while")]),s._v("条件和大多数规范一样，后置条件总是一个布尔表达式:可以是"),n("code",[s._v("true")]),s._v("或 "),n("code",[s._v("false")]),s._v(". 在"),n("code",[s._v("Abs")]),s._v("方法的情况下，一个合理的后置条件如下:")]),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   if x < 0 {\n      return -x;\n   } else {\n      return x;\n   }\n}\nmethod Abs(x: int) returns (y: int)\n   ensures 0 <= y\n{\n   ...\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[s._v("你可以在这里看到为什么返回值被赋予名称。这使得它们很容易在方法的后置条件中引用。当表达式为真时，我们说后置条件保留。后置条件必须适用于函数的每次调用，以及每个可能的返回点 "),n("em",[s._v("(包括函数体末尾的隐式返回点)")]),s._v("。在这种情况下，我们唯一要表达的属性是返回值总是至少为零。\n有时，我们需要为代码建立多个属性。在这种情况下，我们有两个选择。我们可以用布尔型的"),n("code",[s._v("and")]),s._v("操作符("),n("code",[s._v("&&")]),s._v("), 将这两个条件连接起来，或者可以编写多个"),n("code",[s._v("ensures")]),s._v("表达式。后者与前者基本相同，但它区分了不同的属性。例如，"),n("code",[s._v("MultipleReturns")]),s._v(" 方法的返回值名称可能会导致人们猜测以下后置条件:")]),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x\n   ensures x < more\n{\n   more := x + y;\n   less := x - y;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("后置条件也可以这样写:")]),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x && x < more\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("甚至是这样：")]),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n   ensures less < x < more\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("因为"),n("code",[s._v("Dafny")]),s._v("中使用了链接比较运算符语法。"),n("em",[s._v("(一般来说，大多数比较运算符可以串联，但只能同相连接，即不能混合使用"),n("strong",[s._v("大于")]),s._v("和"),n("strong",[s._v("小于")]),s._v("。详情请参阅参考资料。)")]),s._v("\n表示后置条件的第一种方式将"),n("code",[s._v("less")]),s._v("部分与"),n("code",[s._v("more")]),s._v("部分分开，这可能是可取的。另一件需要注意的事情是，我们在后置条件中包含了一个输入参数。这是有用的，因为它允许我们将方法的输入和输出相互关联(这是因为输入参数是只读的，所以在末尾和开始时是一样的)。\n"),n("code",[s._v("Dafny")]),s._v("实际上拒绝了这个程序，声称第一个后置条件不成立 "),n("em",[s._v("(即不为真)")]),s._v("。这意味着"),n("code",[s._v("Dafny")]),s._v("不能证明该注释在每次方法返回时都有效。通常，"),n("code",[s._v("Dafny")]),s._v("验证错误有两个主要原因:规范与代码不一致，以及它不够"),n("strong",[s._v("聪明")]),s._v("来证明所需属性的情况。区分这两种可能性可能是一项困难的任务，但幸运的是，"),n("code",[s._v("Dafny")]),s._v("和它所基于的"),n("code",[s._v("Boogie/Z3")]),s._v("系统非常聪明，并且将证明代码和规范的匹配非常简单。\n在这种情况下，Dafny说代码有错误是正确的。问题的关键在于y是整数，所以它可以是负的。如果"),n("code",[s._v("y")]),s._v("为负(或为零)，那么"),n("code",[s._v("more")]),s._v("可以小于或等于"),n("code",[s._v("x")]),s._v("。除非"),n("code",[s._v("y")]),s._v("严格大于零，否则我们的方法将无法正常工作。这正是"),n("Badge",{attrs:{text:"先决条件"}}),s._v("的概念。前置条件类似于后置条件，除了它必须在方法被调用之前为真。当您调用一个方法时，您的工作是建立(使)先决条件为真，这是"),n("code",[s._v("Dafny")]),s._v("使用证明来实现的。同样，当您编写一个方法时，您可以假定先决条件，但是您必须建立后置条件。然后，方法的调用者可以假定方法返回后置条件保持不变。\n前提条件有自己的关键字"),n("code",[s._v("requires")]),s._v("。我们可以给予"),n("code",[s._v("多次返回")]),s._v("必要的先决条件如下:")],1),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("与后置条件一样，多个前置条件可以用布尔型的"),n("code",[s._v("and")]),s._v("操作符("),n("code",[s._v("&&")]),s._v(")或多个"),n("code",[s._v("require")]),s._v("关键字来写。传统上，源代码中的"),n("code",[s._v("requires")]),s._v("优先于"),n("code",[s._v("ensure")]),s._v("，尽管这并不是绝对必要的(尽管"),n("code",[s._v("requires")]),s._v("和"),n("code",[s._v("ensure")]),s._v("注释相对于其他同类型注释的顺序有时会很重要，我们将在后面看到)。添加了这个条件后，Dafny现在验证代码是否正确，只需要保证这个假设正确，就可以保证方法体中的代码是正确的。")]),s._v(" "),n("p",[n("strong",[s._v("练习0")])]),s._v(" "),n("details",{staticClass:"custom-block details"},[n("summary",[s._v("点击查看题目及代码")]),s._v(" "),n("p",[s._v("编写一个方法"),n("code",[s._v("Max")]),s._v("，它接受两个整数参数并返回它们的最大值。添加适当的注释，并确保对代码进行验证。")]),s._v(" "),n("div",{staticClass:"language-dafny line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("method Max(a: int, b: int) returns (c: int)\n  // What postcondition should go here, so that the function operates as expected?\n  // Hint: there are many ways to write this.\n{\n  // fill in the code here\n}\nmethod Max(a: int, b: int) returns (c: int)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])])]),s._v(" "),n("p",[s._v("并不是所有的方法都有先决条件。例如，我们已经看到的"),n("code",[s._v("Abs")]),s._v("方法是为所有整数定义的，因此没有任何先决条件(除了它的参数是整数这一琐碎的要求，这是由类型系统强制执行的)。尽管它不需要先决条件，"),n("code",[s._v("Abs")]),s._v("函数目前的情况下并不是很有用。为了探究其中的原因，我们需要使用另一种注释，即断言。")])])}),[],!1,null,null,null);e.default=t.exports}}]);