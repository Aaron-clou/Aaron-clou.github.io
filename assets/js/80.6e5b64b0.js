(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{564:function(e,s,t){"use strict";t.r(s);var n=t(18),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Dafny Power User:\nIterating over a Collection")]),e._v(" "),t("p",[e._v("K. Rustan M. Leino")]),e._v(" "),t("p",[e._v("Manuscript KRML 275, 17 February 2020")]),e._v(" "),t("p",[t("strong",[e._v("Abstract.")]),e._v(" Processing the contents of a set or map in a deterministic way takes some work. Using a representative example, this note shows a way to do it.")]),e._v(" "),t("p",[e._v("Mathematical collection types include sets, multisets, sequences, and maps. These are essential to specifications as well as programs. Defining functions over the elements of such collections is more difficult (or at least more labor intensive) than one would expect. In this note, I develop the program and proof for an example that converts a map to a sequence of pairs. The central part of the work concerns getting a compilable function that returns a set's elements into a predictable order.")]),e._v(" "),t("p",[e._v("Throughout this note, the goal is to produce compilable functions.")]),e._v(" "),t("h2",{attrs:{id:"_0-map-to-sequence"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-map-to-sequence"}},[e._v("#")]),e._v(" 0. Map to sequence")]),e._v(" "),t("p",[e._v("A map is set of key-value pairs, where no key is repeated. We can convert a map to a sequence by putting its keys into a sequence and then making pairs by retrieving the value for each key:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function method MapToSequence<A,B>(m: map<A,B>): seq<(A,B)> {\n  var keys := SetToSequence(m.Keys);\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n\nfunction method SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("For a map "),t("code",[e._v("m")]),e._v(", the expression "),t("code",[e._v("m.Keys")]),e._v(" gives the set of keys. Function "),t("code",[e._v("MapToSequence")]),e._v(" passes this set of keys to "),t("code",[e._v("SetToSequence")]),e._v(" to obtain a sequence of these keys. Then, the sequence constructor")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("seq(n, f)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("produces a sequence of length "),t("code",[e._v("n")]),e._v(", where the element with index "),t("code",[e._v("i")]),e._v(" is specified to be "),t("code",[e._v("f(i)")]),e._v(". In "),t("code",[e._v("MapToSequence")]),e._v(", the second argument to the sequence comprehension is a partial function given by the lambda expression")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("i requires 0 <= i < |keys| => (keys[i], m[keys[i]])\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("For an index in the given range, this function returns a pair consisting of the key "),t("code",[e._v("keys[i]")]),e._v(" and its corresponding value in "),t("code",[e._v("m")]),e._v(". It is necessary to give the range of "),t("code",[e._v("i")]),e._v(" in the function's precondition, or else the expression "),t("code",[e._v("keys[i]")]),e._v(" would give rise to an index-of-out-bounds error.")]),e._v(" "),t("p",[e._v("To avoid a key-is-not-in-map error in the expression "),t("code",[e._v("m[keys[i]]")]),e._v(", we need to know that "),t("code",[e._v("keys[i]")]),e._v(" is a key of "),t("code",[e._v("m")]),e._v(". That requires us to know a connection between "),t("code",[e._v("m.Keys")]),e._v(" and "),t("code",[e._v("keys")]),e._v(", which is stated in the postcondition of the (not yet implemented) function "),t("code",[e._v("SetToSequence")]),e._v(".")]),e._v(" "),t("p",[e._v("We now need to implement "),t("code",[e._v("SetToSequence")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"_1-a-ghost-function"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-a-ghost-function"}},[e._v("#")]),e._v(" 1. A ghost function")]),e._v(" "),t("p",[e._v("Let's start easy. We'll define "),t("code",[e._v("SetToSequence")]),e._v(" as a ghost function. The definition is recursive. When the given set is nonempty, the function uses the choose operator, aka the let-such-that operator and written "),t("code",[e._v(":|")]),e._v(", to pick an element from the set.")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function SetToSequence<A>(s: set<A>): seq<A>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s;\n    [x] + SetToSequence(s - {x})\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("That wasn't too bad.")]),e._v(" "),t("h2",{attrs:{id:"_2-making-the-function-compilable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-making-the-function-compilable"}},[e._v("#")]),e._v(" 2. Making the function compilable")]),e._v(" "),t("p",[e._v("To make the "),t("code",[e._v("SetToSequence")]),e._v(" we wrote above compilable, we change the keyword "),t("code",[e._v("function")]),e._v(" to the keyword phrase "),t("code",[e._v("function method")]),e._v(". This generates an error message:")]),e._v(" "),t("blockquote",[t("p",[e._v("to be compilable, the value of a let-such-that expression must be uniquely determined")])]),e._v(" "),t("p",[e._v("Expressions—and functions, whose bodies are expressions—must be deterministic in Dafny. This means that")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var x :| x in s;\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("always needs to pick the same value for "),t("code",[e._v("x")]),e._v(" when given the same "),t("code",[e._v("s")]),e._v(". This would be computationally expensive to do at run time, so Dafny instead puts this burden on the programmer (see ["),t("a",{attrs:{href:"http://leino.science/papers/krml275.html#lpar-20:compiling_hilberts_epsilon_operator",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),t("OutboundLink")],1),e._v("]).")]),e._v(" "),t("p",[e._v("One idea is for us to strengthen the condition "),t("code",[e._v("x in s")]),e._v(" to always pick “the minimum” value from "),t("code",[e._v("s")]),e._v(". This would uniquely determine the value of the let-such-that expression. But what does “minimum” mean? Let's start with integers, where we know what minimum is, and then work up to a general situation.")]),e._v(" "),t("h2",{attrs:{id:"_3-choosing-the-smallest-integer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-choosing-the-smallest-integer"}},[e._v("#")]),e._v(" 3. Choosing the smallest integer")]),e._v(" "),t("p",[e._v("For now, we'll restrict our attention to integer sets. This lets us strengthen the condition in the let-such-that expression to uniquely talk about the minimum element of the set:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function method SetToSequence(s: set<int>): seq<int>\n  ensures var q := SetToSequence(s);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    var x :| x in s && forall y :: y in s ==> x <= y;\n    [x] + SetToSequence(s - {x})\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("The “uniquely determined” requirement is now satisfied. However, since our new such-that predicate is more complicated, the verifier issues a different complaint:")]),e._v(" "),t("blockquote",[t("p",[e._v("cannot establish the existence of a LHS value that satisfies the such-that predicate")])]),e._v(" "),t("p",[e._v("It may seem clear to us that a nonempty set has a minimum element, but we need to convince the verifier of it. Let's do this in a separate lemma, which we declare as follows:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("lemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("We'll insert a call to this lemma just before the let-such-expression in "),t("code",[e._v("SetToSequence")]),e._v(". The body of that function thus becomes")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if s == {} then [] else\n  ThereIsAMinimum(s);\n  var x :| x in s && forall y :: y in s ==> x <= y;\n  [x] + SetToSequence(s - {x})\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("h2",{attrs:{id:"_4-proving-there-s-a-minimum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-proving-there-s-a-minimum"}},[e._v("#")]),e._v(" 4. Proving there's a minimum")]),e._v(" "),t("p",[e._v("Our next task is to give a proof for the "),t("code",[e._v("ThereIsAMinimum")]),e._v(" lemma. Here is an annotated proof:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("lemma ThereIsAMinimum(s: set<int>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> x <= y\n{\n  var x :| x in s;\n  if s == {x} {\n    // obviously, x is the minimum\n  } else {\n    // The minimum in s might be x, or it might be the minimum\n    // in s - {x}. If we knew the minimum of the latter, then\n    // we could compare the two.\n    // Let's start by giving a name to the smaller set:\n    var s' := s - {x};\n    // So, s is the union of s' and {x}:\n    assert s == s' + {x};\n    // The following lemma call establishes that there is a\n    // minimum in s'.\n    ThereIsAMinimum(s');\n  }\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br")])]),t("p",[e._v("The proof starts by picking an arbitrary element, "),t("code",[e._v("x")]),e._v(", from "),t("code",[e._v("s")]),e._v(". It is the minimum if it's the only element in "),t("code",[e._v("s")]),e._v(". Otherwise, the proof brings out the fact that "),t("code",[e._v("s")]),e._v(" is "),t("code",[e._v("s' + {x}")]),e._v(". The recursive call to the lemma gives us, through its postcondition, that there exists a minimum element in "),t("code",[e._v("s'")]),e._v(". The verifier automatically supplies the remaining proof glue, so we're done.")]),e._v(" "),t("p",[e._v("The assertion in the proof may seem silly. We just defined "),t("code",[e._v("s'")]),e._v(" to be "),t("code",[e._v("s - {x}")]),e._v(". Since "),t("code",[e._v("x")]),e._v(" is in "),t("code",[e._v("s")]),e._v(", the property "),t("code",[e._v("s == s' + {x}")]),e._v(" follows immediately. Yes, it does. The verifier can easily confirm this, but verifier is not creative enough to realize that this is a good property to know. This is typical when working with collections. For example, if you're working with a sequence "),t("code",[e._v("q")]),e._v(", you may consider "),t("code",[e._v("q[0]")]),e._v(" separately and do a recursive call on "),t("code",[e._v("q[1..]")]),e._v(". If so, you're likely to need to manually supply")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("assert [q[0]] + q[1..] == q;\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("As with the set property, the verifier easily proves this property, but wouldn't have thought of it by itself.")]),e._v(" "),t("p",[e._v("The moral of the proof is that it's a good idea, when you split a collection into smaller pieces that you want to reason about separately, to assert that the whole collection equals the combination of the smaller pieces.")]),e._v(" "),t("h2",{attrs:{id:"_5-total-orders"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-total-orders"}},[e._v("#")]),e._v(" 5. Total orders")]),e._v(" "),t("p",[e._v("The restriction to integer sets above was nice to work with, because the minimum of a set of integers is easy to define and gives a unique element. To apply the same trick other types, we need to be able to define a “minimum” for those types, too. To define a minimum, you need a "),t("em",[e._v("total order")]),e._v(". Let's review what that means.")]),e._v(" "),t("p",[e._v("A relation over a type "),t("code",[e._v("A")]),e._v(" is a function "),t("code",[e._v("(A, A) -> bool")]),e._v(". Such a relation, call it "),t("code",[e._v("R")]),e._v(", is known as a "),t("em",[e._v("partial order")]),e._v(" when the following three conditions hold:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("R")]),e._v(" is reflexive, that is,\n"),t("code",[e._v("forall a :: R(a, a)")])]),e._v(" "),t("li",[t("code",[e._v("R")]),e._v(" is antisymmetric, that is,\n"),t("code",[e._v("forall a, b :: R(a, b) && R(b, a) ==> a == b")])]),e._v(" "),t("li",[t("code",[e._v("R")]),e._v(" is transitive, that is,\n"),t("code",[e._v("forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c)")])])]),e._v(" "),t("p",[e._v("A "),t("em",[e._v("total order")]),e._v(" is a partial order that additionally satisfies the following condition:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("R")]),e._v(" is connex (closely connected), that is,\n"),t("code",[e._v("forall a, b :: R(a, b) || R(b, a)")])])]),e._v(" "),t("p",[e._v("Note that connexity implies reflexivity.")]),e._v(" "),t("p",[e._v("Here is a predicate that says whether or not a given relation is a total order:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("predicate IsTotalOrder<A(!new)>(R: (A, A) -> bool) {\n  // connexity\n  && (forall a, b :: R(a, b) || R(b, a))\n  // antisymmetry\n  && (forall a, b :: R(a, b) && R(b, a) ==> a == b)\n  // transitivity\n  && (forall a, b, c :: R(a, b) && R(b, c) ==> R(a, c))\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("Dafny won't allow us to write these quantifiers in the predicate, unless it knows a little more about type "),t("code",[e._v("A")]),e._v(". If "),t("code",[e._v("A")]),e._v(" were a class type, then "),t("code",[e._v("forall")]),e._v(" in Dafny means quantifying over the "),t("em",[e._v("allocated")]),e._v(" instances of class "),t("code",[e._v("A")]),e._v(". That would mean that allocating another "),t("code",[e._v("A")]),e._v(" instance could cause "),t("code",[e._v("IsTotalOrder(R)")]),e._v(" to change values. To prevent this, Dafny insists that unbounded quantifications like those in "),t("code",[e._v("IsTotalOrder")]),e._v(" be over types that do not depend on the allocated state. We express that with the "),t("em",[e._v("type characteristic")]),e._v(" "),t("code",[e._v("(!new)")]),e._v(", which is written as a suffix of the type name in the type-parameter declaration.")]),e._v(" "),t("h2",{attrs:{id:"_6-generic-set-to-sequence"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-generic-set-to-sequence"}},[e._v("#")]),e._v(" 6. Generic set to sequence")]),e._v(" "),t("p",[e._v("We revise "),t("code",[e._v("SetToSequence")]),e._v(" to also take a relation, "),t("code",[e._v("R")]),e._v(", which we require to be a total order. In doing so, we change the total order "),t("code",[e._v("<=")]),e._v(" on integers to "),t("code",[e._v("R")]),e._v(", and we also add "),t("code",[e._v("R")]),e._v(" as a parameter to the "),t("code",[e._v("ThereIsAMinimum")]),e._v(" lemma:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function method SetToSequence<A(!new)>(s: set<A>, R: (A, A) -> bool): seq<A>\n  requires IsTotalOrder(R)\n  ensures var q := SetToSequence(s, R);\n    forall i :: 0 <= i < |q| ==> q[i] in s\n{\n  if s == {} then [] else\n    ThereIsAMinimum(s, R);\n    var x :| x in s && forall y :: y in s ==> R(x, y);\n    [x] + SetToSequence(s - {x}, R)\n}\n\nlemma ThereIsAMinimum<A(!new)>(s: set<A>, R: (A, A) -> bool)\n  requires s != {} && IsTotalOrder(R)\n  ensures exists x :: x in s && forall y :: y in s ==> R(x, y)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br")])]),t("p",[e._v("The revised "),t("code",[e._v("SetToSequence")]),e._v(" lemma verifies. Our remaining task is to prove the lemma.")]),e._v(" "),t("h2",{attrs:{id:"_7-total-order-has-minimum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-total-order-has-minimum"}},[e._v("#")]),e._v(" 7. Total order has minimum")]),e._v(" "),t("p",[e._v("We start the proof of our generic "),t("code",[e._v("ThereIsAMinimum")]),e._v(" like the analogous proof for integer sets above:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  var x :| x in s;\n  if s == {x} {  // error: postcondition might not hold on this return path\n  } else {\n  }\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("p",[e._v("The case that was “obvious” before is causing the verifier trouble this time. Let's help it out. Our proof obligation is to show there's some element in "),t("code",[e._v("s")]),e._v(" that is as small as any element in "),t("code",[e._v("s")]),e._v(". If "),t("code",[e._v("s")]),e._v(" is the singleton set "),t("code",[e._v("{x}")]),e._v(", then the element we're looking for can only be "),t("code",[e._v("x")]),e._v(". Now, if "),t("code",[e._v("y")]),e._v(" is an element in "),t("code",[e._v("s")]),e._v(", we need to prove "),t("code",[e._v("R(x, y)")]),e._v(". Since "),t("code",[e._v("s")]),e._v(" is a singleton, we have "),t("code",[e._v("y == x")]),e._v(", and then "),t("code",[e._v("R(x, y)")]),e._v(" follows from connexity. The verifier is missing one of both of these facts. Let's add an assertion about the first fact:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  if s == {x} {\n    assert forall y :: y in s ==> x == y;\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("Ah, yes, the verifier can prove this assertion and can then do the rest of the proof.")]),e._v(" "),t("p",[e._v("On to the non-singleton case. We'll start like in the integer-set proof above:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  } else {\n    var s' := s - {x};\n    assert s == s' + {x};\n    ThereIsAMinimum(s', R);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[e._v("The verifier complains the lemma's postcondition might not hold, so we'll give the verifier more help.")]),e._v(" "),t("p",[e._v("The recursive call to the lemma (which, by the way, is known as “the induction hypothesis”) says there is a minimum in "),t("code",[e._v("s'")]),e._v(". Let's give it a name, which we do by introducing a local variable whose value we constrain to satisfy the condition in the lemma's postcondition's existential quantifier:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    var z :| z in s' && forall y :: y in s' ==> R(z, y);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Since "),t("code",[e._v("s")]),e._v(" is "),t("code",[e._v("s' + {x}")]),e._v(", the minimum we're looking for is either "),t("code",[e._v("z")]),e._v(" or "),t("code",[e._v("x")]),e._v(". Let's treat these cases separately. We do that by using an "),t("code",[e._v("if")]),e._v(" statement. Since the two cases are so symmetric, I think it looks nice to use Dafny's if-case statement:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    // by connexity, one of the two cases below applies\n    if\n    case R(z, x) =>\n      // prove z is the minimum not just of s', but of s\n      // ...\n    case R(x, z) =>\n      // prove x is the minimum of s\n      // ...\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("Let's do the "),t("code",[e._v("R(z, x)")]),e._v(" case first. The hard part is likely to be the quantifier in the postcondition, so let's start with it. To give a proof of a universal quantifier, you use a "),t("code",[e._v("forall")]),e._v(" statement.")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("      forall y | y in s\n        ensures R(z, y)\n      {\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("From "),t("code",[e._v("y in s")]),e._v(", we know either "),t("code",[e._v("y")]),e._v(" is "),t("code",[e._v("x")]),e._v(" or "),t("code",[e._v("y")]),e._v(" is in "),t("code",[e._v("s'")]),e._v(". For the former, the proof follows from the guard "),t("code",[e._v("R(z, x)")]),e._v(". For the latter, the proof follows from the quantification in the such-that condition we used to introduce "),t("code",[e._v("z")]),e._v(". Somehow, the verifier is not picking up on this, so let's help it along. We start here:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("        assert x == y || y in s';\n      }\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("Lo and behold! That's all the verifier needed.")]),e._v(" "),t("p",[e._v("In the "),t("code",[e._v("R(x, z)")]),e._v(" case, we'll lay down the analogous "),t("code",[e._v("forall")]),e._v(" statement to prove the quantifier in the lemma's postcondition:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("      forall y | y in s\n        ensures R(x, y)\n      {\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("If "),t("code",[e._v("y")]),e._v(" is "),t("code",[e._v("x")]),e._v(", then "),t("code",[e._v("R(x, y)")]),e._v(" follows from connexity. On the other hand, if "),t("code",[e._v("y")]),e._v(" is in "),t("code",[e._v("s'")]),e._v(", then the such-that condition that introduced "),t("code",[e._v("z")]),e._v(" tells us "),t("code",[e._v("R(z, y)")]),e._v(", so we get "),t("code",[e._v("R(x, y)")]),e._v(" by transitivity. You may add these hints in various ways to make the proof go through. Here is one way:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("        assert y in s' ==> R(z, y);\n      }\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("A final remark. When we proved "),t("code",[e._v("ThereIsAMinimum")]),e._v(" for integer sets, I argued that it's often useful to include an assertion like:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    assert s == s' + {x};\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("I included it in the generic "),t("code",[e._v("ThereIsAMinimum")]),e._v(" as well. But as it turns out, it's not actually needed there (because we made up for it in the additional hints we gave in the two cases), so you can delete it, if you want.")]),e._v(" "),t("h2",{attrs:{id:"_8-coming-back-to-map-to-sequence"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-coming-back-to-map-to-sequence"}},[e._v("#")]),e._v(" 8. Coming back to map to sequence")]),e._v(" "),t("p",[e._v("We did it!")]),e._v(" "),t("p",[e._v("Well, before we declare success, let's just make sure we can use our functions and lemmas to write the "),t("code",[e._v("MapToSequence")]),e._v(" function that we set out to write. Here's the generic version, which needs a given total order:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function method MapToSequence<A(!new),B>(m: map<A,B>, R: (A, A) -> bool): seq<(A,B)>\n  requires IsTotalOrder(R)\n{\n  var keys := SetToSequence(m.Keys, (a,a') => R(a, a'));\n  seq(|keys|, i requires 0 <= i < |keys| => (keys[i], m[keys[i]]))\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("p",[e._v("We can also specialize it for integer sets:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function method IntMapToSequence<B>(m: map<int,B>): seq<(int,B)> {\n  MapToSequence(m, (a, a') => a <= a')\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("We did it!")]),e._v(" "),t("h2",{attrs:{id:"_9-conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-conclusion"}},[e._v("#")]),e._v(" 9. Conclusion")]),e._v(" "),t("p",[e._v("I hope this long journey showed you a thing or two about working with collections in Dafny.")]),e._v(" "),t("h2",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("p",[e._v("[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, "),t("em",[e._v("LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations")]),e._v(", volume 35 of "),t("em",[e._v("EPiC Series in Computing")]),e._v(", pages 106–118. EasyChair, 2015. "),t("a",{attrs:{href:"http://www.bing.com/search?q=Compiling+Hilbert+epsilon+operator+++Rustan+Leino+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=a.exports}}]);