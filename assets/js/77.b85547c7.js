(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{561:function(e,a,t){"use strict";t.r(a);var s=t(18),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Dafny Power User:\nComprehensions")]),e._v(" "),t("p",[e._v("K. Rustan M. Leino")]),e._v(" "),t("p",[e._v("Manuscript KRML 267, 27 May 2019")]),e._v(" "),t("p",[t("strong",[e._v("Abstract.")]),e._v(" Dafny has a number of comprehension-like constructs. This note describes and compares these constructs, showing how they compare both syntactically and semantically.")]),e._v(" "),t("p",[e._v("Dafny supports universal and existential quantifications, along with constructs used to "),t("em",[e._v("prove")]),e._v(" a universally quantified expression or "),t("em",[e._v("make use of")]),e._v(" an existentially quantified expression. Section "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#sec-quantifiers",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),t("OutboundLink")],1),e._v(" describes these logical quantifiers in Dafny. Section "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#sec-proof-features",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),t("OutboundLink")],1),e._v(" shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.")]),e._v(" "),t("p",[e._v("Set comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. Section "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#sec-sets-and-maps",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),t("OutboundLink")],1),e._v(" shows the general and common forms of these comprehensions.")]),e._v(" "),t("h2",{attrs:{id:"_0-quantifiers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-quantifiers"}},[e._v("#")]),e._v(" 0. Quantifiers")]),e._v(" "),t("h3",{attrs:{id:"basic-quantifier-syntax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic-quantifier-syntax"}},[e._v("#")]),e._v(" Basic quantifier syntax")]),e._v(" "),t("p",[e._v("In mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . It says that the predicate holds for all values of . In programming-language lingo, we say that is a "),t("em",[e._v("bound variable")]),e._v(" whose scope is the "),t("em",[e._v("body")]),e._v(" of the quantifier, . That is, any free occurrences of in are bound to the introduced by the quantifier.")]),e._v(" "),t("p",[e._v("In Dafny, the same universal quantifier is written "),t("code",[e._v("forall x :: P")]),e._v(". From a parsing perspective, the body of the quantifier extends “as far as possible”. Thus, the program snippet")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: R ==> Q\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("is parsed as")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(forall x :: (R ==> Q))\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("not as")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(forall x :: R) ==> Q\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Note that “as far as possible” does not stop at line endings. For example, a common pitfall is to write (here shown for a precondition)")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("requires\n  forall x :: R ==> Q &&\n  S\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("with the intention that "),t("code",[e._v("forall x :: R ==> Q")]),e._v(" and "),t("code",[e._v("S")]),e._v(" are two separate preconditions. Contrary to this expectation, the meaning of declaration, as written here, is")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("requires (forall x :: (R ==> (Q && S)))\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("If you intended to write the conjunction of the quantifier and "),t("code",[e._v("S")]),e._v(", then the proper syntax is")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("requires\n  (forall x :: R ==> Q) &&\n  S\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("A familiar mathematical notation for an existential quantifier is . It says that the predicate holds for some value of . In Dafny, the syntax is "),t("code",[e._v("exists x :: P")]),e._v("."),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#fn-fn-emacs",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"types-of-bound-variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#types-of-bound-variables"}},[e._v("#")]),e._v(" Types of bound variables")]),e._v(" "),t("p",[e._v("Each variable in Dafny has a type. Typically, the type of a bound variable is inferred, but Dafny also allows the type to be declared explicitly. For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x: X :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("declares the type of "),t("code",[e._v("x")]),e._v(" to be "),t("code",[e._v("X")]),e._v(". For brevity, and to show the typical ways of writing quantifiers and comprehensions, I will leave off types throughout this note, but remember that you can always include them if you want to.")]),e._v(" "),t("p",[e._v("A common mathematical notation for quantifiers when the bound variables are drawn from some set is . A Dafny-like rendering of this expression is")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x in S :: P  // error: syntax error\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("However, this is incorrect Dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. The proper way to write such a quantifier in Dafny is")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: x in S ==> P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("h3",{attrs:{id:"multiple-bound-variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multiple-bound-variables"}},[e._v("#")]),e._v(" Multiple bound variables")]),e._v(" "),t("p",[e._v("A quantifier can have more than one bound variable. For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x, y :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("says that "),t("code",[e._v("P")]),e._v(" holds for all values of "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("y")]),e._v(". It is logically equivalent to the nested quantifiers")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: forall y :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("For that matter, it is logically equivalent also to")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall y :: forall x :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Common practice in Dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise."),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#fn-fn-nested",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("In the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x: X, y: Y :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("says that "),t("code",[e._v("x")]),e._v(" has type "),t("code",[e._v("X")]),e._v(" and "),t("code",[e._v("y")]),e._v(" has type "),t("code",[e._v("Y")]),e._v(". If you only include the type of "),t("code",[e._v("y")]),e._v(", as in")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x, y: Y :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("then you are saying that "),t("code",[e._v("y")]),e._v(" has type "),t("code",[e._v("Y")]),e._v(" and that the type of "),t("code",[e._v("x")]),e._v(' is to be inferred. In other words, you can think of this "'),t("code",[e._v(":")]),e._v("“ as having strong binding power than the ”"),t("code",[e._v(",")]),e._v('".')]),e._v(" "),t("h3",{attrs:{id:"the-typical-forms-of-quantifier-bodies"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-typical-forms-of-quantifier-bodies"}},[e._v("#")]),e._v(" The typical forms of quantifier bodies")]),e._v(" "),t("p",[e._v("The body of a universal quantifier is typically an implication, as in")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: R ==> P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("You can read this in one of the following ways:")]),e._v(" "),t("blockquote",[t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(", the implication "),t("code",[e._v("R ==> P")]),e._v(' holds"')]),e._v(" "),t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(", "),t("code",[e._v("R")]),e._v(" implies "),t("code",[e._v("P")]),e._v('"')]),e._v(" "),t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(", if "),t("code",[e._v("R")]),e._v(" holds, then so does "),t("code",[e._v("P")]),e._v('"')])]),e._v(" "),t("p",[e._v("However, the antecedent of this implication ("),t("code",[e._v("R")]),e._v(") often serves the role of restricting (beyond just the type of "),t("code",[e._v("x")]),e._v(") the values of "),t("code",[e._v("x")]),e._v(" under consideration. In other words, "),t("code",[e._v("R")]),e._v(" tells you which values "),t("code",[e._v("x")]),e._v(" ranges over. In that light, you would read the quantifier above in one of the following ways:")]),e._v(" "),t("blockquote",[t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(" satisfying "),t("code",[e._v("R")]),e._v(", "),t("code",[e._v("P")]),e._v(" holds")]),e._v(" "),t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(" such that "),t("code",[e._v("R")]),e._v(" holds, "),t("code",[e._v("P")]),e._v('"')]),e._v(" "),t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(" (where "),t("code",[e._v("x")]),e._v(" satisfies "),t("code",[e._v("R")]),e._v("), "),t("code",[e._v("P")]),e._v(' holds"')]),e._v(" "),t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(" [insert your own descriptive phase for "),t("code",[e._v("R")]),e._v("], "),t("code",[e._v("P")]),e._v('"')])]),e._v(" "),t("p",[e._v("As a concrete instance of the last phrase, you may read "),t("code",[e._v("forall x :: x in S ==> x % 2 == 0")]),e._v(" as")]),e._v(" "),t("blockquote",[t("p",[e._v('"for all '),t("code",[e._v("x")]),e._v(" in "),t("code",[e._v("S")]),e._v(", "),t("code",[e._v("x")]),e._v(' is even"')])]),e._v(" "),t("p",[e._v("and you may read "),t("code",[e._v("forall i :: 0 <= i < a.Length ==> a[i] == 5")]),e._v(" as")]),e._v(" "),t("blockquote",[t("p",[e._v('"for every index '),t("code",[e._v("i")]),e._v(" of array "),t("code",[e._v("a")]),e._v(", "),t("code",[e._v("a")]),e._v("-sub-"),t("code",[e._v("i")]),e._v(" is "),t("code",[e._v("5")]),e._v('"')])]),e._v(" "),t("p",[e._v("In analogy to what I just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exists x :: R && P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("For example:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exists x :: x in S && x % 2 == 0\n\nexists i :: 0 <= i < a.Length && a[i] == 5\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("Again thinking of "),t("code",[e._v("R")]),e._v(" as telling you which values "),t("code",[e._v("x")]),e._v(" ranges over, you may read these existential quantifiers as")]),e._v(" "),t("blockquote",[t("p",[e._v('"there is an '),t("code",[e._v("x")]),e._v(" in "),t("code",[e._v("S")]),e._v(" for which "),t("code",[e._v("x % 2 == 0")]),e._v(' holds"')]),e._v(" "),t("p",[e._v('"there is an index '),t("code",[e._v("i")]),e._v(" into "),t("code",[e._v("a")]),e._v(" such that "),t("code",[e._v("a")]),e._v("-sub-"),t("code",[e._v("i")]),e._v(" is "),t("code",[e._v("5")]),e._v('"')])]),e._v(" "),t("p",[e._v("Following Why3 ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#boogie2011:why3",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),t("OutboundLink")],1),e._v("], Dafny issues a warning if you write "),t("code",[e._v("R ==> P")]),e._v(" as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). If this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exists x :: (R ==> P)\nexists x :: !R || P\nexists x :: P <== R\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h3",{attrs:{id:"range-predicates"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#range-predicates"}},[e._v("#")]),e._v(" Range predicates")]),e._v(" "),t("p",[e._v("Why did I just spend a page telling you ways to pronounce your quantifiers? Because that discussion spotlights the fact that the condition "),t("code",[e._v("R")]),e._v(", in either of")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: R ==> P\nexists x :: R && P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("plays a special role, even though "),t("code",[e._v("R")]),e._v(" is really just a part of the body of these quantifiers. In fact, others have adopted a notation for quantifier that feature a special place for this "),t("em",[e._v("range predicate")]),e._v(" "),t("code",[e._v("R")]),e._v(". Here are some examples:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th"),e._v(" "),t("th"),e._v(" "),t("th")])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("Universal quantifier")]),e._v(" "),t("td",[e._v("Existential quantifier")]),e._v(" "),t("td",[e._v("Source")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td")]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Dijkstra ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#dijkstra:discipline",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Chandy and Misra ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#chandymisra:book",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Gries and Schneider ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#griesschneider:proofs",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("\\forall X x; R; P")])]),e._v(" "),t("td",[t("code",[e._v("\\exists X x; R; P")])]),e._v(" "),t("td",[e._v("JML ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#leavensbakerruby99a",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td")])])]),e._v(" "),t("p",[e._v("(In the case of JML above, "),t("code",[e._v("X")]),e._v(" denotes the type of "),t("code",[e._v("x")]),e._v('.) In textbooks using these notations, it is often remarked that "for brevity, if '),t("code",[e._v("R")]),e._v(" is "),t("code",[e._v("true")]),e._v(' or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted". These shortened forms are:')]),e._v(" "),t("table",[t("thead",[t("tr",[t("th"),e._v(" "),t("th"),e._v(" "),t("th")])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("Range listed separately")]),e._v(" "),t("td",[e._v("Range "),t("code",[e._v("true")]),e._v(" or omitted")]),e._v(" "),t("td",[e._v("Source")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td")]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Dijkstra ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#dijkstra:discipline",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Chandy and Misra ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#chandymisra:book",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td",[e._v("Gries and Schneider ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#griesschneider:proofs",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("\\forall X x; R; P")])]),e._v(" "),t("td",[t("code",[e._v("\\forall X x;; P")])]),e._v(" "),t("td",[e._v("JML ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#leavensbakerruby99a",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),t("OutboundLink")],1),e._v("]")])]),e._v(" "),t("tr",[t("td"),e._v(" "),t("td"),e._v(" "),t("td")])])]),e._v(" "),t("p",[e._v("There's more. By using some notation that separates the "),t("code",[e._v("R")]),e._v(" from "),t("code",[e._v("P")]),e._v(", the De Morgan's Law for quantifiers looks especially nice:")]),e._v(" "),t("p",[e._v("Back to Dafny. If you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in Dafny, too. The syntax is:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x | R :: P\nexists x | R :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("h2",{attrs:{id:"_1-program-statements-for-quantifier-reasoning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-program-statements-for-quantifier-reasoning"}},[e._v("#")]),e._v(" 1. Program Statements for Quantifier Reasoning")]),e._v(" "),t("p",[e._v("Dafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. These have a syntax similar to those of quantifiers, but there are differences.")]),e._v(" "),t("h3",{attrs:{id:"aggregate-statements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aggregate-statements"}},[e._v("#")]),e._v(" Aggregate statements")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("forall")]),e._v(" statement in Dafny is an "),t("em",[e._v("aggregate statement")]),e._v(": it has the effect of performing a number of simultaneous operations. When used in proofs, the statement has the form:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x | R\n  ensures P\n{\n  S;\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("It is used to establish the property "),t("code",[e._v("forall x | R :: P")]),e._v(", that is, "),t("code",[e._v("forall x :: R ==> P")]),e._v(". It does so by checking that the statement "),t("code",[e._v("S")]),e._v(" establishes "),t("code",[e._v("P")]),e._v(" for any "),t("code",[e._v("x")]),e._v(" that satisfies "),t("code",[e._v("R")]),e._v(". In logic, the effect of this statement is called "),t("em",[e._v("universal introduction")]),e._v(".")]),e._v(" "),t("p",[e._v("As a simple example, suppose you have a lemma that proves "),t("code",[e._v("n <= Fib(n)")]),e._v(" for any "),t("code",[e._v("n")]),e._v(" at least "),t("code",[e._v("5")]),e._v(", where "),t("code",[e._v("Fib")]),e._v(" is the usual Fibonacci function:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n\nlemma FibProperty(n: nat)\n  requires 5 <= n\n  ensures n <= Fib(n)\n{\n  // some proof goes here\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br")])]),t("p",[e._v("This lemma gives you the property "),t("code",[e._v("n <= Fib(n)")]),e._v(" for a given "),t("code",[e._v("n")]),e._v(". But suppose you want to have this property in the universally quantified form. That is, you'd like to prove the following lemma:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("lemma FibPropertyAll()\n  ensures forall n :: 5 <= n ==> n <= Fib(n)\n{\n  // some proof to go here\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("How would we write this proof?"),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#fn-fn-fibpropertyall",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The answer is to call "),t("code",[e._v("FibProperty")]),e._v(" once for each "),t("code",[e._v("n")]),e._v(". All at once. For an infinite number of different values for "),t("code",[e._v("n")]),e._v(". That's what you do with the aggregate statement "),t("code",[e._v("forall")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall n | 5 <= n\n  ensures n <= Fib(n)\n{\n  FibProperty(n);\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("In general, the body of a "),t("code",[e._v("forall")]),e._v(" statement is more complicated than just one single lemma call. But for when the body "),t("em",[e._v("is")]),e._v(" just one lemma call or just one "),t("code",[e._v("calc")]),e._v(" statement, then Dafny infers the "),t("code",[e._v("ensures")]),e._v(" clause automatically, so you can omit it:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall n | 5 <= n {\n  FibProperty(n);\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h3",{attrs:{id:"existential-introduction-and-elimination"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#existential-introduction-and-elimination"}},[e._v("#")]),e._v(" Existential introduction and elimination")]),e._v(" "),t("p",[e._v("Working with existential quantifications also uses a repertoire of proof features. I will demonstrate these by writing a proof that shows Fibonacci numbers can be arbitrarily large:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("lemma EverBigger(k: nat)\n  ensures exists n :: k <= Fib(n)\n{\n  // proof to go here\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("Let's start the proof with some cases we can easily do, namely when "),t("code",[e._v("k")]),e._v(" is small, let's say "),t("code",[e._v("0")]),e._v(" or "),t("code",[e._v("1")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if k < 2 {\n  // simple case: proof for k being 0 or 1 goes here\n} else {\n  // difficult case: proof for larger k goes here\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("Dafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.")]),e._v(" "),t("p",[e._v("To prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular "),t("code",[e._v("n")]),e._v(" for which the existential quantifier holds. That is, we want to give a "),t("em",[e._v("witness")]),e._v(" to the existential quantifier. One such witness is "),t("code",[e._v("1")]),e._v(", since "),t("code",[e._v("k <= 1 == Fib(1)")]),e._v(". Another such witness is "),t("code",[e._v("12")]),e._v(", since "),t("code",[e._v("k <= 144 == Fib(12)")]),e._v(". Yet another such witness is "),t("code",[e._v("k")]),e._v(", since "),t("code",[e._v("k <= k == Fib(k)")]),e._v(" in our simple case. Let's go with this one, so we add an assertion to the “then” branch of the "),t("code",[e._v("if")]),e._v(" statement in the lemma body:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("assert k <= Fib(k);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Dafny will prove this assertion"),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#fn-fn-dual-rail-encoding",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),t("OutboundLink")],1),e._v(" and will then notice that "),t("code",[e._v("k")]),e._v(" is an existential witness that proves the postcondition. In logic, this is called "),t("em",[e._v("existential introduction")]),e._v(". All that means is that if you have a value that satisfies a particular property, then such a value exists. Stated different, if you have a value “in your hands”, then a value exists—this seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that "),t("em",[e._v("this")]),e._v(" is what you did for a living).")]),e._v(" "),t("p",[e._v("So what about the difficult case? We can prove it by induction, by first obtaining an "),t("code",[e._v("n")]),e._v(" whose Fibonacci value is at least "),t("code",[e._v("k-1")]),e._v(" and then building an even larger Fibonacci value from there. To start this off, we call the lemma recursively on "),t("code",[e._v("k-1")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("EverBigger(k-1);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("This lets us obtain the postcondition of "),t("code",[e._v("EverBigger(k-1)")]),e._v(". To write that down explicitly in our proof—to check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property is—we can write an assertion:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("assert exists n' :: k-1 <= Fib(n');\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Good so far. Next, we want to construct a Fibonacci number that is at least "),t("code",[e._v("1")]),e._v(" larger than "),t("code",[e._v("Fib(n')")]),e._v(", because that would complete the proof. But what is this "),t("code",[e._v("n'")]),e._v(" that i just mentioned? All the assertion above tells us that some such "),t("code",[e._v("n'")]),e._v(" exists. We'd like to have such an "),t("code",[e._v("n'")]),e._v(" “in our hands” so that we can work with it.")]),e._v(" "),t("p",[e._v("Going from something we know exists to something “in our hands” is called "),t("em",[e._v("Skolemization")]),e._v(" or "),t("em",[e._v("existential elimination")]),e._v(". You achieve it in Dafny by the "),t("em",[e._v("assign-such-that")]),e._v(" statement:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var m: nat :| k-1 <= Fib(m);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("This statement introduce a local variable "),t("code",[e._v("m")]),e._v(" and gives it some arbitrary value that satisfies "),t("code",[e._v("k-1 <= Fib(m)")]),e._v(". Of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an "),t("code",[e._v("m")]),e._v(" exists. This proof obligation follows from the property we asserted just above.")]),e._v(" "),t("p",[e._v("Almost there. All that remains of our plan to establish the lemma's postcondition is to construct a Fibonacci number strictly larger than "),t("code",[e._v("Fib(m)")]),e._v(". We observe that "),t("code",[e._v("Fib(m) + Fib(m+1)")]),e._v(" is strictly larger than "),t("code",[e._v("Fib(m)")]),e._v(", and thus we have that "),t("code",[e._v("Fib(m+2)")]),e._v(" is strictly larger than "),t("code",[e._v("Fib(m)")]),e._v(". Boom!")]),e._v(" "),t("p",[e._v("Okay, let's be frank. Maybe we didn't so much “observe” this as we did “wish” or “conjecture” or “loosely think” that it may hold. Well, it does hold. (Phew!) We can check that by asking the verifier if it can prove it for us:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("assert k <= Fib(m) + Fib(m + 1) == Fib(m + 2);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("The verifier immediately prove this assertion."),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#fn-fn-proof",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),t("OutboundLink")],1),e._v(" Moreover, by writing down this assertion, we are also showing the verifier the witness "),t("code",[e._v("m+2")]),e._v(", which proves the existential quantifier in the lemma's postcondition.")]),e._v(" "),t("p",[e._v("The point I set out to illustrate with this example is that you can Skolemize a quantifier")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exists x :: P\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("by the assign-such-that statement")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var x :| P;\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Notice the difference in punctuation.")]),e._v(" "),t("h3",{attrs:{id:"lemmas-with-out-parameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lemmas-with-out-parameters"}},[e._v("#")]),e._v(" Lemmas with out-parameters")]),e._v(" "),t("p",[e._v("I just showed you an example that involves existential quantifiers. The example showed that the "),t("em",[e._v("proof")]),e._v(" of the "),t("code",[e._v("EverBigger")]),e._v(" lemma used existential introduction twice ("),t("code",[e._v("Fib(k)")]),e._v(" in the simple case and "),t("code",[e._v("Fib(m+2)")]),e._v(" in the difficult case), thus converting the "),t("code",[e._v("k")]),e._v(" and the "),t("code",[e._v("m+2")]),e._v(" “in ours hands” into existential quantifications. The example also showed that the "),t("em",[e._v("invocation")]),e._v(" of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an "),t("code",[e._v("m")]),e._v(" “in our hands”. As impressive it is that Dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.")]),e._v(" "),t("p",[e._v("In mathematics, lemmas are parameterized by the variables they mention. These are like in-parameters. Rarely or never would a mathematical lemma be thought of as having out-parameters. In Dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. This can be quite useful. Instead of a lemma proving the "),t("em",[e._v("existence")]),e._v(" of some value, it may as well just "),t("em",[e._v("return")]),e._v(" some such value.")]),e._v(" "),t("p",[e._v("Here is the "),t("code",[e._v("EverBigger")]),e._v(" lemma from above, but with "),t("code",[e._v("n")]),e._v(" declared as an out-parameter:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("lemma EverBigger(k: nat) returns (n: nat)\n  ensures k <= Fib(n)\n{\n  if k < 2 {\n    n := k;\n  } else {\n    var m := EverBigger(k-1);\n    n := m + 2;\n  }\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br")])]),t("h3",{attrs:{id:"binding-guards"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#binding-guards"}},[e._v("#")]),e._v(" Binding guards")]),e._v(" "),t("p",[e._v("Dafny includes one other feature that makes working with quantifiers more streamlined: "),t("code",[e._v("if")]),e._v(" statements with "),t("em",[e._v("binding guards")]),e._v(". Such a statement answers the order “if there is one, gimmie one in my hand”.")]),e._v(" "),t("p",[e._v("Suppose we write a proof that splits into two cases according whether or not the value "),t("code",[e._v("y")]),e._v(" is a Fibonacci number. We could then write:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if exists n :: y == Fib(n) {\n  var n :| y == Fib(n);\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("p",[e._v("This expresses what we want, but feels a little clumsy, since we are repeating the condition "),t("code",[e._v("y == Fib(n)")]),e._v(". Instead using a binding guard, we can write this "),t("code",[e._v("if")]),e._v(" statement as")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if n :| y == Fib(n) {\n  // y is the nth Fibonacci number\n} else {\n  // y is not a Fibonacci number\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("The punctuation "),t("code",[e._v(":|")]),e._v(" is the same as in the assign-such-that statement, not the "),t("code",[e._v("::")]),e._v(" in the similar position of the existential quantifier.")]),e._v(" "),t("h2",{attrs:{id:"_2-sets-and-maps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-sets-and-maps"}},[e._v("#")]),e._v(" 2. Sets and Maps")]),e._v(" "),t("p",[e._v("Logical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. This is also the case with set comprehensions and map comprehensions.")]),e._v(" "),t("h3",{attrs:{id:"set-comprehensions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-comprehensions"}},[e._v("#")]),e._v(" Set comprehensions")]),e._v(" "),t("p",[e._v("It is easy to write down a set in Dafny. For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{ 2, 3, 5 }\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("is the set of the three smallest prime numbers. Such an expression, where the elements of the set are listed explicitly, is called a "),t("em",[e._v("set display")]),e._v(". But what if the set you want to define cannot be written as a set display?")]),e._v(" "),t("p",[e._v("A "),t("em",[e._v("set comprehension")]),e._v(" defines a set of elements in a schematic way. An example of a set comprehension in common mathematical notation is")]),e._v(" "),t("p",[e._v("which defines the set of the smallest 100 natural numbers. Another example is")]),e._v(" "),t("p",[e._v("which defines the 100 smallest perfect squares. The bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . Letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . That is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .")]),e._v(" "),t("p",[e._v("More generally, the mathematical notation takes some shape like . The reader is supposed to understand that is the bound variable. With the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :")]),e._v(" "),t("p",[e._v("Or, to use the notation where the existential's range is given separately:")]),e._v(" "),t("p",[e._v("In Dafny, the same set comprehension has the following form:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x | R :: f(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[t("code",[e._v("x")]),e._v(" is the bound variable (or, more generally, a list of bound variables), "),t("code",[e._v("R")]),e._v(" is the range predicate for the bound variables, and "),t("code",[e._v("f(x)")]),e._v(" is the "),t("em",[e._v("term expression")]),e._v(" of the set comprehension. The bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. The two example sets given above are written as follows in Dafny:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x | 0 <= x < 100 :: x\nset x | 0 <= x < 100 :: x*x\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("Although at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.")]),e._v(" "),t("p",[e._v("One nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("y in (set x | R :: f(x))   <==>   exists x | R :: y == f(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Another nicety is that one can easily list additional bound variables. Supposing that "),t("code",[e._v("R")]),e._v(" is a predicate over both "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("z")]),e._v(", then here are two examples:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x,n | Fib(n) <= x < Fib(n) + n :: f(x)\nset x,n | Fib(n) <= x < Fib(n) + n :: g(x,n)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("The first of these sets contains "),t("code",[e._v("f(x)")]),e._v(" for every "),t("code",[e._v("x")]),e._v(" that is within "),t("code",[e._v("n")]),e._v(" of "),t("code",[e._v("Fib(n)")]),e._v(" for some "),t("code",[e._v("n")]),e._v(". An equivalent way to write it in common mathematical notation is:")]),e._v(" "),t("p",[e._v("The second set contains "),t("code",[e._v("g(x,n)")]),e._v(" for every "),t("code",[e._v("x")]),e._v(" and "),t("code",[e._v("n")]),e._v(" such that "),t("code",[e._v("x")]),e._v(" is within "),t("code",[e._v("n")]),e._v(" of "),t("code",[e._v("Fib(n)")]),e._v(". Here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:")]),e._v(" "),t("p",[e._v("Dafny's general notation of making the bound variable explicit is also used by many authors (e.g., ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#dijkstra:discipline",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#griesschneider:proofs",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),t("OutboundLink")],1),e._v("]). It is also similar to the list-comprehension notation used in some other languages. For example, the Dafny set")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x,y | 0 <= x <= y <= 100 && x + y == 100 :: (x,y)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("which contains the pairs of natural numbers that sum to "),t("code",[e._v("100")]),e._v(", contains the same elements as the Python list:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("and the Haskell list:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[(x,y) | x <- [0..100], y <- [x..100], x + y = 100]\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("h3",{attrs:{id:"simplified-set-comprehensions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#simplified-set-comprehensions"}},[e._v("#")]),e._v(" Simplified set comprehensions")]),e._v(" "),t("p",[e._v("I just spent many words describing the general set-comprehension notation in Dafny. However, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. For example, as we have seen, the set of the smallest "),t("code",[e._v("100")]),e._v(" natural numbers is:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x | 0 <= x < 100 :: x\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("For this common case, Dafny lets you omit the term expression and simply write:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("set x | 0 <= x < 100\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("This expression looks like the common mathematical notation . Indeed, for these simplified set comprehensions, it is easy to “understand” what the mathematical notation intends to be the bound variables.")]),e._v(" "),t("p",[e._v("As a note about the verifier in Dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.")]),e._v(" "),t("h3",{attrs:{id:"map-comprehensions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-comprehensions"}},[e._v("#")]),e._v(" Map comprehensions")]),e._v(" "),t("p",[e._v("A "),t("em",[e._v("map")]),e._v(" is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). Like the display expressions for sets, a map can be defined by a "),t("em",[e._v("map display")]),e._v(". For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map[2 := 'c', 137 := 'a']\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("maps the integer "),t("code",[e._v("2")]),e._v(" to the character "),t("code",[e._v("'c'")]),e._v(" and maps the integer "),t("code",[e._v("137")]),e._v(" to the character "),t("code",[e._v("'a'")]),e._v(". Each pair like "),t("code",[e._v("2 := 'c'")]),e._v(" can be called a "),t("em",[e._v("maplet")]),e._v(". Also, the left-element of the maplet is called a "),t("em",[e._v("key")]),e._v(" and the right-element gets the nondescript name "),t("em",[e._v("value")]),e._v(".")]),e._v(" "),t("p",[e._v("Like the comprehensions for sets, a map can be defined by a "),t("em",[e._v("map comprehension")]),e._v(". It has the form:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | R :: f(x) := g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("For example,")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | 0 <= x < 100 :: x*x := x\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("is the map from each of the first "),t("code",[e._v("100")]),e._v(" perfect squares to their respective square roots.")]),e._v(" "),t("p",[e._v("If you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. Nevertheless, I will offer some notes and point out some features specific to maps.")]),e._v(" "),t("p",[e._v("One thing to note is that the maplets must have unique keys. For example, the verifier will complain if you try to write a map comprehension like")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | -10 <= x <= 10 :: x*x := x\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("because it says to map "),t("code",[e._v("4")]),e._v(" to both "),t("code",[e._v("2")]),e._v(" and "),t("code",[e._v("-2")]),e._v(", which is not functional.")]),e._v(" "),t("p",[e._v("The general map-comprehension expression is quite flexible. For example, suppose "),t("code",[e._v("m")]),e._v(" is a map from numbers to characters, and suppose we want to create a new map "),t("code",[e._v("n")]),e._v(" from a subset of the keys in "),t("code",[e._v("m")]),e._v(" to some other characters. More precisely, whenever a key in "),t("code",[e._v("m")]),e._v(" is in the image of a function "),t("code",[e._v("f")]),e._v(", say a key "),t("code",[e._v("f(x)")]),e._v(" for some "),t("code",[e._v("x")]),e._v(", then we want "),t("code",[e._v("n")]),e._v(" to map that key to "),t("code",[e._v("h(x)")]),e._v(". We then define "),t("code",[e._v("n")]),e._v(" as")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | f(x) in m.Keys :: f(x) := h(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Most of the time, however, the map comprehensions we tend to write have the form")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | R :: x := g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v('For these common maps, Dafny allows us to omit the "'),t("code",[e._v("x :=")]),e._v('" and write just')]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | R :: g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("Almost all map comprehensions in practice can be written in this simplified form. But for when the simplified form is not sufficient (like in the example above with the maplets "),t("code",[e._v("f(x) := h(x)")]),e._v("), the general form is available.")]),e._v(" "),t("h3",{attrs:{id:"lambda-expressions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lambda-expressions"}},[e._v("#")]),e._v(" Lambda expressions")]),e._v(" "),t("p",[e._v("Finally, a note about the difference between maps and functions. You may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. For comparison, let's consider writing the map")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map x | R :: g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("as a function.")]),e._v(" "),t("p",[e._v("Typically, a function is declared with a name. The map above is then written along the lines of")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function F(x: X): Y\n  requires R\n{\n  g(x)\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("A function can also be anonymous, in which case it is usually called a "),t("em",[e._v("lambda expression")]),e._v(". The example map is then written")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("x requires R => g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("h2",{attrs:{id:"_3-summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-summary"}},[e._v("#")]),e._v(" 3. Summary")]),e._v(" "),t("p",[e._v("Here is a listing of the syntactic forms discussed in this note:")]),e._v(" "),t("div",{staticClass:"language-dafnyx line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("forall x :: P\nforall x | R :: P\nforall x | R ensures P { S; }\nexists x :: P\nexists x | R :: P\nvar x :| P;\nif x :| P { S; }\nset x | R :: f(x)\nset x | R\nmap x | R :: f(x) := h(x)\nmap x | R :: g(x)\nfunction F(x: X): Y { g(x) }\nx requires R => g(x)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br")])]),t("h4",{attrs:{id:"acknowledgments"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgments"}},[e._v("#")]),e._v(" Acknowledgments")]),e._v(" "),t("p",[e._v("I'm grateful to Jay Lorch for many helpful comments on this note.")]),e._v(" "),t("h2",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("p",[e._v("[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, "),t("em",[e._v("Tests and Proofs — 8th International Conference, TAP 2014")]),e._v(", volume 8570 of "),t("em",[e._v("Lecture Notes in Computer Science")]),e._v(", pages 20–35. Springer, July 2014. "),t("a",{attrs:{href:"http://www.bing.com/search?q=Computing+with+solver++Nada+Amin+Rustan+Leino+Tiark+Rompf+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[1]François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich. Why3: Shepherd your herd of provers. In "),t("em",[e._v("Boogie 2011: First International Workshop on Intermediate Verification Languages")]),e._v(", pages 53–64, Wrocław, Poland, August 2011. "),t("a",{attrs:{href:"https://hal.inria.fr/hal-00790310",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://hal.inria.fr/hal-00790310"),t("OutboundLink")],1),e._v(". "),t("a",{attrs:{href:"http://www.bing.com/search?q=Fran+Bobot+Jean+Christophe+Filli+Claude+March+Andrei+Paskevich+Why3+Shepherd+your+herd+provers+_Boogie+First+International+Workshop+Intermediate+Verification+Languages_+pages+Wroc+Poland+August+https+inria++",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[2]K. Mani Chandy and Jayadev Misra. "),t("em",[e._v("Parallel Program Design: A Foundation")]),e._v(". Addison-Wesley, 1988. "),t("a",{attrs:{href:"http://www.bing.com/search?q=_Parallel+Program+Design+Foundation_+++Mani+Chandy+Jayadev+Misra+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[3]Edsger W. Dijkstra. "),t("em",[e._v("A Discipline of Programming")]),e._v(". Prentice Hall, Englewood Cliffs, NJ, 1976. "),t("a",{attrs:{href:"http://www.bing.com/search?q=+Discipline+Programming_++Edsger+Dijkstra+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[4]David Gries and Fred B. Schneider. "),t("em",[e._v("A Logical Approach to Discrete Math")]),e._v(". Texts and Monographs in Computer Science. Springer-Verlag, 1994. "),t("a",{attrs:{href:"http://www.bing.com/search?q=+Logical+Approach+Discrete+Math_++David+Gries+Fred+Schneider+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, "),t("em",[e._v("Behavioral Specifications of Businesses and Systems")]),e._v(", pages 175–188. Kluwer Academic Publishers, 1999. "),t("a",{attrs:{href:"http://www.bing.com/search?q=+notation+detailed+design++Gary+Leavens+Albert+Baker+Clyde+Ruby+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[6]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, "),t("em",[e._v("Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I")]),e._v(", volume 9779 of "),t("em",[e._v("Lecture Notes in Computer Science")]),e._v(", pages 361–381. Springer, 2016. "),t("a",{attrs:{href:"http://www.bing.com/search?q=Trigger+selection+strategies+stabilize+program+verifiers+++Rustan+Leino+ment+Claudel+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),t("OutboundLink")],1)]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("0.The Emacs IDE for Dafny typesets certain Dafny constructs in the notation you're more likely to see in a paper. By default, it shows "),t("code",[e._v("forall x :: P")]),e._v(" as and shows "),t("code",[e._v("exists x :: P")]),e._v(" as . "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#back-fn-fn-emacs",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("1.Internally, the Dafny verifier works more effectively with certain quantifiers. The verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#leinopit-claudel:cav2016",target:"_blank",rel:"noopener noreferrer"}},[e._v("6"),t("OutboundLink")],1),e._v("]. For example, it may choose to un-nest some quantifiers. The goal of such rewrites is to support natural-looking programs while getting good prover performance. "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#back-fn-fn-nested",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("2.As it turns out, Dafny's automatic induction will prove both "),t("code",[e._v("FibProperty")]),e._v(" and "),t("code",[e._v("FibPropertyAll")]),e._v(" automatically. If these were the only lemmas we cared about, there would be nothing else to say or do. Nevertheless, I'm using this example to show the "),t("code",[e._v("forall")]),e._v(" statement. If you want to make sure what I'm about to say gives a proof, you can turn off automatic induction for "),t("code",[e._v("FibPropertyAll")]),e._v(" by marking it with the attribute "),t("code",[e._v("{:induction false}")]),e._v(". "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#back-fn-fn-fibpropertyall",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("3.Dafny can also prove an assertion like "),t("code",[e._v("assert Fib(12) == 144;")]),e._v(". Internally, Dafny uses a “dual-rail encoding” of functions that lets it obtain the value of "),t("code",[e._v("Fib(12)")]),e._v(" (since "),t("code",[e._v("12")]),e._v(" is a literal constant) and "),t("code",[e._v("Fib(k)")]),e._v(" (where "),t("code",[e._v("k")]),e._v(" is a variable). If you're interested in how this is done, I refer you to ["),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#aminetal:computingwithsmt",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),t("OutboundLink")],1),e._v("]. "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#back-fn-fn-dual-rail-encoding",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("4.Here is a proof of the assertion "),t("code",[e._v("k <= Fib(m) + Fib(m+1)")]),e._v(". The “difficult case” in our proof applies when "),t("code",[e._v("k")]),e._v(" is at least "),t("code",[e._v("2")]),e._v(", so "),t("code",[e._v("k-1")]),e._v(" is at least "),t("code",[e._v("1")]),e._v(", so we know about "),t("code",[e._v("Fib(m)")]),e._v(" that it is at least "),t("code",[e._v("1")]),e._v(". From this, it follows that "),t("code",[e._v("m")]),e._v(" cannot be "),t("code",[e._v("0")]),e._v(", for "),t("code",[e._v("Fib(0) == 0")]),e._v(". This is important, because it means that "),t("code",[e._v("m+1")]),e._v(" is at least "),t("code",[e._v("2")]),e._v(" and therefore the inductive case of the definition of "),t("code",[e._v("Fib")]),e._v(" applies. In other words, we have "),t("code",[e._v("Fib(m+1) == Fib(m) + Fib(m-1)")]),e._v(". We already concluded that "),t("code",[e._v("Fib(m)")]),e._v(" is at least "),t("code",[e._v("1")]),e._v(". On behalf of "),t("code",[e._v("Fib")]),e._v(" returning a "),t("code",[e._v("nat")]),e._v(", we have that "),t("code",[e._v("Fib(m-1)")]),e._v(" is at least "),t("code",[e._v("0")]),e._v(". So, "),t("code",[e._v("Fib(m+1)")]),e._v(" is at least "),t("code",[e._v("1")]),e._v(". In other words, "),t("code",[e._v("Fib(m) + Fib(m+1)")]),e._v(" is at least "),t("code",[e._v("1")]),e._v(" more than "),t("code",[e._v("Fib(m)")]),e._v(", which in turn is at least "),t("code",[e._v("k-1")]),e._v(". Thus, "),t("code",[e._v("Fib(m) + Fib(m+1)")]),e._v(" is at least "),t("code",[e._v("k")]),e._v(".")]),e._v(" "),t("p",[e._v("Had we split the “simple case” and “difficult case” up so that the “simple case” only covered "),t("code",[e._v("k == 0")]),e._v(", then we could not have concluded "),t("code",[e._v("m != 0")]),e._v(" in the argument above. Some users of other interactive proof assistants may be bothered by this, because they would say "),t("code",[e._v("k")]),e._v(" has type "),t("code",[e._v("nat")]),e._v(" and therefore the induction on "),t("code",[e._v("k")]),e._v(" should use "),t("code",[e._v("k == 0")]),e._v(" as the base case. Mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of "),t("code",[e._v("EverBigger")]),e._v(" into "),t("code",[e._v("k < 2")]),e._v(" and "),t("code",[e._v("2 <= k")]),e._v(". "),t("a",{attrs:{href:"http://leino.science/papers/krml267.html#back-fn-fn-proof",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);