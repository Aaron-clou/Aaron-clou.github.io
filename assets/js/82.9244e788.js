(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{566:function(e,t,n){"use strict";n.r(t);var a=n(18),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Dafny Power User:\nShort-Circuit Operators")]),e._v(" "),n("p",[e._v("K. Rustan M. Leino")]),e._v(" "),n("p",[e._v("Manuscript KRML 268, 31 May 2019")]),e._v(" "),n("p",[n("strong",[e._v("Abstract.")]),e._v(" The boolean operators (“and”, “or”, …) in Dafny are short-circuiting. This means, for example, that you cannot reverse the operands of “and” and expect your program to be unchanged. This is well known to programmers. But if you write specifications in the same programming language, should you not be nervous that “and” no longer appears to be commutative?")]),e._v(" "),n("p",[e._v("This note points out that the difference lies not in the meaning of the operators, but rather in what expressions are legal in the first place.")]),e._v(" "),n("h2",{attrs:{id:"_0-the-well-definedness-rule"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_0-the-well-definedness-rule"}},[e._v("#")]),e._v(" 0. The Well-Definedness Rule")]),e._v(" "),n("p",[e._v("In Dafny, "),n("code",[e._v("a.Length")]),e._v(" gives the length of the array referenced by "),n("code",[e._v("a")]),e._v(" and "),n("code",[e._v("5/x")]),e._v(" gives the integer quotient of "),n("code",[e._v("5")]),e._v(" and "),n("code",[e._v("x")]),e._v(". But what if "),n("code",[e._v("a")]),e._v(" is "),n("code",[e._v("null")]),e._v(" or if "),n("code",[e._v("x")]),e._v(" is "),n("code",[e._v("0")]),e._v(", what do these expressions mean then? The Dafny verifier checks that you are "),n("em",[e._v("never")]),e._v(" in a situation where you have to rely on what these expressions evaluate to for such operand values. So, in a legal Dafny program, expressions are known to be defined. This allows the verifier to do meaningful reasoning and allows the compiler to assume the absence of run-time failures. I'll call this the "),n("em",[e._v("Well-Definedness Rule")]),e._v(".")]),e._v(" "),n("p",[e._v("To enforce the Well-Definedness Rule, the Dafny verifier checks that every expression you write down is "),n("em",[e._v("well-defined")]),e._v(" in every context where that expression could possibly be used. For example, the well-definedness of "),n("code",[e._v("a.Length")]),e._v(" is "),n("code",[e._v("a != null")]),e._v(" and the well-definedness of "),n("code",[e._v("5/x")]),e._v(" is "),n("code",[e._v("x != 0")]),e._v(".")]),e._v(" "),n("h2",{attrs:{id:"_1-short-circuiting"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-short-circuiting"}},[e._v("#")]),e._v(" 1. Short-circuiting")]),e._v(" "),n("p",[e._v("The boolean operators "),n("code",[e._v("&&")]),e._v(", "),n("code",[e._v("||")]),e._v(", "),n("code",[e._v("==>")]),e._v(", and "),n("code",[e._v("<==")]),e._v(" are "),n("em",[e._v("short-circuiting")]),e._v(" in Dafny. This notion is commonly described in terms of how an expression is evaluated at run time, namely: evaluation proceeds left-to-right (or right-to-left in the case of "),n("code",[e._v("<==")]),e._v("), but an operand is evaluated only if the operands evaluated so far do not already determine the value of the expression. In this way, if the first operand determines the value of the expression (as evaluating the first operand of "),n("code",[e._v("&&")]),e._v(" to "),n("code",[e._v("false")]),e._v(" does), then the evaluation of the second operand is omitted.")]),e._v(" "),n("p",[e._v("The meaning of the boolean operators are the same in Dafny as in logic.")]),e._v(" "),n("p",[e._v("Hold it! How can that be? Conjunction (“and”) in logic is symmetric (that is, "),n("code",[e._v("A && B")]),e._v(" is the same as "),n("code",[e._v("B && A")]),e._v(") and short-circuiting is inherently asymmetric. How can a short-circuiting operator have the same meaning as in logic? Here's how: Short-circuiting affects the well-definedness of expressions, not their meaning when defined.")]),e._v(" "),n("p",[e._v("So, I should have said: Expressions with boolean operators are not always defined in Dafny. But when they are defined, their meaning is the same in Dafny as in logic.")]),e._v(" "),n("h2",{attrs:{id:"_2-example-commutativity-of-and"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-example-commutativity-of-and"}},[e._v("#")]),e._v(" 2. Example: commutativity of and")]),e._v(" "),n("p",[e._v("In logic,")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("x != 0 && 5/x == 1\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("is the very same thing as")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("5/x == 1 && x != 0\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("This is also true in Dafny, but only in situations where these are well-defined.")]),e._v(" "),n("p",[n("code",[e._v("x != 0")]),e._v(" is always well-defined and "),n("code",[e._v("5/x == 1")]),e._v(" is well-defined when "),n("code",[e._v("x")]),e._v(" is non-"),n("code",[e._v("0")]),e._v(". That is, the well-definedness of "),n("code",[e._v("x != 0")]),e._v(" is "),n("code",[e._v("true")]),e._v(" and the well-definedness of "),n("code",[e._v("5/x == 1")]),e._v(" is "),n("code",[e._v("x != 0")]),e._v(".")]),e._v(" "),n("p",[e._v("Let me use "),n("code",[e._v("WDe")]),e._v(" to denote the well-definedness of an expression "),n("code",[e._v("e")]),e._v(". So, "),n("code",[e._v("WDx != 0")]),e._v(" is "),n("code",[e._v("true")]),e._v(" and "),n("code",[e._v("WD5/x == 1")]),e._v(" is "),n("code",[e._v("x != 0")]),e._v(".")]),e._v(" "),n("p",[e._v("For conjunction, we have that "),n("code",[e._v("WDe0 && e1")]),e._v(" is")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("WDe0 && (e0 ==> WDe1)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("That is, while the left argument has to be well-defined, the right argument only has to be well-defined when the left argument evaluates to "),n("code",[e._v("true")]),e._v(".")]),e._v(" "),n("p",[e._v("So, "),n("code",[e._v("WDx != 0 && 5/x == 1")]),e._v(" is")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("true && (x != 0 ==> x != 0)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("which simplifies to "),n("code",[e._v("true")]),e._v(". In contrast, "),n("code",[e._v("WD5/x == 1 && x != 0")]),e._v(" is")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("x != 0 && (5/x == 1 ==> true)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("which simplifies to "),n("code",[e._v("x != 0")]),e._v(".")]),e._v(" "),n("p",[e._v("Summarizing the example, conjunction in logic is symmetric. This is also true in Dafny, provided that both ways of writing the expression are well-defined. As the example shows, the first conjunction is always well-defined, whereas the other is well-defined only when "),n("code",[e._v("x != 0")]),e._v(". So, if you're in a situation where you don't know if "),n("code",[e._v("x != 0")]),e._v(" holds or not, you're better off writing the first of these conjunctions.")]),e._v(" "),n("h2",{attrs:{id:"_3-example-contrapositive"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-example-contrapositive"}},[e._v("#")]),e._v(" 3. Example: contrapositive")]),e._v(" "),n("p",[e._v("The "),n("em",[e._v("contrapositive")]),e._v(" of the implication "),n("code",[e._v("A ==> B")]),e._v(" is "),n("code",[e._v("!B ==> !A")]),e._v(", that is, the implication with the arguments reversed and negated. In logic, these two implications are equivalent. This is also true in Dafny, provided both expressions are defined.")]),e._v(" "),n("p",[e._v("As an example, consider the expression "),n("code",[e._v("a != null ==> a.Length > 0")]),e._v(". We have that "),n("code",[e._v("WDa != null ==> a.Length > 0")]),e._v(" is")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("true && (a != null ==> a != null)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("which simplifies to "),n("code",[e._v("true")]),e._v(". For the contrapositive of the implication, we have that "),n("code",[e._v("WDa.Length <= 0 ==> a == null")]),e._v(" is")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("a != null && (a.Length <= 0 ==> true)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("which simplifies to "),n("code",[e._v("a != null")]),e._v(".")]),e._v(" "),n("p",[e._v("In Dafny, we can only talk about the meaning of expressions if they are well-defined. As we just worked out, the first of these implications is always well-defined whereas the other is well-defined when "),n("code",[e._v("a != null")]),e._v(". So, in any context where "),n("code",[e._v("a != null")]),e._v(" is known to hold, the two implications have the same meaning and you can use them interchangeably. But if there's a possibility that "),n("code",[e._v("a != null")]),e._v(" might not hold, then the first implication is still defined (and thus you can start to talk about what value the expression will evaluate to), whereas the second implication is not well-defined (and thus is flagged as an error by the Dafny verifier).")]),e._v(" "),n("h2",{attrs:{id:"_4-symmetric-well-definedness"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-symmetric-well-definedness"}},[e._v("#")]),e._v(" 4. Symmetric well-definedness")]),e._v(" "),n("p",[e._v("As a final remark, well-definedness of boolean operands in Dafny is defined to match the notion of short-circuiting. This is well understood by programmers. Indeed, no programmer in their right mind would even think of ever writing")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("p.x < 1000 && p != null\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("but would write")]),e._v(" "),n("div",{staticClass:"language-dafnyx line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("p != null && p.x < 1000\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("As we have seen, this gives rise to an asymmetric definition of well-definedness. But this is not the only way to define well-definedness. For more information, see an article by Darvas, Mehta, and Rudich ["),n("a",{attrs:{href:"http://leino.science/papers/krml268.html#darvasmehtarudich:linearwellformedness",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),n("OutboundLink")],1),e._v("].")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("p",[e._v("[0]Ádám Darvas, Farhad Mehta, and Arsenii Rudich. Efficient well-definedness checking. In Alessandro Armando, Peter Baumgartner, and Gilles Dowek, editors, "),n("em",[e._v("Automated Reasoning, 4th International Joint Conference, IJCAR 2008")]),e._v(", volume 5195 of "),n("em",[e._v("Lecture Notes in Computer Science")]),e._v(", pages 100–115. Springer, 2008. "),n("a",{attrs:{href:"http://www.bing.com/search?q=Efficient+well+definedness+checking+++Darvas+Farhad+Mehta+Arsenii+Rudich+",target:"_blank",rel:"noopener noreferrer"}},[e._v("🔎"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);