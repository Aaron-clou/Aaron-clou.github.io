(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{556:function(e,t,a){"use strict";a.r(t);var s=a(18),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"types-in-dafny"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types-in-dafny"}},[e._v("#")]),e._v(" Types in Dafny")]),e._v(" "),a("p",[e._v("Manuscript KRML 243\n27 February 2015")]),e._v(" "),a("p",[e._v("K. Rustan M. Leinoleino@microsoft.com")]),e._v(" "),a("p",[e._v("This part of the Dafny language reference describes the types in the Dafny programming language. What is described is what is implemented in version 1.9.3.20107 of Dafny, with the exception of async-task types which have not yet made it into the main branch.")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-basic-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("0. Basic types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-booleans",target:"_blank",rel:"noopener noreferrer"}},[e._v("0.0. Booleans"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-numeric-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("0.1. Numeric types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-char",target:"_blank",rel:"noopener noreferrer"}},[e._v("0.2. Characters"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-type-parameters",target:"_blank",rel:"noopener noreferrer"}},[e._v("1. Type parameters"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-collection-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("2. Collection types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-sets",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.0. Sets"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-multisets",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1. Multisets"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-sequences",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2. Sequences"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-string",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2.0. Strings"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-finite-and-infinite-maps",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.3. Finite and Infinite Maps"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-types-that-stand-for-other-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("3. Types that stand for other types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-type-synonyms",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.0. Type synonyms"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-opaque-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.1. Opaque types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-datatypes",target:"_blank",rel:"noopener noreferrer"}},[e._v("4. Datatypes"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-inductive-datatypes",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.0. Inductive datatypes"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-tuple-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.1. Tuple types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-co-inductive-datatypes",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.2. Co-inductive datatypes"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-reference-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("5. Reference types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-classes",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.0. Classes"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-arrays",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.1. Arrays"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-one-dimensional-arrays",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.1.0. One-dimensional arrays"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-multi-dimensional-arrays",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.1.1. Multi-dimensional arrays"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-traits",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.2. Traits"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-type-object",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.3. Type "),a("code",[e._v("object")]),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-iterator-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.4. Iterator types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-async-task-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.5. Async-task types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-function-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("6. Function types"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-lambda-expressions",target:"_blank",rel:"noopener noreferrer"}},[e._v("6.0. Lambda expressions"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-newtypes",target:"_blank",rel:"noopener noreferrer"}},[e._v("7. Newtypes"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-numeric-conversions",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.0. Numeric conversion operations"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-subset-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("8. Subset types"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"_0-basic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-basic-types"}},[e._v("#")]),e._v(" 0. Basic types")]),e._v(" "),a("p",[e._v("Dafny offers three basic types, "),a("code",[e._v("bool")]),e._v(" for booleans, "),a("code",[e._v("int")]),e._v(" for integers, and "),a("code",[e._v("real")]),e._v(" for reals.")]),e._v(" "),a("h3",{attrs:{id:"_0-0-booleans"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-0-booleans"}},[e._v("#")]),e._v(" 0.0. Booleans")]),e._v(" "),a("p",[e._v("There are two boolean values and each has a corresponding literal in the language: "),a("code",[e._v("false")]),e._v(" and "),a("code",[e._v("true")]),e._v(".")]),e._v(" "),a("p",[e._v("In addition to equality ("),a("code",[e._v("==")]),e._v(") and disequality ("),a("code",[e._v("!=")]),e._v("), which are defined on all types, type "),a("code",[e._v("bool")]),e._v(" supports the following operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<==>")])]),e._v(" "),a("td",[e._v("equivalence (if and only if)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("==>")])]),e._v(" "),a("td",[e._v("implication (implies)")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<==")])]),e._v(" "),a("td",[e._v("reverse implication (follows from)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("&&")])]),e._v(" "),a("td",[e._v("conjunction (and)")])]),e._v(" "),a("tr",[a("td",[e._v("||")]),e._v(" "),a("td",[e._v("disjunction (or)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("!")])]),e._v(" "),a("td",[e._v("negation (not)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Negation is unary; the others are binary. The table shows the operators in groups of increasing binding power, with equality binding stronger than conjunction and disjunction, and weaker than negation. Within each group, different operators do not associate, so parentheses need to be used. For example,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A && B || C    // error\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("would be ambiguous and instead has to be written as either")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(A && B) || C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("or")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A && (B || C)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("depending on the intended meaning.")]),e._v(" "),a("p",[e._v("The expressions "),a("code",[e._v("A <==> B")]),e._v(" and "),a("code",[e._v("A == B")]),e._v(" give the same value, but note that "),a("code",[e._v("<==>")]),e._v(" is "),a("em",[e._v("associative")]),e._v(" whereas "),a("code",[e._v("==")]),e._v(" is "),a("em",[e._v("chaining")]),e._v(". So,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A <==> B <==> C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is the same as")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A <==> (B <==> C)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("and")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(A <==> B) <==> C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("whereas")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A == B == C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is simply a shorthand for")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A == B && B == C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Conjunction is associative and so is disjunction. These operators are are "),a("em",[e._v("short circuiting (from left to right)")]),e._v(", meaning that their second argument is evaluated only if the evaluation of the first operand does not determine the value of the expression. Logically speaking, the expression "),a("code",[e._v("A && B")]),e._v(" is defined when "),a("code",[e._v("A")]),e._v(" is defined and either "),a("code",[e._v("A")]),e._v(" evaluates to "),a("code",[e._v("false")]),e._v(" or "),a("code",[e._v("B")]),e._v(" is defined. When "),a("code",[e._v("A && B")]),e._v(" is defined, its meaning is the same as the ordinary, symmetric mathematical conjunction ∧. The same holds for "),a("code",[e._v("||")]),e._v(" and ∨.")]),e._v(" "),a("p",[e._v("Implication is "),a("em",[e._v("right associative")]),e._v(" and is short-circuiting from left to right. Reverse implication "),a("code",[e._v("B <== A")]),e._v(" is exactly the same as "),a("code",[e._v("A ==> B")]),e._v(", but gives the ability to write the operands in the opposite order. Consequently, reverse implication is "),a("em",[e._v("left associative")]),e._v(" and is short-circuiting from "),a("em",[e._v("right to left")]),e._v(". To illustrate the associativity rules, each of the following four lines expresses the same property, for any "),a("code",[e._v("A")]),e._v(", "),a("code",[e._v("B")]),e._v(", and "),a("code",[e._v("C")]),e._v(" of type "),a("code",[e._v("bool")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A ==> B ==> C\nA ==> (B ==> C)  // parentheses redundant, since ==> is right associative\nC <== B <== A\n(C <== B) <== A  // parentheses redundant, since <== is left associative\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("To illustrate the short-circuiting rules, note that the expression "),a("code",[e._v("a.Length")]),e._v(" is defined for an array "),a("code",[e._v("a")]),e._v(" only if "),a("code",[e._v("a")]),e._v(" is not "),a("code",[e._v("null")]),e._v(" (see Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-reference-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),a("OutboundLink")],1),e._v("), which means the following two expressions are well-formed:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("The contrapositive of these two expressions would be:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("but these expressions are not well-formed, since well-formedness requires the left (and right, respectively) operand, "),a("code",[e._v("a.Length < 0")]),e._v(", to be well-formed by itself.")]),e._v(" "),a("p",[e._v("Implication "),a("code",[e._v("A ==> B")]),e._v(" is equivalent to the disjunction "),a("code",[e._v("!A || B")]),e._v(", but is sometimes (especially in specifications) clearer to read. Since, "),a("code",[e._v("||")]),e._v(" is short-circuiting from left to right, note that")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a == null || 0 <= a.Length\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is well-formed, whereas")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("0 <= a.Length || a == null  // not well-formed\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is not.")]),e._v(" "),a("p",[e._v("In addition, booleans support "),a("em",[e._v("logical quantifiers")]),e._v(" (forall and exists), described in a different part of the Dafny language reference.")]),e._v(" "),a("h3",{attrs:{id:"_0-1-numeric-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-numeric-types"}},[e._v("#")]),e._v(" 0.1. Numeric types")]),e._v(" "),a("p",[e._v("Dafny supports "),a("em",[e._v("numeric types")]),e._v(" of two kinds, "),a("em",[e._v("integer-based")]),e._v(", which includes the basic type "),a("code",[e._v("int")]),e._v(" of all integers, and "),a("em",[e._v("real-based")]),e._v(", which includes the basic type "),a("code",[e._v("real")]),e._v(" of all real numbers. User-defined numeric types based on "),a("code",[e._v("int")]),e._v(" and "),a("code",[e._v("real")]),e._v(", called "),a("em",[e._v("newtypes")]),e._v(", are described in Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-newtypes",target:"_blank",rel:"noopener noreferrer"}},[e._v("7"),a("OutboundLink")],1),e._v(". Also, the "),a("em",[e._v("subset type")]),e._v(" "),a("code",[e._v("nat")]),e._v(", representing the non-negative subrange of "),a("code",[e._v("int")]),e._v(", is described in Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-subset-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("8"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("The language includes a literal for each non-negative integer, like "),a("code",[e._v("0")]),e._v(", "),a("code",[e._v("13")]),e._v(", and "),a("code",[e._v("1985")]),e._v(". Integers can also be written in hexadecimal using the prefix “"),a("code",[e._v("0x")]),e._v("”, as in "),a("code",[e._v("0x0")]),e._v(", "),a("code",[e._v("0xD")]),e._v(", and "),a("code",[e._v("0x7c1")]),e._v(" (always with a lower case "),a("code",[e._v("x")]),e._v(", but the hexadecimal digits themselves are case insensitive). Leading zeros are allowed. To form negative integers, use the unary minus operator.")]),e._v(" "),a("p",[e._v("There are also literals for some of the non-negative reals. These are written as a decimal point with a nonempty sequence of decimal digits on both sides. For example, "),a("code",[e._v("1.0")]),e._v(", "),a("code",[e._v("1609.344")]),e._v(", and "),a("code",[e._v("0.5772156649")]),e._v(".")]),e._v(" "),a("p",[e._v("For integers (in both decimal and hexidecimal form) and reals, any two digits in a literal may be separated by an underscore in order to improve human readability of the literals. For example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1_000_000        // easier to read than 1000000\n0_12_345_6789    // strange but legal formatting of 123456789\n0x8000_0000      // same as 0x80000000 -- hex digits are often placed in groups of 4\n0.000_000_000_1  // same as 0.0000000001 -- 1 Ångström\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("In addition to equality and disequality, numeric types support the following relational operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("<")]),e._v(" "),a("td",[e._v("less than")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<=")])]),e._v(" "),a("td",[e._v("at most")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">=")])]),e._v(" "),a("td",[e._v("at least")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">")])]),e._v(" "),a("td",[e._v("greater than")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Like equality and disequality, these operators are chaining, as long as they are chained in the “same direction”. That is,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A <= B < C == D <= E\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is simply a shorthand for")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A <= B && B < C && C == D && D <= E\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("whereas")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A < B > C\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is not allowed.")]),e._v(" "),a("p",[e._v("There are also operators on each numeric type:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("+")])]),e._v(" "),a("td",[e._v("addition (plus)")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("-")])]),e._v(" "),a("td",[e._v("subtraction (minus)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("*")])]),e._v(" "),a("td",[e._v("multiplication (times)")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("/")])]),e._v(" "),a("td",[e._v("division (divided by)")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("%")])]),e._v(" "),a("td",[e._v("modulus (mod)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("-")])]),e._v(" "),a("td",[e._v("negation (unary minus)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The binary operators are left associative, and they associate with each other in the two groups. The groups are listed in order of increasing binding power, with equality binding more strongly than the multiplicative operators and weaker than the unary operator. Modulus is supported only for integer-based numeric types. Integer division and modulus are the "),a("em",[e._v("Euclidean division and modulus")]),e._v(". This means that modulus always returns a non-negative, regardless of the signs of the two operands. More precisely, for any integer "),a("code",[e._v("a")]),e._v(" and non-zero integer "),a("code",[e._v("b")]),e._v(",")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a == a / b * b + a % b\n0 <= a % b < B\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("B")]),e._v(" denotes the absolute value of "),a("code",[e._v("b")]),e._v(".")]),e._v(" "),a("p",[e._v("Real-based numeric types have a member "),a("code",[e._v("Trunc")]),e._v(" that returns the "),a("em",[e._v("floor")]),e._v(" of the real value, that is, the largest integer not exceeding the real value. For example, the following properties hold, for any "),a("code",[e._v("r")]),e._v(" and "),a("code",[e._v("r'")]),e._v(" of type "),a("code",[e._v("real")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("3.14.Trunc == 3\n(-2.5).Trunc == -3\n-2.5.Trunc == -2\nreal(r.Trunc) <= r\nr <= r' ==> r.Trunc <= r'.Trunc\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("Note in the third line that member access (like "),a("code",[e._v(".Trunc")]),e._v(") binds stronger than unary minus. The fourth line uses the conversion function "),a("code",[e._v("real")]),e._v(" from "),a("code",[e._v("int")]),e._v(" to "),a("code",[e._v("real")]),e._v(", as described in Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-numeric-conversions",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.0"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_0-2-characters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-2-characters"}},[e._v("#")]),e._v(" 0.2. Characters")]),e._v(" "),a("p",[e._v("Dafny supports a type "),a("code",[e._v("char")]),e._v(" of "),a("em",[e._v("characters")]),e._v(". Character literals are enclosed in single quotes, as in "),a("code",[e._v("'D'")]),e._v(". To write a single quote as a character literal, it is necessary to use an "),a("em",[e._v("escape sequence")]),e._v(". Escape sequences can also be used to write other characters. The supported escape sequences are as follows:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("escape sequence")]),e._v(" "),a("td",[e._v("meaning")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\'")])]),e._v(" "),a("td",[e._v("the character "),a("code",[e._v("'")])])]),e._v(" "),a("tr",[a("td",[e._v('"')]),e._v(" "),a("td",[e._v('the character "')])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\\\")])]),e._v(" "),a("td",[e._v("the character "),a("code",[e._v("\\")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\0")])]),e._v(" "),a("td",[e._v("the null character, same as "),a("code",[e._v("\\u0000")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\n")])]),e._v(" "),a("td",[e._v("line feed")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\r")])]),e._v(" "),a("td",[e._v("carriage return")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\t")])]),e._v(" "),a("td",[e._v("horizontal tab")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\u*xxxx*")])]),e._v(" "),a("td",[e._v("universal character whose hexadecimal code is "),a("code",[e._v("*xxxx*")])])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The escape sequence for a double quote is redundant, because '\"' and '\"' denote the same character—both forms are provided in order to support the same escape sequences as for string literals (Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-string",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2.0"),a("OutboundLink")],1),e._v("). In the form "),a("code",[e._v("\\u*xxxx*")]),e._v(", the "),a("code",[e._v("u")]),e._v(" is always lower case, but the four hexadecimal digits are case insensitive.")]),e._v(" "),a("p",[e._v("Character values are ordered and can be compared using the standard relational operators:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("<")]),e._v(" "),a("td",[e._v("less than")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<=")])]),e._v(" "),a("td",[e._v("at most")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">=")])]),e._v(" "),a("td",[e._v("at least")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">")])]),e._v(" "),a("td",[e._v("greater than")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Sequences of characters represent "),a("em",[e._v("strings")]),e._v(", as described in Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-string",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2.0"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"_1-type-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-type-parameters"}},[e._v("#")]),e._v(" 1. Type parameters")]),e._v(" "),a("p",[e._v("Many of the types (as well as functions and methods) in Dafny can be parameterized by types. These "),a("em",[e._v("type parameters")]),e._v(" are typically declared inside angle brackets and can stand for any type. It is sometimes necessary to restrict these type parameters so that they can only be instantiated by certain families of types. As such, Dafny distinguishes types that support the equality operation not only in ghost contexts but also in compiled contexts. To indicate that a type parameter is restricted to such "),a("em",[e._v("equality supporting")]),e._v(" types, the name of the type parameter takes the suffix “"),a("code",[e._v("(==)")]),e._v("”."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-type-mode",target:"_blank",rel:"noopener noreferrer"}},[e._v("0"),a("OutboundLink")],1),e._v(" For example,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method Compare〈T(==)〉(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("is a method whose type parameter is restricted to equality-supporting types. Again, note that "),a("em",[e._v("all")]),e._v(" types support equality in "),a("em",[e._v("ghost")]),e._v(" contexts; the difference is only for non-ghost (that is, compiled) code. Co-inductive datatypes, function types, as well as inductive datatypes with ghost parameters are examples of types that are not equality supporting.")]),e._v(" "),a("p",[e._v("Dafny has some inference support that makes certain signatures less cluttered (described in a different part of the Dafny language reference). In some cases, this support will infer that a type parameter must be restricted to equality-supporting types, in which case Dafny adds the “"),a("code",[e._v("(==)")]),e._v("” automatically.")]),e._v(" "),a("h2",{attrs:{id:"_2-collection-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-collection-types"}},[e._v("#")]),e._v(" 2. Collection types")]),e._v(" "),a("p",[e._v("Dafny offers several built-in collection types.")]),e._v(" "),a("h3",{attrs:{id:"_2-0-sets"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-sets"}},[e._v("#")]),e._v(" 2.0. Sets")]),e._v(" "),a("p",[e._v("For any type "),a("code",[e._v("T")]),e._v(", each value of type "),a("code",[e._v("set〈T〉")]),e._v(" is a finite set of "),a("code",[e._v("T")]),e._v(" values. Set membership is determined by equality in the type "),a("code",[e._v("T")]),e._v(", so "),a("code",[e._v("set〈T〉")]),e._v(" can be used in a non-ghost context only if "),a("code",[e._v("T")]),e._v(" is equality supporting.")]),e._v(" "),a("p",[e._v("A set can be formed using a "),a("em",[e._v("set display")]),e._v(" expression, which is a possibly empty, unordered, duplicate-insensitive list of expressions enclosed in curly braces. To illustrate,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("are three examples of set displays. There is also a "),a("em",[e._v("set comprehension")]),e._v(" expression (with a binder, like in logical quantifications), described in a different part of the Dafny language reference.")]),e._v(" "),a("p",[e._v("In addition to equality and disequality, set types support the following relational operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("<")]),e._v(" "),a("td",[e._v("proper subset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<=")])]),e._v(" "),a("td",[e._v("subset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">=")])]),e._v(" "),a("td",[e._v("superset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">")])]),e._v(" "),a("td",[e._v("proper superset")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Like the arithmetic relational operators, these operators are chaining.")]),e._v(" "),a("p",[e._v("Sets support the following binary operators, listed in order of increasing binding power:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("!!")])]),e._v(" "),a("td",[e._v("disjointness")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("+")])]),e._v(" "),a("td",[e._v("set union")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("-")])]),e._v(" "),a("td",[e._v("set difference")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("*")])]),e._v(" "),a("td",[e._v("set intersection")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The associaivity rules of "),a("code",[e._v("+")]),e._v(", "),a("code",[e._v("-")]),e._v(", and "),a("code",[e._v("*")]),e._v(" are like those of the arithmetic operators with the same names. The expression "),a("code",[e._v("A !! B")]),e._v(", whose binding power is the same as equality (but which neither associates nor chains with equality), says that sets "),a("code",[e._v("A")]),e._v(" and "),a("code",[e._v("B")]),e._v(" have no elements in common, that is, it is equivalent to")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A * B == {}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("However, the disjointness operator is chaining, so "),a("code",[e._v("A !! B !! C !! D")]),e._v(" means:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("In addition, for any set "),a("code",[e._v("s")]),e._v(" of type "),a("code",[e._v("set〈T〉")]),e._v(" and any expression "),a("code",[e._v("e")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", sets support the following operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("expression")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("|s|")]),e._v(" "),a("td",[e._v("set cardinality")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e in s")])]),e._v(" "),a("td",[e._v("set membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e !in s")])]),e._v(" "),a("td",[e._v("set non-membership")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The expression "),a("code",[e._v("e !in s")]),e._v(" is a syntactic shorthand for "),a("code",[e._v("!(e in s)")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_2-1-multisets"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-multisets"}},[e._v("#")]),e._v(" 2.1. Multisets")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("multiset")]),e._v(" is similar to a set, but keeps track of the multiplicity of each element, not just its presence or absence. For any type "),a("code",[e._v("T")]),e._v(", each value of type "),a("code",[e._v("multiset〈T〉")]),e._v(" is a map from "),a("code",[e._v("T")]),e._v(" values to natural numbers denoting each element's multiplicity. Multisets in Dafny are finite, that is, they contain a finite number of each of a finite set of elements. Stated differently, a multiset maps only a finite number of elements to non-zero (finite) multiplicities.")]),e._v(" "),a("p",[e._v("Like sets, multiset membership is determined by equality in the type "),a("code",[e._v("T")]),e._v(", so "),a("code",[e._v("multiset〈T〉")]),e._v(" can be used in a non-ghost context only if "),a("code",[e._v("T")]),e._v(" is equality supporting.")]),e._v(" "),a("p",[e._v("A multiset can be formed using a "),a("em",[e._v("multiset display")]),e._v(" expression, which is a possibly empty, unordered list of expressions enclosed in curly braces after the keyword "),a("code",[e._v("multiset")]),e._v(". To illustrate,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("multiset{}    multiset{0, 1, 1, 2, 3, 5}    multiset{4+2, 1+5, a*b}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("are three examples of multiset displays. There is no multiset comprehension expression.")]),e._v(" "),a("p",[e._v("In addition to equality and disequality, multiset types support the following relational operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("<")]),e._v(" "),a("td",[e._v("proper multiset subset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<=")])]),e._v(" "),a("td",[e._v("multiset subset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">=")])]),e._v(" "),a("td",[e._v("multiset superset")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v(">")])]),e._v(" "),a("td",[e._v("proper multiset superset")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Like the arithmetic relational operators, these operators are chaining.")]),e._v(" "),a("p",[e._v("Multisets support the following binary operators, listed in order of increasing binding power:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("!!")])]),e._v(" "),a("td",[e._v("multiset disjointness")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("+")])]),e._v(" "),a("td",[e._v("multiset union")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("-")])]),e._v(" "),a("td",[e._v("multiset difference")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("*")])]),e._v(" "),a("td",[e._v("multiset intersection")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The associaivity rules of "),a("code",[e._v("+")]),e._v(", "),a("code",[e._v("-")]),e._v(", and "),a("code",[e._v("*")]),e._v(" are like those of the arithmetic operators with the same names. The expression "),a("code",[e._v("A !! B")]),e._v(" says that multisets "),a("code",[e._v("A")]),e._v(" and "),a("code",[e._v("B")]),e._v(" have no elements in common, that is, it is equivalent to")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("A * B == multiset{}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Like the analogous set operator, "),a("code",[e._v("!!")]),e._v(" is chaining.")]),e._v(" "),a("p",[e._v("In addition, for any multiset "),a("code",[e._v("s")]),e._v(" of type "),a("code",[e._v("multiset〈T〉")]),e._v(", expression "),a("code",[e._v("e")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", and non-negative integer-based numeric "),a("code",[e._v("n")]),e._v(", multisets support the following operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("expression")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("|s|")]),e._v(" "),a("td",[e._v("multiset cardinality")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e in s")])]),e._v(" "),a("td",[e._v("multiset membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e !in s")])]),e._v(" "),a("td",[e._v("multiset non-membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[e]")])]),e._v(" "),a("td",[e._v("multiplicity of "),a("code",[e._v("e")]),e._v(" in "),a("code",[e._v("s")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[e := n]")])]),e._v(" "),a("td",[e._v("multiset update (change of multiplicity)")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The expression "),a("code",[e._v("e in s")]),e._v(" returns "),a("code",[e._v("true")]),e._v(" if and only if "),a("code",[e._v("s[e] != 0")]),e._v(". The expression "),a("code",[e._v("e !in s")]),e._v(" is a syntactic shorthand for "),a("code",[e._v("!(e in s)")]),e._v(". The expression "),a("code",[e._v("s[e := n]")]),e._v(" denotes a multiset like "),a("code",[e._v("s")]),e._v(", but where the multiplicity of element "),a("code",[e._v("e")]),e._v(" is "),a("code",[e._v("n")]),e._v(". Note that the multiset update "),a("code",[e._v("s[e := 0]")]),e._v(" results in a multiset like "),a("code",[e._v("s")]),e._v(" but without any occurrences of "),a("code",[e._v("e")]),e._v(" (whether or not "),a("code",[e._v("s")]),e._v(" has occurrences of "),a("code",[e._v("e")]),e._v(" in the first place). As another example, note that "),a("code",[e._v("s - multiset{e}")]),e._v(" is equivalent to:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if e in s then s[e := s[e] - 1] else s\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_2-2-sequences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-sequences"}},[e._v("#")]),e._v(" 2.2. Sequences")]),e._v(" "),a("p",[e._v("For any type "),a("code",[e._v("T")]),e._v(", a value of type "),a("code",[e._v("seq〈T〉")]),e._v(" denotes a "),a("em",[e._v("sequence")]),e._v(" of "),a("code",[e._v("T")]),e._v(" elements, that is, a mapping from a finite set of consecutive natural numbers (called "),a("em",[e._v("indicies")]),e._v(") to "),a("code",[e._v("T")]),e._v(" values. (Thinking of it as a map, a sequence is therefore something of a dual of a multiset.)")]),e._v(" "),a("p",[e._v("A sequence can be formed using a "),a("em",[e._v("sequence display")]),e._v(" expression, which is a possibly empty, ordered list of expressions enclosed in square brackets. To illustrate,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("are three examples of sequence displays. There is no sequence comprehension expression.")]),e._v(" "),a("p",[e._v("In addition to equality and disequality, sequence types support the following relational operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("<")]),e._v(" "),a("td",[e._v("proper prefix")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("<=")])]),e._v(" "),a("td",[e._v("prefix")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Like the arithmetic relational operators, these operators are chaining. Note the absence of "),a("code",[e._v(">")]),e._v(" and "),a("code",[e._v(">=")]),e._v(".")]),e._v(" "),a("p",[e._v("Sequences support the following binary operator:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("operator")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("+")])]),e._v(" "),a("td",[e._v("concatenation")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Operator "),a("code",[e._v("+")]),e._v(" is associative, like the arithmetic operator with the same name.")]),e._v(" "),a("p",[e._v("In addition, for any sequence "),a("code",[e._v("s")]),e._v(" of type "),a("code",[e._v("seq〈T〉")]),e._v(", expression "),a("code",[e._v("e")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", integer-based numeric "),a("code",[e._v("i")]),e._v(" satisfying "),a("code",[e._v("0 <= i < |s|")]),e._v(", and integer-based numerics "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" satisfying "),a("code",[e._v("0 <= lo <= hi <= |s|")]),e._v(", sequences support the following operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("expression")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("|s|")]),e._v(" "),a("td",[e._v("sequence length")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[i]")])]),e._v(" "),a("td",[e._v("sequence selection")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[i := e]")])]),e._v(" "),a("td",[e._v("sequence update")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e in s")])]),e._v(" "),a("td",[e._v("sequence membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("e !in s")])]),e._v(" "),a("td",[e._v("sequence non-membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[lo..hi]")])]),e._v(" "),a("td",[e._v("subsequence")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[lo..]")])]),e._v(" "),a("td",[e._v("drop")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[..hi]")])]),e._v(" "),a("td",[e._v("take")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("s[*slices*]")])]),e._v(" "),a("td",[e._v("slice")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("multiset(s)")])]),e._v(" "),a("td",[e._v("sequence conversion to a "),a("code",[e._v("multiset〈T〉")])])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("Expression "),a("code",[e._v("s[i := e]")]),e._v(" returns a sequence like "),a("code",[e._v("s")]),e._v(", except that the element at index "),a("code",[e._v("i")]),e._v(" is "),a("code",[e._v("e")]),e._v(". The expression "),a("code",[e._v("e in s")]),e._v(" says there exists an index "),a("code",[e._v("i")]),e._v(" such that "),a("code",[e._v("s[i] == e")]),e._v(". It is allowed in non-ghost contexts only if the element type "),a("code",[e._v("T")]),e._v(" is equality supporting. The expression "),a("code",[e._v("e !in s")]),e._v(" is a syntactic shorthand for "),a("code",[e._v("!(e in s)")]),e._v(".")]),e._v(" "),a("p",[e._v("Expression "),a("code",[e._v("s[lo..hi]")]),e._v(" yields a sequence formed by taking the first "),a("code",[e._v("hi")]),e._v(" elements and then dropping the first "),a("code",[e._v("lo")]),e._v(" elements. The resulting sequence thus has length "),a("code",[e._v("hi - lo")]),e._v(". Note that "),a("code",[e._v("s[0..|s|]")]),e._v(" equals "),a("code",[e._v("s")]),e._v(". If the upper bound is omitted, it defaults to "),a("code",[e._v("|s|")]),e._v(", so "),a("code",[e._v("s[lo..]")]),e._v(" yields the sequence formed by dropping the first "),a("code",[e._v("lo")]),e._v(" elements of "),a("code",[e._v("s")]),e._v(". If the lower bound is omitted, it defaults to "),a("code",[e._v("0")]),e._v(", so "),a("code",[e._v("s[..hi]")]),e._v(" yields the sequence formed by taking the first "),a("code",[e._v("hi")]),e._v(" elements of "),a("code",[e._v("s")]),e._v(".")]),e._v(" "),a("p",[e._v("In the sequence slice operation, "),a("code",[e._v("*slices*")]),e._v(" is a nonempty list of length designators separated and optionally terminated by a colon, and there is at least one colon. Each length designator is a non-negative integer-based numeric, whose sum is no greater than "),a("code",[e._v("|s|")]),e._v(". If there are "),a("em",[e._v("k")]),e._v(" colons, the operation produces "),a("em",[e._v("k")]),e._v(" consecutive subsequences from "),a("code",[e._v("s")]),e._v(", each of the length indicated by the corresponding length designator, and returns these as a sequence of sequences."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-slice-into-tuple",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),a("OutboundLink")],1),e._v(" If "),a("code",[e._v("*slices*")]),e._v(" is terminated by a colon, then the length of the last slice extends until the end of "),a("code",[e._v("s")]),e._v(", that is, its length is "),a("code",[e._v("|s|")]),e._v(" minus the sum of the given length designators. For example, the following equalities hold, for any sequence "),a("code",[e._v("s")]),e._v(" of length at least "),a("code",[e._v("10")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\nassert |t| == 3 && t[0] == [3.14] && t[1] == [];\nassert t[2] == [2.7, 1.41, 1985.44];\nvar u := [true, false, false, true][1:1:];\nassert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\nassert s[10:][0] == s[..10];\nassert s[10:][1] == s[10..];\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("The operation "),a("code",[e._v("multiset(s)")]),e._v(" yields the multiset of elements of sequence "),a("code",[e._v("s")]),e._v(". It is allowed in non-ghost contexts only if the element type "),a("code",[e._v("T")]),e._v(" is equality supporting.")]),e._v(" "),a("h4",{attrs:{id:"_2-2-0-strings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-0-strings"}},[e._v("#")]),e._v(" 2.2.0. Strings")]),e._v(" "),a("p",[e._v("A special case of a sequence type is "),a("code",[e._v("seq〈char〉")]),e._v(", for which Dafny provides a synonym: "),a("code",[e._v("string")]),e._v(". Strings are like other sequences, but provide additional syntax for sequence display expressions, namely "),a("em",[e._v("string literals")]),e._v(". There are two forms of the syntax for string literals: the "),a("em",[e._v("standard form")]),e._v(" and the "),a("em",[e._v("verbatim form")]),e._v(".")]),e._v(" "),a("p",[e._v("String literals of the standard form are enclosed in double quotes, as in "),a("code",[e._v('"Dafny"')]),e._v(". To include a double quote in such a string literal, it is necessary to use an escape sequence. Escape sequences can also be used to include other characters. The supported escape sequences are the same as those for character literals, see Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-char",target:"_blank",rel:"noopener noreferrer"}},[e._v("0.2"),a("OutboundLink")],1),e._v(". For example, the Dafny expression "),a("code",[e._v('"say \\"yes\\""')]),e._v(' represents the string say "yes". The escape sequence for a single quote is redundant, because "\'" and "\'" denote the same string—both forms are provided in order to support the same escape sequences as for character literals.')]),e._v(" "),a("p",[e._v('String literals of the verbatim form are bracketed by @" and ", as in '),a("code",[e._v('@"Dafny"')]),e._v('. To include a double quote in such a string literal, it is necessary to use the escape sequence "", that is, to write the character twice. In the verbatim form, there are no other escape sequences. Even characters like newline can be written inside the string literal (hence spanning more than one line in the program text).')]),e._v(" "),a("p",[e._v("For example, the following three expressions denote the same string:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("Since strings are sequences, the relational operators < and "),a("code",[e._v("<=")]),e._v(" are defined on them. Note, however, that these operators still denote proper prefix and prefix, respectively, not some kind of alphabetic comparison as might be desireable, for example, when sorting strings.")]),e._v(" "),a("h3",{attrs:{id:"_2-3-finite-and-infinite-maps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-finite-and-infinite-maps"}},[e._v("#")]),e._v(" 2.3. Finite and Infinite Maps")]),e._v(" "),a("p",[e._v("For any types "),a("code",[e._v("T")]),e._v(" and "),a("code",[e._v("U")]),e._v(", a value of type "),a("code",[e._v("map〈T,U〉")]),e._v(" denotes a "),a("em",[e._v("(finite) map")]),e._v(" from "),a("code",[e._v("T")]),e._v(" to "),a("code",[e._v("U")]),e._v(". In other words, it is a look-up table indexed by "),a("code",[e._v("T")]),e._v(". The "),a("em",[e._v("domain")]),e._v(" of the map is a finite set of "),a("code",[e._v("T")]),e._v(" values that have associated "),a("code",[e._v("U")]),e._v(" values. Since the keys in the domain are compared using equality in the type "),a("code",[e._v("T")]),e._v(", type "),a("code",[e._v("map〈T,U〉")]),e._v(" can be used in a non-ghost context only if "),a("code",[e._v("T")]),e._v(" is equality supporting.")]),e._v(" "),a("p",[e._v("Similarly, for any types "),a("code",[e._v("T")]),e._v(" and "),a("code",[e._v("U")]),e._v(", a value of type "),a("code",[e._v("imap〈T,U〉")]),e._v(" denotes a "),a("em",[e._v("(possibly) infinite map")]),e._v(". In most regards, "),a("code",[e._v("imap〈T,U〉")]),e._v(" is like "),a("code",[e._v("map〈T,U〉")]),e._v(", but a map of type "),a("code",[e._v("imap〈T,U〉")]),e._v(" is allowed to have an infinite domain.")]),e._v(" "),a("p",[e._v("A map can be formed using a "),a("em",[e._v("map display")]),e._v(" expression, which is a possibly empty, ordered list of "),a("em",[e._v("maplets")]),e._v(", each maplet having the form "),a("code",[e._v("t := u")]),e._v(" where "),a("code",[e._v("t")]),e._v(" is an expression of type "),a("code",[e._v("T")]),e._v(" and "),a("code",[e._v("u")]),e._v(" is an expression of type "),a("code",[e._v("U")]),e._v(", enclosed in square brackets after the keyword "),a("code",[e._v("map")]),e._v(". To illustrate,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("map[]    map[20 := true, 3 := false, 20 := false]    map[a+b := c+d]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("are three examples of map displays. By using the keyword "),a("code",[e._v("imap")]),e._v(" instead of "),a("code",[e._v("map")]),e._v(", the map produced will be of type "),a("code",[e._v("imap〈T,U〉")]),e._v(" instead of "),a("code",[e._v("map〈T,U〉")]),e._v(". Note that an infinite map ("),a("code",[e._v("imap")]),e._v(") is allowed to have a finite domain, whereas a finite map ("),a("code",[e._v("map")]),e._v(") is not allowed to have an infinite domain. If the same key occurs more than once, only the last occurrence appears in the resulting map."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-map-display",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),a("OutboundLink")],1),e._v(" There is also a "),a("em",[e._v("map comprehension expression")]),e._v(", explained in a different part of the Dafny language reference.")]),e._v(" "),a("p",[e._v("For any map "),a("code",[e._v("fm")]),e._v(" of type "),a("code",[e._v("map〈T,U〉")]),e._v(", any map "),a("code",[e._v("m")]),e._v(" of type "),a("code",[e._v("map〈T,U〉")]),e._v(" or "),a("code",[e._v("imap〈T,U〉")]),e._v(", any expression "),a("code",[e._v("t")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", any expression "),a("code",[e._v("u")]),e._v(" of type "),a("code",[e._v("U")]),e._v(", and any "),a("code",[e._v("d")]),e._v(" in the domain of "),a("code",[e._v("m")]),e._v(" (that is, satisfying "),a("code",[e._v("d in m")]),e._v("), maps support the following operations:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("expression")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("|fm|")]),e._v(" "),a("td",[e._v("map cardinality")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("m[d]")])]),e._v(" "),a("td",[e._v("map selection")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("m[t := u]")])]),e._v(" "),a("td",[e._v("map update")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("t in m")])]),e._v(" "),a("td",[e._v("map domain membership")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("t !in m")])]),e._v(" "),a("td",[e._v("map domain non-membership")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[a("code",[e._v("|fm|")]),e._v(" denotes the number of mappings in "),a("code",[e._v("fm")]),e._v(", that is, the cardinality of the domain of "),a("code",[e._v("fm")]),e._v(". Note that the cardinality operator is not supported for infinite maps. Expression "),a("code",[e._v("m[d]")]),e._v(" returns the "),a("code",[e._v("U")]),e._v(" value that "),a("code",[e._v("m")]),e._v(" associates with "),a("code",[e._v("d")]),e._v(". Expression "),a("code",[e._v("m[t := u]")]),e._v(" is a map like "),a("code",[e._v("m")]),e._v(", except that the element at key "),a("code",[e._v("t")]),e._v(" is "),a("code",[e._v("u")]),e._v(". The expression "),a("code",[e._v("t in m")]),e._v(" says "),a("code",[e._v("t")]),e._v(" is in the domain of "),a("code",[e._v("m")]),e._v(" and "),a("code",[e._v("t !in m")]),e._v(" is a syntactic shorthand for "),a("code",[e._v("!(t in m)")]),e._v("."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-map-membership",target:"_blank",rel:"noopener noreferrer"}},[e._v("3"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Here is a small example, where a map "),a("code",[e._v("cache")]),e._v(" of type "),a("code",[e._v("map〈int,real〉")]),e._v(" is used to cache computed values of Joule-Thomson coefficients for some fixed gas at a given temperature:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJouleThomsonCoefficient(K);  // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h2",{attrs:{id:"_3-types-that-stand-for-other-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-types-that-stand-for-other-types"}},[e._v("#")]),e._v(" 3. Types that stand for other types")]),e._v(" "),a("p",[e._v("It is sometimes useful to know a type by several names or to treat a type abstractly.")]),e._v(" "),a("h3",{attrs:{id:"_3-0-type-synonyms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-type-synonyms"}},[e._v("#")]),e._v(" 3.0. Type synonyms")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("type synonym")]),e._v(" declaration:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Y〈T〉 = G\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("declares "),a("code",[e._v("Y〈T〉")]),e._v(" to be a synonym for the type "),a("code",[e._v("G")]),e._v(". Here, "),a("code",[e._v("T")]),e._v(" is a nonempty list of type parameters (each of which is optionally designated with the suffix “"),a("code",[e._v("(==)")]),e._v("”), which can be used as free type variables in "),a("code",[e._v("G")]),e._v(". If the synonym has no type parameters, the “"),a("code",[e._v("〈T〉")]),e._v("” is dropped. In all cases, a type synonym is just a synonym. That is, there is never a difference, other than possibly in error messages produced, between "),a("code",[e._v("Y〈T〉")]),e._v(" and "),a("code",[e._v("G")]),e._v(".")]),e._v(" "),a("p",[e._v("For example, the names of the following type synonyms may improve the readability of a program:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Replacements〈T〉 = map〈T,T〉\ntype Vertex = int\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("As already described in Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-string",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.2.0"),a("OutboundLink")],1),e._v(", "),a("code",[e._v("string")]),e._v(" is a built-in type synonym for "),a("code",[e._v("seq〈char〉")]),e._v(", as if it would have been declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type string = seq〈char〉\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_3-1-opaque-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-opaque-types"}},[e._v("#")]),e._v(" 3.1. Opaque types")]),e._v(" "),a("p",[e._v("A special case of a type synonym is one that is underspecified. Such a type is declared simply by:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Y〈T〉\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("It is a known as an "),a("em",[e._v("opaque type")]),e._v(". Its definition can be revealed in a refining module. To indicate that "),a("code",[e._v("Y")]),e._v(" designates an equality-supporting type, “"),a("code",[e._v("(==)")]),e._v("” can be written immediately following the name “"),a("code",[e._v("Y")]),e._v("”.")]),e._v(" "),a("p",[e._v("For example, the declarations")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type T\nfunction F(t: T): T\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("can be used to model an uninterpreted function "),a("code",[e._v("F")]),e._v(" on some arbitrary type "),a("code",[e._v("T")]),e._v(". As another example,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Monad〈T〉\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("can be used abstractly to represent an arbitrary parameterized monad.")]),e._v(" "),a("h2",{attrs:{id:"_4-datatypes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-datatypes"}},[e._v("#")]),e._v(" 4. Datatypes")]),e._v(" "),a("p",[e._v("Dafny offers two kinds of algebraic datatypes, those defined inductively and those defined co-inductively. The salient property of every datatype is that each value of the type uniquely identifies one of the datatype's constructors and each constructor is injective in its parameters.")]),e._v(" "),a("h3",{attrs:{id:"_4-0-inductive-datatypes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-inductive-datatypes"}},[e._v("#")]),e._v(" 4.0. Inductive datatypes")]),e._v(" "),a("p",[e._v("The values of inductive datatypes can be seen as finite trees where the leaves are values of basic types, numeric types, reference types, co-inductive datatypes, or function types. Indeed, values of inductive datatypes can be compared using Dafny's well-founded < ordering.")]),e._v(" "),a("p",[e._v("An inductive datatype is declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("datatype D〈T〉 = Ctors\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("*Ctors*")]),e._v(" is a nonempty "),a("code",[e._v("|")]),e._v("-separated list of "),a("em",[e._v("(datatype) constructors")]),e._v(" for the datatype. Each constructor has the form:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("C(params)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("*params*")]),e._v(" is a comma-delimited list of types, optionally preceded by a name for the parameter and a colon, and optionally preceded by the keyword "),a("code",[e._v("ghost")]),e._v(". If a constructor has no parameters, the parentheses after the constructor name can be omitted. If no constructor takes a parameter, the type is usually called an "),a("em",[e._v("enumeration")]),e._v("; for example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("datatype Friends = Agnes | Agatha | Jermaine | Jack\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("For every constructor "),a("code",[e._v("C")]),e._v(", Dafny defines a "),a("em",[e._v("discriminator")]),e._v(" "),a("code",[e._v("C?")]),e._v(", which is a member that returns "),a("code",[e._v("true")]),e._v(" if and only if the datatype value has been constructed using "),a("code",[e._v("C")]),e._v(". For every named parameter "),a("code",[e._v("p")]),e._v(" of a constructor "),a("code",[e._v("C")]),e._v(", Dafny defines a "),a("em",[e._v("destructor")]),e._v(" "),a("code",[e._v("p")]),e._v(", which is a member that returns the "),a("code",[e._v("p")]),e._v(" parameter from the "),a("code",[e._v("C")]),e._v(" call used to construct the datatype value; its use requires that "),a("code",[e._v("C?")]),e._v(" holds. For example, for the standard "),a("code",[e._v("List")]),e._v(" type")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("datatype List〈T〉 = Nil | Cons(head: T, tail: List〈T〉)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("the following holds:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Cons(5, Nil).Cons? && Cons(5, Nil).head == 5\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Note that the expression")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Cons(5, Nil).tail.head\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is not well-formed, since "),a("code",[e._v("Cons(5, Nil).tail")]),e._v(" does not satisfy "),a("code",[e._v("Cons?")]),e._v(".")]),e._v(" "),a("p",[e._v("The names of the destructors must be unique across all the constructors of the datatype. A constructor can have the same name as the enclosing datatype; this is especially useful for single-constructor datatypes, which are often called "),a("em",[e._v("record types")]),e._v(". For example, a record type for black-and-white pixels might be represented as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("datatype Pixel = Pixel(x: int, y: int, on: bool)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("To call a constructor, it is usually necessary only to mention the name of the constructor, but if this is ambiguous, it is always possible to qualify the name of constructor by the name of the datatype. For example, "),a("code",[e._v("Cons(5, Nil)")]),e._v(" above can be written")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("List.Cons(5, List.Nil)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("As an alternative to calling a datatype constructor explicitly, a datatype value can be constructed as a change in one parameter from a given datatype value using the "),a("em",[e._v("datatype update")]),e._v(" expression. For any "),a("code",[e._v("d")]),e._v(" whose type is a datatype that includes a constructor "),a("code",[e._v("C")]),e._v(" that has a parameter (destructor) named "),a("code",[e._v("f")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", and any expression "),a("code",[e._v("t")]),e._v(" of type "),a("code",[e._v("T")]),e._v(",")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("d[f := t]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("constructs a value like "),a("code",[e._v("d")]),e._v(" but whose "),a("code",[e._v("f")]),e._v(" parameter is "),a("code",[e._v("t")]),e._v(". The operation requires that "),a("code",[e._v("d")]),e._v(" satisfies "),a("code",[e._v("C?")]),e._v(". For example, the following equality holds:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Cons(4, Nil)[tail := Cons(3, Nil)] == Cons(4, Cons(3, Nil))\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_4-1-tuple-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-tuple-types"}},[e._v("#")]),e._v(" 4.1. Tuple types")]),e._v(" "),a("p",[e._v("Dafny builds in record types that correspond to tuples and gives these a convenient special syntax, namely parentheses. For example, what might have been declared as:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("datatype Pair〈T,U〉 = Pair(0: T, 1: U)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Dafny provides as the type "),a("code",[e._v("(T, U)")]),e._v(" and the constructor "),a("code",[e._v("(t, u)")]),e._v(", as if the datatype's name were “” and its type arguments are given in round parentheses, and as if the constructor name were “”. Note that the destructor names are "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("1")]),e._v(", which are legal identifier names for members. For example, showing the use of a tuple destructor, here is a property that holds of 2-tuples (that is, "),a("em",[e._v("pairs")]),e._v("):")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(5, true).1 == true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Dafny declares "),a("em",[e._v("n")]),e._v("-tuples where "),a("em",[e._v("n")]),e._v(" is 0 or 2 or up. There are no 1-tuples, since parentheses around a single type or a single value have no semantic meaning. The 0-tuple type, "),a("code",[e._v("()")]),e._v(", is often known as the "),a("em",[e._v("unit type")]),e._v(" and its single value, also written "),a("code",[e._v("()")]),e._v(", is known as "),a("em",[e._v("unit")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_4-2-co-inductive-datatypes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-co-inductive-datatypes"}},[e._v("#")]),e._v(" 4.2. Co-inductive datatypes")]),e._v(" "),a("p",[e._v("Whereas Dafny insists that there is a way to construct every inductive datatype value from the ground up, Dafny also supports "),a("em",[e._v("co-inductive datatypes")]),e._v(", whose constructors are evaluated lazily and hence allows infinite structures. A co-inductive datatype is declared using the keyword "),a("code",[e._v("codatatype")]),e._v("; other than that, it is declared and used like an inductive datatype.")]),e._v(" "),a("p",[e._v("For example,")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("codatatype IList〈T〉 = Nil | Cons(head: T, tail: IList〈T〉)\ncodatatype Stream〈T〉 = More(head: T, tail: Stream〈T〉)\ncodatatype Tree〈T〉 = Node(left: Tree〈T〉, value: T, right: Tree〈T〉)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("declare possibly infinite lists (that is, lists that can be either finite or infinite), infinite streams (that is, lists that are always infinite), and infinite binary trees (that is, trees where every branch goes on forever), respectively.")]),e._v(" "),a("h2",{attrs:{id:"_5-reference-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-reference-types"}},[e._v("#")]),e._v(" 5. Reference types")]),e._v(" "),a("p",[e._v("Dafny offers a host of "),a("em",[e._v("reference types")]),e._v(". These represent "),a("em",[e._v("references")]),e._v(" to objects allocated dynamically in the program heap. To access the members of an object, a reference to (that is, a "),a("em",[e._v("pointer")]),e._v(" to or "),a("em",[e._v("object identity")]),e._v(" of) the object is "),a("em",[e._v("dereferenced")]),e._v(".")]),e._v(" "),a("p",[e._v("The special value "),a("code",[e._v("null")]),e._v(" is part of every reference type."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-nullable",target:"_blank",rel:"noopener noreferrer"}},[e._v("4"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"_5-0-classes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-0-classes"}},[e._v("#")]),e._v(" 5.0. Classes")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("class")]),e._v(" "),a("code",[e._v("C")]),e._v(" is a reference type declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class C〈T〉 extends J\n{\n  members\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("where the list of type parameters "),a("code",[e._v("T")]),e._v(" is optional and so is “"),a("code",[e._v("extends J")]),e._v("”, which says that the class extends a trait "),a("code",[e._v("J")]),e._v(". The members of a class are "),a("em",[e._v("fields")]),e._v(", "),a("em",[e._v("functions")]),e._v(", and "),a("em",[e._v("methods")]),e._v(". These are accessed or invoked by dereferencing a reference to a "),a("code",[e._v("C")]),e._v(" instance. A function or method is invoked on an "),a("em",[e._v("instance")]),e._v(" of "),a("code",[e._v("C")]),e._v(", unless the function or method is declared "),a("code",[e._v("static")]),e._v(". Mechanically, this just means the method takes an implicit "),a("em",[e._v("receiver")]),e._v(" parameter, namely, the instance used to access the member. In the specification and body of an instance function or method, the receiver parameter can be referred to explicitly by the keyword "),a("code",[e._v("this")]),e._v(". However, in such places, members of "),a("code",[e._v("this")]),e._v(" can also be mentioned without any qualification. To illustrate, the qualified "),a("code",[e._v("this.f")]),e._v(" and the unqualified "),a("code",[e._v("f")]),e._v(" refer to the same field of the same object in the following example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class C {\n  var f: int;\n  method Example() returns (b: bool)\n  {\n    b := f == this.f;\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("so the method body always assigns "),a("code",[e._v("true")]),e._v(" to the out-parameter "),a("code",[e._v("b")]),e._v(". There is no semantic difference between qualified and unqualified accesses to the same receiver and member.")]),e._v(" "),a("p",[e._v("A "),a("code",[e._v("C")]),e._v(" instance is created using "),a("code",[e._v("new")]),e._v(", for example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c := new C;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Note that "),a("code",[e._v("new")]),e._v(" simply allocates a "),a("code",[e._v("C")]),e._v(" object and returns a reference to it; the initial values of its fields are arbitrary values of their respective types. Therefore, it is common to invoke a method, known as an "),a("em",[e._v("initialization method")]),e._v(", immediately after creation, for example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c := new C;\nc.InitFromList(xs, 3);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("When an initialization method has no out-parameters and modifies no more than "),a("code",[e._v("this")]),e._v(", then the two statements above can be combined into one:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c := new C.InitFromList(xs, 3);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Note that a class can contain several initialization methods, that these methods can be invoked at any time, not just as part of a "),a("code",[e._v("new")]),e._v(", and that "),a("code",[e._v("new")]),e._v(" does not require that an initialization method be invoked at creation.")]),e._v(" "),a("p",[e._v("To write structured object-oriented programs, one often relies on that objects are constructed only in certain ways. For this purpose, Dafny provides "),a("em",[e._v("constructor (method)s")]),e._v(", which are a restricted form of initialization methods. A constructor is declared with the keyword "),a("code",[e._v("constructor")]),e._v(" instead of "),a("code",[e._v("method")]),e._v(". When a class contains a constructor, every call to "),a("code",[e._v("new")]),e._v(" for that class must be accompanied with a call to one of the constructors. Moreover, a constructor cannot be called at other times, only during object creation. Other than these restrictions, there is no semantic difference between using ordinary initialization methods and using constructors.")]),e._v(" "),a("p",[e._v("The Dafny design allows the constructors to be named, which promotes using names like "),a("code",[e._v("InitFromList")]),e._v(" above. Still, many classes have just one constructor or have a typical constructor. Therefore, Dafny allows one "),a("em",[e._v("anonymous constructor")]),e._v(", that is, a constructor whose name is essentially “”. For example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Item {\n  constructor (x: int, y: int)\n  // ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("When invoking this constructor, the “"),a("code",[e._v(".")]),e._v("” is dropped, as in:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("m := new Item(45, 29);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Note that an anonymous constructor is just one way to name a constructor; there can be other constructors as well.")]),e._v(" "),a("h3",{attrs:{id:"_5-1-arrays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-arrays"}},[e._v("#")]),e._v(" 5.1. Arrays")]),e._v(" "),a("p",[e._v("Dafny supports mutable fixed-length "),a("em",[e._v("array types")]),e._v(" of any positive dimension. Array types are reference types.")]),e._v(" "),a("h4",{attrs:{id:"_5-1-0-one-dimensional-arrays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-0-one-dimensional-arrays"}},[e._v("#")]),e._v(" 5.1.0. One-dimensional arrays")]),e._v(" "),a("p",[e._v("A one-dimensional array of "),a("code",[e._v("n")]),e._v(" "),a("code",[e._v("T")]),e._v(" elements is created as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a := new T[n];\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The initial values of the array elements are arbitrary values of type "),a("code",[e._v("T")]),e._v(". The length of an array is retrieved using the immutable "),a("code",[e._v("Length")]),e._v(" member. For example, the array allocated above satisfies:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a.Length == n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("For any integer-based numeric "),a("code",[e._v("i")]),e._v(" in the range "),a("code",[e._v("0 <= i < a.Length")]),e._v(", the "),a("em",[e._v("array selection")]),e._v(" expression "),a("code",[e._v("a[i]")]),e._v(" retrieves element "),a("code",[e._v("i")]),e._v(" (that is, the element preceded by "),a("code",[e._v("i")]),e._v(" elements in the array). The element stored at "),a("code",[e._v("i")]),e._v(" can be changed to a value "),a("code",[e._v("t")]),e._v(" using the array update statement:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a[i] := t;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Caveat: The type of the array created by "),a("code",[e._v("new T[n]")]),e._v(" is "),a("code",[e._v("array〈T〉")]),e._v(". A mistake that is simple to make and that can lead to befuddlement is to write "),a("code",[e._v("array〈T〉")]),e._v(" instead of "),a("code",[e._v("T")]),e._v(" after "),a("code",[e._v("new")]),e._v(". For example, consider the following:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a := new array〈T〉;\nvar b := new array〈T〉[n];\nvar c := new array〈T〉(n);  // resolution error\nvar d := new array(n);  // resolution error\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("The first statement allocates an array of type "),a("code",[e._v("array〈T〉")]),e._v(", but of unknown length. The second allocates an array of type "),a("code",[e._v("array〈array〈T〉〉")]),e._v(" of length "),a("code",[e._v("n")]),e._v(", that is, an array that holds "),a("code",[e._v("n")]),e._v(" values of type "),a("code",[e._v("array〈T〉")]),e._v(". The third statement allocates an array of type "),a("code",[e._v("array〈T〉")]),e._v(" and then attempts to invoke an anonymous constructor on this array, passing argument "),a("code",[e._v("n")]),e._v(". Since "),a("code",[e._v("array")]),e._v(" has no constructors, let alone an anonymous constructor, this statement gives rise to an error. If the type-parameter list is omitted for a type that expects type parameters, Dafny will attempt to fill these in, so as long as the "),a("code",[e._v("array")]),e._v(" type parameter can be inferred, it is okay to leave off the “"),a("code",[e._v("〈T〉")]),e._v("” in the fourth statement above. However, as with the third statement, "),a("code",[e._v("array")]),e._v(" has no anonymous constructor, so an error message is generated.")]),e._v(" "),a("p",[e._v("One-dimensional arrays support operations that convert a stretch of consecutive elements into a sequence. For any array "),a("code",[e._v("a")]),e._v(" of type "),a("code",[e._v("array〈T〉")]),e._v(", integer-based numerics "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" satisfying "),a("code",[e._v("0 <= lo <= hi <= a.Length")]),e._v(", the following operations each yields a "),a("code",[e._v("seq〈T〉")]),e._v(":")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("expression")]),e._v(" "),a("td",[e._v("description")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("a[lo..hi]")])]),e._v(" "),a("td",[e._v("subarray conversion to sequence")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("a[lo..]")])]),e._v(" "),a("td",[e._v("drop")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("a[..hi]")])]),e._v(" "),a("td",[e._v("take")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("a[..]")])]),e._v(" "),a("td",[e._v("array conversion to sequence")])]),e._v(" "),a("tr",[a("td"),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("The expression "),a("code",[e._v("a[lo..hi]")]),e._v(" takes the first "),a("code",[e._v("hi")]),e._v(" elements of the array, then drops the first "),a("code",[e._v("lo")]),e._v(" elements thereof and returns what remains as a sequence. The resulting sequence thus has length "),a("code",[e._v("hi - lo")]),e._v(". The other operations are special instances of the first. If "),a("code",[e._v("lo")]),e._v(" is omitted, it defaults to "),a("code",[e._v("0")]),e._v(" and if "),a("code",[e._v("hi")]),e._v(" is omitted, it defaults to "),a("code",[e._v("a.Length")]),e._v(". In the last operation, both "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" have been omitted, thus "),a("code",[e._v("a[..]")]),e._v(" returns the sequence consisting of all the array elements of "),a("code",[e._v("a")]),e._v(".")]),e._v(" "),a("p",[e._v("The subarray operations are especially useful in specifications. For example, the loop invariant of a binary search algorithm that uses variables "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" to delimit the subarray where the search "),a("code",[e._v("key")]),e._v(" may be still found can be expressed as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("key !in a[..lo] && key !in a[hi..]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Another use is to say that a certain range of array elements have not been changed since the beginning of a method:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a[lo..hi] == old(a[lo..hi])\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("or since the beginning of a loop:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi];\n{\n  // ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("Note that the type of "),a("code",[e._v("prevElements")]),e._v(" in this example is "),a("code",[e._v("seq〈T〉")]),e._v(", if "),a("code",[e._v("a")]),e._v(" has type "),a("code",[e._v("array〈T〉")]),e._v(".")]),e._v(" "),a("p",[e._v("A final example of the subarray operation lies in expressing that an array's elements are a permutation of the array's elements at the beginning of a method, as would be done in most sorting algorithms. Here, the subarray operation is combined with the sequence-to-multiset conversion:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("multiset(a[..]) == multiset(old(a[..]))\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h4",{attrs:{id:"_5-1-1-multi-dimensional-arrays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-multi-dimensional-arrays"}},[e._v("#")]),e._v(" 5.1.1. Multi-dimensional arrays")]),e._v(" "),a("p",[e._v("An array of 2 or more dimensions is mostly like a one-dimensional array, except that "),a("code",[e._v("new")]),e._v(" takes more length arguments (one for each dimension), and the array selection expression and the array update statement take more indices. For example:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("matrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("create a 2-dimensional array whose dimensions have lengths "),a("code",[e._v("m")]),e._v(" and "),a("code",[e._v("n")]),e._v(", respectively, and then swaps the elements at "),a("code",[e._v("i,j")]),e._v(" and "),a("code",[e._v("x,y")]),e._v(". The type of "),a("code",[e._v("matrix")]),e._v(" is "),a("code",[e._v("array2〈T〉")]),e._v(", and similarly for higher-dimensional arrays ("),a("code",[e._v("array3〈T〉")]),e._v(", "),a("code",[e._v("array4〈T〉")]),e._v(", etc.). Note, however, that there is no type "),a("code",[e._v("array0〈T〉")]),e._v(", and what could have been "),a("code",[e._v("array1〈T〉")]),e._v(" is actually named just "),a("code",[e._v("array〈T〉")]),e._v(".")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("new")]),e._v(" operation above requires "),a("code",[e._v("m")]),e._v(" and "),a("code",[e._v("n")]),e._v(" to be non-negative integer-based numerics. These lengths can be retrieved using the immutable fields "),a("code",[e._v("Length0")]),e._v(" and "),a("code",[e._v("Length1")]),e._v(". For example, the following holds of the array created above:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("matrix.Length0 == m && matrix.Length1 == n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Higher-dimensional arrays are similar ("),a("code",[e._v("Length0")]),e._v(", "),a("code",[e._v("Length1")]),e._v(", "),a("code",[e._v("Length2")]),e._v(", …). The array selection expression and array update statement require that the indices are in bounds. For example, the swap statement above is well-formed only if:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("In contrast to one-dimensional arrays, there is no operation to convert stretches of elements from a multi-dimensional array to a sequence.")]),e._v(" "),a("h3",{attrs:{id:"_5-2-traits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-traits"}},[e._v("#")]),e._v(" 5.2. Traits")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("trait")]),e._v(" is an “abstract superclass”, or call it an “interface” or “mixin”. Traits are new to Dafny and are likely to evolve for a while.")]),e._v(" "),a("p",[e._v("The declaration of a trait is much like that of a class:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("trait J\n{\n  members\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("*members*")]),e._v(" can include fields, functions, and methods, but no constructor methods. The functions and methods are allowed to be declared "),a("code",[e._v("static")]),e._v(".")]),e._v(" "),a("p",[e._v("A reference type "),a("code",[e._v("C")]),e._v(" that extends a trait "),a("code",[e._v("J")]),e._v(" is assignable to "),a("code",[e._v("J")]),e._v(", but not the other way around. The members of "),a("code",[e._v("J")]),e._v(" are available as members of "),a("code",[e._v("C")]),e._v(". A member in "),a("code",[e._v("J")]),e._v(" is not allowed to be redeclared in "),a("code",[e._v("C")]),e._v(", except if the member is a non-"),a("code",[e._v("static")]),e._v(" function or method without a body in "),a("code",[e._v("J")]),e._v(". By doing so, type "),a("code",[e._v("C")]),e._v(" can supply a stronger specification and a body for the member.")]),e._v(" "),a("p",[a("code",[e._v("new")]),e._v(" is not allowed to be used with traits. Therefore, there is no object whose allocated type is a trait. But there can of course be objects of a class "),a("code",[e._v("C")]),e._v(" that implements a trait "),a("code",[e._v("J")]),e._v(", and a reference to such a "),a("code",[e._v("C")]),e._v(" object can be used as a value of type "),a("code",[e._v("J")]),e._v(".")]),e._v(" "),a("p",[e._v("As an example, the following trait represents movable geometric shapes:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("trait Shape\n{\n  function method Width(): real\n    reads this\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("Members "),a("code",[e._v("Width")]),e._v(" and "),a("code",[e._v("Move")]),e._v(" are "),a("em",[e._v("abstract")]),e._v(" (that is, body less) and can be implemented differently by different classes that extend the trait. The implementation of method "),a("code",[e._v("MoveH")]),e._v(" is given in the trait and thus gets used by all classes that extend "),a("code",[e._v("Shape")]),e._v(". Here are two classes that each extends "),a("code",[e._v("Shape")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class UnitSquare extends Shape\n{\n  var x: real, y: real;\n  function method Width(): real {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real;\n  function method Width(): real\n    reads this\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br")])]),a("p",[e._v("Note that the classes can declare additional members, that they supply implementations for the abstract members of the trait, that they repeat the member signatures, and that they are responsible for providing their own member specifications that both strengthen the corresponding specification in the trait and are satisfied by the provided body. Finally, here is some code that creates two class instances and uses them together as shapes:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var myShapes: seq〈Shape〉;\nvar A := new UnitSquare;\nmyShapes := [A];\nvar tri := new LowerRightTriangle;\nmyShapes := myShapes + [tri];  // myShapes contains two Shape values, of different classes\nmyShapes[1].MoveH(myShapes[0].Width());  // move shape 1 to the right by the width of shape 0\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h3",{attrs:{id:"_5-3-type-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-type-object"}},[e._v("#")]),e._v(" 5.3. Type "),a("code",[e._v("object")])]),e._v(" "),a("p",[e._v("There is a built-in reference type "),a("code",[e._v("object")]),e._v(" that is like a supertype of all reference types."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-object-trait",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),a("OutboundLink")],1),e._v(" The purpose of type "),a("code",[e._v("object")]),e._v(" is to enable a uniform treatment of "),a("em",[e._v("dynamic frames")]),e._v(". In particular, it is useful to keep a ghost field (typically named "),a("code",[e._v("Repr")]),e._v(" for “representation”) of type "),a("code",[e._v("set〈object〉")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_5-4-iterator-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-iterator-types"}},[e._v("#")]),e._v(" 5.4. Iterator types")]),e._v(" "),a("p",[e._v("An "),a("em",[e._v("iterator")]),e._v(" provides a programming abstraction for writing code that iteratively returns elements. These CLU-style iterators are "),a("em",[e._v("co-routines")]),e._v(" in the sense that they keep track of their own program counter and control can be transferred into and out of the iterator body.")]),e._v(" "),a("p",[e._v("An iterator is declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("iterator Iter〈T〉(in-params) yields (yield-params)\n  specification\n{\n  body\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("T")]),e._v(" is a list of type parameters (as usual, if there are no type parameters, “"),a("code",[e._v("〈T〉")]),e._v("” is omitted). This declaration gives rise to a reference type with the same name, "),a("code",[e._v("Iter〈T〉")]),e._v(". In the signature, in-parameters and yield-parameters are the iterator's analog of a method's in-parameters and out-parameters. The difference is that the out-parameters of a method are returned to a caller just once, whereas the yield-parameters of an iterator are returned each time the iterator body performs a "),a("code",[e._v("yield")]),e._v(". The details of the specification are described in a different part of the Dafny language reference. The body consists of statements, like in a method body, but with the availability also of "),a("code",[e._v("yield")]),e._v(" statements.")]),e._v(" "),a("p",[e._v("From the perspective of an iterator client, the "),a("code",[e._v("iterator")]),e._v(" declaration can be understood as generating a class "),a("code",[e._v("Iter〈T〉")]),e._v(" with various members, a simplified version of which is described next.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("Iter〈T〉")]),e._v(" class contains an anonymous constructor whose parameters are the iterator's in-parameters:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("predicate Valid()\nconstructor (in-params)\n  modifies this\n  ensures Valid()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("An iterator is created using "),a("code",[e._v("new")]),e._v(" and this anonymous constructor. For example, an iterator willing to return ten consecutive integers from "),a("code",[e._v("start")]),e._v(" can be declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("iterator Gen(start: int) yields (x: int)\n{\n  var i := 0;\n  while i < 10 {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("An instance of this iterator is created using:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("iter := new Gen(30);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The predicate "),a("code",[e._v("Valid()")]),e._v(" says when the iterator is in a state where one can attempt to compute more elements. It is a postcondition of the constructor and occurs in the specification of the "),a("code",[e._v("MoveNext")]),e._v(" member:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("method MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("Note that the iterator remains valid as long as "),a("code",[e._v("MoveNext")]),e._v(" returns "),a("code",[e._v("true")]),e._v(". Once "),a("code",[e._v("MoveNext")]),e._v(" returns "),a("code",[e._v("false")]),e._v(", the "),a("code",[e._v("MoveNext")]),e._v(" method can no longer be called. Note, the client is under no obligation to keep calling "),a("code",[e._v("MoveNext")]),e._v(" until it returns "),a("code",[e._v("false")]),e._v(", and the body of the iterator is allowed to keep returning elements forever.")]),e._v(" "),a("p",[e._v("The in-parameters of the iterator are stored in immutable fields of the iterator class. To illustrate in terms of the example above, the iterator class "),a("code",[e._v("Gen")]),e._v(" contains the following field:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var start: int;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The yield-parameters also result in members of the iterator class:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var x: int;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("These fields are set by the "),a("code",[e._v("MoveNext")]),e._v(" method. If "),a("code",[e._v("MoveNext")]),e._v(" returns "),a("code",[e._v("true")]),e._v(", the latest yield values are available in these fields and the client can read them from there.")]),e._v(" "),a("p",[e._v("To aid in writing specifications, the iterator class also contains ghost members that keep the history of values returned by "),a("code",[e._v("MoveNext")]),e._v(". The names of these ghost fields follow the names of the yield-parameters with an “"),a("code",[e._v("s")]),e._v("” appended to the name (to suggest plural). Name checking rules make sure these names do not give rise to ambiguities. The iterator class for "),a("code",[e._v("Gen")]),e._v(" above thus contains:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ghost var xs: seq〈int〉;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("These history fields are changed automatically by "),a("code",[e._v("MoveNext")]),e._v(", but are not assignable by user code.")]),e._v(" "),a("p",[e._v("Finally, the iterator class contains some special fields for use in specifications. In particular, the iterator specification gets recorded in the following immutable fields:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ghost var _reads: set〈object〉;\nghost var _modifies: set〈object〉;\nghost var _decreases0: T0;\nghost var _decreases1: T1;\n// ...\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("where there is a "),a("code",[e._v("_decreases*i*: T*i*")]),e._v(" field for each component of the iterator's "),a("code",[e._v("decreases")]),e._v(" clause."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-iterator-field-names",target:"_blank",rel:"noopener noreferrer"}},[e._v("6"),a("OutboundLink")],1),e._v(" In addition, there is a field:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ghost var _new: set〈object〉;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("to which any objects allocated on behalf of the iterator body get added. The iterator body is allowed to remove elements from the "),a("code",[e._v("_new")]),e._v(" set, but cannot by assignment to "),a("code",[e._v("_new")]),e._v(" add any elements.")]),e._v(" "),a("p",[e._v("Note, in the precondition of the iterator, which is to hold upon construction of the iterator, the in-parameters are indeed in-parameters, not fields of "),a("code",[e._v("this")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_5-5-async-task-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-async-task-types"}},[e._v("#")]),e._v(" 5.5. Async-task types")]),e._v(" "),a("p",[e._v("Another experimental feature in Dafny that is likely to undergo some evolution is "),a("em",[e._v("asynchronous methods")]),e._v(". When an asynchronous method is called, it does not return values for the out-parameters, but instead returns an instance of an "),a("em",[e._v("async-task type")]),e._v(". An asynchronous method declared in a class "),a("code",[e._v("C")]),e._v(" with the following signature:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async method AM〈T〉(in-params) returns (out-params)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("also gives rise to an async-task type "),a("code",[e._v("AM〈T〉")]),e._v(" (outside the enclosing class, the name of the type needs the qualification "),a("code",[e._v("C.AM〈T〉")]),e._v("). The async-task type is a reference type and can be understood as a class with various members, a simplified version of which is described next.")]),e._v(" "),a("p",[e._v("Each in-parameter "),a("code",[e._v("x")]),e._v(" of type "),a("code",[e._v("X")]),e._v(" of the asynchronous method gives rise to a immutable ghost field of the async-task type:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ghost var x: X;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Each out-parameter "),a("code",[e._v("y")]),e._v(" of type "),a("code",[e._v("Y")]),e._v(" gives rise to a field")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var y: Y;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("These fields are changed automatically by the time the asynchronous method is successfully awaited, but are not assignable by user code.")]),e._v(" "),a("p",[e._v("The async-task type also gets a number of special fields that are used to keep track of dependencies, outstanding tasks, newly allocated objects, etc. These fields will be described in more detail as the design of asynchronous methods evolves.")]),e._v(" "),a("h2",{attrs:{id:"_6-function-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-function-types"}},[e._v("#")]),e._v(" 6. Function types")]),e._v(" "),a("p",[e._v("Functions are first-class values in Dafny. Function types have the form "),a("code",[e._v("(T) -> U")]),e._v(" where "),a("code",[e._v("T")]),e._v(" is a comma-delimited list of types and "),a("code",[e._v("U")]),e._v(" is a type. "),a("code",[e._v("T")]),e._v(" is called the function's "),a("em",[e._v("domain type(s)")]),e._v(" and "),a("code",[e._v("U")]),e._v(" is its "),a("em",[e._v("range type")]),e._v(". For example, the type of a function")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function F(x: int, b: bool): real\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is "),a("code",[e._v("(int, bool) -> real")]),e._v(". Parameters are not allowed to be ghost.")]),e._v(" "),a("p",[e._v("To simplify the appearance of the basic case where a function's domain consist of a list of exactly one type, the parentheses around the domain type can be dropped in this case, as in "),a("code",[e._v("T -> U")]),e._v(". This innocent simplification requires additional explanation in the case where that one type is a tuple type, since tuple types are also written with enclosing parentheses. If the function takes a single argument that is a tuple, an additional set of parentheses is needed. For example, the function")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function G(pair: (int, bool)): real\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("has type "),a("code",[e._v("((int, bool)) -> real")]),e._v(". Note the necessary double parentheses. Similarly, a function that takes no arguments is different from one that takes a 0-tuple as an argument. For instance, the functions")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function NoArgs(): real\nfunction Z(unit: ()): real\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("have types "),a("code",[e._v("() -> real")]),e._v(" and "),a("code",[e._v("(()) -> real")]),e._v(", respectively.")]),e._v(" "),a("p",[e._v("The function arrow, "),a("code",[e._v("->")]),e._v(", is right associative, so "),a("code",[e._v("A -> B -> C")]),e._v(" means "),a("code",[e._v("A -> (B -> C)")]),e._v(". The other association requires explicit parentheses: "),a("code",[e._v("(A -> B) -> C")]),e._v(".")]),e._v(" "),a("p",[e._v("Note that the receiver parameter of a named function is not part of the type. Rather, it is used when looking up the function and can then be thought of as being captured into the function definition. For example, suppose function "),a("code",[e._v("F")]),e._v(" above is declared in a class "),a("code",[e._v("C")]),e._v(" and that "),a("code",[e._v("c")]),e._v(" references an object of type "),a("code",[e._v("C")]),e._v("; then, the following is type correct:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f: (int, bool) -> real := c.F;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("whereas it would have been incorrect to have written something like:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f': (C, int, bool) -> real := F;  // not correct\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Outside its type signature, each function value has three properties, described next.")]),e._v(" "),a("p",[e._v("Every function implicitly takes the heap as an argument. No function ever depends on the "),a("em",[e._v("entire")]),e._v(" heap, however. A property of the function is its declared upper bound on the set of heap locations it depends on for a given input. This lets the verifier figure out that certain heap modifications have no effect on the value returned by a certain function. For a function "),a("code",[e._v("f: T -> U")]),e._v(" and a value "),a("code",[e._v("t")]),e._v(" of type "),a("code",[e._v("T")]),e._v(", the dependency set is denoted "),a("code",[e._v("f.reads(t)")]),e._v(" and has type "),a("code",[e._v("set〈object〉")]),e._v(".")]),e._v(" "),a("p",[e._v("The second property of functions stems from that every function is potentially "),a("em",[e._v("partial")]),e._v(". In other words, a property of a function is its "),a("em",[e._v("precondition")]),e._v(". For a function "),a("code",[e._v("f: T -> U")]),e._v(", the precondition of "),a("code",[e._v("f")]),e._v(" for a parameter value "),a("code",[e._v("t")]),e._v(" of type "),a("code",[e._v("T")]),e._v(" is denoted "),a("code",[e._v("f.requires(t)")]),e._v(" and has type "),a("code",[e._v("bool")]),e._v(".")]),e._v(" "),a("p",[e._v("The third property of a function is more obvious—the function's body. For a function "),a("code",[e._v("f: T -> U")]),e._v(", the value that the function yields for an input "),a("code",[e._v("t")]),e._v(" of type "),a("code",[e._v("T")]),e._v(" is denoted "),a("code",[e._v("f(t)")]),e._v(" and has type "),a("code",[e._v("U")]),e._v(".")]),e._v(" "),a("p",[e._v("Note that "),a("code",[e._v("f.reads")]),e._v(" and "),a("code",[e._v("f.requires")]),e._v(" are themselves functions. Suppose "),a("code",[e._v("f")]),e._v(" has type "),a("code",[e._v("T -> U")]),e._v(" and "),a("code",[e._v("t")]),e._v(" has type "),a("code",[e._v("T")]),e._v(". Then, "),a("code",[e._v("f.reads")]),e._v(" is a function of type "),a("code",[e._v("T -> set〈object〉")]),e._v(" whose "),a("code",[e._v("reads")]),e._v(" and "),a("code",[e._v("requires")]),e._v(" properties are:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f.reads.reads(t) == f.reads(t)\nf.reads.requires(t) == true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("code",[e._v("f.requires")]),e._v(" is a function of type "),a("code",[e._v("T -> bool")]),e._v(" whose "),a("code",[e._v("reads")]),e._v(" and "),a("code",[e._v("requires")]),e._v(" properties are:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f.requires.reads(t) == f.reads(t)\nf.requires.requires(t) == true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("h3",{attrs:{id:"_6-0-lambda-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-0-lambda-expressions"}},[e._v("#")]),e._v(" 6.0. Lambda expressions")]),e._v(" "),a("p",[e._v("In addition to named functions, Dafny supports expressions that define functions. These are called "),a("em",[e._v("lambda (expression)s")]),e._v(" (some languages know them as "),a("em",[e._v("anonymous functions")]),e._v("). A lambda expression has the form:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(params) specification => body\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("*params*")]),e._v(" is a comma-delimited list of parameter declarations, each of which has the form "),a("code",[e._v("x")]),e._v(" or "),a("code",[e._v("x: T")]),e._v(". The type "),a("code",[e._v("T")]),e._v(" of a parameter can be omitted when it can be inferred. If the identifier "),a("code",[e._v("x")]),e._v(" is not needed, it can be replaced by “"),a("code",[e._v("_")]),e._v("”. If "),a("code",[e._v("*params*")]),e._v(" consists of a single parameter "),a("code",[e._v("x")]),e._v(" (or "),a("code",[e._v("_")]),e._v(") without an explicit type, then the parentheses can be dropped; for example, the function that returns the successor of a given integer can be written as the following lambda expression:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x => x + 1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The "),a("code",[e._v("*specification*")]),e._v(" is a list of clauses "),a("code",[e._v("requires E")]),e._v(" or "),a("code",[e._v("reads W")]),e._v(", where "),a("code",[e._v("E")]),e._v(" is a boolean expression and "),a("code",[e._v("W")]),e._v(" is a frame expression.")]),e._v(" "),a("p",[a("code",[e._v("*body*")]),e._v(" is an expression that defines the function's return value. The body must be well-formed for all possible values of the parameters that satisfy the precondition (just like the bodies of named functions and methods). In some cases, this means it is necessary to write explicit "),a("code",[e._v("requires")]),e._v(" and "),a("code",[e._v("reads")]),e._v(" clauses. For example, the lambda expression")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x requires x != 0 => 100 / x\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("would not be well-formed if the "),a("code",[e._v("requires")]),e._v(" clause were omitted, because of the possibility of division-by-zero.")]),e._v(" "),a("p",[e._v("In settings where functions cannot be partial and there are no restrictions on reading the heap, the "),a("em",[e._v("eta expansion")]),e._v(" of a function "),a("code",[e._v("F: T -> U")]),e._v(" (that is, the wrapping of "),a("code",[e._v("F")]),e._v(" inside a lambda expression in such a way that the lambda expression is equivalent to "),a("code",[e._v("F")]),e._v(") would be written "),a("code",[e._v("x => F(x)")]),e._v(". In Dafny, eta expansion must also account for the precondition and reads set of the function, so the eta expansion of "),a("code",[e._v("F")]),e._v(" looks like:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x requires F.requires(x) reads F.reads(x) => F(x)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h2",{attrs:{id:"_7-newtypes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-newtypes"}},[e._v("#")]),e._v(" 7. Newtypes")]),e._v(" "),a("p",[e._v("A new numeric type can be declared with the "),a("em",[e._v("newtype")]),e._v(" declaration"),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-newtype-name",target:"_blank",rel:"noopener noreferrer"}},[e._v("7"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("newtype N = x: M | Q\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where "),a("code",[e._v("M")]),e._v(" is a numeric type and "),a("code",[e._v("Q")]),e._v(" is a boolean expression that can use "),a("code",[e._v("x")]),e._v(" as a free variable. If "),a("code",[e._v("M")]),e._v(" is an integer-based numeric type, then so is "),a("code",[e._v("N")]),e._v("; if "),a("code",[e._v("M")]),e._v(" is real-based, then so is "),a("code",[e._v("N")]),e._v(". If the type "),a("code",[e._v("M")]),e._v(" can be inferred from "),a("code",[e._v("Q")]),e._v(", the “"),a("code",[e._v(": M")]),e._v("” can be omitted. If "),a("code",[e._v("Q")]),e._v(" is just "),a("code",[e._v("true")]),e._v(", then the declaration can be given simply as:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("newtype N = M\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Type "),a("code",[e._v("M")]),e._v(" is known as the "),a("em",[e._v("base type")]),e._v(" of "),a("code",[e._v("N")]),e._v(".")]),e._v(" "),a("p",[e._v("A newtype is a numeric type that supports the same operations as its base type. The newtype is distinct from and incompatible with other numeric types; in particular, it is not assignable to its base type without an explicit conversion. An important difference between the operations on a newtype and the operations on its base type is that the newtype operations are defined only if the result satisfies the predicate "),a("code",[e._v("Q")]),e._v(", and likewise for the literals of the newtype."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-newtype-design-question",target:"_blank",rel:"noopener noreferrer"}},[e._v("8"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("For example, suppose "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" are integer-based numerics that satisfy "),a("code",[e._v("0 <= lo <= hi")]),e._v(" and consider the following code fragment:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var mid := (lo + hi) / 2;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("If "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" have type "),a("code",[e._v("int")]),e._v(", then the code fragment is legal; in particular, it never overflows, since "),a("code",[e._v("int")]),e._v(" has no upper bound. In contrast, if "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" are variables of a newtype "),a("code",[e._v("int32")]),e._v(" declared as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("newtype int32 = x | -0x80000000 <= x < 0x80000000\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("then the code fragment is erroneous, since the result of the addition may fail to satisfy the predicate in the definition of "),a("code",[e._v("int32")]),e._v(". The code fragment can be rewritten as")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var mid := lo + (hi - lo) / 2;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("in which case it is legal for both "),a("code",[e._v("int")]),e._v(" and "),a("code",[e._v("int32")]),e._v(".")]),e._v(" "),a("p",[e._v("Since a newtype is incompatible with its base type and since all results of the newtype's operations are members of the newtype, a compiler for Dafny is free to specialize the run-time representation of the newtype. For example, by scrutinizing the definition of "),a("code",[e._v("int32")]),e._v(" above, a compiler may decide to store "),a("code",[e._v("int32")]),e._v(" values using signed 32-bit integers in the target hardware.")]),e._v(" "),a("p",[e._v("Note that the bound variable "),a("code",[e._v("x")]),e._v(" in "),a("code",[e._v("Q")]),e._v(" has type "),a("code",[e._v("M")]),e._v(", not "),a("code",[e._v("N")]),e._v(". nConsequently, it may not be possible to state "),a("code",[e._v("Q")]),e._v(" about the "),a("code",[e._v("N")]),e._v(" value. For example, consider the following type of 8-bit 2's complement integers:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("newtype int8 = x: int | -128 <= x < 128\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("and consider a variable "),a("code",[e._v("c")]),e._v(" of type "),a("code",[e._v("int8")]),e._v(". The expression")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("-128 <= c < 128\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("is not well-defined, because the comparisons require each operand to have type "),a("code",[e._v("int8")]),e._v(", which means the literal "),a("code",[e._v("128")]),e._v(" is checked to be of type "),a("code",[e._v("int8")]),e._v(", which it is not. A proper way to write this expression would be to use a conversion operation, described next, on "),a("code",[e._v("c")]),e._v(" to convert it to the base type:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("-128 <= int(c) < 128\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("There is a restriction that the value "),a("code",[e._v("0")]),e._v(" must be part of every newtype."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-newtype-zero",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"_7-0-numeric-conversion-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-0-numeric-conversion-operations"}},[e._v("#")]),e._v(" 7.0. Numeric conversion operations")]),e._v(" "),a("p",[e._v("For every numeric type "),a("code",[e._v("N")]),e._v(", there is a conversion function with the same name. It is a partial identity function. It is defined when the given value, which can be of any numeric type, is a member of the type converted to. When the conversion is from a real-based numeric type to an integer-based numeric type, the operation requires that the real-based argument has no fractional part. (To round a real-based numeric value down to the nearest integer, use the "),a("code",[e._v(".Trunc")]),e._v(" member, see Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-numeric-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("0.1"),a("OutboundLink")],1),e._v(".)")]),e._v(" "),a("p",[e._v("To illustrate using the example from above, if "),a("code",[e._v("lo")]),e._v(" and "),a("code",[e._v("hi")]),e._v(" have type "),a("code",[e._v("int32")]),e._v(", then the code fragment can legally be written as follows:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var mid := (int(lo) + int(hi)) / 2;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where the type of "),a("code",[e._v("mid")]),e._v(" is inferred to be "),a("code",[e._v("int")]),e._v(". Since the result value of the division is a member of type "),a("code",[e._v("int32")]),e._v(", one can introduce yet another conversion operation to make the type of "),a("code",[e._v("mid")]),e._v(" be "),a("code",[e._v("int32")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var mid := int32((int(lo) + int(hi)) / 2);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("If the compiler does specialize the run-time representation for "),a("code",[e._v("int32")]),e._v(", then these statements come at the expense of two, respectively three, run-time conversions.")]),e._v(" "),a("h2",{attrs:{id:"_8-subset-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-subset-types"}},[e._v("#")]),e._v(" 8. Subset types")]),e._v(" "),a("p",[e._v("A "),a("em",[e._v("subset type")]),e._v(" is a restricted use of an existing type, called the "),a("em",[e._v("base type")]),e._v(" of the subset type. A subset type is like a combined use of the base type and a predicate on the base type.")]),e._v(" "),a("p",[e._v("An assignment from a subset type to its base type is always allowed. An assignment in the other direction, from the base type to a subset type, is allowed provided the value assigned does indeed satisfy the predicate of the subset type. (Note, in contrast, assignments between a newtype and its base type are never allowed, even if the value assigned is a value of the target type. For such assignments, an explicit conversion must be used, see Section "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#sec-numeric-conversions",target:"_blank",rel:"noopener noreferrer"}},[e._v("7.0"),a("OutboundLink")],1),e._v(".)")]),e._v(" "),a("p",[e._v("Dafny supports one subset type, namely the built-in type "),a("code",[e._v("nat")]),e._v(", whose base type is "),a("code",[e._v("int")]),e._v("."),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#fn-fn-more-subset-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("10"),a("OutboundLink")],1),e._v(" Type "),a("code",[e._v("nat")]),e._v(" designates the non-negative subrange of "),a("code",[e._v("int")]),e._v(". A simple example that puts subset type "),a("code",[e._v("nat")]),e._v(" to good use is the standard Fibonacci function:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("An equivalent, but clumsy, formulation of this function (modulo the wording of any error messages produced at call sites) would be to use type "),a("code",[e._v("int")]),e._v(" and to write the restricting predicate in pre- and postconditions:")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("Type inference will never infer the type of a variable to be a subset type. It will instead infer the type to be the base type of the subset type. For example, the type of "),a("code",[e._v("x")]),e._v(" in")]),e._v(" "),a("div",{staticClass:"language-dafny line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("forall x :: P(x)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("will be "),a("code",[e._v("int")]),e._v(", even if predicate "),a("code",[e._v("P")]),e._v(" declares its argument to have type "),a("code",[e._v("nat")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"acknowledgments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgments"}},[e._v("#")]),e._v(" Acknowledgments")]),e._v(" "),a("p",[e._v("This document has been improved as a result of helpful comments from Nadia Polikarpova and Paqui Lucio.")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("0.Being equality-supporting is just one of many "),a("em",[e._v("modes")]),e._v(" that one can imagine types in a rich type system to have. For example, other modes could include having a total order, being zero-initializable, and possibly being uninhabited. If Dafny were to support more modes in the future, the “"),a("code",[e._v("( )")]),e._v("”-suffix syntax may be extended. For now, the suffix can only indicate the equality-supporting mode. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-type-mode",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("1.Now that Dafny supports built-in tuples, the plan is to change the sequence slice operation to return not a sequence of subsequences, but a tuple of subsequences. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-slice-into-tuple",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("2.This is likely to change in the future to disallow multiple occurrences of the same key. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-map-display",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("3.This is likely to change in the future as follows: The "),a("code",[e._v("in")]),e._v(" and "),a("code",[e._v("!in")]),e._v(" operations will no longer be supported on maps. Instead, for any map "),a("code",[e._v("m")]),e._v(", "),a("code",[e._v("m.Domain")]),e._v(" will return its domain as a set and "),a("code",[e._v("m.Range")]),e._v(" will return, also as a set, the image of "),a("code",[e._v("m")]),e._v(" under its domain. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-map-membership",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("4.This will change in a future version of Dafny that will support both nullable and (by default) non-null reference types. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-nullable",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("5.Soon, "),a("code",[e._v("object")]),e._v(" will be made into a built-in trait rather than being a built-in special class. When this happens, it will no longer be possible to do "),a("code",[e._v("new object")]),e._v(". The current compiler restriction that "),a("code",[e._v("object")]),e._v(" cannot be used as a type parameter will then also go away. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-object-trait",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("6.It would make sense to rename the special fields "),a("code",[e._v("_reads")]),e._v(" and "),a("code",[e._v("_modifies")]),e._v(" to have the same names as the corresponding keywords, "),a("code",[e._v("reads")]),e._v(" and "),a("code",[e._v("modifies")]),e._v(", as is done for function values. Also, the various "),a("code",[e._v("_decreases*i*")]),e._v(" fields can combined into one field named "),a("code",[e._v("decreases")]),e._v(" whose type is a "),a("em",[e._v("n")]),e._v("-tuple.")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-iterator-field-names",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("7.Should "),a("code",[e._v("newtype")]),e._v(" perhaps be renamed to "),a("code",[e._v("numtype")]),e._v("? "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-newtype-name",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("8.Would it be useful to also automatically define "),a("code",[e._v("predicate N?(m: M) { Q }")]),e._v("? "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-newtype-design-question",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("9.The restriction is due to a current limitation in the compiler. This will change in the future and will also open up the possibility for subset types and non-null reference types. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-newtype-zero",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("10.A future version of Dafny will support user-defined subset types. "),a("a",{attrs:{href:"http://leino.science/papers/krml243.html#back-fn-fn-more-subset-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("↩"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);