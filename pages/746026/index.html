<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Case study of definitions, proofs, algorithm correctness GCD | Dafny</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/dafnycommunity/img/bgico2.ico">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3282046_1qux519eoim.css">
    <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"></script>
    <meta name="description" content="Dafny中文社区">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css" as="style"><link rel="preload" href="/dafnycommunity/assets/js/app.99d07194.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/2.ab4658c0.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/76.bebf75c9.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/7.5451cfed.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/4.06497870.js" as="script"><link rel="prefetch" href="/dafnycommunity/assets/js/10.ac38cab7.js"><link rel="prefetch" href="/dafnycommunity/assets/js/11.38d5ee16.js"><link rel="prefetch" href="/dafnycommunity/assets/js/12.c434ce94.js"><link rel="prefetch" href="/dafnycommunity/assets/js/13.4e922264.js"><link rel="prefetch" href="/dafnycommunity/assets/js/14.db841cfa.js"><link rel="prefetch" href="/dafnycommunity/assets/js/15.b9c227cc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/16.41dadc32.js"><link rel="prefetch" href="/dafnycommunity/assets/js/17.48b5f1eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/18.ec254833.js"><link rel="prefetch" href="/dafnycommunity/assets/js/19.288ca382.js"><link rel="prefetch" href="/dafnycommunity/assets/js/20.cfeb5fdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/21.ce8ddc5a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/22.1b8c89f0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/23.cb062ace.js"><link rel="prefetch" href="/dafnycommunity/assets/js/24.ff271672.js"><link rel="prefetch" href="/dafnycommunity/assets/js/25.5541f3af.js"><link rel="prefetch" href="/dafnycommunity/assets/js/26.a1bbc4cb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/27.522d7884.js"><link rel="prefetch" href="/dafnycommunity/assets/js/28.9335c003.js"><link rel="prefetch" href="/dafnycommunity/assets/js/29.3fc0b07a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/3.ab8a97d8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/30.57708681.js"><link rel="prefetch" href="/dafnycommunity/assets/js/31.8571b949.js"><link rel="prefetch" href="/dafnycommunity/assets/js/32.f91be5de.js"><link rel="prefetch" href="/dafnycommunity/assets/js/33.8089c59b.js"><link rel="prefetch" href="/dafnycommunity/assets/js/34.874d0299.js"><link rel="prefetch" href="/dafnycommunity/assets/js/35.aff8adfd.js"><link rel="prefetch" href="/dafnycommunity/assets/js/36.ac78b86e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/37.3fae0334.js"><link rel="prefetch" href="/dafnycommunity/assets/js/38.3db4a8d6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/39.e585cc70.js"><link rel="prefetch" href="/dafnycommunity/assets/js/40.afcb8fbe.js"><link rel="prefetch" href="/dafnycommunity/assets/js/41.01f314da.js"><link rel="prefetch" href="/dafnycommunity/assets/js/42.8e4fe21d.js"><link rel="prefetch" href="/dafnycommunity/assets/js/43.571fb232.js"><link rel="prefetch" href="/dafnycommunity/assets/js/44.14aebad2.js"><link rel="prefetch" href="/dafnycommunity/assets/js/45.32f18970.js"><link rel="prefetch" href="/dafnycommunity/assets/js/46.ce0d522f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/47.0bd83351.js"><link rel="prefetch" href="/dafnycommunity/assets/js/48.648f667a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/49.83709ae0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/5.b8548e7f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/50.060e0424.js"><link rel="prefetch" href="/dafnycommunity/assets/js/51.a1291856.js"><link rel="prefetch" href="/dafnycommunity/assets/js/52.45f73497.js"><link rel="prefetch" href="/dafnycommunity/assets/js/53.525782ca.js"><link rel="prefetch" href="/dafnycommunity/assets/js/54.45a04a86.js"><link rel="prefetch" href="/dafnycommunity/assets/js/55.65a94ba0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/56.2d038113.js"><link rel="prefetch" href="/dafnycommunity/assets/js/57.579db650.js"><link rel="prefetch" href="/dafnycommunity/assets/js/58.832d4c89.js"><link rel="prefetch" href="/dafnycommunity/assets/js/59.13befb53.js"><link rel="prefetch" href="/dafnycommunity/assets/js/6.349bf431.js"><link rel="prefetch" href="/dafnycommunity/assets/js/60.41227bb1.js"><link rel="prefetch" href="/dafnycommunity/assets/js/61.1d1b92f4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/62.2cdbc236.js"><link rel="prefetch" href="/dafnycommunity/assets/js/63.83de9482.js"><link rel="prefetch" href="/dafnycommunity/assets/js/64.4ecd0d25.js"><link rel="prefetch" href="/dafnycommunity/assets/js/65.25118b81.js"><link rel="prefetch" href="/dafnycommunity/assets/js/66.cdab1b54.js"><link rel="prefetch" href="/dafnycommunity/assets/js/67.655e6e84.js"><link rel="prefetch" href="/dafnycommunity/assets/js/68.84effb44.js"><link rel="prefetch" href="/dafnycommunity/assets/js/69.8f07f81a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/70.d9a299e6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/71.16ef2000.js"><link rel="prefetch" href="/dafnycommunity/assets/js/72.8252acc5.js"><link rel="prefetch" href="/dafnycommunity/assets/js/73.f53e39bc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/74.5ef910c4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/75.72174d00.js"><link rel="prefetch" href="/dafnycommunity/assets/js/77.b85547c7.js"><link rel="prefetch" href="/dafnycommunity/assets/js/78.a0a1f574.js"><link rel="prefetch" href="/dafnycommunity/assets/js/79.a731d645.js"><link rel="prefetch" href="/dafnycommunity/assets/js/8.522ce892.js"><link rel="prefetch" href="/dafnycommunity/assets/js/80.6e5b64b0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/81.6e19e312.js"><link rel="prefetch" href="/dafnycommunity/assets/js/82.9244e788.js"><link rel="prefetch" href="/dafnycommunity/assets/js/83.f08c5aed.js"><link rel="prefetch" href="/dafnycommunity/assets/js/84.085ef3f8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/85.c41e6e0e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/86.e3798708.js"><link rel="prefetch" href="/dafnycommunity/assets/js/87.fdac1c1c.js"><link rel="prefetch" href="/dafnycommunity/assets/js/88.665ac8c8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/89.78dc55eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/9.4d4f4bdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/90.4757b202.js"><link rel="prefetch" href="/dafnycommunity/assets/js/91.a0746cf2.js">
    <link rel="stylesheet" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dafnycommunity/" class="home-link router-link-active"><img src="/dafnycommunity/img/logo-2.png" alt="Dafny" class="logo"> <span class="site-name can-hide">Dafny</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://s1.ax1x.com/2022/04/01/qh3tDe.png"> <div class="blogger-info"><h3>Dafny</h3> <span>新一代验证语言</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-quick-start</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-tutorials</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>detailed-document</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>publication-lecture</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dafnycommunity/pages/a9363c/" class="sidebar-link">Automatic Induction</a></li><li><a href="/dafnycommunity/pages/30441e/" class="sidebar-link">Calling Lemmas Automatically</a></li><li><a href="/dafnycommunity/pages/746026/" aria-current="page" class="active sidebar-link">Case study of definitions, proofs, algorithm correctness GCD</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_0-problem-description" class="sidebar-link">0. Problem description</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_1-positive-integers" class="sidebar-link">1. Positive integers</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_2-factors" class="sidebar-link">2. Factors</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_3-max-of-a-set" class="sidebar-link">3. Max of a set</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_4-gcd" class="sidebar-link">4. GCD</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_5-properties-of-gcd" class="sidebar-link">5. Properties of GCD</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_6-euclid-s-algorithm" class="sidebar-link">6. Euclid's algorithm</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_7-gcd-subtract-property" class="sidebar-link">7. GCD subtract property</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_8-more-symmetry" class="sidebar-link">8. More symmetry</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_9-main" class="sidebar-link">9. Main</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#_10-conclusions" class="sidebar-link">10. Conclusions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/dafnycommunity/pages/746026/#acknowledgments" class="sidebar-link">Acknowledgments</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/746026/#references" class="sidebar-link">References</a></li></ul></li><li><a href="/dafnycommunity/pages/da6921/" class="sidebar-link">Comprehensions</a></li><li><a href="/dafnycommunity/pages/8d8607/" class="sidebar-link">Different Styles of Proofs</a></li><li><a href="/dafnycommunity/pages/097ba0/" class="sidebar-link">Functions over Set Elements</a></li><li><a href="/dafnycommunity/pages/c4484e/" class="sidebar-link">Iterating over a Collection</a></li><li><a href="/dafnycommunity/pages/7fe522/" class="sidebar-link">old and unchanged</a></li><li><a href="/dafnycommunity/pages/369e25/" class="sidebar-link">Short-Circuit Operators</a></li><li><a href="/dafnycommunity/pages/f8c1c5/" class="sidebar-link">Statement versus Expression Syntax</a></li><li><a href="/dafnycommunity/pages/5a4346/" class="sidebar-link">The Parent Trick for proving termination and a function-by-method use case</a></li><li><a href="/dafnycommunity/pages/c45b5a/" class="sidebar-link">Type-Parameter Completion</a></li><li><a href="/dafnycommunity/pages/3c9a0b/" class="sidebar-link">Type-parameter modes variance and cardinality preservation</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/dafnycommunity/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/dafnycommunity/en-US/#语言" data-v-0c557b5e>语言</a></li><li data-v-0c557b5e><a href="/dafnycommunity/en-US/#publication-lecture" data-v-0c557b5e>publication-lecture</a></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="https://github.com/Aaron-clou" target="_blank" title="作者" class="beLink" data-v-0c557b5e>lijiahai</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-03-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Case study of definitions, proofs, algorithm correctness GCD<!----></h1> <!----> <div class="theme-vdoing-content content__default"><p>Dafny Power User:
Case study of definitions, proofs, algorithm correctness: GCD</p> <p>K. Rustan M. Leino</p> <p>Manuscript KRML 279, 22 June 2021</p> <p><strong>Abstract.</strong> The purpose of this note is to show an example development of a program, introducing definitions that support the specification of the program, stating and proving lemmas about those definitions, and using the lemmas in proving the correctness of the program. Euclid's subtractive algorithm for computing the greatest common divisor is used as the example.</p> <h2 id="_0-problem-description"><a href="#_0-problem-description" class="header-anchor">#</a> 0. Problem description</h2> <p>Let's specify and verify an algorithm to compute the greatest common divisor (GCD) of two numbers. For the specification, we will introduce a function whose definition is intended to be “obviously correct”. We won't use that function to compute the GCD, because the “obviously correct” definition would give really inefficient code if compiled directly. Instead, we'll use Euclid's algorithm for computing the value that the “obviously correct” function defines. We'll prove that the algorithm does compute that value.</p> <p>In essence, we'll have</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Gcd(x: pos, y: pos): pos

method EuclidGcd(x: pos, y: pos) returns (gcd: pos)
  ensures gcd == Gcd(x, y)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>where <code>pos</code> denotes the type of positive integers.</p> <h2 id="_1-positive-integers"><a href="#_1-positive-integers" class="header-anchor">#</a> 1. Positive integers</h2> <p>Everything we do will concern (strictly) positive integers. Dafny builds in a type for natural numbers (that is, non-negative integers), but not positive integers. We can define these using a <em>subset type</em> in Dafny:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>type pos = x | 1 &lt;= x  // error: cannot find witness to show type is inhabited
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Dafny wants to know if this type has any inhabitants, and it doesn't figure that out by itself. This doesn't matter for our example, but we do need to address the error we're getting. To do that, we supply a <code>witness</code> clause:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>type pos = x | 1 &lt;= x witness 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>If we really didn't care to exhibit a witness that shows the type to be nonempty, we could have written <code>witness *</code>, which causes Dafny to treat the type <code>pos</code> as possibly empty. For our example, you can do either, but since it's easy to supply an actual witness, we do that.</p> <p>In the sequel, I will just say <em>number</em> when I mean positive integer.</p> <h2 id="_2-factors"><a href="#_2-factors" class="header-anchor">#</a> 2. Factors</h2> <p>The <em>divisors</em> of a number are its factors. We define a predicate that says what it means for a number <code>p</code> to be a factor of a number <code>x</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>predicate IsFactor(p: pos, x: pos) {
  exists q :: p * q == x
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>In words, <code>p</code> is a factor of <code>x</code> iff there is a multiplicand <code>q</code> such that <code>x</code> is the product <code>p * q</code>.</p> <p>To talk about <em>all</em> the factors of a number, we introduce a function <code>Factors</code> that we define using a set comprehension. A straightforward definition would be:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Factors(x: pos): set&lt;pos&gt; {
  set p: pos | IsFactor(p, x)  // error: set constructed must be finite
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>A <code>set</code> in Dafny denotes a <em>finite</em> set (for possibly infinite sets, use <code>iset</code>). In this case, Dafny doesn't immediately see that the comprehension would generate a finite set. Luckily, it is simple for us to add another conjunct to the comprehension that lets Dafny see that the set is finite:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Factors(x: pos): set&lt;pos&gt; {
  set p: pos | p &lt;= x &amp;&amp; IsFactor(p, x)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>In adding this conjunct, there's a risk we're making a mistake, because perhaps the new set doesn't include all the factors we'd like. Our conjunct <code>p &lt;= x</code> certainly looks innocent enough, but why not prove that adding it does not accidentally leave out any factors. We can do that by proving that this set has the same elements as the possibly infinite set:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma FactorsHasAllFactors(x: pos)
  ensures forall n :: n in Factors(x) &lt;==&gt; n in iset p: pos | IsFactor(p, x)
{
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>The proof of a lemma is given in the lemma's body (that is, between the pair of curly braces that follow the lemma's specification). In this case, the proof is empty, because Dafny proves the lemma automatically without any further help from us.</p> <p>Before leaving the definition of factors, let's state and prove two simple lemmas. These lemmas act as sanity checks on our definitions, and they will also be helpful later in our development.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma FactorsContains1(x: pos)
  ensures 1 in Factors(x)
{
  assert 1 * x == x;
}

lemma FactorsContainsSelf(x: pos)
  ensures x in Factors(x)
{
  assert x * 1 == x;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>To prove that a number <code>n</code> (here, <code>1</code> or <code>x</code>) is in the set <code>Factors(x)</code>, we need to establish that <code>n</code> satisfies the condition in the set comprehension (in the body of <code>Factors(x)</code>). The conjunct <code>n &lt;= x</code> is proved automatically, but the conjunct <code>IsFactor(n, x)</code> is not. By the definition of <code>IsFactor</code>, we need to prove the existence of a multiplicand <code>q</code> for which <code>n * q == x</code>. Such a proof typically involves demonstrating a witness, which is what the <code>assert</code> statements in the two lemmas above do. From those assertions, the verifier completes the proofs of the lemmas.</p> <h2 id="_3-max-of-a-set"><a href="#_3-max-of-a-set" class="header-anchor">#</a> 3. Max of a set</h2> <p>To talk about the <em>greatest</em> common divisor, we need a function that picks out the largest number in a set. A somewhat declarative way to do that is to use the such-that construct. In particular, for a set <code>s</code>, the let-such-that expression</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>var x :| x in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= x;
x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>says to bind <code>x</code> to a value satisfying the condition <code>x in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= x</code>, and then return the value of the expression <code>x</code>. The condition says that <code>x</code> is in the set <code>s</code>, and that, among all the numbers in <code>s</code>, <code>x</code> is the largest.</p> <p>Use of a such-that construct comes with a proof obligation that a value satisfying the given condition exists. If we require <code>s</code> to be nonempty, then the <code>x in s</code> condition is easily satisfied, but it takes more work to convince the verifier that a value for <code>x</code> satisfies the quantifier. We'll define a lemma for that purpose. We'll name the lemma <code>MaxExists</code> and then we can write our function <code>Max</code> as follows:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Max(s: set&lt;pos&gt;): pos
  requires s != {}
{
  MaxExists(s);
  var x :| x in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= x;
  x
}

lemma MaxExists(s: set&lt;pos&gt;)
  requires s != {}
  ensures exists x :: x in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Dafny uses the lemma invocation <code>MaxExists(s)</code> in establishing the well-formedness of the subsequent expression. Note, by the way, that <code>Max</code> (and lemma <code>MaxExists</code>, too) has a precondition <code>s != {}</code> (keyword <code>requires</code>). This means that the function (and the lemma, too) can only be called for a nonempty set.</p> <p>Alright, so then how do we prove <code>MaxExists</code>? The most straightforward way to prove the existence of such an <code>x</code> is to compute an <code>x</code> satisfying the desired properties. We'll introduce another function for computing the max, call it <code>FindMax</code>, and use it in the proof of the <code>MaxExists</code> lemma. Function <code>FindMax</code> will be implemented recursively.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma MaxExists(s: set&lt;pos&gt;)
  requires s != {}
  ensures exists x :: x in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= x
{
  var x := FindMax(s);
}
 
function FindMax(s: set&lt;pos&gt;): pos
  requires s != {}
  ensures max in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= FindMax(s)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Aren't we going in circles now? Yes, in some ways we're making life more difficult than necessary. If we have <code>FindMax</code>, we don't need <code>Max</code>, and then we also don't need lemma <code>MaxExists</code>. Indeed, we could have written and used just <code>FindMax</code> and never introduced <code>Max</code> or <code>MaxExists</code>. But for this example, I wanted the primary definitions to be as clear as possible without concern for <em>how</em> things are computed. In that sense, the body of <code>Max</code> is more declarative than the body we are about to write for <code>FindMax</code>.</p> <p>Here is the full definition of <code>FindMax</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function FindMax(s: set&lt;pos&gt;): (max: pos)
  requires s != {}
  ensures max in s &amp;&amp; forall y :: y in s ==&gt; y &lt;= max
{
  var x :| x in s;
  if s == {x} then
    x
  else
    var s' := s - {x};
    assert s == s' + {x};
    var y := FindMax(s');
    if x &lt; y then y else x
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>When a function postcondition wants to mention the result value of the function, you can just use the function itself, with the arguments given: <code>FindMax(s)</code>. I did this when I first introduced <code>FindMax</code> above. In the full definition, I show an alternative way of doing this, which is to introduce a name for the result value: <code>max</code>. That name is usable only in the postcondition of the function. Many times, introducing such a name for the result leads to a shorter specification.</p> <h2 id="_4-gcd"><a href="#_4-gcd" class="header-anchor">#</a> 4. GCD</h2> <p>With the functions we defined, we're now ready to define GCD. Take the factors of <code>x</code> and the factors of <code>y</code>, intersect them to get their common factors, and then take the maximum thereof:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Gcd(x: pos, y: pos): pos {
  var common := Factors(x) * Factors(y);
  Max(common)  // error: common must be nonempty
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>For this simple definition, the verifier reports a precondition violation, because it's unable to prove that <code>common</code> satisfies the precondition of <code>Max</code>. We know that <code>common</code> is nonempty, because we know that <code>1</code> is a common factor of any two numbers <code>x</code> and <code>y</code>. To bring that information to the verifier's attention, we write an assertion:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Gcd(x: pos, y: pos): pos {
  var common := Factors(x) * Factors(y);
  assert 1 in common;  // error: assertion violation
  Max(common)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Alas, the verifier is not able to prove this assertion. But we can see that the presence of the assertion is enough to eliminate the precondition violation. So, we now focus on proving the assertion. This is where we use the <code>FactorsContains1</code> lemma we introduced earlier. Two calls to that lemma will prove the assertion, which is best captured in the program text by changing the <code>assert</code> to an <code>assert by</code> and giving the proof of the assertion in the <code>by</code> block:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Gcd(x: pos, y: pos): pos {
  var common := Factors(x) * Factors(y);
  assert 1 in common by {
    FactorsContains1(x);
    FactorsContains1(y);
  }
  Max(common)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>That does it! We have now given a well-formed definition of <code>Gcd</code>.</p> <h2 id="_5-properties-of-gcd"><a href="#_5-properties-of-gcd" class="header-anchor">#</a> 5. Properties of GCD</h2> <p>We'll prove three properties of our <code>Gcd</code> function—call them sanity checks, if you will. (We'll need a fourth property as well, but I'll introduce it later.)</p> <p>As a first sanity check, we expect <code>Gcd(x, y)</code> to return a number that is a factor of both <code>x</code> and <code>y</code>. Furthermore, among all the numbers that are factors of both <code>x</code> and <code>y</code>, what <code>Gcd(x, y)</code> returns should be the largest.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma AboutGcd(x: pos, y: pos)
  ensures IsFactor(Gcd(x, y), x)
  ensures IsFactor(Gcd(x, y), y)
  ensures forall p: pos :: IsFactor(p, x) &amp;&amp; IsFactor(p, y) ==&gt; p &lt;= Gcd(x, y)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>The first two postconditions of this lemma are proved automatically, but not the third. How do we go about proving that a universal quantifier (that is, a <code>forall</code> expression) holds? We use Dafny's <code>forall</code> <em>statement</em>. When used in a proof, the <code>forall</code> statement corresponds to the “universal introduction” rule in logic. This is the rule that says &quot;if you want to prove <code>forall x :: P(x)</code>, then all you need to do is pick an arbitrary <code>x</code> and prove <code>P(x)</code> for that <code>x</code>.</p> <p>We introduce the <code>forall</code> statement like this:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  forall p: pos | IsFactor(p, x) &amp;&amp; IsFactor(p, y)
    ensures p &lt;= Gcd(x, y)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>To prove it, we only need to bring up the fact that <code>p</code>, which is a factor of both <code>x</code> and <code>y</code>, is in the intersection of factors of <code>x</code> and <code>y</code>. The verifier is then able to complete the proof.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma AboutGcd(x: pos, y: pos)
  ensures IsFactor(Gcd(x, y), x)
  ensures IsFactor(Gcd(x, y), y)
  ensures forall p: pos :: IsFactor(p, x) &amp;&amp; IsFactor(p, y) ==&gt; p &lt;= Gcd(x, y)
{
  forall p: pos | IsFactor(p, x) &amp;&amp; IsFactor(p, y)
    ensures p &lt;= Gcd(x, y)
  {
    assert p in Factors(x) * Factors(y);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>The Dafny verifier often needs help with properties like this. To prove them, just write them as an assertion. In other words, the verifier <em>knows</em> this property about set intersection, but it isn't creative enough the bring that property into the proof. By asserting the property, we're asking the verifier to confirm the property (which it's able to do) and then to use that property in the rest of the proof (which in this case completes the proof).</p> <p>As a second sanity check, we prove that <code>Gcd</code> is symmetric.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma GcdSymmetric(x: pos, y: pos)
  ensures Gcd(x, y) == Gcd(y, x)
{
  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The proof comes down to the fact that set intersection is symmetric, which we bring to the verifier's attention by writing it as a lemma.</p> <p>As a third sanity check, we prove that <code>Gcd</code> is idempotent. That is, if you give it the same argument twice, it will return that argument.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma GcdIdempotent(x: pos)
  ensures Gcd(x, x) == x
{
  FactorsContainsSelf(x);
  assert x in Factors(x) * Factors(x);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The proof of this property comes down to the fact that set intersection is idempotent, as well as the property that a number is one of its own factors.</p> <h2 id="_6-euclid-s-algorithm"><a href="#_6-euclid-s-algorithm" class="header-anchor">#</a> 6. Euclid's algorithm</h2> <p>Euclid's subtractive algorithm for finding the GCD of two numbers is to repeatedly subtract the smaller of the numbers from the larger until they are both equal. Each such subtraction preserves the GCD—an invariant that we will need to prove—and the GCD of two equal numbers is that number—which we established by lemma <code>GcdIdempotent</code> above.</p> <p>The algorithm, with the loop invariant and idempotence lemma, thus looks like this:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>method EuclidGcd(X: pos, Y: pos) returns (gcd: pos)
  ensures gcd == Gcd(X, Y)
{
  var x, y := X, Y;
  while
    invariant Gcd(x, y) == Gcd(X, Y)  // error: invariant not maintained
    decreases x + y
  {
    case x &lt; y =&gt;
      y := y - x;
    case y &lt; x =&gt;
      x := x - y;
  }
  GcdIdempotent(x);
  return x;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>This method uses a <code>while</code>-<code>case</code> loop. (If you're familiar with Dijkstra's guarded commands [<a href="http://leino.science/papers/krml279.html#dijkstra:discipline" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>], this is the <strong>do-od</strong> loop.) Each iteration of this loop chooses one of the <code>case</code>s to execute. The <code>case</code> chosen must be one whose guard condition evaluates to <code>true</code> (and if the guards of several <code>case</code>s evaluate to <code>true</code>, the loop chooses arbitrarily between those <code>case</code>s) . If no such guard condition evaluates to <code>true</code>, then the loop stops iterating. The loop in <code>EuclidGcd</code> could of course be an ordinary <code>while x != y</code> loop, but the symmetry of the two cases afforded by the <code>while</code>-<code>case</code> loop makes it aesthetically pleasing.</p> <p>In addition to a loop invariant, the loop also declares a termination metric (keyword <code>decreases</code>). Proving that the loop terminates comes down to proving that each iteration makes the value of the termination metric decrease (in Dafny's built-in well-founded order on integers).</p> <p>The <code>EuclidGcd</code> method above does not verify, because the verifier is unable to prove that each iteration maintains the loop invariant. For this, we need the fourth property of GCD that I alluded to above:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma GcdSubtract(x: pos, y: pos)
  requires x &lt; y
  ensures Gcd(x, y) == Gcd(x, y - x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Using this lemma and the symmetry of GCD, we can complete the proof of <code>Gcd</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>method EuclidGcd(X: pos, Y: pos) returns (gcd: pos)
  ensures gcd == Gcd(X, Y)
{
  var x, y := X, Y;
  while
    invariant Gcd(x, y) == Gcd(X, Y)
    decreases x + y
  {
    case x &lt; y =&gt;
      GcdSubtract(x, y);
      y := y - x;
    case y &lt; x =&gt;
      calc {
        Gcd(x, y);
      ==  { GcdSymmetric(x, y); }
        Gcd(y, x);
      ==  { GcdSubtract(y, x); }
        Gcd(y, x - y);
      ==  { GcdSymmetric(y, x - y); }
        Gcd(x - y, y);
      }
      x := x - y;
  }
  GcdIdempotent(x);
  return x;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>This version adds a call to <code>GcdSubtract</code> in the first branch of the loop. In the second branch of the loop, the proof calculation uses equality-preserving steps to transform the expression <code>Gcd(x, y)</code> into <code>Gcd(x - y, y)</code>. The hints given in the steps appeal to the <code>GcdSubtract</code> and <code>GcdSymmetric</code> lemmas.</p> <h2 id="_7-gcd-subtract-property"><a href="#_7-gcd-subtract-property" class="header-anchor">#</a> 7. GCD subtract property</h2> <p>The proof of <code>GcdSubtract</code> is more involved than any of the other definitions and lemmas in this case study.</p> <p>The proof starts by introducing a name for <code>Gcd(x, y)</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  var p := Gcd(x, y);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>We know from the definition of <code>Gcd</code> that <code>p</code> is a factor of both <code>x</code> and <code>y</code>, and we can prove that <code>p</code> is also a factor of <code>y - x</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  assert IsFactor(p, y - x) by {
    var a :| p * a == x;
    var b :| p * b == y;
    calc {
      y - x;
    ==
      p * b - p * a;
    ==
      p * (b - a);
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>To prove <code>IsFactor(p, y - x)</code>, we introduce names <code>a</code> and <code>b</code> for the multiplicands that the definition of <code>IsFactor</code> tells us exist (since <code>p</code> is a factor of both <code>x</code> and <code>y</code>). A simple calculation using basic arithmetic steps then gives us that <code>p</code> can be multiplied another number (namely, <code>b - a</code>) to get <code>y - x</code>.</p> <p>Since <code>p</code> is a factor of both <code>x</code> and <code>y - x</code>, we have that it's in the common factors of <code>x</code> and <code>y - x</code>. We write two lines to make sure the verifier is on board with this property, phrased in terms of set intersection:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  var common := Factors(x) * Factors(y - x);
  assert p in common;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Lastly, we need to show that <code>p</code> is the largest such common factor. We state this property using a <code>forall</code> statement:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  forall q | q in common
    ensures q &lt;= p
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>To prove this property, we fill in the body of the <code>forall</code> statement. For <code>q</code>, which denotes an arbitrary number in the set <code>common</code>, we give names to the multiplicands that yield the products <code>x</code> and <code>y - x</code>, respectively:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  {
    var a :| q * a == x;
    var b :| q * b == y - x;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Using simple arithmetic steps, we can use a proof calculation to establish that <code>q</code> is also a factor of <code>y</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>    assert IsFactor(q, y) by {
      calc {
        y;
      ==
        x + (y - x);
      ==
        q * a + q * b;
      ==
        q * (a + b);
      }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>So, since <code>q</code> is a factor of both <code>x</code> and <code>y</code>, the definition of <code>Gcd(x, y)</code> tells us <code>q &lt;= Gcd(x, y)</code>. By giving yet another hint about set intersection:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>    assert q in Factors(x) * Factors(y);
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>the verifier completes the proof.</p> <h2 id="_8-more-symmetry"><a href="#_8-more-symmetry" class="header-anchor">#</a> 8. More symmetry</h2> <p>While we now have a full proof of the GCD algorithm, your aesthetic sense may be bothered by the asymmetry in how we supplied the proofs in the two cases of the loop. Since the <code>while</code>-<code>case</code> loop affords us a symmetric rendition of the two cases, it would be nice if we could make the proofs of the two cases more similar as well.</p> <p>There are several ways we can improve on this situation. One is to refactor the proof calculation of the second <code>case</code> into its own lemma. Then, then each <code>case</code> would have one line of proof.</p> <p>Just for fun, let me describe another “trick” to make the two cases (not <em>entirely</em> symmetric, but at least) <em>more</em> similar. The trick is to make the (already asymmetric) <code>GcdSubtract</code> lemma also swap the arguments to <code>Gcd</code>. We rewrite it into:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma GcdSubtract(x: pos, y: pos)
  requires x &lt; y
  ensures Gcd(y, x) == Gcd(x, y - x)
{
  GcdSymmetric(x, y);
  // ... the proof continues as before
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Note that the left-hand side of the postcondition is now <code>Gcd(y, x)</code>, not <code>Gcd(x, y)</code> as it had been in our first version of this lemma. The only change required for the proof is to appeal to the symmetry of <code>Gcd</code>, which we can do by one lemma call immediately inside the body of the lemma. This gives us a proof of our reformulated <code>GcdSubtract</code> lemma.</p> <p>With this reformulation, we can simplify the second <code>case</code> of <code>EuclidGcd</code>, at the expense of making the first <code>case</code> more complicated. Essentially, we're moving one lemma call from the second <code>case</code> to the first, so instead of having 1 and 3 lemma calls in the two respective <code>case</code>s, we'll have 2 and 2.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>    case x &lt; y =&gt;
      GcdSubtract(x, y);
      GcdSymmetric(y, x);
      y := y - x;
    case y &lt; x =&gt;
      GcdSymmetric(x - y, y);
      GcdSubtract(y, x);
      x := x - y;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>It's not entirely symmetric, but perhaps you still like it. Or perhaps you'll remember this trick for another situation where the shoe fits perfectly. If nothing else, you can stick with the first complete proof we developed above.</p> <h2 id="_9-main"><a href="#_9-main" class="header-anchor">#</a> 9. Main</h2> <p>If the proof itself doesn't satisfy you and still want to see the algorithm in action, you can write a <code>Main</code> method and compile and run the program. (A simple way of doing that from the command line is to use the <code>/compile:3</code> option with the <code>dafny</code> tool. It will verify and then run the program.)</p> <p>Here is a sample <code>Main</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>method Main() {
  Test(15, 9);
  Test(14, 22);
  Test(371, 1);
  Test(1, 2);
  Test(1, 1);
  Test(13, 13);
  Test(60, 60);
}

method Test(x: pos, y: pos) {
  var gcd := EuclidGcd(x, y);
  print x, &quot; gcd &quot;, y, &quot;  =  &quot;, gcd, &quot;\n&quot;;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_10-conclusions"><a href="#_10-conclusions" class="header-anchor">#</a> 10. Conclusions</h2> <p>This case study shows how to define a domain of interest (here, factors of numbers, leading up to the definition of GCD), state and prove some lemmas about those definitions, and then use these in the proof of a small program.</p> <p>The program, including all lemmas and other proof obligations associated with the definitions, takes the Dafny verifier less than 3 seconds to verify. You can find the entire program in the Dafny test suite [<a href="http://leino.science/papers/krml279.html#leino:gcd" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>].</p> <p>Euclid's GCD algorithm is a familiar textbook example. It's proved in different forms in various verifiers. For example, the TLA+ tutorial uses this program as an example [<a href="http://leino.science/papers/krml279.html#tla:tutorial" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]. It assumes the mathematical properties of GCD that we proved here. The gallery of Why3 programs contains a version of Euclid's GCD algorithm that uses modulo instead of subtraction with each step, which results in fewer iterations [<a href="http://leino.science/papers/krml279.html#why3:gcd" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>].</p> <h4 id="acknowledgments"><a href="#acknowledgments" class="header-anchor">#</a> Acknowledgments</h4> <p>I thank Reto Kramer for suggesting this problem as a useful case study.</p> <h2 id="references"><a href="#references" class="header-anchor">#</a> References</h2> <p>[0]TLA proof system. <a href="https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html" target="_blank" rel="noopener noreferrer">https://tla.msr-inria.inria.fr/tlaps/content/Documentation/Tutorial/The_example.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <a href="http://www.bing.com/search?q=+++proof+system+https+inria+inria+tlaps+content+Documentation+Tutorial+The_example+html++" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[1]Edsger W. Dijkstra. <em>A Discipline of Programming</em>. Prentice Hall, Englewood Cliffs, NJ, 1976. <a href="http://www.bing.com/search?q=+Discipline+Programming_++Edsger+Dijkstra+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[2]Jean-Christophe Filliâtre and Claude Marché. Greatest common divisor, using the euclidean algorithm. <a href="http://toccata.lri.fr/gallery/gcd.en.html" target="_blank" rel="noopener noreferrer">http://toccata.lri.fr/gallery/gcd.en.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <a href="http://www.bing.com/search?q=Greatest+common+divisor+using+euclidean+algorithm++Jean+Christophe+Filli+Claude+March+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[3]K. Rustan M. Leino. gcd.dfy. <a href="https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy" target="_blank" rel="noopener noreferrer">https://github.com/dafny-lang/dafny/blob/master/Test/dafny4/gcd.dfy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, June 2021. <a href="http://www.bing.com/search?q=+++Rustan+Leino+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/aaron-clou/dafnycommunity/edit/master/docs/80.语言/30.publication-lecture/10.Case study of definitions, proofs, algorithm correctness GCD.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/03/26, 14:38:56</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/dafnycommunity/pages/30441e/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Calling Lemmas Automatically</div></a> <a href="/dafnycommunity/pages/da6921/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Comprehensions</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/dafnycommunity/pages/30441e/" class="prev">Calling Lemmas Automatically</a></span> <span class="next"><a href="/dafnycommunity/pages/da6921/">Comprehensions</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/dafnycommunity/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/dafnycommunity/pages/0978ce/"><div>
            寻找最大和最小数
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>02</dd> <dt><a href="/dafnycommunity/pages/e3e481/"><div>
            斐波那契数列
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>03</dd> <dt><a href="/dafnycommunity/pages/02fdef/"><div>
            线性查询
            <!----></div></a> <span class="date">04-06</span></dt></dl> <dl><dd></dd> <dt><a href="/dafnycommunity/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Aaron-clou/dafnycommunity" title="Github" target="_blank" class="iconfont icon-github-fill"></a><a href="https://gitee.com/leo214/dafnycommunity" title="Gitee" target="_blank" class="iconfont icon-gitee2"></a><a href="1374921025@qq.com" title="Email" target="_blank" class="iconfont icon-email-fill"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Li Jiahai | Dafny Community | 2022</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><!----><div id="tcomment"></div><div></div></div></div>
    <script src="/dafnycommunity/assets/js/app.99d07194.js" defer></script><script src="/dafnycommunity/assets/js/2.ab4658c0.js" defer></script><script src="/dafnycommunity/assets/js/76.bebf75c9.js" defer></script><script src="/dafnycommunity/assets/js/7.5451cfed.js" defer></script><script src="/dafnycommunity/assets/js/4.06497870.js" defer></script>
  </body>
</html>
