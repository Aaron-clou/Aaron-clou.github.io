<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>The Parent Trick for proving termination and a function-by-method use case | Dafny</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/dafnycommunity/img/bgico2.ico">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3282046_1qux519eoim.css">
    <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"></script>
    <meta name="description" content="Dafny中文社区">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css" as="style"><link rel="preload" href="/dafnycommunity/assets/js/app.99d07194.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/2.ab4658c0.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/84.085ef3f8.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/7.5451cfed.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/4.06497870.js" as="script"><link rel="prefetch" href="/dafnycommunity/assets/js/10.ac38cab7.js"><link rel="prefetch" href="/dafnycommunity/assets/js/11.38d5ee16.js"><link rel="prefetch" href="/dafnycommunity/assets/js/12.c434ce94.js"><link rel="prefetch" href="/dafnycommunity/assets/js/13.4e922264.js"><link rel="prefetch" href="/dafnycommunity/assets/js/14.db841cfa.js"><link rel="prefetch" href="/dafnycommunity/assets/js/15.b9c227cc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/16.41dadc32.js"><link rel="prefetch" href="/dafnycommunity/assets/js/17.48b5f1eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/18.ec254833.js"><link rel="prefetch" href="/dafnycommunity/assets/js/19.288ca382.js"><link rel="prefetch" href="/dafnycommunity/assets/js/20.cfeb5fdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/21.ce8ddc5a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/22.1b8c89f0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/23.cb062ace.js"><link rel="prefetch" href="/dafnycommunity/assets/js/24.ff271672.js"><link rel="prefetch" href="/dafnycommunity/assets/js/25.5541f3af.js"><link rel="prefetch" href="/dafnycommunity/assets/js/26.a1bbc4cb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/27.522d7884.js"><link rel="prefetch" href="/dafnycommunity/assets/js/28.9335c003.js"><link rel="prefetch" href="/dafnycommunity/assets/js/29.3fc0b07a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/3.ab8a97d8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/30.57708681.js"><link rel="prefetch" href="/dafnycommunity/assets/js/31.8571b949.js"><link rel="prefetch" href="/dafnycommunity/assets/js/32.f91be5de.js"><link rel="prefetch" href="/dafnycommunity/assets/js/33.8089c59b.js"><link rel="prefetch" href="/dafnycommunity/assets/js/34.874d0299.js"><link rel="prefetch" href="/dafnycommunity/assets/js/35.aff8adfd.js"><link rel="prefetch" href="/dafnycommunity/assets/js/36.ac78b86e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/37.3fae0334.js"><link rel="prefetch" href="/dafnycommunity/assets/js/38.3db4a8d6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/39.e585cc70.js"><link rel="prefetch" href="/dafnycommunity/assets/js/40.afcb8fbe.js"><link rel="prefetch" href="/dafnycommunity/assets/js/41.01f314da.js"><link rel="prefetch" href="/dafnycommunity/assets/js/42.8e4fe21d.js"><link rel="prefetch" href="/dafnycommunity/assets/js/43.571fb232.js"><link rel="prefetch" href="/dafnycommunity/assets/js/44.14aebad2.js"><link rel="prefetch" href="/dafnycommunity/assets/js/45.32f18970.js"><link rel="prefetch" href="/dafnycommunity/assets/js/46.ce0d522f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/47.0bd83351.js"><link rel="prefetch" href="/dafnycommunity/assets/js/48.648f667a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/49.83709ae0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/5.b8548e7f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/50.060e0424.js"><link rel="prefetch" href="/dafnycommunity/assets/js/51.a1291856.js"><link rel="prefetch" href="/dafnycommunity/assets/js/52.45f73497.js"><link rel="prefetch" href="/dafnycommunity/assets/js/53.525782ca.js"><link rel="prefetch" href="/dafnycommunity/assets/js/54.45a04a86.js"><link rel="prefetch" href="/dafnycommunity/assets/js/55.65a94ba0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/56.2d038113.js"><link rel="prefetch" href="/dafnycommunity/assets/js/57.579db650.js"><link rel="prefetch" href="/dafnycommunity/assets/js/58.832d4c89.js"><link rel="prefetch" href="/dafnycommunity/assets/js/59.13befb53.js"><link rel="prefetch" href="/dafnycommunity/assets/js/6.349bf431.js"><link rel="prefetch" href="/dafnycommunity/assets/js/60.41227bb1.js"><link rel="prefetch" href="/dafnycommunity/assets/js/61.1d1b92f4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/62.2cdbc236.js"><link rel="prefetch" href="/dafnycommunity/assets/js/63.83de9482.js"><link rel="prefetch" href="/dafnycommunity/assets/js/64.4ecd0d25.js"><link rel="prefetch" href="/dafnycommunity/assets/js/65.25118b81.js"><link rel="prefetch" href="/dafnycommunity/assets/js/66.cdab1b54.js"><link rel="prefetch" href="/dafnycommunity/assets/js/67.655e6e84.js"><link rel="prefetch" href="/dafnycommunity/assets/js/68.84effb44.js"><link rel="prefetch" href="/dafnycommunity/assets/js/69.8f07f81a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/70.d9a299e6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/71.16ef2000.js"><link rel="prefetch" href="/dafnycommunity/assets/js/72.8252acc5.js"><link rel="prefetch" href="/dafnycommunity/assets/js/73.f53e39bc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/74.5ef910c4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/75.72174d00.js"><link rel="prefetch" href="/dafnycommunity/assets/js/76.bebf75c9.js"><link rel="prefetch" href="/dafnycommunity/assets/js/77.b85547c7.js"><link rel="prefetch" href="/dafnycommunity/assets/js/78.a0a1f574.js"><link rel="prefetch" href="/dafnycommunity/assets/js/79.a731d645.js"><link rel="prefetch" href="/dafnycommunity/assets/js/8.522ce892.js"><link rel="prefetch" href="/dafnycommunity/assets/js/80.6e5b64b0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/81.6e19e312.js"><link rel="prefetch" href="/dafnycommunity/assets/js/82.9244e788.js"><link rel="prefetch" href="/dafnycommunity/assets/js/83.f08c5aed.js"><link rel="prefetch" href="/dafnycommunity/assets/js/85.c41e6e0e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/86.e3798708.js"><link rel="prefetch" href="/dafnycommunity/assets/js/87.fdac1c1c.js"><link rel="prefetch" href="/dafnycommunity/assets/js/88.665ac8c8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/89.78dc55eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/9.4d4f4bdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/90.4757b202.js"><link rel="prefetch" href="/dafnycommunity/assets/js/91.a0746cf2.js">
    <link rel="stylesheet" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dafnycommunity/" class="home-link router-link-active"><img src="/dafnycommunity/img/logo-2.png" alt="Dafny" class="logo"> <span class="site-name can-hide">Dafny</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://s1.ax1x.com/2022/04/01/qh3tDe.png"> <div class="blogger-info"><h3>Dafny</h3> <span>新一代验证语言</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-quick-start</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-tutorials</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>detailed-document</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>publication-lecture</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dafnycommunity/pages/a9363c/" class="sidebar-link">Automatic Induction</a></li><li><a href="/dafnycommunity/pages/30441e/" class="sidebar-link">Calling Lemmas Automatically</a></li><li><a href="/dafnycommunity/pages/746026/" class="sidebar-link">Case study of definitions, proofs, algorithm correctness GCD</a></li><li><a href="/dafnycommunity/pages/da6921/" class="sidebar-link">Comprehensions</a></li><li><a href="/dafnycommunity/pages/8d8607/" class="sidebar-link">Different Styles of Proofs</a></li><li><a href="/dafnycommunity/pages/097ba0/" class="sidebar-link">Functions over Set Elements</a></li><li><a href="/dafnycommunity/pages/c4484e/" class="sidebar-link">Iterating over a Collection</a></li><li><a href="/dafnycommunity/pages/7fe522/" class="sidebar-link">old and unchanged</a></li><li><a href="/dafnycommunity/pages/369e25/" class="sidebar-link">Short-Circuit Operators</a></li><li><a href="/dafnycommunity/pages/f8c1c5/" class="sidebar-link">Statement versus Expression Syntax</a></li><li><a href="/dafnycommunity/pages/5a4346/" aria-current="page" class="active sidebar-link">The Parent Trick for proving termination and a function-by-method use case</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_0-motivating-example-sets-of-strings" class="sidebar-link">0. Motivating example: sets of strings</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_1-two-mutually-recursive-functions" class="sidebar-link">1. Two mutually recursive functions</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_2-why-the-parent-trick-works" class="sidebar-link">2. Why the Parent Trick works</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_3-two-more-remarks" class="sidebar-link">3. Two more remarks</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_4-segue-into-an-arduous-journey" class="sidebar-link">4. Segue into an arduous journey</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_5-making-a-unique-choice" class="sidebar-link">5. Making a unique choice</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_6-restructuring-the-recursion" class="sidebar-link">6. Restructuring the recursion</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_7-a-more-efficient-choice" class="sidebar-link">7. A more efficient choice</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_8-function-by-method" class="sidebar-link">8. Function-by-method</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_9-max-as-a-function-by-method" class="sidebar-link">9. Max as a function-by-method</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_10-a-more-common-situation" class="sidebar-link">10. A more common situation</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_11-naming-the-choice" class="sidebar-link">11. Naming the choice</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_12-what-you-remove-may-differ-from-what-you-just-added" class="sidebar-link">12. What you remove may differ from what you just added</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_13-termination" class="sidebar-link">13. Termination</a></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#_14-summary" class="sidebar-link">14. Summary</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/dafnycommunity/pages/5a4346/#acknowledgments" class="sidebar-link">Acknowledgments</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/5a4346/#references" class="sidebar-link">References</a></li></ul></li><li><a href="/dafnycommunity/pages/c45b5a/" class="sidebar-link">Type-Parameter Completion</a></li><li><a href="/dafnycommunity/pages/3c9a0b/" class="sidebar-link">Type-parameter modes variance and cardinality preservation</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/dafnycommunity/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/dafnycommunity/en-US/#语言" data-v-0c557b5e>语言</a></li><li data-v-0c557b5e><a href="/dafnycommunity/en-US/#publication-lecture" data-v-0c557b5e>publication-lecture</a></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="https://github.com/Aaron-clou" target="_blank" title="作者" class="beLink" data-v-0c557b5e>lijiahai</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-03-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">The Parent Trick for proving termination and a function-by-method use case<!----></h1> <!----> <div class="theme-vdoing-content content__default"><p>Dafny Power User:
The Parent Trick for proving termination, and a function-by-method use case</p> <p>K. Rustan M. Leino</p> <p>Manuscript KRML 283, 11 February 2022</p> <p><strong>Abstract.</strong> This note proves termination for a common situation of mutually recursive functions. After that, it takes an arduous journey to turn an aggregating set operation into compiled code, which gives an opportunity to showcase Dafny's <code>function-by-method</code> construct.</p> <h2 id="_0-motivating-example-sets-of-strings"><a href="#_0-motivating-example-sets-of-strings" class="header-anchor">#</a> 0. Motivating example: sets of strings</h2> <p>A nonempty prefix-closed set <code>S</code> of strings can be stored as a DAG where each edge is labeled with one character. The presence in <code>S</code> of a string <code>L</code> is represented by the presence of a path from the root of the DAG through edges whose labels, in order, spell out <code>L</code>. For example, a DAG that represents the set <code>{&quot;&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;b&quot;}</code> is</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>            Node (root)
            /  \
           a    b
          /      \
        Node      |
          \       |
           b      |
            \    /
             Node
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>We declare the data structure for storing such sets of strings as follows:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>datatype StringSet = Node(children: map&lt;char, StringSet&gt;)

predicate In(s: string, tree: StringSet) {
   s == &quot;&quot; ||
   var ch := s[0];
      ch in tree.children.Keys &amp;&amp;
      In(s[1..], tree.children[ch])
}

lemma Examples() {
  var tree :=
    var empty := Node(map[]);
    var n := Node(map['b' := empty]);
    Node(map['a' := n, 'b' := empty]);
  assert In(&quot;&quot;, tree);
  assert In(&quot;ab&quot;, tree);
  assert !In(&quot;xyz&quot;, tree);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_1-two-mutually-recursive-functions"><a href="#_1-two-mutually-recursive-functions" class="header-anchor">#</a> 1. Two mutually recursive functions</h2> <p>Let's write a function that computes the length of the longest string in the set. We'll do it using two mutually recursive functions (and a helper function <code>Maximum</code>).</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function MaxLen(tree: StringSet): nat {
  if tree.children == map[] then
    0
  else
    1 + MaxLenForest(tree.children.Values)
}

function MaxLenForest(trees: set&lt;StringSet&gt;): nat {
  if trees == {} then
    0
  else
    var t :| t in trees;
    var m := MaxLen(t);
    var n := MaxLenForest(trees - {t});
    Maximum(m, n)
}

function Maximum(x: int, y: int): int {
  if x &lt; y then y else x
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>But herein lies a problem: proving termination. As it stands, the verifier complains that it cannot prove termination for the call from <code>MaxLen</code> to <code>MaxLenForest</code> or for the call from <code>MaxLenForest</code> to <code>MaxLen</code>. (But it is able to prove termination for the recursive call to <code>MaxLenForest</code>.)</p> <p>Let's remind ourselves of what the <code>decreases</code> clauses for the two functions are, since we didn't write them explicitly and thus get Dafny's defaults. If you hover over the functions in the IDE, you'll discover that the <code>decreases</code> clauses that Dafny used are the following:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function MaxLen(tree: StringSet): nat
  decreases tree

function MaxLenForest(trees: set&lt;StringSet&gt;): nat
  decreases trees
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Termination for the recursive call of <code>MaxLenForest</code> verifies, because <code>trees - {t}</code> is smaller than <code>tree</code>. But for the other two calls, it's no wonder that termination cannot be proved, since Dafny's built-in well-founded order does not relate datatypes (here, <code>StringSet</code>) and sets.</p> <p>If we could arrange for the <code>decreases</code> clauses to have the same type, or at least that the types of one is a prefix of the types of the other, we may be able to make progress. This can be done by thinking of <code>MaxLenForest</code> as operating in “the context of” an enclosing tree, that is, the “parent” tree of the forest. Adding such a <code>parent</code> parameter to <code>MaxLenForest</code> and, for the purpose of this presentation, showing the default <code>decreases</code> clauses explicitly, we get:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function MaxLen(tree: StringSet): nat
  decreases tree
{
  if tree.children == map[] then
    0
  else
    1 + MaxLenForest(tree, tree.children.Values)
}

function MaxLenForest(parent: StringSet, trees: set&lt;StringSet&gt;): nat
  decreases parent, trees
{
  if trees == {} then
    0
  else
    var t :| t in trees;
    var m := MaxLen(t);
    var n := MaxLenForest(parent, trees - {t});
    Maximum(m, n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>This is a little better, because now the verifier can prove the termination of the call from <code>MaxLen</code> to <code>MaxLenForest</code>. The reason it can do that is that Dafny's lexicographic ordering considers the 2-tuple <code>tree, tree.children.Values</code> to be smaller than the 1-tuple <code>tree</code>.</p> <p>But we still need to prove termination of the call from <code>MaxLenForest</code> back to <code>MaxLen</code>. We'd like to argue that this call terminates because <code>t</code> is “smaller than”—that is, structurally included in—the enclosing parent. But this information is not spelled out in the program. To make the information available, we need to write a precondition for <code>MaxLenForest</code> that says that the forest in enclosed in <code>parent</code>. Dafny allows operator <code>&lt;</code> to be used with datatypes, with the meaning of “structurally included in”.</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function MaxLen(tree: StringSet): nat
  decreases tree
{
  if tree.children == map[] then
    0
  else
    1 + MaxLenForest(tree, tree.children.Values)
}

function MaxLenForest(parent: StringSet, trees: set&lt;StringSet&gt;): nat
  requires forall t :: t in trees ==&gt; t &lt; parent
  decreases parent, trees
{
  if trees == {} then
    0
  else
    var t :| t in trees;
    var m := MaxLen(t);
    var n := MaxLenForest(parent, trees - {t});
    Maximum(m, n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>With that precondition, the verifier completes the proof of the program.</p> <h2 id="_2-why-the-parent-trick-works"><a href="#_2-why-the-parent-trick-works" class="header-anchor">#</a> 2. Why the Parent Trick works</h2> <p>So, although Dafny's well-founded order does not relate datatypes and sets, even for a set that is structurally included in a datatype value, the verifier does know that <em>the elements</em> of that set (assuming the type of the elements is a datatype) are structurally included in the parent. In symbols, the well-founded order does not let you prove</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>tree.children &lt; tree
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>but it does let you prove</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>tree.children[i] &lt; tree
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>for any <code>i</code> in range. This is why “the parent trick” is an idiom that lets you prove termination for these sorts of mutually recursive functions.</p> <p>In summary, the need for the parent trick came about because we had two mutually recursive functions. This meant that we needed to “remember” the context in which the <code>MaxLenForest</code> function is called, which is done by passing the extra parameter. If <code>MaxLenForest</code> somehow were written as just one recursive function, then we would still use Dafny's knowledge that a datatype value <code>d</code> inside the set inside a datatype value <code>D</code> is structurally included in <code>D</code> (and thus <code>d &lt; D</code>), but we wouldn't need to apply the parent trick to pass the context as a parameter. I will show such an example below (see function <code>MaxLen</code> in Section <a href="http://leino.science/papers/krml283.html#sec-max-function" target="_blank" rel="noopener noreferrer">6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>).</p> <h2 id="_3-two-more-remarks"><a href="#_3-two-more-remarks" class="header-anchor">#</a> 3. Two more remarks</h2> <p>First, in presenting the program above, I explicitly showed the <code>decreases</code> clauses. But if you list the parameters in the order that I did, then the explicit <code>decreases</code> clause will coincide with Dafny's defaults. So, you can omit the <code>decreases</code> clauses and the verifier will still be able to prove the program.</p> <p>Second, as I wrote them, the functions are ghost, so they are erased by the compiler and not available at run time. If you want the functions to be available at run time, you might be bothered by having to pass the “parent” parameter along everywhere. This is easily solved by then marking the “parent” parameter as <code>ghost</code>. This is possible, because <code>parent</code> is not used by the function, other than for its proof, so it's fine if the compiler erases the parameter.</p> <h2 id="_4-segue-into-an-arduous-journey"><a href="#_4-segue-into-an-arduous-journey" class="header-anchor">#</a> 4. Segue into an arduous journey</h2> <p>If you try doing what I just said in the two remarks, the functions will be declared as follows:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function method MaxLen(tree: StringSet): nat {
  if tree.children == map[] then
    0
  else
    1 + MaxLenForest(tree, tree.children.Values)
}

function method MaxLenForest(ghost parent: StringSet, trees: set&lt;StringSet&gt;): nat
  requires forall t :: t in trees ==&gt; t &lt; parent
{
  if trees == {} then
    0
  else
    var t :| t in trees;
    var m := MaxLen(t);
    var n := MaxLenForest(parent, trees - {t});
    Maximum(m, n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>but you'll notice an error:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>var t :| t in trees;
^ here
Error: to be compilable, the value of a let-such-that expression must be
uniquely determined
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>This is a completely different problem than the termination problem we worked to solve above. The problem is that the choice of a <code>t</code> that satisfies <code>t in trees</code> is not unique, as is required for compiling the let-such-that expression. The reasons for this restriction are explained in a different paper [<a href="http://leino.science/papers/krml283.html#lpar-20:compiling_hilberts_epsilon_operator" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]. If you don't care about compiling <code>MaxLen</code>, you can stop reading now. Otherwise, stretch your legs, get more coffee, and keep reading.</p> <h2 id="_5-making-a-unique-choice"><a href="#_5-making-a-unique-choice" class="header-anchor">#</a> 5. Making a unique choice</h2> <p>To make the choice of <code>t</code> unique, we need to strengthen the constraint in the let-such-that expression. For example, we might want to pick the “smallest” of the values in <code>trees</code>. But what does “smallest” mean among a set of <code>StringSet</code> trees? An easier way out is to change the program to pass the whole map <code>tree.children</code> to <code>MaxLenForest</code>, rather than just the children trees themselves (<code>tree.childre.Values</code>). Then, we can pick the smallest among the labels, which—since our labels have type <code>char</code>—is easy to do. Here's what we get:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function method MaxLen(tree: StringSet): nat {
  if tree.children == map[] then
    0
  else
    1 + MaxLenForest(tree, tree.children)
}

function method MaxLenForest(ghost parent: StringSet,
                             children: map&lt;char, StringSet&gt;): nat
  requires forall lbl :: lbl in children.Keys ==&gt; children[lbl] &lt; parent
{
  if children == map[] then
    0
  else
    var lbl :|
      lbl in children.Keys &amp;&amp;
      forall lbl' :: lbl' in children.Keys ==&gt; lbl &lt;= lbl';
    var m := MaxLen(children[lbl]);
    var n := MaxLenForest(parent, children - {lbl});
    Maximum(m, n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>Note that the expression <code>children - {lbl}</code> is a map-domain subtraction. That is, it denotes the map that is like <code>children</code>, except it doesn't have the key <code>lbl</code>.</p> <p>The additional constraint makes the choice unique. However, now that we've strengthened it, the verifier is no longer convinced there is any choice for <code>lbl</code>. To fix this problem, we need to demonstrate that every nonempty set of characters has a smallest element. The easiest way to conduct such a demonstration is to compute it:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function PickSmallest(s: set&lt;char&gt;): (ch: char)
  requires s != {}
  ensures ch in s &amp;&amp; forall ch' :: ch' in s ==&gt; ch &lt;= ch'
{
  var ch :| ch in s;
  if ch' :| ch' in s &amp;&amp; ch' &lt; ch then
    var s' := s - {ch};
    assert s == s' + {ch};
    PickSmallest(s')
  else
    ch
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>“But wait!”, you say. &quot;How come this function gets away with the weak let-such-that constraint that was a problem in <code>MaxLenForest</code>?&quot; It's because <code>PickSmallest</code> is a ghost function, so its let-such-that expression does not have the uniqueness requirement (see [<a href="http://leino.science/papers/krml283.html#lpar-20:compiling_hilberts_epsilon_operator" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]). Alright, then, so our final step is to use function <code>PickSmallest</code> just before the let-such-that expression in <code>MaxLenForest</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function method MaxLenForest(ghost parent: StringSet,
                             children: map&lt;char, StringSet&gt;): nat
  requires forall lbl :: lbl in children.Keys ==&gt; children[lbl] &lt; parent
{
  if children == map[] then
    0
  else
    ghost var smallest := PickSmallest(children.Keys);
    var lbl :|
      lbl in children.Keys &amp;&amp;
      forall lbl' :: lbl' in children.Keys ==&gt; lbl &lt;= lbl';
    var m := MaxLen(children[lbl]);
    var n := MaxLenForest(parent, children - {lbl});
    Maximum(m, n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>After putting the result of <code>PickSmallest</code> into a ghost variable, the verifier has all the evidence it needs for the existence of a value of <code>lbl</code>. So, this concludes our program.</p> <h2 id="_6-restructuring-the-recursion"><a href="#_6-restructuring-the-recursion" class="header-anchor">#</a> 6. Restructuring the recursion</h2> <p>The running example has already showed several techniques and features in Dafny. But in our final program above, we still have a rather big and unsatisfying let-such-that constraint. The mandate that we have to pick a unique element from the set seems unnecessarily harsh, since all we're trying to do is compute the maximum of a set, and the maximum will be the same regardless of which order we consider the elements in. So, what we'd like to do is use nondeterminism inside <code>MaxLenForest</code>, as long as we can prove that the nondeterminism does not affect the result. And Dafny has just the feature for this: <code>function</code>-<code>by</code>-<code>method</code> declarations.</p> <p>To make a reusable function, let's define a general function <code>Max</code> as follows:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function method Max(s: set&lt;int&gt;): int
  requires s != {}
  ensures Max(s) in s
  ensures forall z :: z in s ==&gt; z &lt;= Max(s)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>By constructing the set of elements we want to take the maximum of, we can use <code>Max</code> in <code>MaxLen</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function method MaxLen(tree: StringSet): nat {
  if tree.children == map[] then
    0
  else
    var s := set t | t in tree.children.Values :: MaxLen(t);
    assert s != {} by {
      assert forall lbl ::
        lbl in tree.children.Keys ==&gt; MaxLen(tree.children[lbl]) in s;
    }
    1 + Max(s)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>As you see here, the verifier needed help in proving that <code>s</code> is nonempty. This proof obligation is addressed by asserting that, for every label in (the known to be nonempty) <code>tree.children</code>, <code>s</code> contains the <code>MaxLen</code> of the corresponding value. (Since <code>MaxLen</code> is now recursive and doesn't go through a mutually recursive function like <code>MaxLenForest</code>, we don't need the parent trick. That is, there's no longer a need to pass any additional context parameter.)</p> <h2 id="_7-a-more-efficient-choice"><a href="#_7-a-more-efficient-choice" class="header-anchor">#</a> 7. A more efficient choice</h2> <p>From now on, we'll focus just on <code>Max</code>. It would be nice to write its body as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  var x :| x in s;
  if s == {x} then
    x
  else
    var s' := s - {x};
    assert s == s' + {x};
    var y := Max(s');
    Maximum(x, y)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Alas, this is not allowed, because the compiled let-such-that does not uniquely determine the value for <code>x</code>. This is the exactly the problem that we started with and want to steer around!</p> <p>Function-by-method to the rescue.</p> <h2 id="_8-function-by-method"><a href="#_8-function-by-method" class="header-anchor">#</a> 8. Function-by-method</h2> <p>Say what?! A <code>function-by-method</code> is a combination of a function and method. The body of the function part of a <code>function-by-method</code> is a ghost expression, but this expression acts just as the specification for what value is to be returned. The body of the method part of the <code>function-by-method</code> then gives a compilable method body for computing the value.</p> <p>Using a bit of program text, the basic idea is to declare a <code>function-by-method</code> like</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function F(x: X): (y: Y)
  requires Pre(x)
  ensures Post(x, y)
{
  Expr;
} by method {
  MBody;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>where <code>Expr</code> is a ghost expression (the “function part”) and <code>MBody</code> is a compilable statement list (the “method part”).</p> <p>To explain the meaning of this <code>function-by-method</code>, it's helpful to look at it as two declarations:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function F(x: X): (y: Y)
  requires Pre(x)
  ensures Post(x, y)
{
  Expr;
}

method _F(x: X) returns (y: Y)
  requires Pre(x)
  ensures y == F(x)
{
  MBody;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Now, Dafny arranges that every use of the original <code>function-by-method</code> in a ghost context calls ghost function <code>F</code>, and that every use of the <code>function-by-method</code> is a non-ghost context calls the compiled method <code>_F</code>.</p> <p>Note that any <code>ensures</code> clause on the original <code>function-by-method</code> is a proof obligation of the function part. The postcondition of the method part is <code>y == F(x)</code>. (I'll come back to this point later.)</p> <h2 id="_9-max-as-a-function-by-method"><a href="#_9-max-as-a-function-by-method" class="header-anchor">#</a> 9. Max as a function-by-method</h2> <p>Using a <code>function-by-method</code> declaration, we write <code>Max</code> as follows:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Max(s: set&lt;int&gt;): (m: int)
  requires s != {}
  ensures m in s &amp;&amp; forall z :: z in s ==&gt; z &lt;= m
{
  var x :| x in s;
  if s == {x} then
    x
  else
    var s' := s - {x};
    assert s == s' + {x};
    var y := Max(s');
    Maximum(x, y)
} by method {
   m :| m in s;
   var r := s - {m};
   while r != {}
     invariant r &lt; s
     invariant m in s &amp;&amp; forall z :: z in s - r ==&gt; z &lt;= m
   {
     var x :| x in r;
     assert forall z :: z in s - (r - {x}) ==&gt; z in s - r || z == x;
     r := r - {x};
     if m &lt; x {
       m := x;
     }
   }
   assert s - {} == s;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>This function-by-method verifies as given. However, the reason it verifies is subtle and may not be what you expect (especially if this is the first time you see a <code>function-by-method</code>). Let me explain the reason and then show a more typical proof of a <code>function-by-method</code>.</p> <p>The point of the method part of a <code>function-by-method</code> is to provide a method implementation that returns exactly the same value as the given function body. For this reason, the postcondition that the method body has to satisfy is <code>m == Max(s)</code>. This is a very precise postcondition. The <code>ensures</code> clause declared in the <code>function-by-method</code> applies to the function part. It is usually much less precise; in fact, for most functions, this <code>ensures</code> clause is omitted, since the body of the function transparently says what the result value is.</p> <p>In general, just because the method part of a <code>function-by-method</code> happens to satisfy the <code>ensures</code> clause of the <code>function-by-method</code> does not mean the method part is correct. But in our <code>Max</code> example, the two coincide, because the <code>ensures</code> clause I gave for the <code>function-by-method</code> uniquely determines <code>m</code>. Thus, any method body that satisfies this <code>ensures</code> clause also satisfies <code>m == Max(s)</code>. (You can confirm this by deleting <code>m in s</code> from the <code>ensures</code> clause. This will cause the method part to fail to verify, while the function part still verifies.)</p> <h2 id="_10-a-more-common-situation"><a href="#_10-a-more-common-situation" class="header-anchor">#</a> 10. A more common situation</h2> <p>A more generally applicable pattern for proving the method part of a recursive makes use of the function in the loop invariant. To illustrate this, I will remove the <code>ensures</code> clause of <code>Max</code>. Consequently, the iterative method body needs to establish that it computes exactly what the recursion function body does.</p> <p>The idea is to use a body like this:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  m :| m in s;
  var r := {m};
  while r != s
    invariant {} != r &lt;= s
    invariant m == Max(r)
  {
    var x :| x in s - r;
    r := r + {x};
    if m &lt; x {
      m := x;
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>This loops maintains the invariant <code>m == Max(r)</code> while enlarging <code>r</code> until it becomes <code>s</code>. Doing this proof is tricky, because of two issues. Both of these issues have standard solutions, which are really good to know. The two issues and solutions are explained for a simpler example in another Dafny Power User note [<a href="http://leino.science/papers/krml283.html#krml274" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>], but it seems worthwhile to show them here as well.</p> <h2 id="_11-naming-the-choice"><a href="#_11-naming-the-choice" class="header-anchor">#</a> 11. Naming the choice</h2> <p>The first issue is that the let-such-that expression is like a function, but by Dafny semantics it may be a different function for each textual occurrence of <code>:|</code> (see [<a href="http://leino.science/papers/krml283.html#lpar-20:compiling_hilberts_epsilon_operator" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]). It is easy to become confused and frustrated if, without realizing it, you're using more than one <code>:|</code> function. Therefore, let's make sure there is only one textual occurrence of this operator. We do that by putting it inside a named function:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Pick(s: set&lt;int&gt;): int
  requires s != {}
{
  var x :| x in s; x
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>With this function, we write the function part of the <code>function-by-method</code> <code>Max</code> as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>  var x := Pick(s);
  if s == {x} then
    x
  else
    Maximum(Max(s - {x}), x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_12-what-you-remove-may-differ-from-what-you-just-added"><a href="#_12-what-you-remove-may-differ-from-what-you-just-added" class="header-anchor">#</a> 12. What you remove may differ from what you just added</h2> <p>The second issue is that we will need to help the verifier along in the proof of invariance for the loop. The reason is that the next element that the loop adds to the growing set <code>r</code> may not be the same element that the <code>Pick</code> function would choose when going in the opposite direction. Specifically, if the loop adds <code>x</code> to <code>r</code> as it's computing <code>Max(r + {x})</code>, there's no reason to believe that the definition of <code>Max(r + {x})</code> picks <code>x</code> and recurses on <code>Max(r)</code>. (Again, for a simpler example and better motivation, see [<a href="http://leino.science/papers/krml283.html#krml274" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>].)</p> <p>This lemma is tricky to prove, even if you've written similar proofs several times. An additional complication for our function <code>Max</code> is that <code>Max</code> requires its argument to be nonempty. Here is the lemma and a proof:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma MaxOfOneMore(t: set&lt;int&gt;, x: int)
  requires t != {} &amp;&amp; x !in t
  ensures Max(t + {x}) == Maximum(Max(t), x)
  decreases |t|
{
  var u := t + {x};
  var z := Pick(u);
  var u'x, u'z := u - {x}, u - {z};
  assert Max(u) == Maximum(Max(u'z), z);

  if z == x {
    // Straight from the definition of Max
  } else if t == {z} {
    assert u'z == {x} &amp;&amp; u'x == {z};
    // This is known about Max on singletons:
    assert Max(u'z) == x;
    assert Max(u'x) == z;
    // So, regardless of which of x and z gets picked first, the result is the same
    assert Max(u) == Maximum(x, z) == Maximum(z, x);
  } else {
    var u'z'x := u'z - {x};
    calc {
      Maximum(Max(u'z), z);
    ==  { assert u'z == (u'z'x) + {x}; }
      Maximum(Max((u'z'x) + {x}), z);
    ==  { MaxOfOneMore(u'z'x, x); }
      Maximum(Maximum(Max(u'z'x), x), z);
    ==  // Maximum is commutative and associative
      Maximum(Maximum(Max(u'z'x), z), x);
    ==  { MaxOfOneMore(u'z'x, z); }
      Maximum(Max(u'z'x + {z}), x);
    ==  { assert u'z'x + {z} == u'x == t; }
      Maximum(Max(t), x);
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>That's a mouthful. But once you have the lemma, using it once in the loop body finishes the proof of our <code>function-by-method</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Max(s: set&lt;int&gt;): (m: int)
  requires s != {}
{
  var x := Pick(s);
  if s == {x} then
    x
  else
    Maximum(Max(s - {x}), x)
} by method {
  m :| m in s;
  var r := {m};
  while r != s
    invariant {} != r &lt;= s
    invariant m == Max(r)
  {
    var x :| x in s - r;
    MaxOfOneMore(r, x);
    r := r + {x};
    if m &lt; x {
      m := x;
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_13-termination"><a href="#_13-termination" class="header-anchor">#</a> 13. Termination</h2> <p>A final remark. It looks as if <code>Max</code> uses the lemma <code>MaxOfOneMore</code>, and the lemma uses <code>Max</code>. Doesn't this mutual recursion mean we have to prove termination? No, because there's isn't actually any mutual recursion in this example. To understand why, remember that the two parts of a <code>function-by-method</code> are treated as if they were one function and one method (see Section <a href="http://leino.science/papers/krml283.html#sec-function-by-method" target="_blank" rel="noopener noreferrer">8<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>). This function and method are different points in the call graph, where calls to <code>Max</code> from ghost contexts go to the function part and calls to <code>Max</code> from compiled contexts go to the method part. Therefore, we have that the following call-graph edges:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>Max (function) --&gt; Max (function)
MaxOfOneMore   --&gt; MaxOfOneMore, Max (function)
Max (method)   --&gt; MaxOfOneMore, Max (function)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>As you can see from these, the function part of <code>Max</code> is recursive and the lemma is recursive, but there is no mutual recursion.</p> <h2 id="_14-summary"><a href="#_14-summary" class="header-anchor">#</a> 14. Summary</h2> <p>I started this note with the innocent problem of how to prove the termination of two mutually recursive functions. As the solution, I showed the Parent Trick. I then changed the code to make it compilable, which introduced proof obligations to show certain choices to be deterministic. This can be better solved using a <code>function-by-method</code>, so I gave a brief introduction to Dafny's <code>function-by-method</code> declaration and used it to present two solutions. The more straightforward solution worked for the example at hand, whereas the second solution shows a more typical pattern for such method implementations.</p> <h4 id="acknowledgments"><a href="#acknowledgments" class="header-anchor">#</a> Acknowledgments</h4> <p>I'm grateful to Mikaël Mayer for asking a question about these mutually recursive functions, which propelled me to write this note, and for his helpful comments on the write-up. The <code>function-by-method</code> construct was designed as a direct outgrowth of some collaborative work with Daniel Matichuk, Olivier Savary Belanger, and Mike Dodds, where as a step toward verified compilation we were considering how to implement immutable things with mutable things.</p> <h2 id="references"><a href="#references" class="header-anchor">#</a> References</h2> <p>[0]K. Rustan M. Leino. Compiling Hilbert's epsilon operator. In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei Voronkov, editors, <em>LPAR-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning — Short Presentations</em>, volume 35 of <em>EPiC Series in Computing</em>, pages 106–118. EasyChair, 2015. <a href="https://easychair.org/publications/paper/dM" target="_blank" rel="noopener noreferrer">https://easychair.org/publications/paper/dM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <a href="http://www.bing.com/search?q=Compiling+Hilbert+epsilon+operator+++Rustan+Leino+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[1]K. Rustan M. Leino. Dafny power user: Functions over set elements. Manuscript KRML 274, February 2020. <a href="http://leino.science/papers/krml274.html" target="_blank" rel="noopener noreferrer">http://leino.science/papers/krml274.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <a href="http://www.bing.com/search?q=Dafny+power+user+Functions+over+elements+++Rustan+Leino+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/aaron-clou/dafnycommunity/edit/master/docs/80.语言/30.publication-lecture/55.The Parent Trick for proving termination and a function-by-method use case.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/03/26, 14:38:56</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/dafnycommunity/pages/f8c1c5/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Statement versus Expression Syntax</div></a> <a href="/dafnycommunity/pages/c45b5a/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Type-Parameter Completion</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/dafnycommunity/pages/f8c1c5/" class="prev">Statement versus Expression Syntax</a></span> <span class="next"><a href="/dafnycommunity/pages/c45b5a/">Type-Parameter Completion</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/dafnycommunity/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/dafnycommunity/pages/0978ce/"><div>
            寻找最大和最小数
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>02</dd> <dt><a href="/dafnycommunity/pages/e3e481/"><div>
            斐波那契数列
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>03</dd> <dt><a href="/dafnycommunity/pages/02fdef/"><div>
            线性查询
            <!----></div></a> <span class="date">04-06</span></dt></dl> <dl><dd></dd> <dt><a href="/dafnycommunity/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Aaron-clou/dafnycommunity" title="Github" target="_blank" class="iconfont icon-github-fill"></a><a href="https://gitee.com/leo214/dafnycommunity" title="Gitee" target="_blank" class="iconfont icon-gitee2"></a><a href="1374921025@qq.com" title="Email" target="_blank" class="iconfont icon-email-fill"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Li Jiahai | Dafny Community | 2022</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><!----><div id="tcomment"></div><div></div></div></div>
    <script src="/dafnycommunity/assets/js/app.99d07194.js" defer></script><script src="/dafnycommunity/assets/js/2.ab4658c0.js" defer></script><script src="/dafnycommunity/assets/js/84.085ef3f8.js" defer></script><script src="/dafnycommunity/assets/js/7.5451cfed.js" defer></script><script src="/dafnycommunity/assets/js/4.06497870.js" defer></script>
  </body>
</html>
