<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Comprehensions | Dafny</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/dafnycommunity/img/bgico2.ico">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3282046_1qux519eoim.css">
    <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.0/dist/twikoo.all.min.js"></script>
    <meta name="description" content="Dafny中文社区">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css" as="style"><link rel="preload" href="/dafnycommunity/assets/js/app.99d07194.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/2.ab4658c0.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/77.b85547c7.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/7.5451cfed.js" as="script"><link rel="preload" href="/dafnycommunity/assets/js/4.06497870.js" as="script"><link rel="prefetch" href="/dafnycommunity/assets/js/10.ac38cab7.js"><link rel="prefetch" href="/dafnycommunity/assets/js/11.38d5ee16.js"><link rel="prefetch" href="/dafnycommunity/assets/js/12.c434ce94.js"><link rel="prefetch" href="/dafnycommunity/assets/js/13.4e922264.js"><link rel="prefetch" href="/dafnycommunity/assets/js/14.db841cfa.js"><link rel="prefetch" href="/dafnycommunity/assets/js/15.b9c227cc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/16.41dadc32.js"><link rel="prefetch" href="/dafnycommunity/assets/js/17.48b5f1eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/18.ec254833.js"><link rel="prefetch" href="/dafnycommunity/assets/js/19.288ca382.js"><link rel="prefetch" href="/dafnycommunity/assets/js/20.cfeb5fdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/21.ce8ddc5a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/22.1b8c89f0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/23.cb062ace.js"><link rel="prefetch" href="/dafnycommunity/assets/js/24.ff271672.js"><link rel="prefetch" href="/dafnycommunity/assets/js/25.5541f3af.js"><link rel="prefetch" href="/dafnycommunity/assets/js/26.a1bbc4cb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/27.522d7884.js"><link rel="prefetch" href="/dafnycommunity/assets/js/28.9335c003.js"><link rel="prefetch" href="/dafnycommunity/assets/js/29.3fc0b07a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/3.ab8a97d8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/30.57708681.js"><link rel="prefetch" href="/dafnycommunity/assets/js/31.8571b949.js"><link rel="prefetch" href="/dafnycommunity/assets/js/32.f91be5de.js"><link rel="prefetch" href="/dafnycommunity/assets/js/33.8089c59b.js"><link rel="prefetch" href="/dafnycommunity/assets/js/34.874d0299.js"><link rel="prefetch" href="/dafnycommunity/assets/js/35.aff8adfd.js"><link rel="prefetch" href="/dafnycommunity/assets/js/36.ac78b86e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/37.3fae0334.js"><link rel="prefetch" href="/dafnycommunity/assets/js/38.3db4a8d6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/39.e585cc70.js"><link rel="prefetch" href="/dafnycommunity/assets/js/40.afcb8fbe.js"><link rel="prefetch" href="/dafnycommunity/assets/js/41.01f314da.js"><link rel="prefetch" href="/dafnycommunity/assets/js/42.8e4fe21d.js"><link rel="prefetch" href="/dafnycommunity/assets/js/43.571fb232.js"><link rel="prefetch" href="/dafnycommunity/assets/js/44.14aebad2.js"><link rel="prefetch" href="/dafnycommunity/assets/js/45.32f18970.js"><link rel="prefetch" href="/dafnycommunity/assets/js/46.ce0d522f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/47.0bd83351.js"><link rel="prefetch" href="/dafnycommunity/assets/js/48.648f667a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/49.83709ae0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/5.b8548e7f.js"><link rel="prefetch" href="/dafnycommunity/assets/js/50.060e0424.js"><link rel="prefetch" href="/dafnycommunity/assets/js/51.a1291856.js"><link rel="prefetch" href="/dafnycommunity/assets/js/52.45f73497.js"><link rel="prefetch" href="/dafnycommunity/assets/js/53.525782ca.js"><link rel="prefetch" href="/dafnycommunity/assets/js/54.45a04a86.js"><link rel="prefetch" href="/dafnycommunity/assets/js/55.65a94ba0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/56.2d038113.js"><link rel="prefetch" href="/dafnycommunity/assets/js/57.579db650.js"><link rel="prefetch" href="/dafnycommunity/assets/js/58.832d4c89.js"><link rel="prefetch" href="/dafnycommunity/assets/js/59.13befb53.js"><link rel="prefetch" href="/dafnycommunity/assets/js/6.349bf431.js"><link rel="prefetch" href="/dafnycommunity/assets/js/60.41227bb1.js"><link rel="prefetch" href="/dafnycommunity/assets/js/61.1d1b92f4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/62.2cdbc236.js"><link rel="prefetch" href="/dafnycommunity/assets/js/63.83de9482.js"><link rel="prefetch" href="/dafnycommunity/assets/js/64.4ecd0d25.js"><link rel="prefetch" href="/dafnycommunity/assets/js/65.25118b81.js"><link rel="prefetch" href="/dafnycommunity/assets/js/66.cdab1b54.js"><link rel="prefetch" href="/dafnycommunity/assets/js/67.655e6e84.js"><link rel="prefetch" href="/dafnycommunity/assets/js/68.84effb44.js"><link rel="prefetch" href="/dafnycommunity/assets/js/69.8f07f81a.js"><link rel="prefetch" href="/dafnycommunity/assets/js/70.d9a299e6.js"><link rel="prefetch" href="/dafnycommunity/assets/js/71.16ef2000.js"><link rel="prefetch" href="/dafnycommunity/assets/js/72.8252acc5.js"><link rel="prefetch" href="/dafnycommunity/assets/js/73.f53e39bc.js"><link rel="prefetch" href="/dafnycommunity/assets/js/74.5ef910c4.js"><link rel="prefetch" href="/dafnycommunity/assets/js/75.72174d00.js"><link rel="prefetch" href="/dafnycommunity/assets/js/76.bebf75c9.js"><link rel="prefetch" href="/dafnycommunity/assets/js/78.a0a1f574.js"><link rel="prefetch" href="/dafnycommunity/assets/js/79.a731d645.js"><link rel="prefetch" href="/dafnycommunity/assets/js/8.522ce892.js"><link rel="prefetch" href="/dafnycommunity/assets/js/80.6e5b64b0.js"><link rel="prefetch" href="/dafnycommunity/assets/js/81.6e19e312.js"><link rel="prefetch" href="/dafnycommunity/assets/js/82.9244e788.js"><link rel="prefetch" href="/dafnycommunity/assets/js/83.f08c5aed.js"><link rel="prefetch" href="/dafnycommunity/assets/js/84.085ef3f8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/85.c41e6e0e.js"><link rel="prefetch" href="/dafnycommunity/assets/js/86.e3798708.js"><link rel="prefetch" href="/dafnycommunity/assets/js/87.fdac1c1c.js"><link rel="prefetch" href="/dafnycommunity/assets/js/88.665ac8c8.js"><link rel="prefetch" href="/dafnycommunity/assets/js/89.78dc55eb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/9.4d4f4bdb.js"><link rel="prefetch" href="/dafnycommunity/assets/js/90.4757b202.js"><link rel="prefetch" href="/dafnycommunity/assets/js/91.a0746cf2.js">
    <link rel="stylesheet" href="/dafnycommunity/assets/css/0.styles.ecdcfe28.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dafnycommunity/" class="home-link router-link-active"><img src="/dafnycommunity/img/logo-2.png" alt="Dafny" class="logo"> <span class="site-name can-hide">Dafny</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://s1.ax1x.com/2022/04/01/qh3tDe.png"> <div class="blogger-info"><h3>Dafny</h3> <span>新一代验证语言</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/dafnycommunity/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/dafnycommunity/peizhi/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>入门介绍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/56e571/" class="nav-link">什么是dafny?</a></li></ul></li><li class="dropdown-item"><h4>用起来吧！</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/4fa796/" class="nav-link">安装</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/085606/" class="nav-link">快速上手</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/39fb20/" class="nav-link">可能遇到的问题?</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/dafnycommunity/zhinan/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny快速入门</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/6e15a6/" class="nav-link">基础学习 Basic</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/eba166/" class="nav-link">方法 Method</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/83cdf9/" class="nav-link">关键字 Keyword</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/01d76e/" class="nav-link">函数 Function</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0fadc1/" class="nav-link">类 Class </a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a010ab/" class="nav-link">泛型 Generics</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/c4fda3/" class="nav-link">声明 Statement</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e8438e/" class="nav-link">表达式 Expression</a></li></ul></li><li class="dropdown-item"><h4>Dafny简单例子</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0978ce/" class="nav-link">寻找最大最小数和</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/e3e481/" class="nav-link">斐波那契数列</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/02fdef/" class="nav-link">线性查询</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9b332b/" class="nav-link">引理-计算序列非负元素个数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/3d1110/" class="nav-link">集合</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2146d4/" class="nav-link">终止</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><a href="/dafnycommunity/jiaocheng/" class="link-title">教程</a> <span class="title" style="display:none;">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Dafny指导</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/877eb3/" class="nav-link">介绍</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/bf40c0/" class="nav-link">方法 Methods</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/2e0c73/" class="nav-link">前置/后置条件 Pre/Postconditions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/36c1b4/" class="nav-link">断言 Assertions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a1d5a4/" class="nav-link">函数 Functions</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/d89435/" class="nav-link">循环不变体 Loop Invariants</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/828a83/" class="nav-link">数组 Arrays</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/17e8d1/" class="nav-link">量词(函数) Quantifiers</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cc01af/" class="nav-link">谓词(函数) Predicates</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/13bbcd/" class="nav-link">框架 Framing</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1319be/" class="nav-link">二分搜索 Binary Search</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/30a8c2/" class="nav-link">总结</a></li></ul></li><li class="dropdown-item"><h4>Dafny进阶语法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/273cac/" class="nav-link">引理和归纳 Lemmas and Induction</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/9d19b8/" class="nav-link">模块 Modules</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/b9300a/" class="nav-link">集合 sets</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/cb3d21/" class="nav-link">序列 sequence</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fc6196/" class="nav-link">终止 Terminal</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/a2a107/" class="nav-link">值类型 Values Types</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="资源" class="dropdown-title"><a href="/dafnycommunity/ziyuan/" class="link-title">资源</a> <span class="title" style="display:none;">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>实践探索</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/718207/" class="nav-link">自动归纳</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1f579f/" class="nav-link">自动调用引理</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/f6638c/" class="nav-link">定义、证明、算法正确性</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/1d2420/" class="nav-link">各种推导式</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/20c275/" class="nav-link">不同类型的证明</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/67167e/" class="nav-link">集合元素上的函数</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/be298d/" class="nav-link">在集合上的迭代</a></li></ul></li><li class="dropdown-item"><h4>常用工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/dafnycommunity/pages/8065fd/" class="nav-link">Type System</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/0f17ab/" class="nav-link">Style Guide</a></li><li class="dropdown-subitem"><a href="/dafnycommunity/pages/fe5721/" class="nav-link">Cheet Sheet</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/1b94a4/" class="nav-link">✨收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🏷️语言" class="dropdown-title"><!----> <span class="title" style="display:;">🏷️语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dafnycommunity/" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/dafnycommunity/en-US/" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/dafnycommunity/pages/caf1f9/" class="nav-link">💬社区留言板</a></div> <a href="https://github.com/aaron-clou/dafnycommunity" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-quick-start</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dafny-tutorials</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>detailed-document</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>publication-lecture</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dafnycommunity/pages/a9363c/" class="sidebar-link">Automatic Induction</a></li><li><a href="/dafnycommunity/pages/30441e/" class="sidebar-link">Calling Lemmas Automatically</a></li><li><a href="/dafnycommunity/pages/746026/" class="sidebar-link">Case study of definitions, proofs, algorithm correctness GCD</a></li><li><a href="/dafnycommunity/pages/da6921/" aria-current="page" class="active sidebar-link">Comprehensions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/da6921/#_0-quantifiers" class="sidebar-link">0. Quantifiers</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#basic-quantifier-syntax" class="sidebar-link">Basic quantifier syntax</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#types-of-bound-variables" class="sidebar-link">Types of bound variables</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#multiple-bound-variables" class="sidebar-link">Multiple bound variables</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#the-typical-forms-of-quantifier-bodies" class="sidebar-link">The typical forms of quantifier bodies</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#range-predicates" class="sidebar-link">Range predicates</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/da6921/#_1-program-statements-for-quantifier-reasoning" class="sidebar-link">1. Program Statements for Quantifier Reasoning</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#aggregate-statements" class="sidebar-link">Aggregate statements</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#existential-introduction-and-elimination" class="sidebar-link">Existential introduction and elimination</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#lemmas-with-out-parameters" class="sidebar-link">Lemmas with out-parameters</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#binding-guards" class="sidebar-link">Binding guards</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/da6921/#_2-sets-and-maps" class="sidebar-link">2. Sets and Maps</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#set-comprehensions" class="sidebar-link">Set comprehensions</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#simplified-set-comprehensions" class="sidebar-link">Simplified set comprehensions</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#map-comprehensions" class="sidebar-link">Map comprehensions</a></li><li class="sidebar-sub-header level3"><a href="/dafnycommunity/pages/da6921/#lambda-expressions" class="sidebar-link">Lambda expressions</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/da6921/#_3-summary" class="sidebar-link">3. Summary</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/dafnycommunity/pages/da6921/#acknowledgments" class="sidebar-link">Acknowledgments</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/dafnycommunity/pages/da6921/#references" class="sidebar-link">References</a></li></ul></li><li><a href="/dafnycommunity/pages/8d8607/" class="sidebar-link">Different Styles of Proofs</a></li><li><a href="/dafnycommunity/pages/097ba0/" class="sidebar-link">Functions over Set Elements</a></li><li><a href="/dafnycommunity/pages/c4484e/" class="sidebar-link">Iterating over a Collection</a></li><li><a href="/dafnycommunity/pages/7fe522/" class="sidebar-link">old and unchanged</a></li><li><a href="/dafnycommunity/pages/369e25/" class="sidebar-link">Short-Circuit Operators</a></li><li><a href="/dafnycommunity/pages/f8c1c5/" class="sidebar-link">Statement versus Expression Syntax</a></li><li><a href="/dafnycommunity/pages/5a4346/" class="sidebar-link">The Parent Trick for proving termination and a function-by-method use case</a></li><li><a href="/dafnycommunity/pages/c45b5a/" class="sidebar-link">Type-Parameter Completion</a></li><li><a href="/dafnycommunity/pages/3c9a0b/" class="sidebar-link">Type-parameter modes variance and cardinality preservation</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/dafnycommunity/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/dafnycommunity/en-US/#语言" data-v-0c557b5e>语言</a></li><li data-v-0c557b5e><a href="/dafnycommunity/en-US/#publication-lecture" data-v-0c557b5e>publication-lecture</a></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="https://github.com/Aaron-clou" target="_blank" title="作者" class="beLink" data-v-0c557b5e>lijiahai</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-03-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Comprehensions<!----></h1> <!----> <div class="theme-vdoing-content content__default"><p>Dafny Power User:
Comprehensions</p> <p>K. Rustan M. Leino</p> <p>Manuscript KRML 267, 27 May 2019</p> <p><strong>Abstract.</strong> Dafny has a number of comprehension-like constructs. This note describes and compares these constructs, showing how they compare both syntactically and semantically.</p> <p>Dafny supports universal and existential quantifications, along with constructs used to <em>prove</em> a universally quantified expression or <em>make use of</em> an existentially quantified expression. Section <a href="http://leino.science/papers/krml267.html#sec-quantifiers" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> describes these logical quantifiers in Dafny. Section <a href="http://leino.science/papers/krml267.html#sec-proof-features" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> shows program statements that can be used when reasoning about the quantifiers and points out differences in the various syntactic forms.</p> <p>Set comprehensions and map comprehensions are like quantifiers in that they introduce bound variables that range over certain values. Section <a href="http://leino.science/papers/krml267.html#sec-sets-and-maps" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> shows the general and common forms of these comprehensions.</p> <h2 id="_0-quantifiers"><a href="#_0-quantifiers" class="header-anchor">#</a> 0. Quantifiers</h2> <h3 id="basic-quantifier-syntax"><a href="#basic-quantifier-syntax" class="header-anchor">#</a> Basic quantifier syntax</h3> <p>In mathematical textbooks and papers, the familiar universal quantifier takes on some notation like . It says that the predicate holds for all values of . In programming-language lingo, we say that is a <em>bound variable</em> whose scope is the <em>body</em> of the quantifier, . That is, any free occurrences of in are bound to the introduced by the quantifier.</p> <p>In Dafny, the same universal quantifier is written <code>forall x :: P</code>. From a parsing perspective, the body of the quantifier extends “as far as possible”. Thus, the program snippet</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: R ==&gt; Q
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>is parsed as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>(forall x :: (R ==&gt; Q))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>not as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>(forall x :: R) ==&gt; Q
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Note that “as far as possible” does not stop at line endings. For example, a common pitfall is to write (here shown for a precondition)</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>requires
  forall x :: R ==&gt; Q &amp;&amp;
  S
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>with the intention that <code>forall x :: R ==&gt; Q</code> and <code>S</code> are two separate preconditions. Contrary to this expectation, the meaning of declaration, as written here, is</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>requires (forall x :: (R ==&gt; (Q &amp;&amp; S)))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>If you intended to write the conjunction of the quantifier and <code>S</code>, then the proper syntax is</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>requires
  (forall x :: R ==&gt; Q) &amp;&amp;
  S
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>A familiar mathematical notation for an existential quantifier is . It says that the predicate holds for some value of . In Dafny, the syntax is <code>exists x :: P</code>.<a href="http://leino.science/papers/krml267.html#fn-fn-emacs" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="types-of-bound-variables"><a href="#types-of-bound-variables" class="header-anchor">#</a> Types of bound variables</h3> <p>Each variable in Dafny has a type. Typically, the type of a bound variable is inferred, but Dafny also allows the type to be declared explicitly. For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x: X :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>declares the type of <code>x</code> to be <code>X</code>. For brevity, and to show the typical ways of writing quantifiers and comprehensions, I will leave off types throughout this note, but remember that you can always include them if you want to.</p> <p>A common mathematical notation for quantifiers when the bound variables are drawn from some set is . A Dafny-like rendering of this expression is</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x in S :: P  // error: syntax error
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>However, this is incorrect Dafny syntax, because it uses a set membership predicate where only the bound variable (optionally, with a type) is expected. The proper way to write such a quantifier in Dafny is</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: x in S ==&gt; P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="multiple-bound-variables"><a href="#multiple-bound-variables" class="header-anchor">#</a> Multiple bound variables</h3> <p>A quantifier can have more than one bound variable. For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x, y :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>says that <code>P</code> holds for all values of <code>x</code> and <code>y</code>. It is logically equivalent to the nested quantifiers</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: forall y :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>For that matter, it is logically equivalent also to</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall y :: forall x :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Common practice in Dafny is to prefer the quantifier with multiple variables over the nested forms, if for no other reason than that it is more concise.<a href="http://leino.science/papers/krml267.html#fn-fn-nested" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>In the event that you write a list of bound variables and give types explicitly, note that each given type applies only to the variable that immediately precedes it. For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x: X, y: Y :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>says that <code>x</code> has type <code>X</code> and <code>y</code> has type <code>Y</code>. If you only include the type of <code>y</code>, as in</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x, y: Y :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>then you are saying that <code>y</code> has type <code>Y</code> and that the type of <code>x</code> is to be inferred. In other words, you can think of this &quot;<code>:</code>“ as having strong binding power than the ”<code>,</code>&quot;.</p> <h3 id="the-typical-forms-of-quantifier-bodies"><a href="#the-typical-forms-of-quantifier-bodies" class="header-anchor">#</a> The typical forms of quantifier bodies</h3> <p>The body of a universal quantifier is typically an implication, as in</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: R ==&gt; P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>You can read this in one of the following ways:</p> <blockquote><p>&quot;for all <code>x</code>, the implication <code>R ==&gt; P</code> holds&quot;</p> <p>&quot;for all <code>x</code>, <code>R</code> implies <code>P</code>&quot;</p> <p>&quot;for all <code>x</code>, if <code>R</code> holds, then so does <code>P</code>&quot;</p></blockquote> <p>However, the antecedent of this implication (<code>R</code>) often serves the role of restricting (beyond just the type of <code>x</code>) the values of <code>x</code> under consideration. In other words, <code>R</code> tells you which values <code>x</code> ranges over. In that light, you would read the quantifier above in one of the following ways:</p> <blockquote><p>&quot;for all <code>x</code> satisfying <code>R</code>, <code>P</code> holds</p> <p>&quot;for all <code>x</code> such that <code>R</code> holds, <code>P</code>&quot;</p> <p>&quot;for all <code>x</code> (where <code>x</code> satisfies <code>R</code>), <code>P</code> holds&quot;</p> <p>&quot;for all <code>x</code> [insert your own descriptive phase for <code>R</code>], <code>P</code>&quot;</p></blockquote> <p>As a concrete instance of the last phrase, you may read <code>forall x :: x in S ==&gt; x % 2 == 0</code> as</p> <blockquote><p>&quot;for all <code>x</code> in <code>S</code>, <code>x</code> is even&quot;</p></blockquote> <p>and you may read <code>forall i :: 0 &lt;= i &lt; a.Length ==&gt; a[i] == 5</code> as</p> <blockquote><p>&quot;for every index <code>i</code> of array <code>a</code>, <code>a</code>-sub-<code>i</code> is <code>5</code>&quot;</p></blockquote> <p>In analogy to what I just said about universal quantifiers, the typical form of an existential quantifier is a conjunction, as in</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>exists x :: R &amp;&amp; P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>For example:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>exists x :: x in S &amp;&amp; x % 2 == 0

exists i :: 0 &lt;= i &lt; a.Length &amp;&amp; a[i] == 5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Again thinking of <code>R</code> as telling you which values <code>x</code> ranges over, you may read these existential quantifiers as</p> <blockquote><p>&quot;there is an <code>x</code> in <code>S</code> for which <code>x % 2 == 0</code> holds&quot;</p> <p>&quot;there is an index <code>i</code> into <code>a</code> such that <code>a</code>-sub-<code>i</code> is <code>5</code>&quot;</p></blockquote> <p>Following Why3 [<a href="http://leino.science/papers/krml267.html#boogie2011:why3" target="_blank" rel="noopener noreferrer">1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>], Dafny issues a warning if you write <code>R ==&gt; P</code> as the body of an existential quantifier, because this is almost always a user error (a typo or a think-o). If this is really what you want to write, you can suppress the warning by instead writing any of the following expressions:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>exists x :: (R ==&gt; P)
exists x :: !R || P
exists x :: P &lt;== R
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="range-predicates"><a href="#range-predicates" class="header-anchor">#</a> Range predicates</h3> <p>Why did I just spend a page telling you ways to pronounce your quantifiers? Because that discussion spotlights the fact that the condition <code>R</code>, in either of</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: R ==&gt; P
exists x :: R &amp;&amp; P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>plays a special role, even though <code>R</code> is really just a part of the body of these quantifiers. In fact, others have adopted a notation for quantifier that feature a special place for this <em>range predicate</em> <code>R</code>. Here are some examples:</p> <table><thead><tr><th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>Universal quantifier</td> <td>Existential quantifier</td> <td>Source</td></tr> <tr><td></td> <td></td> <td></td></tr> <tr><td></td> <td></td> <td>Dijkstra [<a href="http://leino.science/papers/krml267.html#dijkstra:discipline" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td>Chandy and Misra [<a href="http://leino.science/papers/krml267.html#chandymisra:book" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td>Gries and Schneider [<a href="http://leino.science/papers/krml267.html#griesschneider:proofs" target="_blank" rel="noopener noreferrer">4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td><code>\forall X x; R; P</code></td> <td><code>\exists X x; R; P</code></td> <td>JML [<a href="http://leino.science/papers/krml267.html#leavensbakerruby99a" target="_blank" rel="noopener noreferrer">5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <p>(In the case of JML above, <code>X</code> denotes the type of <code>x</code>.) In textbooks using these notations, it is often remarked that &quot;for brevity, if <code>R</code> is <code>true</code> or is understood from context, then it (and for some of the authors above, some adjacent punctuation) is omitted&quot;. These shortened forms are:</p> <table><thead><tr><th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>Range listed separately</td> <td>Range <code>true</code> or omitted</td> <td>Source</td></tr> <tr><td></td> <td></td> <td></td></tr> <tr><td></td> <td></td> <td>Dijkstra [<a href="http://leino.science/papers/krml267.html#dijkstra:discipline" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td>Chandy and Misra [<a href="http://leino.science/papers/krml267.html#chandymisra:book" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td>Gries and Schneider [<a href="http://leino.science/papers/krml267.html#griesschneider:proofs" target="_blank" rel="noopener noreferrer">4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td><code>\forall X x; R; P</code></td> <td><code>\forall X x;; P</code></td> <td>JML [<a href="http://leino.science/papers/krml267.html#leavensbakerruby99a" target="_blank" rel="noopener noreferrer">5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <p>There's more. By using some notation that separates the <code>R</code> from <code>P</code>, the De Morgan's Law for quantifiers looks especially nice:</p> <p>Back to Dafny. If you like the notation where you get to separate the range of the bound variables from the rest of the quantifier body, then you'll be glad to learn that you can do this in Dafny, too. The syntax is:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x | R :: P
exists x | R :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_1-program-statements-for-quantifier-reasoning"><a href="#_1-program-statements-for-quantifier-reasoning" class="header-anchor">#</a> 1. Program Statements for Quantifier Reasoning</h2> <p>Dafny includes some proof features that are useful when reasoning about programs or theorems that involve quantifiers. These have a syntax similar to those of quantifiers, but there are differences.</p> <h3 id="aggregate-statements"><a href="#aggregate-statements" class="header-anchor">#</a> Aggregate statements</h3> <p>The <code>forall</code> statement in Dafny is an <em>aggregate statement</em>: it has the effect of performing a number of simultaneous operations. When used in proofs, the statement has the form:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x | R
  ensures P
{
  S;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>It is used to establish the property <code>forall x | R :: P</code>, that is, <code>forall x :: R ==&gt; P</code>. It does so by checking that the statement <code>S</code> establishes <code>P</code> for any <code>x</code> that satisfies <code>R</code>. In logic, the effect of this statement is called <em>universal introduction</em>.</p> <p>As a simple example, suppose you have a lemma that proves <code>n &lt;= Fib(n)</code> for any <code>n</code> at least <code>5</code>, where <code>Fib</code> is the usual Fibonacci function:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function Fib(n: nat): nat {
  if n &lt; 2 then n else Fib(n-2) + Fib(n-1)
}

lemma FibProperty(n: nat)
  requires 5 &lt;= n
  ensures n &lt;= Fib(n)
{
  // some proof goes here
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>This lemma gives you the property <code>n &lt;= Fib(n)</code> for a given <code>n</code>. But suppose you want to have this property in the universally quantified form. That is, you'd like to prove the following lemma:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma FibPropertyAll()
  ensures forall n :: 5 &lt;= n ==&gt; n &lt;= Fib(n)
{
  // some proof to go here
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>How would we write this proof?<a href="http://leino.science/papers/krml267.html#fn-fn-fibpropertyall" target="_blank" rel="noopener noreferrer">2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>The answer is to call <code>FibProperty</code> once for each <code>n</code>. All at once. For an infinite number of different values for <code>n</code>. That's what you do with the aggregate statement <code>forall</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall n | 5 &lt;= n
  ensures n &lt;= Fib(n)
{
  FibProperty(n);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>In general, the body of a <code>forall</code> statement is more complicated than just one single lemma call. But for when the body <em>is</em> just one lemma call or just one <code>calc</code> statement, then Dafny infers the <code>ensures</code> clause automatically, so you can omit it:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall n | 5 &lt;= n {
  FibProperty(n);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="existential-introduction-and-elimination"><a href="#existential-introduction-and-elimination" class="header-anchor">#</a> Existential introduction and elimination</h3> <p>Working with existential quantifications also uses a repertoire of proof features. I will demonstrate these by writing a proof that shows Fibonacci numbers can be arbitrarily large:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma EverBigger(k: nat)
  ensures exists n :: k &lt;= Fib(n)
{
  // proof to go here
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Let's start the proof with some cases we can easily do, namely when <code>k</code> is small, let's say <code>0</code> or <code>1</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>if k &lt; 2 {
  // simple case: proof for k being 0 or 1 goes here
} else {
  // difficult case: proof for larger k goes here
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Dafny does not prove either of these cases automatically, so we need to give more of the proofs ourselves.</p> <p>To prove the lemma in the simple case, it suffices to demonstrate to the verifier a particular <code>n</code> for which the existential quantifier holds. That is, we want to give a <em>witness</em> to the existential quantifier. One such witness is <code>1</code>, since <code>k &lt;= 1 == Fib(1)</code>. Another such witness is <code>12</code>, since <code>k &lt;= 144 == Fib(12)</code>. Yet another such witness is <code>k</code>, since <code>k &lt;= k == Fib(k)</code> in our simple case. Let's go with this one, so we add an assertion to the “then” branch of the <code>if</code> statement in the lemma body:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>assert k &lt;= Fib(k);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Dafny will prove this assertion<a href="http://leino.science/papers/krml267.html#fn-fn-dual-rail-encoding" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and will then notice that <code>k</code> is an existential witness that proves the postcondition. In logic, this is called <em>existential introduction</em>. All that means is that if you have a value that satisfies a particular property, then such a value exists. Stated different, if you have a value “in your hands”, then a value exists—this seems so obvious that we almost feel awkward speaking about it (your next-door neighbor would certainly think you crazy to hear that <em>this</em> is what you did for a living).</p> <p>So what about the difficult case? We can prove it by induction, by first obtaining an <code>n</code> whose Fibonacci value is at least <code>k-1</code> and then building an even larger Fibonacci value from there. To start this off, we call the lemma recursively on <code>k-1</code>:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>EverBigger(k-1);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>This lets us obtain the postcondition of <code>EverBigger(k-1)</code>. To write that down explicitly in our proof—to check that the verifier draws the conclusion we'd expect from the lemma call and to remind ourselves of what property is—we can write an assertion:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>assert exists n' :: k-1 &lt;= Fib(n');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Good so far. Next, we want to construct a Fibonacci number that is at least <code>1</code> larger than <code>Fib(n')</code>, because that would complete the proof. But what is this <code>n'</code> that i just mentioned? All the assertion above tells us that some such <code>n'</code> exists. We'd like to have such an <code>n'</code> “in our hands” so that we can work with it.</p> <p>Going from something we know exists to something “in our hands” is called <em>Skolemization</em> or <em>existential elimination</em>. You achieve it in Dafny by the <em>assign-such-that</em> statement:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>var m: nat :| k-1 &lt;= Fib(m);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>This statement introduce a local variable <code>m</code> and gives it some arbitrary value that satisfies <code>k-1 &lt;= Fib(m)</code>. Of course, this would not be possible if no such value exists, so the assign-such-that statement incurs a proof obligation that such an <code>m</code> exists. This proof obligation follows from the property we asserted just above.</p> <p>Almost there. All that remains of our plan to establish the lemma's postcondition is to construct a Fibonacci number strictly larger than <code>Fib(m)</code>. We observe that <code>Fib(m) + Fib(m+1)</code> is strictly larger than <code>Fib(m)</code>, and thus we have that <code>Fib(m+2)</code> is strictly larger than <code>Fib(m)</code>. Boom!</p> <p>Okay, let's be frank. Maybe we didn't so much “observe” this as we did “wish” or “conjecture” or “loosely think” that it may hold. Well, it does hold. (Phew!) We can check that by asking the verifier if it can prove it for us:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>assert k &lt;= Fib(m) + Fib(m + 1) == Fib(m + 2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>The verifier immediately prove this assertion.<a href="http://leino.science/papers/krml267.html#fn-fn-proof" target="_blank" rel="noopener noreferrer">4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Moreover, by writing down this assertion, we are also showing the verifier the witness <code>m+2</code>, which proves the existential quantifier in the lemma's postcondition.</p> <p>The point I set out to illustrate with this example is that you can Skolemize a quantifier</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>exists x :: P
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>by the assign-such-that statement</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>var x :| P;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Notice the difference in punctuation.</p> <h3 id="lemmas-with-out-parameters"><a href="#lemmas-with-out-parameters" class="header-anchor">#</a> Lemmas with out-parameters</h3> <p>I just showed you an example that involves existential quantifiers. The example showed that the <em>proof</em> of the <code>EverBigger</code> lemma used existential introduction twice (<code>Fib(k)</code> in the simple case and <code>Fib(m+2)</code> in the difficult case), thus converting the <code>k</code> and the <code>m+2</code> “in ours hands” into existential quantifications. The example also showed that the <em>invocation</em> of the (recursive call to the) lemma used existential elimination to convert the existential quantification in the lemma's postcondition into an <code>m</code> “in our hands”. As impressive it is that Dafny has such features, it has an even more useful feature that lets you avoid these existential-quantifier conversions in the first place: lemma out-parameters.</p> <p>In mathematics, lemmas are parameterized by the variables they mention. These are like in-parameters. Rarely or never would a mathematical lemma be thought of as having out-parameters. In Dafny, a lemma is really just a ghost method, and a method can have both in- and out-parameters. This can be quite useful. Instead of a lemma proving the <em>existence</em> of some value, it may as well just <em>return</em> some such value.</p> <p>Here is the <code>EverBigger</code> lemma from above, but with <code>n</code> declared as an out-parameter:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>lemma EverBigger(k: nat) returns (n: nat)
  ensures k &lt;= Fib(n)
{
  if k &lt; 2 {
    n := k;
  } else {
    var m := EverBigger(k-1);
    n := m + 2;
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="binding-guards"><a href="#binding-guards" class="header-anchor">#</a> Binding guards</h3> <p>Dafny includes one other feature that makes working with quantifiers more streamlined: <code>if</code> statements with <em>binding guards</em>. Such a statement answers the order “if there is one, gimmie one in my hand”.</p> <p>Suppose we write a proof that splits into two cases according whether or not the value <code>y</code> is a Fibonacci number. We could then write:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>if exists n :: y == Fib(n) {
  var n :| y == Fib(n);
  // y is the nth Fibonacci number
} else {
  // y is not a Fibonacci number
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>This expresses what we want, but feels a little clumsy, since we are repeating the condition <code>y == Fib(n)</code>. Instead using a binding guard, we can write this <code>if</code> statement as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>if n :| y == Fib(n) {
  // y is the nth Fibonacci number
} else {
  // y is not a Fibonacci number
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The punctuation <code>:|</code> is the same as in the assign-such-that statement, not the <code>::</code> in the similar position of the existential quantifier.</p> <h2 id="_2-sets-and-maps"><a href="#_2-sets-and-maps" class="header-anchor">#</a> 2. Sets and Maps</h2> <p>Logical quantifiers and the other constructs we've seen introduce some bound variables and in some way restrict the values that those bound variables may range over. This is also the case with set comprehensions and map comprehensions.</p> <h3 id="set-comprehensions"><a href="#set-comprehensions" class="header-anchor">#</a> Set comprehensions</h3> <p>It is easy to write down a set in Dafny. For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>{ 2, 3, 5 }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>is the set of the three smallest prime numbers. Such an expression, where the elements of the set are listed explicitly, is called a <em>set display</em>. But what if the set you want to define cannot be written as a set display?</p> <p>A <em>set comprehension</em> defines a set of elements in a schematic way. An example of a set comprehension in common mathematical notation is</p> <p>which defines the set of the smallest 100 natural numbers. Another example is</p> <p>which defines the 100 smallest perfect squares. The bound variable in both of these comprehensions is , and the values over which is specified to range is defined by the predicate . Letting range over those values, the first set then contains the elements of the form whereas the second set contains the elements of the form . That is, in the first set, the elements are the legal values of themselves, whereas in the second set, the elements are the squares of each legal value of .</p> <p>More generally, the mathematical notation takes some shape like . The reader is supposed to understand that is the bound variable. With the understanding that is the bound variable, we can define the set comprehension by describing exactly when the set contains an element :</p> <p>Or, to use the notation where the existential's range is given separately:</p> <p>In Dafny, the same set comprehension has the following form:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x | R :: f(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>x</code> is the bound variable (or, more generally, a list of bound variables), <code>R</code> is the range predicate for the bound variables, and <code>f(x)</code> is the <em>term expression</em> of the set comprehension. The bound variable is listed explicitly, unlike the common mathematical notation where the reader has to infer what the bound variable is. The two example sets given above are written as follows in Dafny:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x | 0 &lt;= x &lt; 100 :: x
set x | 0 &lt;= x &lt; 100 :: x*x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Although at first sight it just looks less concise, the notation that lists the bound variable explicitly has some niceties.</p> <p>One nicety is that the definition in terms of the quantifier, like above, shows the similarity of notation:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>y in (set x | R :: f(x))   &lt;==&gt;   exists x | R :: y == f(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Another nicety is that one can easily list additional bound variables. Supposing that <code>R</code> is a predicate over both <code>x</code> and <code>z</code>, then here are two examples:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x,n | Fib(n) &lt;= x &lt; Fib(n) + n :: f(x)
set x,n | Fib(n) &lt;= x &lt; Fib(n) + n :: g(x,n)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>The first of these sets contains <code>f(x)</code> for every <code>x</code> that is within <code>n</code> of <code>Fib(n)</code> for some <code>n</code>. An equivalent way to write it in common mathematical notation is:</p> <p>The second set contains <code>g(x,n)</code> for every <code>x</code> and <code>n</code> such that <code>x</code> is within <code>n</code> of <code>Fib(n)</code>. Here, the equivalent mathematical notation is more clumsy and requires using yet another bound variable:</p> <p>Dafny's general notation of making the bound variable explicit is also used by many authors (e.g., [<a href="http://leino.science/papers/krml267.html#dijkstra:discipline" target="_blank" rel="noopener noreferrer">3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="http://leino.science/papers/krml267.html#griesschneider:proofs" target="_blank" rel="noopener noreferrer">4<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]). It is also similar to the list-comprehension notation used in some other languages. For example, the Dafny set</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x,y | 0 &lt;= x &lt;= y &lt;= 100 &amp;&amp; x + y == 100 :: (x,y)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>which contains the pairs of natural numbers that sum to <code>100</code>, contains the same elements as the Python list:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>[(x,y) for x in range(0, 101) for y in range(x, 101) if x + y == 100]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>and the Haskell list:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>[(x,y) | x &lt;- [0..100], y &lt;- [x..100], x + y = 100]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="simplified-set-comprehensions"><a href="#simplified-set-comprehensions" class="header-anchor">#</a> Simplified set comprehensions</h3> <p>I just spent many words describing the general set-comprehension notation in Dafny. However, in many set comprehensions in practice, there is just one bound variable and the term expression is just that bound variable. For example, as we have seen, the set of the smallest <code>100</code> natural numbers is:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x | 0 &lt;= x &lt; 100 :: x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>For this common case, Dafny lets you omit the term expression and simply write:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>set x | 0 &lt;= x &lt; 100
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>This expression looks like the common mathematical notation . Indeed, for these simplified set comprehensions, it is easy to “understand” what the mathematical notation intends to be the bound variables.</p> <p>As a note about the verifier in Dafny, automation tends to work better for the simplified set comprehensions where the term expression can be omitted.</p> <h3 id="map-comprehensions"><a href="#map-comprehensions" class="header-anchor">#</a> Map comprehensions</h3> <p>A <em>map</em> is essentially a set of pairs, where the left-elements of the pairs are unique (that is, each left-element functionally determines the corresponding right-element). Like the display expressions for sets, a map can be defined by a <em>map display</em>. For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map[2 := 'c', 137 := 'a']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>maps the integer <code>2</code> to the character <code>'c'</code> and maps the integer <code>137</code> to the character <code>'a'</code>. Each pair like <code>2 := 'c'</code> can be called a <em>maplet</em>. Also, the left-element of the maplet is called a <em>key</em> and the right-element gets the nondescript name <em>value</em>.</p> <p>Like the comprehensions for sets, a map can be defined by a <em>map comprehension</em>. It has the form:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | R :: f(x) := g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>For example,</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | 0 &lt;= x &lt; 100 :: x*x := x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>is the map from each of the first <code>100</code> perfect squares to their respective square roots.</p> <p>If you read a map comprehension as a set of maplets with unique keys, then you essentially already understand the notation. Nevertheless, I will offer some notes and point out some features specific to maps.</p> <p>One thing to note is that the maplets must have unique keys. For example, the verifier will complain if you try to write a map comprehension like</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | -10 &lt;= x &lt;= 10 :: x*x := x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>because it says to map <code>4</code> to both <code>2</code> and <code>-2</code>, which is not functional.</p> <p>The general map-comprehension expression is quite flexible. For example, suppose <code>m</code> is a map from numbers to characters, and suppose we want to create a new map <code>n</code> from a subset of the keys in <code>m</code> to some other characters. More precisely, whenever a key in <code>m</code> is in the image of a function <code>f</code>, say a key <code>f(x)</code> for some <code>x</code>, then we want <code>n</code> to map that key to <code>h(x)</code>. We then define <code>n</code> as</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | f(x) in m.Keys :: f(x) := h(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Most of the time, however, the map comprehensions we tend to write have the form</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | R :: x := g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>For these common maps, Dafny allows us to omit the &quot;<code>x :=</code>&quot; and write just</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | R :: g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Almost all map comprehensions in practice can be written in this simplified form. But for when the simplified form is not sufficient (like in the example above with the maplets <code>f(x) := h(x)</code>), the general form is available.</p> <h3 id="lambda-expressions"><a href="#lambda-expressions" class="header-anchor">#</a> Lambda expressions</h3> <p>Finally, a note about the difference between maps and functions. You may think of a map as a precomputed table, whereas a function is something that computes a value from a given key. For comparison, let's consider writing the map</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>map x | R :: g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>as a function.</p> <p>Typically, a function is declared with a name. The map above is then written along the lines of</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>function F(x: X): Y
  requires R
{
  g(x)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>A function can also be anonymous, in which case it is usually called a <em>lambda expression</em>. The example map is then written</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>x requires R =&gt; g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_3-summary"><a href="#_3-summary" class="header-anchor">#</a> 3. Summary</h2> <p>Here is a listing of the syntactic forms discussed in this note:</p> <div class="language-dafnyx line-numbers-mode"><pre class="language-text"><code>forall x :: P
forall x | R :: P
forall x | R ensures P { S; }
exists x :: P
exists x | R :: P
var x :| P;
if x :| P { S; }
set x | R :: f(x)
set x | R
map x | R :: f(x) := h(x)
map x | R :: g(x)
function F(x: X): Y { g(x) }
x requires R =&gt; g(x)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="acknowledgments"><a href="#acknowledgments" class="header-anchor">#</a> Acknowledgments</h4> <p>I'm grateful to Jay Lorch for many helpful comments on this note.</p> <h2 id="references"><a href="#references" class="header-anchor">#</a> References</h2> <p>[0]Nada Amin, K. Rustan M. Leino, and Tiark Rompf. Computing with an SMT solver. In Martina Seidl and Nikolai Tillmann, editors, <em>Tests and Proofs — 8th International Conference, TAP 2014</em>, volume 8570 of <em>Lecture Notes in Computer Science</em>, pages 20–35. Springer, July 2014. <a href="http://www.bing.com/search?q=Computing+with+solver++Nada+Amin+Rustan+Leino+Tiark+Rompf+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[1]François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich. Why3: Shepherd your herd of provers. In <em>Boogie 2011: First International Workshop on Intermediate Verification Languages</em>, pages 53–64, Wrocław, Poland, August 2011. <a href="https://hal.inria.fr/hal-00790310" target="_blank" rel="noopener noreferrer">https://hal.inria.fr/hal-00790310<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <a href="http://www.bing.com/search?q=Fran+Bobot+Jean+Christophe+Filli+Claude+March+Andrei+Paskevich+Why3+Shepherd+your+herd+provers+_Boogie+First+International+Workshop+Intermediate+Verification+Languages_+pages+Wroc+Poland+August+https+inria++" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[2]K. Mani Chandy and Jayadev Misra. <em>Parallel Program Design: A Foundation</em>. Addison-Wesley, 1988. <a href="http://www.bing.com/search?q=_Parallel+Program+Design+Foundation_+++Mani+Chandy+Jayadev+Misra+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[3]Edsger W. Dijkstra. <em>A Discipline of Programming</em>. Prentice Hall, Englewood Cliffs, NJ, 1976. <a href="http://www.bing.com/search?q=+Discipline+Programming_++Edsger+Dijkstra+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[4]David Gries and Fred B. Schneider. <em>A Logical Approach to Discrete Math</em>. Texts and Monographs in Computer Science. Springer-Verlag, 1994. <a href="http://www.bing.com/search?q=+Logical+Approach+Discrete+Math_++David+Gries+Fred+Schneider+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[5]Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, <em>Behavioral Specifications of Businesses and Systems</em>, pages 175–188. Kluwer Academic Publishers, 1999. <a href="http://www.bing.com/search?q=+notation+detailed+design++Gary+Leavens+Albert+Baker+Clyde+Ruby+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[6]K. Rustan M. Leino and Clément Pit-Claudel. Trigger selection strategies to stabilize program verifiers. In Swarat Chaudhuri and Azadeh Farzan, editors, <em>Computer Aided Verification - 28th International Conference, CAV 2016, Proceedings, Part I</em>, volume 9779 of <em>Lecture Notes in Computer Science</em>, pages 361–381. Springer, 2016. <a href="http://www.bing.com/search?q=Trigger+selection+strategies+stabilize+program+verifiers+++Rustan+Leino+ment+Claudel+" target="_blank" rel="noopener noreferrer">🔎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <p>0.The Emacs IDE for Dafny typesets certain Dafny constructs in the notation you're more likely to see in a paper. By default, it shows <code>forall x :: P</code> as and shows <code>exists x :: P</code> as . <a href="http://leino.science/papers/krml267.html#back-fn-fn-emacs" target="_blank" rel="noopener noreferrer">↩<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>1.Internally, the Dafny verifier works more effectively with certain quantifiers. The verifier tries to detect when an alternative form of a given quantifier may perform better, and will in those cases rewrite the quantifier automatically [<a href="http://leino.science/papers/krml267.html#leinopit-claudel:cav2016" target="_blank" rel="noopener noreferrer">6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]. For example, it may choose to un-nest some quantifiers. The goal of such rewrites is to support natural-looking programs while getting good prover performance. <a href="http://leino.science/papers/krml267.html#back-fn-fn-nested" target="_blank" rel="noopener noreferrer">↩<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>2.As it turns out, Dafny's automatic induction will prove both <code>FibProperty</code> and <code>FibPropertyAll</code> automatically. If these were the only lemmas we cared about, there would be nothing else to say or do. Nevertheless, I'm using this example to show the <code>forall</code> statement. If you want to make sure what I'm about to say gives a proof, you can turn off automatic induction for <code>FibPropertyAll</code> by marking it with the attribute <code>{:induction false}</code>. <a href="http://leino.science/papers/krml267.html#back-fn-fn-fibpropertyall" target="_blank" rel="noopener noreferrer">↩<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>3.Dafny can also prove an assertion like <code>assert Fib(12) == 144;</code>. Internally, Dafny uses a “dual-rail encoding” of functions that lets it obtain the value of <code>Fib(12)</code> (since <code>12</code> is a literal constant) and <code>Fib(k)</code> (where <code>k</code> is a variable). If you're interested in how this is done, I refer you to [<a href="http://leino.science/papers/krml267.html#aminetal:computingwithsmt" target="_blank" rel="noopener noreferrer">0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>]. <a href="http://leino.science/papers/krml267.html#back-fn-fn-dual-rail-encoding" target="_blank" rel="noopener noreferrer">↩<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>4.Here is a proof of the assertion <code>k &lt;= Fib(m) + Fib(m+1)</code>. The “difficult case” in our proof applies when <code>k</code> is at least <code>2</code>, so <code>k-1</code> is at least <code>1</code>, so we know about <code>Fib(m)</code> that it is at least <code>1</code>. From this, it follows that <code>m</code> cannot be <code>0</code>, for <code>Fib(0) == 0</code>. This is important, because it means that <code>m+1</code> is at least <code>2</code> and therefore the inductive case of the definition of <code>Fib</code> applies. In other words, we have <code>Fib(m+1) == Fib(m) + Fib(m-1)</code>. We already concluded that <code>Fib(m)</code> is at least <code>1</code>. On behalf of <code>Fib</code> returning a <code>nat</code>, we have that <code>Fib(m-1)</code> is at least <code>0</code>. So, <code>Fib(m+1)</code> is at least <code>1</code>. In other words, <code>Fib(m) + Fib(m+1)</code> is at least <code>1</code> more than <code>Fib(m)</code>, which in turn is at least <code>k-1</code>. Thus, <code>Fib(m) + Fib(m+1)</code> is at least <code>k</code>.</p> <p>Had we split the “simple case” and “difficult case” up so that the “simple case” only covered <code>k == 0</code>, then we could not have concluded <code>m != 0</code> in the argument above. Some users of other interactive proof assistants may be bothered by this, because they would say <code>k</code> has type <code>nat</code> and therefore the induction on <code>k</code> should use <code>k == 0</code> as the base case. Mathematics imposes no such restriction on induction, and indeed, as this proof shows, we profit from splitting the cases of <code>EverBigger</code> into <code>k &lt; 2</code> and <code>2 &lt;= k</code>. <a href="http://leino.science/papers/krml267.html#back-fn-fn-proof" target="_blank" rel="noopener noreferrer">↩<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/aaron-clou/dafnycommunity/edit/master/docs/80.语言/30.publication-lecture/15.Comprehensions.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/03/26, 14:38:56</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/dafnycommunity/pages/746026/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Case study of definitions, proofs, algorithm correctness GCD</div></a> <a href="/dafnycommunity/pages/8d8607/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Different Styles of Proofs</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/dafnycommunity/pages/746026/" class="prev">Case study of definitions, proofs, algorithm correctness GCD</a></span> <span class="next"><a href="/dafnycommunity/pages/8d8607/">Different Styles of Proofs</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/dafnycommunity/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/dafnycommunity/pages/0978ce/"><div>
            寻找最大和最小数
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>02</dd> <dt><a href="/dafnycommunity/pages/e3e481/"><div>
            斐波那契数列
            <!----></div></a> <span class="date">04-06</span></dt></dl><dl><dd>03</dd> <dt><a href="/dafnycommunity/pages/02fdef/"><div>
            线性查询
            <!----></div></a> <span class="date">04-06</span></dt></dl> <dl><dd></dd> <dt><a href="/dafnycommunity/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/Aaron-clou/dafnycommunity" title="Github" target="_blank" class="iconfont icon-github-fill"></a><a href="https://gitee.com/leo214/dafnycommunity" title="Gitee" target="_blank" class="iconfont icon-gitee2"></a><a href="1374921025@qq.com" title="Email" target="_blank" class="iconfont icon-email-fill"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Li Jiahai | Dafny Community | 2022</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><!----><div id="tcomment"></div><div></div></div></div>
    <script src="/dafnycommunity/assets/js/app.99d07194.js" defer></script><script src="/dafnycommunity/assets/js/2.ab4658c0.js" defer></script><script src="/dafnycommunity/assets/js/77.b85547c7.js" defer></script><script src="/dafnycommunity/assets/js/7.5451cfed.js" defer></script><script src="/dafnycommunity/assets/js/4.06497870.js" defer></script>
  </body>
</html>
